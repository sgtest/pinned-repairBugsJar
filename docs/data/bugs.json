[{"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["VmMultipleConsumersRemoteRouteTest.testVmMultipleConsumersRemoteRoute:66 Timeout waiting for endpoints to receive enough messages. mock://route1 timed out.", "CBRPredicateBeanThrowExceptionTest>TestSupport.runBare:58->testCBRKaboom:74 null"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\nindex 0310c9a..44f4b10 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\n@@ -30,6 +30,10 @@\n import org.apache.camel.util.AsyncProcessorConverterHelper;\n import org.apache.camel.util.AsyncProcessorHelper;\n import org.apache.camel.util.ServiceHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.camel.processor.PipelineHelper.continueProcessing;\n \n /**\n  * Implements a Choice structure where one or more predicates are used which if\n@@ -39,6 +43,7 @@\n  * @version \n  */\n public class ChoiceProcessor extends ServiceSupport implements AsyncProcessor, Navigate<Processor>, Traceable {\n+    private static final Logger LOG = LoggerFactory.getLogger(ChoiceProcessor.class);\n     private final List<Processor> filters;\n     private final Processor otherwise;\n \n@@ -84,13 +89,16 @@ public void done(boolean doneSync) {\n                 try {\n                     matches = filter.getPredicate().matches(exchange);\n                     exchange.setProperty(Exchange.FILTER_MATCHED, matches);\n+                    // as we have pre evaluated the predicate then use its processor directly when routing\n+                    processor = filter.getProcessor();\n                 } catch (Throwable e) {\n                     exchange.setException(e);\n-                    choiceCallback.done(true);\n-                    return true;\n                 }\n-                // as we have pre evaluated the predicate then use its processor directly when routing\n-                processor = filter.getProcessor();\n+            }\n+\n+            // check for error if so we should break out\n+            if (!continueProcessing(exchange, \"so breaking out of choice\", LOG)) {\n+                break;\n             }\n \n             // if we did not match then continue to next filter\n", "nb_test": 4735, "linesAdd": 10, "jira_id": "6889", "singleLine": false, "nb_skipped": 1, "commit": "cd40b712", "nb_failure": 2, "linesRem": 3}, {"files": 0, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["RecipientListShareUnitOfWorkOnExceptionHandledFalseIssueTest>TestSupport.runBare:58->testRecipientList:34->TestSupport.assertIsInstanceOf:166 Expected an instance of type: java.lang.IllegalArgumentException but was null", "SplitSubUnitOfWorkTest>TestSupport.runBare:58->testError:57->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Received message count. Expected: <0> but was: <1>", "SplitSubUnitOfWorkWithMDCLoggingTest>TestSupport.runBare:58->SplitSubUnitOfWorkTest.testError:57->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Received message count. Expected: <0> but was: <1>", "SplitTwoSubUnitOfWorkTest>TestSupport.runBare:58->testError:61->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Received message count. Expected: <0> but was: <1>"], "patch": "", "nb_test": 5519, "linesAdd": 0, "jira_id": "9444", "singleLine": false, "nb_skipped": 4, "commit": "baece126", "nb_failure": 4, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testInOnly(org.apache.camel.component.bean.BeanWithHeadersAndBodyInject3Test)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\nindex cdcfa6a..5f73fe3 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\n@@ -254,12 +254,18 @@ public String toString() {\n     /**\n      * Returns an expression for the outbound message headers\n      *\n-     * @return an expression object which will return the headers\n+     * @return an expression object which will return the headers, will be <tt>null</tt> if the\n+     * exchange is not out capable.\n      */\n     public static Expression outHeadersExpression() {\n         return new ExpressionAdapter() {\n             public Object evaluate(Exchange exchange) {\n+                // only get out headers if the MEP is out capable\n+                if (ExchangeHelper.isOutCapable(exchange)) {\n                     return exchange.getOut().getHeaders();\n+                } else {\n+                    return null;\n+                }\n             }\n \n             @Override\n", "nb_test": 2992, "linesAdd": 4, "jira_id": "3388", "singleLine": false, "nb_skipped": 0, "commit": "0919a0f6", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["FileIdempotentConsumerCreateRepoTest.shouldUseCurrentDirIfHasNoParentFile:46->assertStoreExists:55 \u00bb NullPointer"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/idempotent/FileIdempotentRepository.java b/camel-core/src/main/java/org/apache/camel/processor/idempotent/FileIdempotentRepository.java\nindex 301fb0d..2451daf 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/idempotent/FileIdempotentRepository.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/idempotent/FileIdempotentRepository.java\n@@ -290,7 +290,9 @@ protected void loadStore() throws IOException {\n         if (!fileStore.exists()) {\n             LOG.debug(\"Creating filestore: {}\", fileStore);\n             File parent = fileStore.getParentFile();\n+            if (parent != null) {\n                 parent.mkdirs();\n+            }\n             boolean created = FileUtil.createNewFile(fileStore);\n             if (!created) {\n                 throw new IOException(\"Cannot create filestore: \" + fileStore);\n", "nb_test": 5485, "linesAdd": 2, "jira_id": "9340", "singleLine": false, "nb_skipped": 4, "commit": "1cab39f6", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testNormalizeEndpointUriWithDualParameters(org.apache.camel.util.URISupportTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/URISupport.java b/camel-core/src/main/java/org/apache/camel/util/URISupport.java\nindex 71abd94..2675786 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/URISupport.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/URISupport.java\n@@ -22,7 +22,9 @@\n import java.net.URLDecoder;\n import java.net.URLEncoder;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n+import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -74,7 +76,28 @@ public static String sanitizeUri(String uri) {\n                     if (p >= 0) {\n                         String name = URLDecoder.decode(parameter.substring(0, p), CHARSET);\n                         String value = URLDecoder.decode(parameter.substring(p + 1), CHARSET);\n+\n+                        // does the key already exist?\n+                        if (rc.containsKey(name)) {\n+                            // yes it does, so make sure we can support multiple values, but using a list\n+                            // to hold the multiple values\n+                            Object existing = rc.get(name);\n+                            List<String> list;\n+                            if (existing instanceof List) {\n+                                list = CastUtils.cast((List<?>) existing);\n+                            } else {\n+                                // create a new list to hold the multiple values\n+                                list = new ArrayList<String>();\n+                                String s = existing != null ? existing.toString() : null;\n+                                if (s != null) {\n+                                    list.add(s);\n+                                }\n+                            }\n+                            list.add(value);\n+                            rc.put(name, list);\n+                        } else {\n                             rc.put(name, value);\n+                        }\n                     } else {\n                         rc.put(parameter, null);\n                     }\n@@ -134,6 +157,7 @@ public static String stripPrefix(String value, String prefix) {\n         return value;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public static String createQueryString(Map<Object, Object> options) throws URISyntaxException {\n         try {\n             if (options.size() > 0) {\n@@ -147,12 +171,23 @@ public static String createQueryString(Map<Object, Object> options) throws URISy\n                     }\n \n                     String key = (String) o;\n-                    String value = (String) options.get(key);\n-                    rc.append(URLEncoder.encode(key, CHARSET));\n-                    // only append if value is not null\n-                    if (value != null) {\n-                        rc.append(\"=\");\n-                        rc.append(URLEncoder.encode(value, CHARSET));\n+                    Object value = options.get(key);\n+\n+                    // the value may be a list since the same key has multiple values\n+                    if (value instanceof List) {\n+                        List<String> list = (List<String>) value;\n+                        for (Iterator<String> it = list.iterator(); it.hasNext();) {\n+                            String s = it.next();\n+                            appendQueryStringParameter(key, s, rc);\n+                            // append & separator if there is more in the list to append\n+                            if (it.hasNext()) {\n+                                rc.append(\"&\");\n+                            }\n+                        }\n+                    } else {\n+                        // use the value as a String\n+                        String s = value != null ? value.toString() : null;\n+                        appendQueryStringParameter(key, s, rc);\n                     }\n                 }\n                 return rc.toString();\n@@ -166,6 +201,16 @@ public static String createQueryString(Map<Object, Object> options) throws URISy\n         }\n     }\n \n+    private static void appendQueryStringParameter(String key, String value, StringBuilder rc) throws UnsupportedEncodingException {\n+        rc.append(URLEncoder.encode(key, CHARSET));\n+        // only append if value is not null\n+        if (value != null) {\n+            rc.append(\"=\");\n+            rc.append(URLEncoder.encode(value, CHARSET));\n+        }\n+    }\n+\n+\n     /**\n      * Creates a URI from the original URI and the remaining parameters\n      * <p/>\n", "nb_test": 3588, "linesAdd": 43, "jira_id": "4211", "singleLine": false, "nb_skipped": 0, "commit": "4efddb3f", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["CustomListAggregationStrategySplitTest>TestSupport.runBare:58->testCustomAggregationStrategy:49->ContextTestSupport.assertMockEndpointsSatisfied:343 Assertion error at index 0 on mock mock://result with predicate: body instanceof java.util.List on Exchange[Message: 100]"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex 84c488a..69e4667 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -47,6 +47,7 @@\n import org.apache.camel.Producer;\n import org.apache.camel.Traceable;\n import org.apache.camel.processor.aggregate.AggregationStrategy;\n+import org.apache.camel.processor.aggregate.CompletionAwareAggregationStrategy;\n import org.apache.camel.processor.aggregate.TimeoutAwareAggregationStrategy;\n import org.apache.camel.spi.RouteContext;\n import org.apache.camel.spi.TracedRouteNodes;\n@@ -747,6 +748,12 @@ protected void doDone(Exchange original, Exchange subExchange, final Iterable<Pr\n             IOHelper.close((Closeable) pairs, \"pairs\", LOG);\n         }\n \n+        AggregationStrategy strategy = getAggregationStrategy(subExchange);\n+        // invoke the on completion callback\n+        if (strategy instanceof CompletionAwareAggregationStrategy) {\n+            ((CompletionAwareAggregationStrategy) strategy).onCompletion(subExchange);\n+        }\n+\n         // cleanup any per exchange aggregation strategy\n         removeAggregationStrategyFromExchange(original);\n \n", "nb_test": 4796, "linesAdd": 6, "jira_id": "7167", "singleLine": false, "nb_skipped": 3, "commit": "1e33fcbc", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testSplitterAndVerifyMock(org.apache.camel.issues.SplitterThrowExceptionInExpressionTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex fcb8bfc..bdee56f 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -174,10 +174,16 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n \n         // multicast uses fine grained error handling on the output processors\n         // so use try .. catch to cater for this\n+        boolean exhaust = false;\n         try {\n             boolean sync = true;\n \n             pairs = createProcessorExchangePairs(exchange);\n+\n+            // after we have created the processors we consider the exchange as exhausted if an unhandled\n+            // exception was thrown, (used in the catch block)\n+            exhaust = true;\n+\n             if (isParallelProcessing()) {\n                 // ensure an executor is set when running in parallel\n                 ObjectHelper.notNull(executorService, \"executorService\", this);\n@@ -194,14 +200,14 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         } catch (Throwable e) {\n             exchange.setException(e);\n             // and do the done work\n-            doDone(exchange, null, callback, true);\n+            doDone(exchange, null, callback, true, exhaust);\n             return true;\n         }\n \n         // multicasting was processed successfully\n         // and do the done work\n         Exchange subExchange = result.get() != null ? result.get() : null;\n-        doDone(exchange, subExchange, callback, true);\n+        doDone(exchange, subExchange, callback, true, exhaust);\n         return true;\n     }\n \n@@ -455,7 +461,7 @@ public void done(boolean doneSync) {\n                             result.set(subExchange);\n                         }\n                         // and do the done work\n-                        doDone(original, subExchange, callback, false);\n+                        doDone(original, subExchange, callback, false, true);\n                         return;\n                     }\n \n@@ -465,7 +471,7 @@ public void done(boolean doneSync) {\n                         // wrap in exception to explain where it failed\n                         subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\n                         // and do the done work\n-                        doDone(original, subExchange, callback, false);\n+                        doDone(original, subExchange, callback, false, true);\n                         return;\n                     }\n \n@@ -501,7 +507,7 @@ public void done(boolean doneSync) {\n                                 result.set(subExchange);\n                             }\n                             // and do the done work\n-                            doDone(original, subExchange, callback, false);\n+                            doDone(original, subExchange, callback, false, true);\n                             return;\n                         }\n \n@@ -511,7 +517,7 @@ public void done(boolean doneSync) {\n                             // wrap in exception to explain where it failed\n                             subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\n                             // and do the done work\n-                            doDone(original, subExchange, callback, false);\n+                            doDone(original, subExchange, callback, false, true);\n                             return;\n                         }\n \n@@ -520,7 +526,7 @@ public void done(boolean doneSync) {\n \n                     // do the done work\n                     subExchange = result.get() != null ? result.get() : null;\n-                    doDone(original, subExchange, callback, false);\n+                    doDone(original, subExchange, callback, false, true);\n                 }\n             });\n         } finally {\n@@ -589,15 +595,16 @@ private void doProcessParallel(final ProcessorExchangePair pair) throws Exceptio\n      * @param subExchange the current sub exchange, can be <tt>null</tt> for the synchronous part\n      * @param callback    the callback\n      * @param doneSync    the <tt>doneSync</tt> parameter to call on callback\n+     * @param exhaust     whether or not error handling is exhausted\n      */\n-    protected void doDone(Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync) {\n+    protected void doDone(Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync, boolean exhaust) {\n         // cleanup any per exchange aggregation strategy\n         removeAggregationStrategyFromExchange(original);\n         if (original.getException() != null) {\n             // multicast uses error handling on its output processors and they have tried to redeliver\n             // so we shall signal back to the other error handlers that we are exhausted and they should not\n             // also try to redeliver as we will then do that twice\n-            original.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE);\n+            original.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhaust);\n         }\n         if (subExchange != null) {\n             // and copy the current result to original so it will contain this exception\n", "nb_test": 2999, "linesAdd": 13, "jira_id": "3394", "singleLine": false, "nb_skipped": 0, "commit": "18e1a142", "nb_failure": 0, "linesRem": 9}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testDoneFile(org.apache.camel.component.file.FilerConsumerDoneFileNoopTest): Done file should be not be deleted: /space/parallel/camel2/dataset/camel/CAMEL-5224_2db5570fd92870f18b4292b0bdcbc5af8240324e/camel-core/target/done/done", "testThreadNotUsedForEveryAggregatorWithCustomExecutorService(org.apache.camel.processor.aggregator.AggregateTimeoutWithExecutorServiceTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\nindex 58c825f..726df83 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\n@@ -109,8 +109,8 @@ protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrate\n             endpoint.getIdempotentRepository().add(absoluteFileName);\n         }\n \n-        // delete done file if used\n-        if (endpoint.getDoneFileName() != null) {\n+        // delete done file if used (and not noop=true)\n+        if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {\n             // done file must be in same path as the original input file\n             String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n             ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n", "nb_test": 4182, "linesAdd": 1, "jira_id": "5224", "singleLine": false, "nb_skipped": 1, "commit": "2db5570f", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["EndpointWithRawUriParameterTest>TestSupport.runBare:58->testRawUriParameter:99->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Header with name password for message: 0. Expected: <++%%w?rd)> but was: <++%%w?rd>", "ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/URISupport.java b/camel-core/src/main/java/org/apache/camel/util/URISupport.java\nindex 4b06a13..0f37a2c 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/URISupport.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/URISupport.java\n@@ -155,7 +155,7 @@ public static String sanitizePath(String path) {\n                 char ch = uri.charAt(i);\n                 // look ahead of the next char\n                 char next;\n-                if (i < uri.length() - 2) {\n+                if (i <= uri.length() - 2) {\n                     next = uri.charAt(i + 1);\n                 } else {\n                     next = '\\u0000';\n", "nb_test": 4915, "linesAdd": 1, "jira_id": "7459", "singleLine": false, "nb_skipped": 3, "commit": "57ba1bde", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["CustomListAggregationStrategyCompletionFromBatchConsumerTest>TestSupport.runBare:58->testCustomAggregationStrategy:43->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Received message count. Expected: <1> but was: <0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\nindex d37bba3..a19bdbc 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\n@@ -80,11 +80,9 @@ public void onCompletion(Exchange exchange) {\n      */\n     public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n         List<V> list;\n-        Exchange answer = oldExchange;\n \n         if (oldExchange == null) {\n-            answer = new DefaultExchange(newExchange);\n-            list = getList(answer);\n+            list = getList(newExchange);\n         } else {\n             list = getList(oldExchange);\n         }\n@@ -96,7 +94,7 @@ public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n             }\n         }\n \n-        return answer;\n+        return oldExchange != null ? oldExchange : newExchange;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n", "nb_test": 4668, "linesAdd": 2, "jira_id": "6557", "singleLine": false, "nb_skipped": 1, "commit": "2c5a42db", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOk(org.apache.camel.processor.DefaultErrorHandlerOnExceptionTraceTest): expected:<[ref:myProcessor]> but was:<[wrap[org.apache.camel.processor.DefaultErrorHandlerOnExceptionTraceTest$MyProcessor@100a9f9a]]>", "testWithError(org.apache.camel.processor.DefaultErrorHandlerOnExceptionTraceTest): expected:<[ref:myProcessor]> but was:<[wrap[org.apache.camel.processor.DefaultErrorHandlerOnExceptionTraceTest$MyProcessor@6f94d3fd]]>", "testSynchronizeComplete(org.apache.camel.processor.OnCompletionGlobalTraceTest): expected:<[ref:myProcessor]> but was:<[wrap[org.apache.camel.processor.OnCompletionGlobalTraceTest$MyProcessor@24142bd3]]>", "testSynchronizeFailure(org.apache.camel.processor.OnCompletionGlobalTraceTest): expected:<[ref:myProcessor]> but was:<[wrap[org.apache.camel.processor.OnCompletionGlobalTraceTest$MyProcessor@31f7eceb]]>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\nindex cb7eb9f..adb508a 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\n@@ -19,14 +19,14 @@\n import java.util.List;\n \n import org.apache.camel.Processor;\n-import org.apache.camel.Traceable;\n import org.apache.camel.util.ServiceHelper;\n \n /**\n  * A processor which ensures wrapping processors is having lifecycle handled.\n+ *\n+ * @version \n  */\n-public class WrapProcessor extends DelegateAsyncProcessor implements Traceable {\n-\n+public class WrapProcessor extends DelegateAsyncProcessor {\n     private final Processor wrapped;\n \n     public WrapProcessor(Processor processor, Processor wrapped) {\n@@ -39,10 +39,6 @@ public String toString() {\n         return \"Wrap[\" + wrapped + \"] -> \" + processor;\n     }\n \n-    public String getTraceLabel() {\n-        return \"wrap[\" + wrapped + \"]\";\n-    }\n-\n     @Override\n     public List<Processor> next() {\n         // must include wrapped in navigate\n", "nb_test": 4371, "linesAdd": 1, "jira_id": "5844", "singleLine": false, "nb_skipped": 1, "commit": "e775071b", "nb_failure": 4, "linesRem": 7}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["IdempotentConsumerNoMessageIdTest>TestSupport.runBare:58->testNoMessageId:58 \u00bb CamelExecution"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java b/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\nindex 100a660..d3afe7a 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\n@@ -80,7 +80,9 @@ public void process(Exchange exchange) throws Exception {\n     public boolean process(Exchange exchange, AsyncCallback callback) {\n         final String messageId = messageIdExpression.evaluate(exchange, String.class);\n         if (messageId == null) {\n-            throw new NoMessageIdException(exchange, messageIdExpression);\n+            exchange.setException(new NoMessageIdException(exchange, messageIdExpression));\n+            callback.done(true);\n+            return true;\n         }\n \n         boolean newKey;\n", "nb_test": 5103, "linesAdd": 3, "jira_id": "7990", "singleLine": false, "nb_skipped": 3, "commit": "d581c4a4", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testGetEndPointByTypeUnknown(org.apache.camel.impl.DefaultCamelContextTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex 751e35b..5454442 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.camel.impl;\n \n+import static java.lang.String.format;\n+\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.ArrayList;\n@@ -465,7 +467,9 @@ public Endpoint getEndpoint(String uri) {\n \n     public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {\n         Endpoint endpoint = getEndpoint(name);\n-\n+        if(endpoint == null){\n+        \tthrow new IllegalArgumentException(\"No endpoint found with name: \" + name);\n+        }\n         if (endpoint instanceof InterceptSendToEndpoint) {\n             endpoint = ((InterceptSendToEndpoint) endpoint).getDelegate();\n         }\n", "nb_test": 3006, "linesAdd": 5, "jira_id": "3428", "singleLine": false, "nb_skipped": 0, "commit": "320545cd", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["PropertiesComponentConcatenatePropertiesTest>TestSupport.runBare:58->testConcatPropertiesComponentDefault:54 \u00bb CamelExecution"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java b/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java\nindex f7bffa7..1ee227a 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java\n@@ -16,19 +16,17 @@\n  */\n package org.apache.camel.component.properties;\n \n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.HashSet;\n import java.util.Properties;\n+import java.util.Set;\n \n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.StringHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static java.lang.String.format;\n+\n /**\n  * A parser to parse a string which contains property placeholders\n- *\n- * @version \n  */\n public class DefaultPropertiesParser implements AugmentedPropertyNameAwarePropertiesParser {\n     protected final Logger log = LoggerFactory.getLogger(getClass());\n@@ -38,167 +36,258 @@ public String parseUri(String text, Properties properties, String prefixToken, S\n         return parseUri(text, properties, prefixToken, suffixToken, null, null, false);\n     }\n \n-    public String parseUri(String text, Properties properties, String prefixToken, String suffixToken,\n-                           String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {\n-        String answer = text;\n-        boolean done = false;\n+    public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix,\n+                           boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {\n+        ParsingContext context = new ParsingContext(properties, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);\n+        return context.parse(text);\n+    }\n \n-        // the placeholders can contain nested placeholders so we need to do recursive parsing\n-        // we must therefore also do circular reference check and must keep a list of visited keys\n-        List<String> visited = new ArrayList<String>();\n-        while (!done) {\n-            List<String> replaced = new ArrayList<String>();\n-            answer = doParseUri(answer, properties, replaced, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);\n+    public String parseProperty(String key, String value, Properties properties) {\n+        return value;\n+    }\n+\n+    /**\n+     * This inner class helps replacing properties.\n+     */\n+    private final class ParsingContext {\n+        private final Properties properties;\n+        private final String prefixToken;\n+        private final String suffixToken;\n+        private final String propertyPrefix;\n+        private final String propertySuffix;\n+        private final boolean fallbackToUnaugmentedProperty;\n+\n+        public ParsingContext(Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix,\n+                              boolean fallbackToUnaugmentedProperty) {\n+            this.properties = properties;\n+            this.prefixToken = prefixToken;\n+            this.suffixToken = suffixToken;\n+            this.propertyPrefix = propertyPrefix;\n+            this.propertySuffix = propertySuffix;\n+            this.fallbackToUnaugmentedProperty = fallbackToUnaugmentedProperty;\n+        }\n \n-            // check the replaced with the visited to avoid circular reference\n-            for (String replace : replaced) {\n-                if (visited.contains(replace)) {\n-                    throw new IllegalArgumentException(\"Circular reference detected with key [\" + replace + \"] from text: \" + text);\n+        /**\n+         * Parses the given input string and replaces all properties\n+         *\n+         * @param input Input string\n+         * @return Evaluated string\n+         */\n+        public String parse(String input) {\n+            return doParse(input, new HashSet<String>());\n         }\n+\n+        /**\n+         * Recursively parses the given input string and replaces all properties\n+         *\n+         * @param input                Input string\n+         * @param replacedPropertyKeys Already replaced property keys used for tracking circular references\n+         * @return Evaluated string\n+         */\n+        private String doParse(String input, Set<String> replacedPropertyKeys) {\n+            String answer = input;\n+            Property property;\n+            while ((property = readProperty(answer)) != null) {\n+                // Check for circular references\n+                if (replacedPropertyKeys.contains(property.getKey())) {\n+                    throw new IllegalArgumentException(\"Circular reference detected with key [\" + property.getKey() + \"] from text: \" + input);\n                 }\n-            // okay all okay so add the replaced as visited\n-            visited.addAll(replaced);\n \n-            // we are done when we can no longer find any prefix tokens in the answer\n-            done = findTokenPosition(answer, 0, prefixToken) == -1;\n+                Set<String> newReplaced = new HashSet<String>(replacedPropertyKeys);\n+                newReplaced.add(property.getKey());\n+\n+                String before = answer.substring(0, property.getBeginIndex());\n+                String after = answer.substring(property.getEndIndex());\n+                answer = before + doParse(property.getValue(), newReplaced) + after;\n             }\n             return answer;\n         }\n \n-    public String parseProperty(String key, String value, Properties properties) {\n-        return value;\n+        /**\n+         * Finds a property in the given string. It returns {@code null} if there's no property defined.\n+         *\n+         * @param input Input string\n+         * @return A property in the given string or {@code null} if not found\n+         */\n+        private Property readProperty(String input) {\n+            // Find the index of the first valid suffix token\n+            int suffix = getSuffixIndex(input);\n+\n+            // If not found, ensure that there is no valid prefix token in the string\n+            if (suffix == -1) {\n+                if (getMatchingPrefixIndex(input, input.length()) != -1) {\n+                    throw new IllegalArgumentException(format(\"Missing %s from the text: %s\", suffixToken, input));\n+                }\n+                return null;\n             }\n \n-    private String doParseUri(String uri, Properties properties, List<String> replaced, String prefixToken, String suffixToken,\n-                              String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) {\n-        StringBuilder sb = new StringBuilder();\n+            // Find the index of the prefix token that matches the suffix token\n+            int prefix = getMatchingPrefixIndex(input, suffix);\n+            if (prefix == -1) {\n+                throw new IllegalArgumentException(format(\"Missing %s from the text: %s\", prefixToken, input));\n+            }\n \n-        int pivot = 0;\n-        int size = uri.length();\n-        while (pivot < size) {\n-            int idx = findTokenPosition(uri, pivot, prefixToken);\n-            if (idx < 0) {\n-                sb.append(createConstantPart(uri, pivot, size));\n-                break;\n-            } else {\n-                if (pivot < idx) {\n-                    sb.append(createConstantPart(uri, pivot, idx));\n+            String key = input.substring(prefix + prefixToken.length(), suffix);\n+            String value = getPropertyValue(key, input);\n+            return new Property(prefix, suffix + suffixToken.length(), key, value);\n         }\n-                pivot = idx + prefixToken.length();\n-                int endIdx = findTokenPosition(uri, pivot, suffixToken);\n-                if (endIdx < 0) {\n-                    throw new IllegalArgumentException(\"Expecting \" + suffixToken + \" but found end of string from text: \" + uri);\n+\n+        /**\n+         * Gets the first index of the suffix token that is not surrounded by quotes\n+         *\n+         * @param input Input string\n+         * @return First index of the suffix token that is not surrounded by quotes\n+         */\n+        private int getSuffixIndex(String input) {\n+            int index = -1;\n+            do {\n+                index = input.indexOf(suffixToken, index + 1);\n+            } while (index != -1 && isQuoted(input, index, suffixToken));\n+            return index;\n         }\n-                String key = uri.substring(pivot, endIdx);\n-                String augmentedKey = key;\n \n-                if (propertyPrefix != null) {\n-                    log.debug(\"Augmenting property key [{}] with prefix: {}\", key, propertyPrefix);\n-                    augmentedKey = propertyPrefix + augmentedKey;\n+        /**\n+         * Gets the index of the prefix token that matches the suffix at the given index and that is not surrounded by quotes\n+         *\n+         * @param input       Input string\n+         * @param suffixIndex Index of the suffix token\n+         * @return Index of the prefix token that matches the suffix at the given index and that is not surrounded by quotes\n+         */\n+        private int getMatchingPrefixIndex(String input, int suffixIndex) {\n+            int index = suffixIndex;\n+            do {\n+                index = input.lastIndexOf(prefixToken, index - 1);\n+            } while (index != -1 && isQuoted(input, index, prefixToken));\n+            return index;\n         }\n \n-                if (propertySuffix != null) {\n-                    log.debug(\"Augmenting property key [{}] with suffix: {}\", key, propertySuffix);\n-                    augmentedKey = augmentedKey + propertySuffix;\n+        /**\n+         * Indicates whether or not the token at the given index is surrounded by single or double quotes\n+         *\n+         * @param input Input string\n+         * @param index Index of the token\n+         * @param token Token\n+         * @return {@code true}\n+         */\n+        private boolean isQuoted(String input, int index, String token) {\n+            int beforeIndex = index - 1;\n+            int afterIndex = index + token.length();\n+            if (beforeIndex >= 0 && afterIndex < input.length()) {\n+                char before = input.charAt(beforeIndex);\n+                char after = input.charAt(afterIndex);\n+                return (before == after) && (before == '\\'' || before == '\"');\n+            }\n+            return false;\n         }\n \n-                String part = createPlaceholderPart(augmentedKey, properties, replaced, prefixToken, suffixToken);\n+        /**\n+         * Gets the value of the property with given key\n+         *\n+         * @param key   Key of the property\n+         * @param input Input string (used for exception message if value not found)\n+         * @return Value of the property with the given key\n+         */\n+        private String getPropertyValue(String key, String input) {\n+            String augmentedKey = getAugmentedKey(key);\n+            boolean shouldFallback = fallbackToUnaugmentedProperty && !key.equals(augmentedKey);\n \n-                // Note: Only fallback to unaugmented when the original key was actually augmented\n-                if (part == null && fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\n-                    log.debug(\"Property wth key [{}] not found, attempting with unaugmented key: {}\", augmentedKey, key);\n-                    part = createPlaceholderPart(key, properties, replaced, prefixToken, suffixToken);\n+            String value = doGetPropertyValue(augmentedKey);\n+            if (value == null && shouldFallback) {\n+                log.debug(\"Property with key [{}] not found, attempting with unaugmented key: {}\", augmentedKey, key);\n+                value = doGetPropertyValue(key);\n             }\n \n-                if (part == null) {\n+            if (value == null) {\n                 StringBuilder esb = new StringBuilder();\n                 esb.append(\"Property with key [\").append(augmentedKey).append(\"] \");\n-                    if (fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\n+                if (shouldFallback) {\n                     esb.append(\"(and original key [\").append(key).append(\"]) \");\n                 }\n-                    esb.append(\"not found in properties from text: \").append(uri);\n+                esb.append(\"not found in properties from text: \").append(input);\n                 throw new IllegalArgumentException(esb.toString());\n             }\n-                sb.append(part);\n-                pivot = endIdx + suffixToken.length();\n-            }\n-        }\n-        return sb.toString();\n-    }\n \n-    private int findTokenPosition(String uri, int pivot, String token) {\n-        int idx = uri.indexOf(token, pivot);\n-        while (idx > 0) {\n-            // grab part as the previous char + token + next char, to test if the token is quoted\n-            String part = null;\n-            int len = idx + token.length() + 1;\n-            if (uri.length() >= len) {\n-                part = uri.substring(idx - 1, len);\n+            return value;\n         }\n-            if (StringHelper.isQuoted(part)) {\n-                // the token was quoted, so regard it as a literal\n-                // and then try to find from next position\n-                pivot = idx + token.length() + 1;\n-                idx = uri.indexOf(token, pivot);\n-            } else {\n-                // found token\n-                return idx;\n+\n+        /**\n+         * Gets the augmented key of the given base key\n+         *\n+         * @param key Base key\n+         * @return Augmented key\n+         */\n+        private String getAugmentedKey(String key) {\n+            String augmentedKey = key;\n+            if (propertyPrefix != null) {\n+                log.debug(\"Augmenting property key [{}] with prefix: {}\", key, propertyPrefix);\n+                augmentedKey = propertyPrefix + augmentedKey;\n             }\n+            if (propertySuffix != null) {\n+                log.debug(\"Augmenting property key [{}] with suffix: {}\", key, propertySuffix);\n+                augmentedKey = augmentedKey + propertySuffix;\n             }\n-        return idx;\n+            return augmentedKey;\n         }\n \n-    private boolean isNestProperty(String uri, String prefixToken, String suffixToken) {\n-        if (ObjectHelper.isNotEmpty(uri)) {\n-            uri = uri.trim();\n-            if (uri.startsWith(prefixToken) && uri.endsWith(suffixToken)) {\n-                return true;\n+        /**\n+         * Gets the property with the given key, it returns {@code null} if the property is not found\n+         *\n+         * @param key Key of the property\n+         * @return Value of the property or {@code null} if not found\n+         */\n+        private String doGetPropertyValue(String key) {\n+            String value = System.getProperty(key);\n+            if (value != null) {\n+                log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, value);\n+            } else if (properties != null) {\n+                value = properties.getProperty(key);\n             }\n+            return value;\n         }\n-        return false;\n     }\n \n-    private String takeOffNestTokes(String uri, String prefixToken, String suffixToken) {\n-        int start = prefixToken.length(); \n-        int end = uri.length() - suffixToken.length();\n-        return uri.substring(start, end); \n-    }\n+    /**\n+     * This inner class is the definition of a property used in a string\n+     */\n+    private static final class Property {\n+        private final int beginIndex;\n+        private final int endIndex;\n+        private final String key;\n+        private final String value;\n \n-    private String createConstantPart(String uri, int start, int end) {\n-        return uri.substring(start, end);\n+        private Property(int beginIndex, int endIndex, String key, String value) {\n+            this.beginIndex = beginIndex;\n+            this.endIndex = endIndex;\n+            this.key = key;\n+            this.value = value;\n         }\n \n-    private String createPlaceholderPart(String key, Properties properties, List<String> replaced, String prefixToken, String suffixToken) {\n-        // keep track of which parts we have replaced\n-        replaced.add(key);\n-        \n-        String propertyValue = System.getProperty(key);\n-        if (propertyValue != null) {\n-            log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n-        } else if (properties != null) {\n-            propertyValue = properties.getProperty(key);\n-        }\n-        \n-        // we need to check if the propertyValue is nested\n-        // we need to check if there is cycle dependency of the nested properties\n-        List<String> visited = new ArrayList<String>();\n-        while (isNestProperty(propertyValue, prefixToken, suffixToken)) {\n-            visited.add(key);\n-            // need to take off the token first\n-            String value = takeOffNestTokes(propertyValue, prefixToken, suffixToken);\n-            key = parseUri(value, properties, prefixToken, suffixToken);\n-            if (visited.contains(key)) {\n-                throw new IllegalArgumentException(\"Circular reference detected with key [\" + key + \"] from text: \" + propertyValue);\n-            }\n-            propertyValue = System.getProperty(key);\n-            if (propertyValue != null) {\n-                log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n-            } else if (properties != null) {\n-                propertyValue = properties.getProperty(key);\n+        /**\n+         * Gets the begin index of the property (including the prefix token).\n+         */\n+        public int getBeginIndex() {\n+            return beginIndex;\n         }\n+\n+        /**\n+         * Gets the end index of the property (including the suffix token).\n+         */\n+        public int getEndIndex() {\n+            return endIndex;\n         }\n \n-        return parseProperty(key, propertyValue, properties);\n+        /**\n+         * Gets the key of the property.\n+         */\n+        public String getKey() {\n+            return key;\n         }\n \n+        /**\n+         * Gets the value of the property.\n+         */\n+        public String getValue() {\n+            return value;\n+        }\n+    }\n }\n", "nb_test": 4976, "linesAdd": 131, "jira_id": "7429", "singleLine": false, "nb_skipped": 3, "commit": "43956f93", "nb_failure": 0, "linesRem": 107}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["BeanWithExpressionInjectionPredicateTest>TestSupport.runBare:58->testSendMessageWithFoo:43 expected:<true> but was:<false>", "VmMultipleConsumersRemoteRouteTest.testVmMultipleConsumersRemoteRoute:62 mock://route1 Received message count. Expected: <100> but was: <36>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/DefaultAnnotationExpressionFactory.java b/camel-core/src/main/java/org/apache/camel/component/bean/DefaultAnnotationExpressionFactory.java\nindex 1038cdf..cf961c3 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/DefaultAnnotationExpressionFactory.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/DefaultAnnotationExpressionFactory.java\n@@ -21,9 +21,11 @@\n \n import org.apache.camel.CamelContext;\n import org.apache.camel.Expression;\n+import org.apache.camel.Predicate;\n import org.apache.camel.language.LanguageAnnotation;\n import org.apache.camel.spi.Language;\n import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.PredicateToExpressionAdapter;\n \n /**\n  * Default implementation of the {@link AnnotationExpressionFactory}.\n@@ -42,8 +44,14 @@ public Expression createExpression(CamelContext camelContext, Annotation annotat\n             throw new IllegalArgumentException(\"Cannot find the language: \" + languageName + \" on the classpath\");\n         }\n         String expression = getExpressionFromAnnotation(annotation);\n+\n+        if (expressionReturnType == Boolean.class || expressionReturnType == boolean.class) {\n+            Predicate predicate = language.createPredicate(expression);\n+            return PredicateToExpressionAdapter.toExpression(predicate);\n+        } else {\n             return language.createExpression(expression);\n         }\n+    }\n \n     protected String getExpressionFromAnnotation(Annotation annotation) {\n         Object value = getAnnotationObjectValue(annotation, \"value\");\n", "nb_test": 4699, "linesAdd": 8, "jira_id": "6743", "singleLine": false, "nb_skipped": 1, "commit": "745a85ab", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["StreamCachingRoutingSlipTest>TestSupport.runBare:58->testByteArrayInputStream:33->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://bar Body of message: 0. Expected: <<hello/>> but was: <>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java b/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\nindex cd4a864..bde0f42 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\n@@ -36,6 +36,7 @@\n import org.apache.camel.support.ServiceSupport;\n import org.apache.camel.util.AsyncProcessorHelper;\n import org.apache.camel.util.ExchangeHelper;\n+import org.apache.camel.util.MessageHelper;\n import org.apache.camel.util.ObjectHelper;\n import org.apache.camel.util.ServiceHelper;\n import org.slf4j.Logger;\n@@ -268,6 +269,10 @@ protected Exchange prepareExchangeForRoutingSlip(Exchange current, Endpoint endp\n         // exchange being routed.\n         copy.setExchangeId(current.getExchangeId());\n         copyOutToIn(copy, current);\n+\n+        // ensure stream caching is reset\n+        MessageHelper.resetStreamCache(copy.getIn());\n+\n         return copy;\n     }\n \n", "nb_test": 4618, "linesAdd": 4, "jira_id": "6604", "singleLine": false, "nb_skipped": 1, "commit": "55751402", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testObjectNameModification(org.apache.camel.management.DefaultManagementAgentMockTest):"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementAgent.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementAgent.java\nindex d59c492..c9aa47d 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementAgent.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementAgent.java\n@@ -22,9 +22,9 @@\n import java.net.UnknownHostException;\n import java.rmi.RemoteException;\n import java.rmi.registry.LocateRegistry;\n-import java.util.HashSet;\n+import java.util.HashMap;\n import java.util.List;\n-import java.util.Set;\n+import java.util.Map;\n import java.util.concurrent.ExecutorService;\n import javax.management.JMException;\n import javax.management.MBeanServer;\n@@ -60,7 +60,8 @@\n     private CamelContext camelContext;\n     private ExecutorService executorService;\n     private MBeanServer server;\n-    private final Set<ObjectName> mbeansRegistered = new HashSet<ObjectName>();\n+    // need a name -> actual name mapping as some servers changes the names (suc as WebSphere)\n+    private final Map<ObjectName, ObjectName> mbeansRegistered = new HashMap<ObjectName, ObjectName>();\n     private JMXConnectorServer cs;\n \n     private Integer registryPort;\n@@ -240,15 +241,17 @@ public void register(Object obj, ObjectName name, boolean forceRegistration) thr\n     }\n \n     public void unregister(ObjectName name) throws JMException {\n-        if (server.isRegistered(name)) {\n-            server.unregisterMBean(name);\n+        if (isRegistered(name)) {\n+            server.unregisterMBean(mbeansRegistered.get(name));\n             LOG.debug(\"Unregistered MBean with ObjectName: {}\", name);\n         }\n         mbeansRegistered.remove(name);\n     }\n \n     public boolean isRegistered(ObjectName name) {\n-        return server.isRegistered(name);\n+        return (mbeansRegistered.containsKey(name) \n+                && server.isRegistered(mbeansRegistered.get(name))) \n+                || server.isRegistered(name);\n     }\n \n     protected void doStart() throws Exception {\n@@ -280,11 +283,10 @@ protected void doStop() throws Exception {\n         }\n \n         // Using the array to hold the busMBeans to avoid the CurrentModificationException\n-        ObjectName[] mBeans = mbeansRegistered.toArray(new ObjectName[mbeansRegistered.size()]);\n+        ObjectName[] mBeans = mbeansRegistered.keySet().toArray(new ObjectName[mbeansRegistered.size()]);\n         int caught = 0;\n         for (ObjectName name : mBeans) {\n             try {\n-                mbeansRegistered.remove(name);\n                 unregister(name);\n             } catch (Exception e) {\n                 LOG.info(\"Exception unregistering MBean with name \" + name, e);\n@@ -302,7 +304,7 @@ private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceR\n         throws JMException {\n \n         // have we already registered the bean, there can be shared instances in the camel routes\n-        boolean exists = server.isRegistered(name);\n+        boolean exists = isRegistered(name);\n         if (exists) {\n             if (forceRegistration) {\n                 LOG.info(\"ForceRegistration enabled, unregistering existing MBean with ObjectName: {}\", name);\n@@ -324,7 +326,7 @@ private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceR\n         if (instance != null) {\n             ObjectName registeredName = instance.getObjectName();\n             LOG.debug(\"Registered MBean with ObjectName: {}\", registeredName);\n-            mbeansRegistered.add(registeredName);\n+            mbeansRegistered.put(name, registeredName);\n         }\n     }\n \n", "nb_test": 4160, "linesAdd": 11, "jira_id": "5187", "singleLine": false, "nb_skipped": 0, "commit": "8cadc344", "nb_failure": 1, "linesRem": 10}, {"files": 3, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FileConsumerRelativeFileNameTest>TestSupport.runBare:58->testValidFilenameOnExchange:49->TestSupport.assertDirectoryEquals:448->TestSupport.assertDirectoryEquals:463 expected:<...t/filename-consumer-[bye].txt> but was:<...t/filename-consumer-[hello].txt>", "TryCatchRecipientListTest>TestSupport.runBare:58->testDualTryCatchRecipientList:77->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://bar Received message count. Expected: <1> but was: <0>", "TryCatchRecipientListTest>TestSupport.runBare:58->testTryCatchRecipientList:58->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Received message count. Expected: <1> but was: <0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/Exchange.java b/camel-core/src/main/java/org/apache/camel/Exchange.java\nindex 506ba29..f9f3fe3 100644\n--- a/camel-core/src/main/java/org/apache/camel/Exchange.java\n+++ b/camel-core/src/main/java/org/apache/camel/Exchange.java\n@@ -194,6 +194,7 @@\n     String TRACE_EVENT_NODE_ID   = \"CamelTraceEventNodeId\";\n     String TRACE_EVENT_TIMESTAMP = \"CamelTraceEventTimestamp\";\n     String TRACE_EVENT_EXCHANGE  = \"CamelTraceEventExchange\";\n+    String TRY_ROUTE_BLOCK       = \"TryRouteBlock\";\n     String TRANSFER_ENCODING     = \"Transfer-Encoding\";\n \n     String UNIT_OF_WORK_EXHAUSTED    = \"CamelUnitOfWorkExhausted\";\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex 69e4667..697ae32 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -885,7 +885,10 @@ protected ProcessorExchangePair createProcessorExchangePair(int index, Processor\n     protected Processor createErrorHandler(RouteContext routeContext, Exchange exchange, Processor processor) {\n         Processor answer;\n \n-        if (routeContext != null) {\n+        boolean tryBlock = exchange.getProperty(Exchange.TRY_ROUTE_BLOCK, false, boolean.class);\n+\n+        // do not wrap in error handler if we are inside a try block\n+        if (!tryBlock && routeContext != null) {\n             // wrap the producer in error handler so we have fine grained error handling on\n             // the output side instead of the input side\n             // this is needed to support redelivery on that output alone and not doing redelivery\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\nindex 1bfe5dd..b53a14e 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\n@@ -73,6 +73,7 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         exchange.setProperty(Exchange.EXCEPTION_HANDLED, null);\n \n         while (continueRouting(processors, exchange)) {\n+            exchange.setProperty(Exchange.TRY_ROUTE_BLOCK, true);\n             ExchangeHelper.prepareOutToIn(exchange);\n \n             // process the next processor\n@@ -92,6 +93,7 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         }\n \n         ExchangeHelper.prepareOutToIn(exchange);\n+        exchange.removeProperty(Exchange.TRY_ROUTE_BLOCK);\n         exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\n         LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n         callback.done(true);\n@@ -115,6 +117,7 @@ public void done(boolean doneSync) {\n \n                 // continue processing the try .. catch .. finally asynchronously\n                 while (continueRouting(processors, exchange)) {\n+                    exchange.setProperty(Exchange.TRY_ROUTE_BLOCK, true);\n                     ExchangeHelper.prepareOutToIn(exchange);\n \n                     // process the next processor\n@@ -130,6 +133,7 @@ public void done(boolean doneSync) {\n                 }\n \n                 ExchangeHelper.prepareOutToIn(exchange);\n+                exchange.removeProperty(Exchange.TRY_ROUTE_BLOCK);\n                 exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\n                 LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n                 callback.done(false);\n", "nb_test": 4857, "linesAdd": 8, "jira_id": "7275", "singleLine": false, "nb_skipped": 3, "commit": "44cad623", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SedaErrorTest>TestSupport.runBare:58->testErrorHandle:41->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://dlc Received message count. Expected: <1> but was: <0>", "VmMultipleConsumersRemoteRouteTest.testVmMultipleConsumersRemoteRoute:66 Timeout waiting for endpoints to receive enough messages. mock://route1 timed out.", "ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\nindex b7d3c3c..6ba6fc8 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\n@@ -107,7 +107,10 @@ public boolean process(Exchange exchange, final AsyncCallback callback) {\n \n             EventHelper.notifyExchangeSending(exchange.getContext(), target, destination);\n             LOG.debug(\">>>> {} {}\", destination, exchange);\n-            return producer.process(exchange, new AsyncCallback() {\n+\n+            boolean sync = true;\n+            try {\n+                sync = producer.process(exchange, new AsyncCallback() {\n                     @Override\n                     public void done(boolean doneSync) {\n                         try {\n@@ -121,6 +124,14 @@ public void done(boolean doneSync) {\n                         }\n                     }\n                 });\n+            } catch (Throwable throwable) {\n+                if (exchange != null) {\n+                    exchange.setException(throwable);\n+                }\n+\n+            }\n+\n+            return sync;\n         }\n \n         // send the exchange to the destination using the producer cache for the non optimized producers\n", "nb_test": 4744, "linesAdd": 12, "jira_id": "6918", "singleLine": false, "nb_skipped": 1, "commit": "5761250c", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FileMoveAndMoveFailedIssueTest>TestSupport.runBare:58->testMove:37->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result The file should exists: target/input/target/input.bak/somedate/hello.txt", "FileMoveAndMoveFailedIssueTest>TestSupport.runBare:58->testMoveFailed:46->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result The file should exists: target/input/target/input.err/somedate/bomb.txt"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\nindex 907de21..e517550 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n@@ -185,7 +185,7 @@ public void changeFileName(String newName) {\n \n         // Make sure the names is normalized.\n         String newFileName = FileUtil.normalizePath(newName);\n-        String newEndpointPath = FileUtil.normalizePath(endpointPath);\n+        String newEndpointPath = FileUtil.normalizePath(endpointPath.endsWith(\"\" + File.separatorChar) ? endpointPath : endpointPath + File.separatorChar);\n \n         LOG.trace(\"Normalized endpointPath: {}\", newEndpointPath);\n         LOG.trace(\"Normalized newFileName: ()\", newFileName);\n", "nb_test": 5476, "linesAdd": 1, "jira_id": "9238", "singleLine": false, "nb_skipped": 4, "commit": "169b981e", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["AdviceWithCBRTest>TestSupport.runBare:58->testAdviceCBR:49->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://foo2 Received message count. Expected: <1> but was: <2>", "ProcessorDefinitionHelperTest>TestSupport.runBare:58->testFilterTypeInOutputs:32 expected:<[foo]> but was:<[choice1]>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\nindex 5575d36..2ae283b 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\n@@ -198,9 +198,6 @@ public static String getRouteId(ProcessorDefinition<?> node) {\n         }\n \n         for (ProcessorDefinition out : outputs) {\n-            if (type.isInstance(out)) {\n-                found.add((T)out);\n-            }\n \n             // send is much common\n             if (out instanceof SendDefinition) {\n@@ -222,6 +219,9 @@ public static String getRouteId(ProcessorDefinition<?> node) {\n                     List<ProcessorDefinition<?>> children = choice.getOtherwise().getOutputs();\n                     doFindType(children, type, found);\n                 }\n+\n+                // do not check children as we already did that\n+                continue;\n             }\n \n             // special for try ... catch ... finally\n@@ -253,6 +253,10 @@ public static String getRouteId(ProcessorDefinition<?> node) {\n                 continue;\n             }\n \n+            if (type.isInstance(out)) {\n+                found.add((T)out);\n+            }\n+\n             // try children as well\n             List<ProcessorDefinition<?>> children = out.getOutputs();\n             doFindType(children, type, found);\n", "nb_test": 4980, "linesAdd": 6, "jira_id": "7562", "singleLine": false, "nb_skipped": 3, "commit": "689147e9", "nb_failure": 2, "linesRem": 3}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["DataFormatStreamingTest>TestSupport.runBare:58->DataFormatTest.testMarshalThenUnmarshalBean:42 \u00bb CamelExecution"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/stream/CachedOutputStream.java b/camel-core/src/main/java/org/apache/camel/converter/stream/CachedOutputStream.java\nindex c5f3b49..0e3540c 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/stream/CachedOutputStream.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/stream/CachedOutputStream.java\n@@ -71,11 +71,10 @@ public CachedOutputStream(Exchange exchange) {\n         this(exchange, true);\n     }\n \n-    public CachedOutputStream(Exchange exchange, boolean closedOnCompletion) {\n+    public CachedOutputStream(Exchange exchange, final boolean closedOnCompletion) {\n         this.strategy = exchange.getContext().getStreamCachingStrategy();\n         currentStream = new CachedByteArrayOutputStream(strategy.getBufferSize());\n         \n-        if (closedOnCompletion) {\n         // add on completion so we can cleanup after the exchange is done such as deleting temporary files\n         exchange.addOnCompletion(new SynchronizationAdapter() {\n             @Override\n@@ -84,9 +83,16 @@ public void onDone(Exchange exchange) {\n                     if (fileInputStreamCache != null) {\n                         fileInputStreamCache.close();\n                     }\n+                    if (closedOnCompletion) {\n                         close();\n+                    }\n                 } catch (Exception e) {\n-                        LOG.warn(\"Error deleting temporary cache file: \" + tempFile, e);\n+                    LOG.warn(\"Error closing streams. This exception will be ignored.\", e);\n+                }\n+                try {\n+                    cleanUpTempFile();\n+                } catch (Exception e) {\n+                    LOG.warn(\"Error deleting temporary cache file: \" + tempFile + \". This exception will be ignored.\", e);\n                 }\n             }\n     \n@@ -96,7 +102,6 @@ public String toString() {\n             }\n         });\n     }\n-    }\n \n     public void flush() throws IOException {\n         currentStream.flush();       \n@@ -104,7 +109,6 @@ public void flush() throws IOException {\n \n     public void close() throws IOException {\n         currentStream.close();\n-        cleanUpTempFile();\n     }\n \n     public boolean equals(Object obj) {\n", "nb_test": 4772, "linesAdd": 9, "jira_id": "7055", "singleLine": false, "nb_skipped": 1, "commit": "15e1077d", "nb_failure": 0, "linesRem": 5}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testBeanBeforeAggregation(org.apache.camel.processor.aggregator.BeanBeforeAggregateIssueTest)", "testEnd2FailureTest(org.apache.camel.issues.MulticastParallelStopOnExceptionWithOnExceptionIssueTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\nindex f2f09c0..78ab290 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n@@ -177,12 +177,16 @@ public void process(Exchange exchange) throws Exception {\n             throw new ClosedCorrelationKeyException(key, exchange);\n         }\n \n+        // copy exchange, and do not share the unit of work\n+        // the aggregated output runs in another unit of work\n+        Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false);\n+\n         // when memory based then its fast using synchronized, but if the aggregation repository is IO\n         // bound such as JPA etc then concurrent aggregation per correlation key could\n         // improve performance as we can run aggregation repository get/add in parallel\n         lock.lock();\n         try {\n-            doAggregation(key, exchange);\n+            doAggregation(key, copy);\n         } finally {\n             lock.unlock();\n         }\n", "nb_test": 3083, "linesAdd": 3, "jira_id": "3535", "singleLine": false, "nb_skipped": 0, "commit": "b56d2962", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testIssue(org.apache.camel.issues.StopRouteImpactsErrorHandlerTest)", "testIssue(org.apache.camel.issues.StopRouteShouldNotStopContextScopedErrorHandlerIssueTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\nindex eb31c6b..efbaa17 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\n@@ -840,7 +840,13 @@ protected void doStart() throws Exception {\n \n     @Override\n     protected void doStop() throws Exception {\n-        ServiceHelper.stopServices(deadLetter, output, outputAsync);\n+        // noop, do not stop any services which we only do when shutting down\n+        // as the error handler can be context scoped, and should not stop in case\n+        // a route stops\n     }\n \n+    @Override\n+    protected void doShutdown() throws Exception {\n+        ServiceHelper.stopServices(deadLetter, output, outputAsync);\n+    }\n }\n", "nb_test": 3316, "linesAdd": 4, "jira_id": "3878", "singleLine": false, "nb_skipped": 0, "commit": "b9094cb5", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["AsyncLoopCopyTest>TestSupport.runBare:58->testAsyncLoopCopy:42->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://loopIterationStart Body of message: 1. Expected: <Hello Camel> but was: <Bye Camel>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/LoopProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/LoopProcessor.java\nindex df2baed..89649b1 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/LoopProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/LoopProcessor.java\n@@ -61,6 +61,10 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n             return true;\n         }\n         \n+        // we hold on to the original Exchange in case it's needed for copies\n+        final Exchange original = exchange;\n+        \n+        // per-iteration exchange\n         Exchange target = exchange;\n \n         // set the size before we start\n@@ -70,8 +74,9 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         while (index.get() < count.get()) {\n \n             // and prepare for next iteration\n-            target = prepareExchange(exchange, index.get());\n-            boolean sync = process(target, callback, index, count);\n+            // if (!copy) target = exchange; else copy of original\n+            target = prepareExchange(exchange, index.get(), original);\n+            boolean sync = process(target, callback, index, count, original);\n \n             if (!sync) {\n                 LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n@@ -94,7 +99,8 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n     }\n \n     protected boolean process(final Exchange exchange, final AsyncCallback callback,\n-                              final AtomicInteger index, final AtomicInteger count) {\n+                              final AtomicInteger index, final AtomicInteger count,\n+                              final Exchange original) {\n \n         // set current index as property\n         LOG.debug(\"LoopProcessor: iteration #{}\", index.get());\n@@ -116,10 +122,10 @@ public void done(boolean doneSync) {\n                 while (index.get() < count.get()) {\n \n                     // and prepare for next iteration\n-                    target = prepareExchange(exchange, index.get());\n+                    target = prepareExchange(exchange, index.get(), original);\n \n                     // process again\n-                    boolean sync = process(target, callback, index, count);\n+                    boolean sync = process(target, callback, index, count, original);\n                     if (!sync) {\n                         LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n                         // the remainder of the routing slip will be completed async\n@@ -148,10 +154,11 @@ public void done(boolean doneSync) {\n      * @param index the index of the next iteration\n      * @return the exchange to use\n      */\n-    protected Exchange prepareExchange(Exchange exchange, int index) {\n+    protected Exchange prepareExchange(Exchange exchange, int index, Exchange original) {\n         if (copy) {\n             // use a copy but let it reuse the same exchange id so it appear as one exchange\n-            return ExchangeHelper.createCopy(exchange, true);\n+            // use the original exchange rather than the looping exchange (esp. with the async routing engine)\n+            return ExchangeHelper.createCopy(original, true);\n         } else {\n             ExchangeHelper.prepareOutToIn(exchange);\n             return exchange;\n", "nb_test": 4675, "linesAdd": 10, "jira_id": "6667", "singleLine": false, "nb_skipped": 1, "commit": "1fc7bd7a", "nb_failure": 1, "linesRem": 7}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testPollFileAndShouldBeDeletedAtThirdPoll(org.apache.camel.component.file.FromFilePollThirdTimeOkTest): mock://result Body of message: 0. Expected: <Hello World this file will be deleted> but was: <null>", "testPercentEncode(org.apache.camel.util.UnsafeCharactersEncoderTest): Get the wrong encoding result expected:<...re%20bar%20like%20'%[25]A'> but was:<...re%20bar%20like%20'%[]A'>", "testThreadNotUsedForEveryAggregatorWithCustomExecutorService(org.apache.camel.processor.aggregator.AggregateTimeoutWithExecutorServiceTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/util/UnsafeUriCharactersEncoder.java\nindex 39659e4..4bc707f 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/UnsafeUriCharactersEncoder.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/UnsafeUriCharactersEncoder.java\n@@ -20,6 +20,8 @@\n \n /**\n  * Encoder for unsafe URI characters.\n+ * <p/>\n+ * A good source for details is <a href=\"http://en.wikipedia.org/wiki/Url_encode\">wikipedia url encode</a> article.\n  */\n public final class UnsafeUriCharactersEncoder {\n     private static BitSet unsafeCharacters;   \n@@ -33,7 +35,7 @@\n         unsafeCharacters.set('<');\n         unsafeCharacters.set('>');\n         unsafeCharacters.set('#');\n-        // unsafeCharacters.set('%');\n+        unsafeCharacters.set('%');\n         unsafeCharacters.set('{');\n         unsafeCharacters.set('}');\n         unsafeCharacters.set('|');\n@@ -70,10 +72,27 @@ public static String encode(String s) {\n         }\n \n         // okay there are some unsafe characters so we do need to encode\n+        // see details at: http://en.wikipedia.org/wiki/Url_encode\n         StringBuilder sb = new StringBuilder();\n-        for (char ch : chars) {\n+        for (int i = 0; i < chars.length; i++) {\n+            char ch = chars[i];\n             if (ch > 0 && ch < 128 && unsafeCharacters.get(ch)) {\n+                // special for % sign as it may be a decimal encoded value\n+                if (ch == '%') {\n+                    char next = i + 1 < chars.length ? chars[i + 1] : ' ';\n+                    char next2 = i + 2 < chars.length ? chars[i + 2] : ' ';\n+\n+                    if (isHexDigit(next) && isHexDigit(next2)) {\n+                        // its already encoded (decimal encoded) so just append as is\n+                        sb.append(ch);\n+                    } else {\n+                        // must escape then, as its an unsafe character\n+                        appendEscape(sb, (byte)ch);\n+                    }\n+                } else {\n+                    // must escape then, as its an unsafe character\n                     appendEscape(sb, (byte)ch);\n+                }\n             } else {\n                 sb.append(ch);\n             }\n@@ -88,4 +106,13 @@ private static void appendEscape(StringBuilder sb, byte b) {\n         sb.append(HEX_DIGITS[(b >> 0) & 0x0f]);\n     }\n \n+    private static boolean isHexDigit(char ch) {\n+        for (char hex : HEX_DIGITS) {\n+            if (hex == ch) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n }\n", "nb_test": 4218, "linesAdd": 23, "jira_id": "5357", "singleLine": false, "nb_skipped": 1, "commit": "4cf7e80e", "nb_failure": 2, "linesRem": 1}, {"files": 4, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMultithreadedLocking(org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategyTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java b/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\nindex 206bb98..1c28345 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\n@@ -106,14 +106,19 @@ public boolean buildDirectory(String directory, boolean absolute) throws Generic\n             }\n         }\n \n+        // We need to make sure that this is thread-safe and only one thread tries to create the path directory at the same time.\n+        synchronized (this) {\n             if (path.isDirectory() && path.exists()) {\n                 // the directory already exists\n                 return true;\n             } else {\n-            LOG.trace(\"Building directory: {}\", path);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Building directory: \" + path);\n+                }\n                 return path.mkdirs();\n             }\n         }\n+    }\n \n     public List<File> listFiles() throws GenericFileOperationFailedException {\n         // noop\n@@ -152,7 +157,9 @@ public boolean storeFile(String fileName, Exchange exchange) throws GenericFileO\n         if (file.exists()) {\n             if (endpoint.getFileExist() == GenericFileExist.Ignore) {\n                 // ignore but indicate that the file was written\n-                LOG.trace(\"An existing file already exists: {}. Ignore and do not override it.\", file);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"An existing file already exists: \" + file + \". Ignore and do not override it.\");\n+                }\n                 return true;\n             } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\n                 throw new GenericFileOperationFailedException(\"File already exist: \" + file + \". Cannot write new file.\");\n@@ -222,13 +229,17 @@ private void keepLastModified(Exchange exchange, File file) {\n             }\n             if (last != null) {\n                 boolean result = file.setLastModified(last);\n-                LOG.trace(\"Keeping last modified timestamp: {} on file: {} with result: {}\", new Object[]{last, file, result});\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Keeping last modified timestamp: \" + last + \" on file: \" + file + \" with result: \" + result);\n+                }\n             }\n         }\n     }\n \n     private boolean writeFileByLocalWorkPath(File source, File file) {\n-        LOG.trace(\"Using local work file being renamed from: {} to: {}\", source, file);\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Using local work file being renamed from: \" + source + \" to: \" + file);\n+        }\n \n         return FileUtil.renameFile(source, file);\n     }\n@@ -239,7 +250,9 @@ private void writeFileByFile(File source, File target) throws IOException {\n         try {\n             out = prepareOutputFileChannel(target, out);\n \n-            LOG.trace(\"Using FileChannel to transfer from: {} to: {}\", in, out);\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Using FileChannel to transfer from: \" + in + \" to: \" + out);\n+            }\n \n             long size = in.size();\n             long position = 0;\n@@ -257,7 +270,9 @@ private void writeFileByStream(InputStream in, File target) throws IOException {\n         try {\n             out = prepareOutputFileChannel(target, out);\n \n-            LOG.trace(\"Using InputStream to transfer from: {} to: {}\", in, out);\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Using InputStream to transfer from: \" + in + \" to: \" + out);\n+            }\n             int size = endpoint.getBufferSize();\n             byte[] buffer = new byte[size];\n             ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java\nindex 9235dcc..8f5ff7b 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java\n@@ -29,19 +29,22 @@\n \n     @Override\n     public boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {\n-        // must invoke super\n-        boolean result = super.begin(operations, endpoint, exchange, file);\n-        if (!result) {\n-            return false;\n-        }\n+\n+        // We need to invoke super, but to the file that we are going to use for processing, so we do super after renaming.\n+        GenericFile<T> to = file;\n \n         if (beginRenamer != null) {\n             GenericFile<T> newName = beginRenamer.renameFile(exchange, file);\n-            GenericFile<T> to = renameFile(operations, file, newName);\n+            to = renameFile(operations, file, newName);\n             if (to != null) {\n                 to.bindToExchange(exchange);\n             }\n         }\n+        // must invoke super\n+        boolean result = super.begin(operations, endpoint, exchange, to);\n+        if (!result) {\n+            return false;\n+        }\n \n         return true;\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java\nindex 1e32688..943e71f 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java\n@@ -31,19 +31,22 @@ public GenericFileRenameProcessStrategy() {\n \n     @Override\n     public boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {\n-        // must invoke super\n-        boolean result = super.begin(operations, endpoint, exchange, file);\n-        if (!result) {\n-            return false;\n-        }\n+\n+        // We need to invoke super, but to the file that we are going to use for processing, so we do super after renaming.\n+        GenericFile<T> to = file;\n \n         if (beginRenamer != null) {\n             GenericFile<T> newName = beginRenamer.renameFile(exchange, file);\n-            GenericFile<T> to = renameFile(operations, file, newName);\n+            to = renameFile(operations, file, newName);\n             if (to != null) {\n                 to.bindToExchange(exchange);\n             }\n         }\n+        // must invoke super\n+        boolean result = super.begin(operations, endpoint, exchange, to);\n+        if (!result) {\n+            return false;\n+        }\n \n         return true;\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\nindex 6d72d19..734a654 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\n@@ -34,8 +34,6 @@\n  */\n public class MarkerFileExclusiveReadLockStrategy implements GenericFileExclusiveReadLockStrategy<File> {\n     private static final transient Logger LOG = LoggerFactory.getLogger(MarkerFileExclusiveReadLockStrategy.class);\n-    private File lock;\n-    private String lockFileName;\n \n     public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) {\n         String dir = endpoint.getConfiguration().getDirectory();\n@@ -50,29 +48,26 @@ public void prepareOnStartup(GenericFileOperations<File> operations, GenericFile\n \n     public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations,\n                                             GenericFile<File> file, Exchange exchange) throws Exception {\n-        lockFileName = file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;\n+        String lockFileName = getLockFileName(file);\n         LOG.trace(\"Locking the file: {} using the lock file name: {}\", file, lockFileName);\n \n         // create a plain file as marker filer for locking (do not use FileLock)\n-        lock = new File(lockFileName);\n+        File lock = new File(lockFileName);\n         boolean acquired = lock.createNewFile();\n-        if (!acquired) {\n-            lock = null;\n-\n-        }\n \n         return acquired;\n     }\n \n     public void releaseExclusiveReadLock(GenericFileOperations<File> operations,\n                                          GenericFile<File> file, Exchange exchange) throws Exception {\n-        if (lock != null) {\n+        String lockFileName = getLockFileName(file);\n+        File lock = new File(lockFileName);\n+\n         LOG.trace(\"Unlocking file: {}\", lockFileName);\n \n         boolean deleted = FileUtil.deleteFile(lock);\n         LOG.trace(\"Lock file: {} was deleted: {}\", lockFileName, deleted);\n     }\n-    }\n \n     public void setTimeout(long timeout) {\n         // noop\n@@ -101,4 +96,8 @@ private static void deleteLockFiles(File dir, boolean recursive) {\n         }\n     }\n \n+    private static String getLockFileName(GenericFile<File> file) {\n+        return file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;\n+    }\n+\n }\n", "nb_test": 3269, "linesAdd": 43, "jira_id": "3789", "singleLine": false, "nb_skipped": 0, "commit": "9319e139", "nb_failure": 1, "linesRem": 26}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["MulticastGroupedExchangeExceptionTest>TestSupport.runBare:58->testAFail:75 \u00bb CamelExecution"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/GroupedExchangeAggregationStrategy.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/GroupedExchangeAggregationStrategy.java\nindex 84b375d..2906270 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/GroupedExchangeAggregationStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/GroupedExchangeAggregationStrategy.java\n@@ -19,6 +19,7 @@\n import java.util.List;\n \n import org.apache.camel.Exchange;\n+import org.apache.camel.impl.DefaultExchange;\n \n /**\n  * Aggregate all exchanges into a single combined Exchange holding all the aggregated exchanges\n@@ -43,13 +43,12 @@ public void onCompletion(Exchange exchange) {\n \n     @Override\n     public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n-        Exchange answer = super.aggregate(oldExchange, newExchange);\n         if (oldExchange == null) {\n-            // for the first time we must do a copy as the answer, so the outgoing\n-            // exchange is not one of the grouped exchanges, as that causes a endless circular reference\n-            answer = answer.copy();\n+            // for the first time we must create a new empty exchange as the holder, as the outgoing exchange\n+            // must not be one of the grouped exchanges, as that causes a endless circular reference\n+            oldExchange = new DefaultExchange(newExchange);\n         }\n-        return answer;\n+        return super.aggregate(oldExchange, newExchange);\n     }\n \n     @Override\n", "nb_test": 4910, "linesAdd": 3, "jira_id": "7271", "singleLine": false, "nb_skipped": 3, "commit": "a5a2f750", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testXPathWithNamespaceDifferentNamespace(org.apache.camel.builder.xml.ExtractXPathWithNamespaceTest)", "testToShort(org.apache.camel.converter.ObjectConverterTest)", "testToInteger(org.apache.camel.converter.ObjectConverterTest)", "testToLong(org.apache.camel.converter.ObjectConverterTest)", "testToFloat(org.apache.camel.converter.ObjectConverterTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/ObjectConverter.java b/camel-core/src/main/java/org/apache/camel/converter/ObjectConverter.java\nindex 465c4e9..24df843 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/ObjectConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/ObjectConverter.java\n@@ -137,6 +137,9 @@ public static Short toShort(Object value) {\n         if (value instanceof Short) {\n             return (Short) value;\n         } else if (value instanceof Number) {\n+            if (value.equals(Double.NaN)) {\n+                return null;\n+            }\n             Number number = (Number) value;\n             return number.shortValue();\n         } else if (value instanceof String) {\n@@ -154,6 +157,9 @@ public static Integer toInteger(Object value) {\n         if (value instanceof Integer) {\n             return (Integer) value;\n         } else if (value instanceof Number) {\n+            if (value.equals(Double.NaN)) {\n+                return null;\n+            }\n             Number number = (Number) value;\n             return number.intValue();\n         } else if (value instanceof String) {\n@@ -171,6 +177,9 @@ public static Long toLong(Object value) {\n         if (value instanceof Long) {\n             return (Long) value;\n         } else if (value instanceof Number) {\n+            if (value.equals(Double.NaN)) {\n+                return null;\n+            }\n             Number number = (Number) value;\n             return number.longValue();\n         } else if (value instanceof String) {\n@@ -188,6 +197,9 @@ public static Float toFloat(Object value) {\n         if (value instanceof Float) {\n             return (Float) value;\n         } else if (value instanceof Number) {\n+            if (value.equals(Double.NaN)) {\n+                return null;\n+            }\n             Number number = (Number) value;\n             return number.floatValue();\n         } else if (value instanceof String) {\n", "nb_test": 3396, "linesAdd": 12, "jira_id": "4011", "singleLine": false, "nb_skipped": 0, "commit": "cbffff59", "nb_failure": 5, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>", "DefaultEndpointTest>TestSupport.runBare:58->testToString:48 \u00bb IllegalArgument ..."], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultEndpoint.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultEndpoint.java\nindex 3dae289..badd48e 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultEndpoint.java\n@@ -136,7 +136,13 @@ public boolean equals(Object object) {\n \n     @Override\n     public String toString() {\n-        return String.format(\"Endpoint[%s]\", URISupport.sanitizeUri(getEndpointUri()));\n+        String value = null;\n+        try {\n+            value = getEndpointUri();\n+        } catch (RuntimeException e) {\n+            // ignore any exception and use null for building the string value\n+        }\n+        return String.format(\"Endpoint[%s]\", URISupport.sanitizeUri(value));\n     }\n \n     /**\n", "nb_test": 4886, "linesAdd": 6, "jira_id": "7344", "singleLine": false, "nb_skipped": 3, "commit": "91228815", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "camel", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["BeanLanguageOGNLTest>TestSupport.runBare:58->testBeanLanguageOGNL:29 expected:<Hello [World]> but was:<Hello [org.apache.camel.language.BeanLanguageOGNLTest$MyOtherReallyCoolBean@747eb1c4]>", "BeanOgnMethodWithXPathInjectionTest>TestSupport.runBare:58->testSendTwoMessages:52 \u00bb CamelExecution", "BeanOgnMethodWithXPathInjectionTest>TestSupport.runBare:58->testSendMessage:40 \u00bb CamelExecution"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex 53c1254..5b8804d 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -228,6 +228,8 @@ private MethodInvocation createInvocation(Object pojo, Exchange exchange, Method\n                     List<ParameterInfo> lpi = new ArrayList<ParameterInfo>(1);\n                     lpi.add(pi);\n                     methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, lpi, lpi, false, false);\n+                    // Need to update the message body to be pojo for the invocation\n+                    exchange.getIn().setBody(pojo);\n                 } catch (NoSuchMethodException e) {\n                     throw new MethodNotFoundException(exchange, pojo, \"getClass\");\n                 }\ndiff --git a/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java b/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\nindex 1092f6e..3cbc2fa 100644\n--- a/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\n@@ -300,8 +300,6 @@ public void process(Exchange exchange) throws Exception {\n \n                 // prepare for next bean to invoke\n                 beanToCall = result;\n-                // we need to set the result to the exchange for further processing\n-                resultExchange.getIn().setBody(result);\n             }\n         }\n \n", "nb_test": 4959, "linesAdd": 1, "jira_id": "7478", "singleLine": false, "nb_skipped": 3, "commit": "69b00a31", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testBodyOgnlOnString(org.apache.camel.language.simple.SimpleTest): Failed to invoke method: .toUpperCase() on null due to: org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: toUpperCase() on null due to: org.apache.camel.component.bean.AmbiguousMethodCallException: Ambiguous method invocations possible: [public java.lang.String java.lang.String.toUpperCase(java.util.Locale), public java.lang.String java.lang.String.toUpperCase()]. Exchange[Message: Camel]"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex 43f40f5..4a8ddef 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -71,6 +71,7 @@\n     // shared state with details of operations introspected from the bean, created during the constructor\n     private Map<String, List<MethodInfo>> operations = new HashMap<String, List<MethodInfo>>();\n     private List<MethodInfo> operationsWithBody = new ArrayList<MethodInfo>();\n+    private List<MethodInfo> operationsWithNoBody = new ArrayList<MethodInfo>();\n     private List<MethodInfo> operationsWithCustomAnnotation = new ArrayList<MethodInfo>();\n     private List<MethodInfo> operationsWithHandlerAnnotation = new ArrayList<MethodInfo>();\n     private Map<Method, MethodInfo> methodMap = new HashMap<Method, MethodInfo>();\n@@ -130,6 +131,7 @@ public BeanInfo(CamelContext camelContext, Class<?> type, Method explicitMethod,\n         // to keep this code thread safe\n         operations = Collections.unmodifiableMap(operations);\n         operationsWithBody = Collections.unmodifiableList(operationsWithBody);\n+        operationsWithNoBody = Collections.unmodifiableList(operationsWithNoBody);\n         operationsWithCustomAnnotation = Collections.unmodifiableList(operationsWithCustomAnnotation);\n         operationsWithHandlerAnnotation = Collections.unmodifiableList(operationsWithHandlerAnnotation);\n         methodMap = Collections.unmodifiableMap(methodMap);\n@@ -311,6 +313,8 @@ private MethodInfo introspect(Class<?> clazz, Method method) {\n             operationsWithCustomAnnotation.add(methodInfo);\n         } else if (methodInfo.hasBodyParameter()) {\n             operationsWithBody.add(methodInfo);\n+        } else {\n+            operationsWithNoBody.add(methodInfo);\n         }\n \n         if (methodInfo.hasHandlerAnnotation()) {\n@@ -442,6 +446,7 @@ protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) t\n         // must use defensive copy, to avoid altering the shared lists\n         // and we want to remove unwanted operations from these local lists\n         final List<MethodInfo> localOperationsWithBody = new ArrayList<MethodInfo>(operationsWithBody);\n+        final List<MethodInfo> localOperationsWithNoBody = new ArrayList<MethodInfo>(operationsWithNoBody);\n         final List<MethodInfo> localOperationsWithCustomAnnotation = new ArrayList<MethodInfo>(operationsWithCustomAnnotation);\n         final List<MethodInfo> localOperationsWithHandlerAnnotation = new ArrayList<MethodInfo>(operationsWithHandlerAnnotation);\n \n@@ -450,11 +455,13 @@ protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) t\n             removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\n             removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);\n             removeNonMatchingMethods(localOperationsWithBody, name);\n+            removeNonMatchingMethods(localOperationsWithNoBody, name);\n         } else {\n             // remove all getter/setter as we do not want to consider these methods\n             removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);\n             removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);\n             removeAllSetterOrGetterMethods(localOperationsWithBody);\n+            removeAllSetterOrGetterMethods(localOperationsWithNoBody);\n         }\n \n         if (localOperationsWithHandlerAnnotation.size() > 1) {\n@@ -468,6 +475,13 @@ protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) t\n         } else if (localOperationsWithCustomAnnotation.size() == 1) {\n             // if there is one method with an annotation then use that one\n             return localOperationsWithCustomAnnotation.get(0);\n+        }\n+\n+        // named method and with no parameters\n+        boolean noParameters = name != null && name.endsWith(\"()\");\n+        if (noParameters && localOperationsWithNoBody.size() == 1) {\n+            // if there was a method name configured and it has no parameters, then use the method with no body (eg no parameters)\n+            return localOperationsWithNoBody.get(0);\n         } else if (localOperationsWithBody.size() == 1) {\n             // if there is one method with body then use that one\n             return localOperationsWithBody.get(0);\n", "nb_test": 4152, "linesAdd": 12, "jira_id": "5154", "singleLine": false, "nb_skipped": 0, "commit": "a8586a69", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["JndiRegistryTest.testLookupByType:53 expected:<1> but was:<0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/JndiRegistry.java b/camel-core/src/main/java/org/apache/camel/impl/JndiRegistry.java\nindex dc663e3..8a077b3 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/JndiRegistry.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/JndiRegistry.java\n@@ -78,8 +78,8 @@ public Object lookupByName(String name) {\n             NamingEnumeration<NameClassPair> list = getContext().list(\"\");\n             while (list.hasMore()) {\n                 NameClassPair pair = list.next();\n-                if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {\n                 Object instance = context.lookup(pair.getName());\n+                if (type.isInstance(instance)) {\n                     answer.put(pair.getName(), type.cast(instance));\n                 }\n             }\n@@ -96,8 +96,8 @@ public Object lookupByName(String name) {\n             NamingEnumeration<NameClassPair> list = getContext().list(\"\");\n             while (list.hasMore()) {\n                 NameClassPair pair = list.next();\n-                if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {\n                 Object instance = context.lookup(pair.getName());\n+                if (type.isInstance(instance)) {\n                     answer.add(type.cast(instance));\n                 }\n             }\n", "nb_test": 4984, "linesAdd": 2, "jira_id": "7418", "singleLine": false, "nb_skipped": 3, "commit": "cabee0e9", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSplitUsingMethodCall(org.apache.camel.component.vm.VMSplitterTest): mock://result Received message count. Expected: <3> but was: <0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java b/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\nindex 796cbdd..2ac12c3 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\n@@ -170,7 +170,7 @@ public Expression createExpression(CamelContext camelContext) {\n             BeanHolder holder = new RegistryBean(camelContext, ref);\n             // get the bean which will check that it exists\n             instance = holder.getBean();\n-            answer = new BeanExpression(ref, getMethod());\n+            answer = new BeanExpression(instance, getMethod());\n         }\n \n         validateHasMethod(camelContext, instance, beanType, getMethod());\n", "nb_test": 3872, "linesAdd": 1, "jira_id": "4542", "singleLine": false, "nb_skipped": 0, "commit": "c408c3ed", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMoveDoneCustomHeader(org.apache.camel.component.file.FromFileMoveDoneCustomHeaderTest): mock://result The file should exists: target/inbox/dones/mydone.txt"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\nindex 69b15d5..ead41ea 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n@@ -18,6 +18,7 @@\n \n import java.io.File;\n import java.util.Date;\n+import java.util.Map;\n \n import org.apache.camel.Exchange;\n import org.apache.camel.util.FileUtil;\n@@ -93,10 +94,25 @@ public void copyFromPopulateAdditional(GenericFile<T> source, GenericFile<T> res\n      * Bind this GenericFile to an Exchange\n      */\n     public void bindToExchange(Exchange exchange) {\n+        Map<String, Object> headers;\n+\n         exchange.setProperty(FileComponent.FILE_EXCHANGE_FILE, this);\n-        GenericFileMessage<T> in = new GenericFileMessage<T>(this);\n-        exchange.setIn(in);\n-        populateHeaders(in);\n+        GenericFileMessage<T> msg = new GenericFileMessage<T>(this);\n+        if (exchange.hasOut()) {\n+            headers = exchange.getOut().hasHeaders() ? exchange.getOut().getHeaders() : null;\n+            exchange.setOut(msg);\n+        } else {\n+            headers = exchange.getIn().hasHeaders() ? exchange.getIn().getHeaders() : null;\n+            exchange.setIn(msg);\n+        }\n+\n+        // preserve any existing (non file) headers, before we re-populate headers\n+        if (headers != null) {\n+            msg.setHeaders(headers);\n+            // remove any file related headers, as we will re-populate file headers\n+            msg.removeHeaders(\"CamelFile*\");\n+        }\n+        populateHeaders(msg);\n     }\n \n     /**\n", "nb_test": 3736, "linesAdd": 17, "jira_id": "4370", "singleLine": false, "nb_skipped": 0, "commit": "7345fefc", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["BeanOgnlBodyMethodReturnNullValueTest>TestSupport.runBare:58->testNullValue:42 expected:<foo: [null]; bar: test> but was:<foo: [org.apache.camel.component.bean.BeanOgnlBodyMethodReturnNullValueTest$ExamplePojo@fe96b09]; bar: test>", "AggregateTimeoutTest>TestSupport.runBare:58->testAggregateTimeout:51 expected:<1> but was:<0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\nindex 7160d3d..cc58c50 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\n@@ -512,13 +512,15 @@ private Object evaluateParameterValue(Exchange exchange, int index, Object param\n                     try {\n                         expression = exchange.getContext().resolveLanguage(\"simple\").createExpression(exp);\n                         parameterValue = expression.evaluate(exchange, Object.class);\n+                        // use \"null\" to indicate the expression returned a null value which is a valid response we need to honor\n+                        if (parameterValue == null) {\n+                            parameterValue = \"null\";\n+                        }\n                     } catch (Exception e) {\n                         throw new ExpressionEvaluationException(expression, \"Cannot create/evaluate simple expression: \" + exp\n                                 + \" to be bound to parameter at index: \" + index + \" on method: \" + getMethod(), exchange, e);\n                     }\n \n-                    if (parameterValue != null) {\n-\n                     // special for explicit null parameter values (as end users can explicit indicate they want null as parameter)\n                     // see method javadoc for details\n                     if (\"null\".equals(parameterValue)) {\n@@ -555,7 +557,6 @@ private Object evaluateParameterValue(Exchange exchange, int index, Object param\n                         }\n                     }\n                 }\n-                }\n \n                 return answer;\n             }\n", "nb_test": 4686, "linesAdd": 3, "jira_id": "6687", "singleLine": false, "nb_skipped": 1, "commit": "617eab1c", "nb_failure": 2, "linesRem": 3}, {"files": 0, "project": "camel", "nb_error": 76, "classification": {"singleLine": false}, "failing_tests": ["ManagedRouteUpdateRouteFromXmlTest>TestSupport.runBare:58->testUpdateRouteFromXmlMismatchRouteId:138->TestSupport.assertIsInstanceOf:148 object should be a java.lang.IllegalArgumentException but was: javax.xml.bind.JAXBException: Provider com.sun.xml.bind.v2.ContextFactory could not be instantiated: javax.xml.bind.JAXBException: error loading class \"RestPropertyDefinition\" listed in org/apache/camel/model/rest/jaxb.index, make sure that entries are accessable on CLASSPATH and of the form \"ClassName\" or \"OuterClass.InnerClass\", not \"ClassName.class\" or \"fully.qualified.ClassName\"", "- with linked exception:", "[java.lang.ClassNotFoundException: org.apache.camel.model.rest.RestPropertyDefinition]", "- with linked exception:", "[javax.xml.bind.JAXBException: error loading class \"RestPropertyDefinition\" listed in org/apache/camel/model/rest/jaxb.index, make sure that entries are accessable on CLASSPATH and of the form \"ClassName\" or \"OuterClass.InnerClass\", not \"ClassName.class\" or \"fully.qualified.ClassName\"", "- with linked exception:", "[java.lang.ClassNotFoundException: org.apache.camel.model.rest.RestPropertyDefinition]] with type: javax.xml.bind.JAXBException", "ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>", "FromRestConfigurationTest>TestSupport.runBare:58->testFromRestModel:30 NullPointer", "CamelContextAddRouteDefinitionsFromXmlTest>TestSupport.runBare:58->setUp:41->createJaxbContext:45 \u00bb JAXB", "CamelContextAddRouteDefinitionsFromXmlTest>TestSupport.runBare:58->setUp:41->createJaxbContext:45 \u00bb JAXB", "CamelContextAddRouteDefinitionsFromXmlTest>TestSupport.runBare:58->setUp:41->createJaxbContext:45 \u00bb JAXB", "CamelContextAddRouteDefinitionsFromXmlTest>TestSupport.runBare:58->setUp:41->createJaxbContext:45 \u00bb JAXB", "CamelContextAddRouteDefinitionsFromXmlTest>TestSupport.runBare:58->setUp:41->createJaxbContext:45 \u00bb JAXB", "ManagedCamelContextDumpRoutesAsXmlTest>TestSupport.runBare:58->testDumpAsXml:39 \u00bb MBean", "ManagedCamelContextUpdateRoutesFromXmlTest>TestSupport.runBare:58->testDumpAsXml:63 \u00bb MBean", "ManagedCamelContextUpdateRoutesWithPropertyPlaceholdersFromXmlPTest>TestSupport.runBare:58->testUpdateEscaped:132 \u00bb MBean", "ManagedCamelContextUpdateRoutesWithPropertyPlaceholdersFromXmlPTest>TestSupport.runBare:58->testUpdate:83 \u00bb MBean", "ManagedFromRestGetTest>TestSupport.runBare:58->testFromRestModel:47 \u00bb MBean Ex...", "ManagedRouteDumpRouteAsXmlTest>TestSupport.runBare:58->testDumpAsXml:51 \u00bb MBean", "ManagedRouteUpdateRouteFromXmlTest>TestSupport.runBare:58->testUpdateRouteFromXmlWithoutRouteId:96 \u00bb MBean", "ManagedRouteUpdateRouteFromXmlTest>TestSupport.runBare:58->testUpdateRouteFromXml:58 \u00bb MBean", "GenerateXmFromCamelContextTest>TestSupport.runBare:58->testCreateRouteFromCamelContext:40->dump:44 \u00bb JAXB", "GenerateXmlTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "GenerateXmlTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "LoadRouteFromXmlTest>TestSupport.runBare:58->testLoadRouteFromXml:43 \u00bb JAXB Pr...", "LoadRouteFromXmlWithInterceptTest>TestSupport.runBare:58->testLoadRouteFromXmlWithIntercept:35 \u00bb JAXB", "LoadRouteFromXmlWithOnExceptionTest>TestSupport.runBare:58->testLoadRouteFromXmlWitOnException:45 \u00bb JAXB", "LoadRouteFromXmlWithPolicyTest>TestSupport.runBare:58->testLoadRouteFromXmlWitPolicy:47 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "XmlParseTest>TestSupport.runBare:58->XmlTestSupport.setUp:54->XmlTestSupport.createJaxbContext:58 \u00bb JAXB", "DumpModelAsXmlAggregateRouteTest>TestSupport.runBare:58->testDumpModelAsXml:29 \u00bb JAXB", "DumpModelAsXmlChoiceFilterRouteTest>TestSupport.runBare:58->testDumpModelAsXmAl:39 \u00bb JAXB", "DumpModelAsXmlChoiceFilterRouteTest>TestSupport.runBare:58->testDumpModelAsXml:29 \u00bb JAXB", "DumpModelAsXmlRouteExpressionTest>TestSupport.runBare:58->testDumpModelAsXmlBean:62 \u00bb JAXB", "DumpModelAsXmlRouteExpressionTest>TestSupport.runBare:58->testDumpModelAsXmlHeader:54 \u00bb JAXB", "DumpModelAsXmlRouteExpressionTest>TestSupport.runBare:58->testDumpModelAsXml:38 \u00bb JAXB", "DumpModelAsXmlRouteExpressionTest>TestSupport.runBare:58->testDumpModelAsXmlXPath:46 \u00bb JAXB", "DumpModelAsXmlRoutePredicateTest>TestSupport.runBare:58->testDumpModelAsXmlBean:62 \u00bb JAXB", "DumpModelAsXmlRoutePredicateTest>TestSupport.runBare:58->testDumpModelAsXmlHeader:54 \u00bb JAXB", "DumpModelAsXmlRoutePredicateTest>TestSupport.runBare:58->testDumpModelAsXml:38 \u00bb JAXB", "DumpModelAsXmlRoutePredicateTest>TestSupport.runBare:58->testDumpModelAsXmlXPath:46 \u00bb JAXB", "DumpModelAsXmlTransformRouteTest>TestSupport.runBare:58->testDumpModelAsXml:34 \u00bb JAXB"], "patch": "", "nb_test": 5008, "linesAdd": 0, "jira_id": "7364", "singleLine": false, "nb_skipped": 3, "commit": "7bbb88ba", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SimpleTest>TestSupport.runBare:58->testBodyAs:467->LanguageTestSupport.assertExpression:69->LanguageTestSupport.assertExpression:62->ContextTestSupport.assertExpression:314->TestSupport.assertExpression:241 Expression: bodyAs[String] on Exchange: Exchange[Message: hello] expected:<hello.test> but was:<hello>", "SimpleTest>TestSupport.runBare:58->testMandatoryBodyAs:499->LanguageTestSupport.assertExpression:69->LanguageTestSupport.assertExpression:62->ContextTestSupport.assertExpression:314->TestSupport.assertExpression:241 Expression: mandatoryBodyAs[String] on Exchange: Exchange[Message: 456] expected:<hello.test> but was:<456>", "ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\nindex d02f050..32a22b2 100644\n--- a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n@@ -195,9 +195,11 @@ private Expression createSimpleExpressionBodyOrHeader(String function, boolean s\n         String remainder = ifStartsWithReturnRemainder(\"bodyAs\", function);\n         if (remainder != null) {\n             String type = ObjectHelper.between(remainder, \"(\", \")\");\n-            if (type == null) {\n+            remainder = ObjectHelper.after(remainder, \")\");\n+            if (type == null || ObjectHelper.isNotEmpty(remainder)) {\n                 throw new SimpleParserException(\"Valid syntax: ${bodyAs(type)} was: \" + function, token.getIndex());\n             }\n+            \n             type = StringHelper.removeQuotes(type);\n             return ExpressionBuilder.bodyExpression(type);\n         }\n@@ -205,7 +207,8 @@ private Expression createSimpleExpressionBodyOrHeader(String function, boolean s\n         remainder = ifStartsWithReturnRemainder(\"mandatoryBodyAs\", function);\n         if (remainder != null) {\n             String type = ObjectHelper.between(remainder, \"(\", \")\");\n-            if (type == null) {\n+            remainder = ObjectHelper.after(remainder, \")\");\n+            if (type == null || ObjectHelper.isNotEmpty(remainder)) {\n                 throw new SimpleParserException(\"Valid syntax: ${mandatoryBodyAs(type)} was: \" + function, token.getIndex());\n             }\n             type = StringHelper.removeQuotes(type);\n", "nb_test": 4887, "linesAdd": 5, "jira_id": "7359", "singleLine": false, "nb_skipped": 3, "commit": "e6fbbf04", "nb_failure": 3, "linesRem": 2}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["org.apache.camel.impl.DefaultExchangeTest.testFaultSafeCopy(org.apache.camel.impl.DefaultExchangeTest)", "Run 1: DefaultExchangeTest>TestSupport.runBare:58->testFaultSafeCopy:224->testFaultCopy:234 Fault property was not copied to IN message expected:<true> but was:<false>", "Run 2: DefaultExchangeTest>TestSupport.runBare:58->testFaultSafeCopy:224->testFaultCopy:234 Fault property was not copied to IN message expected:<true> but was:<false>", "Run 3: DefaultExchangeTest>TestSupport.runBare:58->testFaultSafeCopy:224->testFaultCopy:234 Fault property was not copied to IN message expected:<true> but was:<false>", "Flaked tests:", "org.apache.camel.management.ManagedRouteSuspendAndResumeTest.testSuspendAndResume(org.apache.camel.management.ManagedRouteSuspendAndResumeTest)", "Run 1: ManagedRouteSuspendAndResumeTest>TestSupport.runBare:58->testSuspendAndResume:92 expected:<2> but was:<1>", "Run 2: PASS"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\nindex e1f83f6..923c0d8 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\n@@ -98,6 +98,7 @@ public Exchange copy(boolean safeCopy) {\n \n         if (safeCopy) {\n             exchange.getIn().setBody(getIn().getBody());\n+            exchange.getIn().setFault(getIn().isFault());\n             if (getIn().hasHeaders()) {\n                 exchange.getIn().setHeaders(safeCopyHeaders(getIn().getHeaders()));\n                 // just copy the attachments here\n@@ -105,6 +106,7 @@ public Exchange copy(boolean safeCopy) {\n             }\n             if (hasOut()) {\n                 exchange.getOut().setBody(getOut().getBody());\n+                exchange.getOut().setFault(getOut().isFault());\n                 if (getOut().hasHeaders()) {\n                     exchange.getOut().setHeaders(safeCopyHeaders(getOut().getHeaders()));\n                 }\n", "nb_test": 5545, "linesAdd": 2, "jira_id": "9666", "singleLine": false, "nb_skipped": 4, "commit": "da035952", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAggregateExpressionSize(org.apache.camel.processor.aggregator.AggregateExpressionSizeOverrideFixedTest): mock://aggregated Body of message: 0. Expected: <A+B+C> but was: <A+B>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\nindex a5c592b..00cb744 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n@@ -313,6 +313,9 @@ protected String isCompleted(String key, Exchange exchange) {\n                 int size = exchange.getProperty(Exchange.AGGREGATED_SIZE, 1, Integer.class);\n                 if (size >= value) {\n                     return \"size\";\n+                } else {\n+                    // not completed yet\n+                    return null;\n                 }\n             }\n         }\n", "nb_test": 4324, "linesAdd": 2, "jira_id": "5720", "singleLine": false, "nb_skipped": 1, "commit": "4a05eccf", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["org.apache.camel.language.simple.SimpleTest.testSimpleFileDir(org.apache.camel.language.simple.SimpleTest)", "Run 1: SimpleTest>TestSupport.runBare:58->testSimpleFileDir:110->LanguageTestSupport.assertExpression:69->LanguageTestSupport.assertExpression:62->ContextTestSupport.assertExpression:311 \u00bb SimpleParser", "Run 2: SimpleTest>TestSupport.runBare:58->testSimpleFileDir:110->LanguageTestSupport.assertExpression:69->LanguageTestSupport.assertExpression:62->ContextTestSupport.assertExpression:311 \u00bb SimpleParser", "Run 3: SimpleTest>TestSupport.runBare:58->testSimpleFileDir:110->LanguageTestSupport.assertExpression:69->LanguageTestSupport.assertExpression:62->ContextTestSupport.assertExpression:311 \u00bb SimpleParser", "Flaked tests:", "org.apache.camel.management.ManagedThrottlerTest.testThrottleAsyncVisableViaJmx(org.apache.camel.management.ManagedThrottlerTest)", "Run 1: ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:180 expected:<10> but was:<9>", "Run 2: ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:180 expected:<10> but was:<9>", "Run 3: PASS"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\nindex be5e4ac..5110ae9 100644\n--- a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n@@ -141,8 +141,8 @@ private Expression createSimpleExpression(String function, boolean strict) {\n         // file: prefix\n         remainder = ifStartsWithReturnRemainder(\"file:\", function);\n         if (remainder != null) {\n-            Expression fileExpression = createSimpleFileExpression(remainder);\n-            if (function != null) {\n+            Expression fileExpression = createSimpleFileExpression(remainder, strict);\n+            if (fileExpression != null) {\n                 return fileExpression;\n             }\n         }\n@@ -388,7 +388,7 @@ private Expression createSimpleExpressionDirectly(String expression) {\n         return null;\n     }\n \n-    private Expression createSimpleFileExpression(String remainder) {\n+    private Expression createSimpleFileExpression(String remainder, boolean strict) {\n         if (ObjectHelper.equal(remainder, \"name\")) {\n             return ExpressionBuilder.fileNameExpression();\n         } else if (ObjectHelper.equal(remainder, \"name.noext\")) {\n@@ -418,8 +418,11 @@ private Expression createSimpleFileExpression(String remainder) {\n         } else if (ObjectHelper.equal(remainder, \"modified\")) {\n             return ExpressionBuilder.fileLastModifiedExpression();\n         }\n+        if (strict) {\n             throw new SimpleParserException(\"Unknown file language syntax: \" + remainder, token.getIndex());\n         }\n+        return null;\n+    }\n \n     private String ifStartsWithReturnRemainder(String prefix, String text) {\n         if (text.startsWith(prefix)) {\n", "nb_test": 5540, "linesAdd": 6, "jira_id": "9641", "singleLine": false, "nb_skipped": 4, "commit": "9a6e6d8a", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testOnExceptionWhenSimpleOgnl(org.apache.camel.processor.onexception.OnExceptionWhenSimpleOgnlTest): Exception occurred during execution on the exchange: Exchange[Message: Hello World]"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java b/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\nindex 98ac1c5..f79e041 100644\n--- a/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\n@@ -154,6 +154,9 @@ public void process(Exchange exchange) throws Exception {\n             try {\n                 // copy the original exchange to avoid side effects on it\n                 Exchange resultExchange = exchange.copy();\n+                // remove any existing exception in case we do OGNL on the exception\n+                resultExchange.setException(null);\n+\n                 // force to use InOut to retrieve the result on the OUT message\n                 resultExchange.setPattern(ExchangePattern.InOut);\n                 processor.process(resultExchange);\n@@ -195,6 +198,8 @@ public OgnlInvokeProcessor(BeanHolder beanHolder, String ognl) {\n         public void process(Exchange exchange) throws Exception {\n             // copy the original exchange to avoid side effects on it\n             Exchange resultExchange = exchange.copy();\n+            // remove any existing exception in case we do OGNL on the exception\n+            resultExchange.setException(null);\n             // force to use InOut to retrieve the result on the OUT message\n             resultExchange.setPattern(ExchangePattern.InOut);\n             // do not propagate any method name when using OGNL, as with OGNL we\n", "nb_test": 3842, "linesAdd": 3, "jira_id": "4513", "singleLine": false, "nb_skipped": 0, "commit": "9e05f77f", "nb_failure": 0, "linesRem": 0}, {"files": 3, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testIssue(org.apache.camel.issues.TwoRouteScopedOnExceptionWithInterceptSendToEndpointIssueWithPredicateTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java b/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java\nindex aa00fbb..a7904e8 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java\n@@ -24,6 +24,8 @@\n import org.apache.camel.Processor;\n import org.apache.camel.impl.ServiceSupport;\n import org.apache.camel.model.OnExceptionDefinition;\n+import org.apache.camel.model.ProcessorDefinitionHelper;\n+import org.apache.camel.model.RouteDefinition;\n import org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy;\n import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyKey;\n import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;\n@@ -49,7 +51,9 @@ public void addExceptionPolicy(OnExceptionDefinition exceptionType) {\n         List<Class> list = exceptionType.getExceptionClasses();\n \n         for (Class clazz : list) {\n-            ExceptionPolicyKey key = new ExceptionPolicyKey(clazz, exceptionType.getOnWhen());\n+            RouteDefinition route = ProcessorDefinitionHelper.getRoute(exceptionType);\n+            String routeId = route != null ? route.getId() : null;\n+            ExceptionPolicyKey key = new ExceptionPolicyKey(routeId, clazz, exceptionType.getOnWhen());\n             exceptionPolicies.put(key, exceptionType);\n         }\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java\nindex 01d86e3..d727e17 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java\n@@ -17,6 +17,7 @@\n package org.apache.camel.processor.exceptionpolicy;\n \n import java.util.Iterator;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n import java.util.TreeMap;\n@@ -61,17 +62,29 @@ public OnExceptionDefinition getExceptionPolicy(Map<ExceptionPolicyKey, OnExcept\n                                                     Exchange exchange, Throwable exception) {\n \n         Map<Integer, OnExceptionDefinition> candidates = new TreeMap<Integer, OnExceptionDefinition>();\n+        Map<ExceptionPolicyKey, OnExceptionDefinition> routeScoped = new LinkedHashMap<ExceptionPolicyKey, OnExceptionDefinition>();\n+        Map<ExceptionPolicyKey, OnExceptionDefinition> contextScoped = new LinkedHashMap<ExceptionPolicyKey, OnExceptionDefinition>();\n \n+        // split policies into route and context scoped\n+        initRouteAndContextScopedExceptionPolicies(exceptionPolicies, routeScoped, contextScoped);\n+\n+        // at first check route scoped as we prefer them over context scoped\n         // recursive up the tree using the iterator\n         boolean exactMatch = false;\n         Iterator<Throwable> it = createExceptionIterator(exception);\n         while (!exactMatch && it.hasNext()) {\n             // we should stop looking if we have found an exact match\n-            exactMatch = findMatchedExceptionPolicy(exceptionPolicies, exchange, it.next(), candidates);\n+            exactMatch = findMatchedExceptionPolicy(routeScoped, exchange, it.next(), candidates);\n         }\n \n-        // now go through the candidates and find the best\n+        // fallback to check context scoped (only do this if there was no exact match)\n+        it = createExceptionIterator(exception);\n+        while (!exactMatch && it.hasNext()) {\n+            // we should stop looking if we have found an exact match\n+            exactMatch = findMatchedExceptionPolicy(contextScoped, exchange, it.next(), candidates);\n+        }\n \n+        // now go through the candidates and find the best\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Found \" + candidates.size() + \" candidates\");\n         }\n@@ -80,11 +93,26 @@ public OnExceptionDefinition getExceptionPolicy(Map<ExceptionPolicyKey, OnExcept\n             // no type found\n             return null;\n         } else {\n-            // return the first in the map as its sorted and\n+            // return the first in the map as its sorted and we checked route scoped first, which we prefer\n             return candidates.values().iterator().next();\n         }\n     }\n \n+    private void initRouteAndContextScopedExceptionPolicies(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies,\n+                                                            Map<ExceptionPolicyKey, OnExceptionDefinition> routeScoped,\n+                                                            Map<ExceptionPolicyKey, OnExceptionDefinition> contextScoped) {\n+\n+        // loop through all the entries and split into route and context scoped\n+        Set<Map.Entry<ExceptionPolicyKey, OnExceptionDefinition>> entries = exceptionPolicies.entrySet();\n+        for (Map.Entry<ExceptionPolicyKey, OnExceptionDefinition> entry : entries) {\n+            if (entry.getKey().getRouteId() != null) {\n+                routeScoped.put(entry.getKey(), entry.getValue());\n+            } else {\n+                contextScoped.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+    }\n+\n \n     private boolean findMatchedExceptionPolicy(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies,\n                                                Exchange exchange, Throwable exception,\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java\nindex cbd1fa1..3c79baa 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java\n@@ -20,16 +20,30 @@\n \n /**\n  * Exception policy key is a compound key for storing:\n- * <b>exception class</b> + <b>when</b> => <b>exception type</b>.\n+ * <b>route id </b> + <b>exception class</b> + <b>when</b> => <b>exception type</b>.\n  * <p/>\n  * This is used by Camel to store the onException types configured that has or has not predicates attached (when).\n  */\n public final class ExceptionPolicyKey {\n \n+    private final String routeId;\n     private final Class exceptionClass;\n     private final WhenDefinition when;\n \n+    @Deprecated\n     public ExceptionPolicyKey(Class exceptionClass, WhenDefinition when) {\n+        this(null, exceptionClass, when);\n+    }\n+\n+    /**\n+     * Key for exception clause\n+     *\n+     * @param routeId          the route, or use <tt>null</tt> for a global scoped\n+     * @param exceptionClass   the exception class\n+     * @param when             optional predicate when the exception clause should trigger\n+     */\n+    public ExceptionPolicyKey(String routeId, Class exceptionClass, WhenDefinition when) {\n+        this.routeId = routeId;\n         this.exceptionClass = exceptionClass;\n         this.when = when;\n     }\n@@ -42,10 +56,16 @@ public WhenDefinition getWhen() {\n         return when;\n     }\n \n+    public String getRouteId() {\n+        return routeId;\n+    }\n+\n+    @Deprecated\n     public static ExceptionPolicyKey newInstance(Class exceptionClass) {\n         return new ExceptionPolicyKey(exceptionClass, null);\n     }\n \n+    @Deprecated\n     public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {\n         return new ExceptionPolicyKey(exceptionClass, when);\n     }\n@@ -61,7 +81,10 @@ public boolean equals(Object o) {\n \n         ExceptionPolicyKey that = (ExceptionPolicyKey) o;\n \n-        if (!exceptionClass.equals(that.exceptionClass)) {\n+        if (exceptionClass != null ? !exceptionClass.equals(that.exceptionClass) : that.exceptionClass != null) {\n+            return false;\n+        }\n+        if (routeId != null ? !routeId.equals(that.routeId) : that.routeId != null) {\n             return false;\n         }\n         if (when != null ? !when.equals(that.when) : that.when != null) {\n@@ -73,13 +96,14 @@ public boolean equals(Object o) {\n \n     @Override\n     public int hashCode() {\n-        int result = exceptionClass.hashCode();\n+        int result = routeId != null ? routeId.hashCode() : 0;\n+        result = 31 * result + (exceptionClass != null ? exceptionClass.hashCode() : 0);\n         result = 31 * result + (when != null ? when.hashCode() : 0);\n         return result;\n     }\n \n     @Override\n     public String toString() {\n-        return \"ExceptionPolicyKey[\" + exceptionClass + (when != null ? \" \" + when : \"\") + \"]\";\n+        return \"ExceptionPolicyKey[route: \" + (routeId != null ? routeId : \"<global>\") + \", \" + exceptionClass + (when != null ? \" \" + when : \"\") + \"]\";\n     }\n }\n", "nb_test": 3043, "linesAdd": 49, "jira_id": "3448", "singleLine": false, "nb_skipped": 0, "commit": "b345dd82", "nb_failure": 0, "linesRem": 5}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["IdempotentConsumerRepoExceptionTest>TestSupport.runBare:58->testRepoException:38 \u00bb CamelExecution"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java b/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\nindex e28a214..7b64546 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\n@@ -91,13 +91,23 @@ public void process(Exchange exchange) throws Exception {\n     }\n \n     public boolean process(final Exchange exchange, final AsyncCallback callback) {\n-        final String messageId = messageIdExpression.evaluate(exchange, String.class);\n+        final AsyncCallback target;\n+\n+        final String messageId;\n+        try {\n+            messageId = messageIdExpression.evaluate(exchange, String.class);\n             if (messageId == null) {\n                 exchange.setException(new NoMessageIdException(exchange, messageIdExpression));\n                 callback.done(true);\n                 return true;\n             }\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+            callback.done(true);\n+            return true;\n+        }\n \n+        try {\n             boolean newKey;\n             if (eager) {\n                 // add the key to the repository\n@@ -132,11 +141,16 @@ public boolean process(final Exchange exchange, final AsyncCallback callback) {\n             }\n \n             final Synchronization onCompletion = new IdempotentOnCompletion(idempotentRepository, messageId, eager, removeOnFailure);\n-        final AsyncCallback target = new IdempotentConsumerCallback(exchange, onCompletion, callback, completionEager);\n+            target = new IdempotentConsumerCallback(exchange, onCompletion, callback, completionEager);\n             if (!completionEager) {\n                 // the scope is to do the idempotent completion work as an unit of work on the exchange when its done being routed\n                 exchange.addOnCompletion(onCompletion);\n             }\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+            callback.done(true);\n+            return true;\n+        }\n \n         // process the exchange\n         return processor.process(exchange, target);\n", "nb_test": 5492, "linesAdd": 17, "jira_id": "9480", "singleLine": false, "nb_skipped": 4, "commit": "0ead2cac", "nb_failure": 0, "linesRem": 2}, {"files": 3, "project": "camel", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["FileConsumeMultipleDirectoriesTest>TestSupport.runBare:58->testMultiDir:47->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Body of message: 0. Expected: <Bye World> but was: <Hello World>", "MarkerFileExclusiveReadLockStrategyUnlockTest>TestSupport.runBare:58->testUnlocking:41->TestSupport.assertFileNotExists:480 File target/marker-unlock/input-a/file1.dat.camelLock should not exist", "FileChangedReadLockMinAgeTest>TestSupport.runBare:58->testChangedReadLockMinAge:53->ContextTestSupport.assertMockEndpointsSatisfied:343 Assertion error at index 0 on mock mock://result with predicate: exchangeProperty(CamelReceivedTimestamp) > 1467960713343 evaluated as: 1467960713343 > 1467960713343 on Exchange[ID-PRIMERGY-TX300-S7-45583-1467960374100-968-2][slowfile.dat]", "VmMultipleConsumersMultipleContextTest>TestSupport.runBare:58->testVmMultipleConsumersDifferentEndpoints:145 mock://route1 Received message count. Expected: <100> but was: <95>", "VmMultipleContextsStartStopTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb IllegalArgument", "VmQueueTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb FailedToCreateRoute", "VmShouldNotUseSameThreadTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:39->ContextTestSupport.setUp:117->ContextTestSupport.startCamelContext:174 \u00bb IllegalArgument"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\nindex 343d836..907de21 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n@@ -35,6 +35,7 @@\n public class GenericFile<T> implements WrappedFile<T>  {\n     private static final Logger LOG = LoggerFactory.getLogger(GenericFile.class);\n \n+    private String copyFromAbsoluteFilePath;\n     private String endpointPath;\n     private String fileName;\n     private String fileNameOnly;\n@@ -66,6 +67,7 @@ public char getFileSeparator() {\n         } catch (Exception e) {\n             throw ObjectHelper.wrapRuntimeCamelException(e);\n         }\n+        result.setCopyFromAbsoluteFilePath(source.getAbsoluteFilePath());\n         result.setEndpointPath(source.getEndpointPath());\n         result.setAbsolute(source.isAbsolute());\n         result.setDirectory(source.isDirectory());\n@@ -365,6 +367,14 @@ public void setDirectory(boolean directory) {\n         this.directory = directory;\n     }\n \n+    public String getCopyFromAbsoluteFilePath() {\n+        return copyFromAbsoluteFilePath;\n+    }\n+\n+    public void setCopyFromAbsoluteFilePath(String copyFromAbsoluteFilePath) {\n+        this.copyFromAbsoluteFilePath = copyFromAbsoluteFilePath;\n+    }\n+\n     /**\n      * Fixes the path separator to be according to the protocol\n      */\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java\nindex 8fd94f5..de5101f 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java\n@@ -127,10 +127,11 @@ public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations,\n             }\n         }\n \n-        // we grabbed the lock\n-        exchange.setProperty(Exchange.FILE_LOCK_EXCLUSIVE_LOCK, lock);\n-        exchange.setProperty(Exchange.FILE_LOCK_RANDOM_ACCESS_FILE, randomAccessFile);\n+        // store read-lock state\n+        exchange.setProperty(asReadLockKey(file, Exchange.FILE_LOCK_EXCLUSIVE_LOCK), lock);\n+        exchange.setProperty(asReadLockKey(file, Exchange.FILE_LOCK_RANDOM_ACCESS_FILE), randomAccessFile);\n \n+        // we grabbed the lock\n         return true;\n     }\n \n@@ -140,10 +141,10 @@ protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations\n         // must call super\n         super.doReleaseExclusiveReadLock(operations, file, exchange);\n \n-        String target = file.getFileName();\n-        FileLock lock = exchange.getProperty(Exchange.FILE_LOCK_EXCLUSIVE_LOCK, FileLock.class);\n-        RandomAccessFile rac = exchange.getProperty(Exchange.FILE_LOCK_RANDOM_ACCESS_FILE, RandomAccessFile.class);\n+        FileLock lock = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_EXCLUSIVE_LOCK), FileLock.class);\n+        RandomAccessFile rac = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_EXCLUSIVE_LOCK), RandomAccessFile.class);\n \n+        String target = file.getFileName();\n         if (lock != null) {\n             Channel channel = lock.acquiredBy();\n             try {\n@@ -186,4 +187,12 @@ public void setReadLockLoggingLevel(LoggingLevel readLockLoggingLevel) {\n         this.readLockLoggingLevel = readLockLoggingLevel;\n     }\n \n+    private static String asReadLockKey(GenericFile file, String key) {\n+        // use the copy from absolute path as that was the original path of the file when the lock was acquired\n+        // for example if the file consumer uses preMove then the file is moved and therefore has another name\n+        // that would no longer match\n+        String path = file.getCopyFromAbsoluteFilePath() != null ? file.getCopyFromAbsoluteFilePath() : file.getAbsoluteFilePath();\n+        return path + \"-\" + key;\n+    }\n+\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\nindex ceabd01..1c92bbd 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\n@@ -73,8 +73,10 @@ public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations,\n \n         // create a plain file as marker filer for locking (do not use FileLock)\n         boolean acquired = FileUtil.createNewFile(new File(lockFileName));\n-        exchange.setProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, acquired);\n-        exchange.setProperty(Exchange.FILE_LOCK_FILE_NAME, lockFileName);\n+\n+        // store read-lock state\n+        exchange.setProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_ACQUIRED), acquired);\n+        exchange.setProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_NAME), lockFileName);\n \n         return acquired;\n     }\n@@ -101,9 +103,11 @@ protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations\n             return;\n         }\n \n+        boolean acquired = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_ACQUIRED), false, Boolean.class);\n+\n         // only release the file if camel get the lock before\n-        if (exchange.getProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, false, Boolean.class)) {\n-            String lockFileName = exchange.getProperty(Exchange.FILE_LOCK_FILE_NAME, getLockFileName(file), String.class);\n+        if (acquired) {\n+            String lockFileName = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_NAME), String.class);\n             File lock = new File(lockFileName);\n \n             if (lock.exists()) {\n@@ -162,4 +166,12 @@ private static String getLockFileName(GenericFile<File> file) {\n         return file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;\n     }\n \n+    private static String asReadLockKey(GenericFile file, String key) {\n+        // use the copy from absolute path as that was the original path of the file when the lock was acquired\n+        // for example if the file consumer uses preMove then the file is moved and therefore has another name\n+        // that would no longer match\n+        String path = file.getCopyFromAbsoluteFilePath() != null ? file.getCopyFromAbsoluteFilePath() : file.getAbsoluteFilePath();\n+        return path + \"-\" + key;\n+    }\n+\n }\n", "nb_test": 5361, "linesAdd": 32, "jira_id": "8954", "singleLine": false, "nb_skipped": 4, "commit": "7b1253db", "nb_failure": 4, "linesRem": 9}, {"files": 2, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRemoveRouteAndThenAddItAgain(org.apache.camel.component.seda.SedaRemoveRouteThenAddItAgainTest): mock://out Received message count. Expected: <1> but was: <0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\nindex 5b2d872..e33d21d 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n@@ -85,7 +85,7 @@ public SedaComponent getComponent() {\n     }\n \n     public Producer createProducer() throws Exception {\n-        return new SedaProducer(this, getQueue(), getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull());\n+        return new SedaProducer(this, getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull());\n     }\n \n     public Consumer createConsumer(Processor processor) throws Exception {\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\nindex d39e39f..3614460 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n@@ -32,6 +32,10 @@\n  * @version \n  */\n public class SedaProducer extends DefaultAsyncProducer {\n+    /**\n+     * @deprecated Better make use of the {@link SedaEndpoint#getQueue()} API which delivers the accurate reference to the queue currently being used.\n+     */\n+    @Deprecated\n     protected final BlockingQueue<Exchange> queue;\n     private final SedaEndpoint endpoint;\n     private final WaitForTaskToComplete waitForTaskToComplete;\n@@ -39,17 +43,24 @@\n     private final boolean blockWhenFull;\n \n     /**\n-     * @deprecated use the other constructor\n+     * @deprecated Use {@link #SedaProducer(SedaEndpoint, WaitForTaskToComplete, long, boolean) the other constructor}.\n      */\n     @Deprecated\n     public SedaProducer(SedaEndpoint endpoint, BlockingQueue<Exchange> queue, WaitForTaskToComplete waitForTaskToComplete, long timeout) {\n-        this(endpoint, queue, waitForTaskToComplete, timeout, false);\n+        this(endpoint, waitForTaskToComplete, timeout, false);\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #SedaProducer(SedaEndpoint, WaitForTaskToComplete, long, boolean) the other constructor}.\n+     */\n+    @Deprecated\n+    public SedaProducer(SedaEndpoint endpoint, BlockingQueue<Exchange> queue, WaitForTaskToComplete waitForTaskToComplete, long timeout, boolean blockWhenFull) {\n+        this(endpoint, waitForTaskToComplete, timeout, blockWhenFull);\n     }\n \n-    public SedaProducer(SedaEndpoint endpoint, BlockingQueue<Exchange> queue, WaitForTaskToComplete waitForTaskToComplete,\n-                        long timeout, boolean blockWhenFull) {\n+    public SedaProducer(SedaEndpoint endpoint, WaitForTaskToComplete waitForTaskToComplete, long timeout, boolean blockWhenFull) {\n         super(endpoint);\n-        this.queue = queue;\n+        this.queue = endpoint.getQueue();\n         this.endpoint = endpoint;\n         this.waitForTaskToComplete = waitForTaskToComplete;\n         this.timeout = timeout;\n@@ -125,7 +136,7 @@ public String toString() {\n                 if (!done) {\n                     exchange.setException(new ExchangeTimedOutException(exchange, timeout));\n                     // remove timed out Exchange from queue\n-                    queue.remove(copy);\n+                    endpoint.getQueue().remove(copy);\n                     // count down to indicate timeout\n                     latch.countDown();\n                 }\n@@ -183,6 +194,7 @@ protected void doStop() throws Exception {\n      * @param exchange the exchange to add to the queue\n      */\n     protected void addToQueue(Exchange exchange) {\n+        BlockingQueue<Exchange> queue = endpoint.getQueue();\n         if (blockWhenFull) {\n             try {\n                 queue.put(exchange);\n", "nb_test": 4242, "linesAdd": 12, "jira_id": "5432", "singleLine": false, "nb_skipped": 1, "commit": "93935780", "nb_failure": 1, "linesRem": 6}, {"files": 3, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SplitterWithScannerIoExceptionTest>TestSupport.runBare:58->testSplitterStreamingWithError:34->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://b Received message count. Expected: <0> but was: <1>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\nindex a9dd334..d1a0f64 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n@@ -192,19 +192,20 @@ public void remove() {\n \n         @Override\n         public void close() throws IOException {\n-            if (value instanceof Closeable) {\n-                IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n-            } else if (value instanceof Scanner) {\n-                // special for Scanner as it does not implement Closeable\n+            if (value instanceof Scanner) {\n+                // special for Scanner which implement the Closeable since JDK7 \n                 Scanner scanner = (Scanner) value;\n                 scanner.close();\n-\n                 IOException ioException = scanner.ioException();\n                 if (ioException != null) {\n                     throw ioException;\n                 }\n+            } else if (value instanceof Closeable) {\n+                // we should throw out the exception here   \n+                IOHelper.closeWithException((Closeable) value);\n             }\n         }\n+       \n     }\n \n     private Iterable<ProcessorExchangePair> createProcessorExchangePairsList(Exchange exchange, Object value) {\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/GroupIterator.java b/camel-core/src/main/java/org/apache/camel/util/GroupIterator.java\nindex 95a5a1e..158dbed 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/GroupIterator.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/GroupIterator.java\n@@ -65,17 +65,25 @@ public GroupIterator(CamelContext camelContext, Iterator<?> it, String token, in\n \n     @Override\n     public void close() throws IOException {\n-        if (it instanceof Closeable) {\n-            IOHelper.close((Closeable) it);\n-        } else if (it instanceof Scanner) {\n-            // special for Scanner as it does not implement Closeable\n-            ((Scanner) it).close();\n-        }\n+        try {\n+            if (it instanceof Scanner) {\n+                // special for Scanner which implement the Closeable since JDK7 \n+                Scanner scanner = (Scanner) it;\n+                scanner.close();\n+                IOException ioException = scanner.ioException();\n+                if (ioException != null) {\n+                    throw ioException;\n+                }\n+            } else if (it instanceof Closeable) {\n+                IOHelper.closeWithException((Closeable) it);\n+            }\n+        } finally {\n             // close the buffer as well\n             bos.close();\n             // we are now closed\n             closed = true;\n         }\n+    }\n \n     @Override\n     public boolean hasNext() {\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/IOHelper.java b/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\nindex efd8b56..ed2f793 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\n@@ -339,6 +339,23 @@ public static void close(Closeable closeable, String name, Logger log) {\n     }\n     \n     /**\n+     * Closes the given resource if it is available and don't catch the exception\n+     *\n+     * @param closeable the object to close\n+     * @throws IOException\n+      */\n+    public static void closeWithException(Closeable closeable) throws IOException {\n+        if (closeable != null) {\n+            try {\n+                closeable.close();\n+            } catch (IOException e) {\n+                // don't catch the exception here\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    /**\n      * Closes the given channel if it is available, logging any closing exceptions to the given log.\n      * The file's channel can optionally be forced to disk.\n      *\n", "nb_test": 4774, "linesAdd": 27, "jira_id": "7100", "singleLine": false, "nb_skipped": 1, "commit": "00a9b02b", "nb_failure": 1, "linesRem": 9}, {"files": 1, "project": "camel", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["VmMultipleConsumersMultipleContextTest>TestSupport.runBare:58->testVmMultipleConsumersDifferentEndpoints:145 mock://route1 Received message count. Expected: <100> but was: <36>", "VmMultipleConsumersMultipleContextTest>TestSupport.runBare:58->testVmMultipleConsumersMultipleContext:96 mock://route1 Received message count. Expected: <100> but was: <102>", "VmMultipleConsumersRemoteRouteTest.testVmMultipleConsumersRemoteRoute:66 mock://route1 Received message count. Expected: <100> but was: <147>", "DefaultProducerCacheTest>TestSupport.runBare:58->testReleaseProducerInvokesStopAndShutdownByNonSingeltonProducers:94 expected:<3> but was:<0>", "ManagedThrottlerTest>TestSupport.runBare:58->testThrottleVisableViaJmx:137 null", "VmMultipleContextsStartStopTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb IllegalArgument", "VmQueueTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb FailedToCreateRoute", "VmShouldNotUseSameThreadTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:39->ContextTestSupport.setUp:117->ContextTestSupport.startCamelContext:174 \u00bb IllegalArgument"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\nindex 6b292c0..b35eca5 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n@@ -30,6 +30,7 @@\n import org.apache.camel.Producer;\n import org.apache.camel.ProducerCallback;\n import org.apache.camel.ServicePoolAware;\n+import org.apache.camel.ShutdownableService;\n import org.apache.camel.processor.UnitOfWorkProducer;\n import org.apache.camel.spi.ServicePool;\n import org.apache.camel.support.ServiceSupport;\n@@ -137,6 +138,11 @@ public void releaseProducer(Endpoint endpoint, Producer producer) throws Excepti\n         } else if (!producer.isSingleton()) {\n             // stop non singleton producers as we should not leak resources\n             producer.stop();\n+\n+            // shutdown as well in case the producer is shutdownable\n+            if (producer instanceof ShutdownableService) {\n+                ShutdownableService.class.cast(producer).shutdown();\n+            }\n         }\n     }\n \n", "nb_test": 4740, "linesAdd": 5, "jira_id": "6948", "singleLine": false, "nb_skipped": 1, "commit": "f744afd9", "nb_failure": 5, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FileConsumerIdempotentTest>TestSupport.runBare:58->testIdempotent:56->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Body of message: 0. Expected: <Hello World> but was: <null>", "NIOConverterTest>TestSupport.runBare:58->testByteBufferToStringConversion:69 expected:<123456789[]> but was:<123456789[\u0000\u0000\u0000\u0000\u0000\u0000\u0000]>", "AggregateTimeoutTest>TestSupport.runBare:58->testAggregateTimeout:51 expected:<1> but was:<0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\nindex 41273b6..e1cf6d6 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n@@ -54,7 +54,7 @@ private NIOConverter() {\n \n     @Converter\n     public static String toString(ByteBuffer buffer, Exchange exchange) throws IOException {\n-        return IOConverter.toString(buffer.array(), exchange);\n+        return IOConverter.toString(toByteArray(buffer), exchange);\n     }\n \n     @Converter\n", "nb_test": 4839, "linesAdd": 1, "jira_id": "7241", "singleLine": false, "nb_skipped": 3, "commit": "18c23fa8", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testOutOfSequenceAfterCapacityReachedComplex(org.apache.camel.processor.ResequenceStreamRejectOldExchangesTest): mock://result Body of message: 1. Expected: <D> but was: <B>", "testSendMessageToLogAllOff(org.apache.camel.component.log.LogFormatterTest): Exception occurred during execution on the exchange: Exchange[Message: Hello World]"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/log/LogFormatter.java b/camel-core/src/main/java/org/apache/camel/component/log/LogFormatter.java\nindex 19eba1b..c190974 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/log/LogFormatter.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/log/LogFormatter.java\n@@ -167,12 +167,24 @@ public String format(Exchange exchange) {\n                 }\n             }\n \n-            // get rid of the leading space comma if needed\n-            return \"Exchange[\" + (multiline ? answer.append(']').toString() : answer.toString().substring(2) + \"]\");\n+            // switch string buffer\n+            sb = answer;\n         }\n \n+        if (multiline) {\n+            sb.insert(0, \"Exchange[\");\n+            sb.append(\"]\");\n+            return sb.toString();\n+        } else {\n             // get rid of the leading space comma if needed\n-        return \"Exchange[\" + (multiline ? sb.append(']').toString() : sb.toString().substring(2) + \"]\");\n+            if (sb.length() > 0 && sb.charAt(0) == ',' && sb.charAt(1) == ' ') {\n+                sb.replace(0, 2, \"\");\n+            }\n+            sb.insert(0, \"Exchange[\");\n+            sb.append(\"]\");\n+\n+            return sb.toString();\n+        }\n     }\n \n     public boolean isShowExchangeId() {\n", "nb_test": 4359, "linesAdd": 14, "jira_id": "5699", "singleLine": false, "nb_skipped": 1, "commit": "6d63a502", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["BeanWithInputStreamBodyTest>TestSupport.runBare:58->testToBeanWithInputStreamBodyMethodOGNL:138->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Body of message: 0. Expected: <There is 11 bytes> but was: <There is 0 bytes>", "AggregateTimeoutTest>TestSupport.runBare:58->testAggregateTimeout:51 expected:<1> but was:<0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\nindex a4dd2e0..0c22e75 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\n@@ -393,8 +393,6 @@ public boolean isStaticMethod() {\n     /**\n      * Returns true if this method is covariant with the specified method\n      * (this method may above or below the specified method in the class hierarchy)\n-     * @param method\n-     * @return\n      */\n     public boolean isCovariantWith(MethodInfo method) {\n         return \n@@ -541,14 +539,19 @@ private Object evaluateParameterValue(Exchange exchange, int index, Object param\n                         return Void.TYPE;\n                     }\n \n+                    // the parameter value may match the expected type, then we use it as-is\n+                    if (parameterType.isAssignableFrom(parameterValue.getClass())) {\n+                        valid = true;\n+                    } else {\n                         // the parameter value was not already valid, but since the simple language have evaluated the expression\n                         // which may change the parameterValue, so we have to check it again to see if its now valid\n-                    exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);\n+                        exp = exchange.getContext().getTypeConverter().tryConvertTo(String.class, parameterValue);\n                         // String values from the simple language is always valid\n                         if (!valid) {\n                             // re validate if the parameter was not valid the first time (String values should be accepted)\n                             valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);\n                         }\n+                    }\n \n                     if (valid) {\n                         // we need to unquote String parameters, as the enclosing quotes is there to denote a parameter value\n", "nb_test": 4720, "linesAdd": 5, "jira_id": "6810", "singleLine": false, "nb_skipped": 1, "commit": "6b210169", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FilerConsumerMoveFailedDoneFileNameTest>TestSupport.runBare:58->testDoneFile:48 Done file should be deleted: target/done/done", "ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\nindex 5bedc00..db16a66 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\n@@ -117,27 +117,7 @@ protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrate\n             }\n         }\n \n-        // must be last in batch to delete the done file name\n-        // delete done file if used (and not noop=true)\n-        boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);\n-        if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {\n-            // done file must be in same path as the original input file\n-            String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n-            ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n-            // we should delete the dynamic done file \n-            if (endpoint.getDoneFileName().indexOf(\"{file:name\") > 0 || complete) { \n-                try {\n-                    // delete done file\n-                    boolean deleted = operations.deleteFile(doneFileName);\n-                    log.trace(\"Done file: {} was deleted: {}\", doneFileName, deleted);\n-                    if (!deleted) {\n-                        log.warn(\"Done file: \" + doneFileName + \" could not be deleted\");\n-                    }\n-                } catch (Exception e) {\n-                    handleException(\"Error deleting done file: \" + doneFileName, exchange, e);\n-                }\n-            }\n-        }\n+        handleDoneFile(exchange);\n \n         try {\n             log.trace(\"Commit file strategy: {} for file: {}\", processStrategy, file);\n@@ -160,6 +140,13 @@ protected void processStrategyRollback(GenericFileProcessStrategy<T> processStra\n         if (log.isWarnEnabled()) {\n             log.warn(\"Rollback file strategy: \" + processStrategy + \" for file: \" + file);\n         }\n+\n+        // only delete done file if moveFailed option is enabled, as otherwise on rollback,\n+        // we should leave the done file so we can retry\n+        if (endpoint.getMoveFailed() != null) {\n+            handleDoneFile(exchange);\n+        }\n+\n         try {\n             processStrategy.rollback(operations, endpoint, exchange, file);\n         } catch (Exception e) {\n@@ -167,6 +154,30 @@ protected void processStrategyRollback(GenericFileProcessStrategy<T> processStra\n         }\n     }\n \n+    protected void handleDoneFile(Exchange exchange) {\n+        // must be last in batch to delete the done file name\n+        // delete done file if used (and not noop=true)\n+        boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);\n+        if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {\n+            // done file must be in same path as the original input file\n+            String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n+            ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n+            // we should delete the dynamic done file\n+            if (endpoint.getDoneFileName().indexOf(\"{file:name\") > 0 || complete) {\n+                try {\n+                    // delete done file\n+                    boolean deleted = operations.deleteFile(doneFileName);\n+                    log.trace(\"Done file: {} was deleted: {}\", doneFileName, deleted);\n+                    if (!deleted) {\n+                        log.warn(\"Done file: \" + doneFileName + \" could not be deleted\");\n+                    }\n+                } catch (Exception e) {\n+                    handleException(\"Error deleting done file: \" + doneFileName, exchange, e);\n+                }\n+            }\n+        }\n+    }\n+\n     protected void handleException(String message, Exchange exchange, Throwable t) {\n         Throwable newt = (t == null) ? new IllegalArgumentException(\"Handling [null] exception\") : t;\n         getExceptionHandler().handleException(message, exchange, newt);\n", "nb_test": 4758, "linesAdd": 25, "jira_id": "6964", "singleLine": false, "nb_skipped": 1, "commit": "6b2ffb30", "nb_failure": 2, "linesRem": 16}, {"files": 2, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDLCSetHeader(org.apache.camel.processor.DeadLetterChannelUnmarshalSetHeaderTest): mock://error No header with name foo found for message: 0"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MarshalProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MarshalProcessor.java\nindex b4e3289..9a01a55 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MarshalProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MarshalProcessor.java\n@@ -55,9 +55,15 @@ public void process(Exchange exchange) throws Exception {\n         Message out = exchange.getOut();\n         out.copyFrom(in);\n \n+        try {\n             dataFormat.marshal(exchange, body, buffer);\n             byte[] data = buffer.toByteArray();\n             out.setBody(data);\n+        } catch (Exception e) {\n+            // remove OUT message, as an exception occurred\n+            exchange.setOut(null);\n+            throw e;\n+        }\n     }\n \n     @Override\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/UnmarshalProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/UnmarshalProcessor.java\nindex 414b088..b8c5e5f 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/UnmarshalProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/UnmarshalProcessor.java\n@@ -27,6 +27,7 @@\n import org.apache.camel.spi.DataFormat;\n import org.apache.camel.support.ServiceSupport;\n import org.apache.camel.util.ExchangeHelper;\n+import org.apache.camel.util.IOHelper;\n import org.apache.camel.util.ObjectHelper;\n import org.apache.camel.util.ServiceHelper;\n \n@@ -56,10 +57,12 @@ public void process(Exchange exchange) throws Exception {\n \n             Object result = dataFormat.unmarshal(exchange, stream);\n             out.setBody(result);\n+        } catch (Exception e) {\n+            // remove OUT message, as an exception occurred\n+            exchange.setOut(null);\n+            throw e;\n         } finally {\n-            if (stream != null) {\n-                stream.close();\n-            }\n+            IOHelper.close(stream, \"input stream\");\n         }\n     }\n \n", "nb_test": 3855, "linesAdd": 10, "jira_id": "4509", "singleLine": false, "nb_skipped": 0, "commit": "8e3450f4", "nb_failure": 1, "linesRem": 3}, {"files": 2, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["org.apache.camel.management.ManagedInterceptFromTest.testManageWithInterceptFrom(org.apache.camel.management.ManagedInterceptFromTest)", "Run 1: ManagedInterceptFromTest>TestSupport.runBare:58->ContextTestSupport.setUp:117->ContextTestSupport.startCamelContext:174 \u00bb ClassCast", "Run 2: ManagedInterceptFromTest>TestSupport.runBare:58->ContextTestSupport.setUp:117->ContextTestSupport.startCamelContext:174 \u00bb ClassCast", "Run 3: ManagedInterceptFromTest>TestSupport.runBare:58->ContextTestSupport.setUp:117->ContextTestSupport.startCamelContext:174 \u00bb ClassCast"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementObjectStrategy.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementObjectStrategy.java\nindex d30e4fe..c53cffb 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementObjectStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementObjectStrategy.java\n@@ -96,6 +96,7 @@\n import org.apache.camel.management.mbean.ManagedValidate;\n import org.apache.camel.management.mbean.ManagedWeightedLoadBalancer;\n import org.apache.camel.management.mbean.ManagedWireTapProcessor;\n+import org.apache.camel.model.ExpressionNode;\n import org.apache.camel.model.LoadBalanceDefinition;\n import org.apache.camel.model.ModelCamelContext;\n import org.apache.camel.model.ProcessDefinition;\n@@ -307,7 +308,7 @@ public Object getManagedObjectForProcessor(CamelContext context, Processor proce\n             } else if (target instanceof RoutingSlip) {\n                 answer = new ManagedRoutingSlip(context, (RoutingSlip) target, (org.apache.camel.model.RoutingSlipDefinition) definition);\n             } else if (target instanceof FilterProcessor) {\n-                answer = new ManagedFilter(context, (FilterProcessor) target, (org.apache.camel.model.FilterDefinition) definition);\n+                answer = new ManagedFilter(context, (FilterProcessor) target, (ExpressionNode)definition);\n             } else if (target instanceof LogProcessor) {\n                 answer = new ManagedLog(context, (LogProcessor) target, definition);\n             } else if (target instanceof LoopProcessor) {\ndiff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedFilter.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedFilter.java\nindex 9d9ae5a..2d253b6 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedFilter.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedFilter.java\n@@ -19,7 +19,7 @@\n import org.apache.camel.CamelContext;\n import org.apache.camel.api.management.ManagedResource;\n import org.apache.camel.api.management.mbean.ManagedFilterMBean;\n-import org.apache.camel.model.FilterDefinition;\n+import org.apache.camel.model.ExpressionNode;\n import org.apache.camel.processor.FilterProcessor;\n \n /**\n@@ -29,14 +29,14 @@\n public class ManagedFilter extends ManagedProcessor implements ManagedFilterMBean {\n     private final FilterProcessor processor;\n \n-    public ManagedFilter(CamelContext context, FilterProcessor processor, FilterDefinition definition) {\n+    public ManagedFilter(CamelContext context, FilterProcessor processor, ExpressionNode definition) {\n         super(context, processor, definition);\n         this.processor = processor;\n     }\n \n     @Override\n-    public FilterDefinition getDefinition() {\n-        return (FilterDefinition) super.getDefinition();\n+    public ExpressionNode getDefinition() {\n+        return (ExpressionNode) super.getDefinition();\n     }\n \n     @Override\n", "nb_test": 5552, "linesAdd": 6, "jira_id": "9672", "singleLine": false, "nb_skipped": 4, "commit": "84922699", "nb_failure": 0, "linesRem": 5}, {"files": 2, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FileConsumerRestartNotLeakThreadTest>TestSupport.runBare:58->testLeak:52 There should not be so many active threads, was 51"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultScheduledPollConsumerScheduler.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultScheduledPollConsumerScheduler.java\nindex c132cad..729ee75 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultScheduledPollConsumerScheduler.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultScheduledPollConsumerScheduler.java\n@@ -156,13 +156,10 @@ protected void doStart() throws Exception {\n     protected void doStop() throws Exception {\n         if (future != null) {\n             LOG.debug(\"This consumer is stopping, so cancelling scheduled task: \" + future);\n-            future.cancel(false);\n+            future.cancel(true);\n             future = null;\n         }\n-    }\n \n-    @Override\n-    protected void doShutdown() throws Exception {\n         if (shutdownExecutor && scheduledExecutorService != null) {\n             getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutorService);\n             scheduledExecutorService = null;\ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/ScheduledPollConsumer.java b/camel-core/src/main/java/org/apache/camel/impl/ScheduledPollConsumer.java\nindex 5d080e2..e300d49 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ScheduledPollConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ScheduledPollConsumer.java\n@@ -514,7 +514,8 @@ public void startScheduler() {\n \n     @Override\n     protected void doStop() throws Exception {\n-        ServiceHelper.stopService(scheduler);\n+        scheduler.unscheduleTask();\n+        ServiceHelper.stopAndShutdownServices(scheduler);\n \n         // clear counters\n         backoffCounter = 0;\n", "nb_test": 5172, "linesAdd": 3, "jira_id": "8146", "singleLine": false, "nb_skipped": 4, "commit": "17475d80", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "camel", "nb_error": 5, "classification": {"singleLine": false}, "failing_tests": ["VmMultipleConsumersMultipleContextTest>TestSupport.runBare:58->testVmMultipleConsumersDifferentEndpoints:145 mock://route1 Received message count. Expected: <100> but was: <95>", "VmMultipleConsumersMultipleContextTest>TestSupport.runBare:58->testVmMultipleConsumersMultipleContext:96 mock://route1 Received message count. Expected: <100> but was: <105>", "ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>", "PropertiesComponentLoadPropertiesFromFileTest>TestSupport.runBare:58->PropertiesComponentTest.testPropertiesComponentParameterizedPropertyPrefix:306 \u00bb FailedToCreateRoute", "PropertiesComponentTest>TestSupport.runBare:58->testPropertiesComponentParameterizedPropertyPrefix:306 \u00bb FailedToCreateRoute", "VmMultipleContextsStartStopTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb IllegalArgument", "VmQueueTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb FailedToCreateRoute", "VmShouldNotUseSameThreadTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:39->ContextTestSupport.setUp:117->ContextTestSupport.startCamelContext:174 \u00bb IllegalArgument"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/properties/PropertiesComponent.java b/camel-core/src/main/java/org/apache/camel/component/properties/PropertiesComponent.java\nindex 7d0e75c..3a7c13d 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/properties/PropertiesComponent.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/properties/PropertiesComponent.java\n@@ -204,6 +204,9 @@ public String getPropertyPrefix() {\n \n     public void setPropertyPrefix(String propertyPrefix) {\n         this.propertyPrefix = propertyPrefix;\n+        if (ObjectHelper.isNotEmpty(this.propertyPrefix)) {\n+            this.propertyPrefix = FilePathResolver.resolvePath(this.propertyPrefix);\n+        }\n     }\n \n     public String getPropertySuffix() {\n@@ -212,6 +215,9 @@ public String getPropertySuffix() {\n \n     public void setPropertySuffix(String propertySuffix) {\n         this.propertySuffix = propertySuffix;\n+        if (ObjectHelper.isNotEmpty(this.propertySuffix)) {\n+            this.propertySuffix = FilePathResolver.resolvePath(this.propertySuffix);\n+        }\n     }\n \n     public boolean isFallbackToUnaugmentedProperty() {\n", "nb_test": 5030, "linesAdd": 6, "jira_id": "7456", "singleLine": false, "nb_skipped": 3, "commit": "02da984a", "nb_failure": 3, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testSplitterStreamingWithError(org.apache.camel.processor.SplitterStreamingErrorHandlingTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\nindex 97e5178..6d585fb 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n@@ -109,6 +109,9 @@ public boolean process(Exchange exchange, final AsyncCallback callback) {\n     private Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {\n         final Iterator iterator = ObjectHelper.createIterator(value);\n         return new Iterable() {\n+            // create a copy which we use as master to copy during splitting\n+            // this avoids any side effect reflected upon the incoming exchange\n+            private final Exchange copy = ExchangeHelper.createCopy(exchange, true);\n \n             public Iterator iterator() {\n                 return new Iterator() {\n@@ -137,7 +140,8 @@ public boolean hasNext() {\n \n                     public Object next() {\n                         Object part = iterator.next();\n-                        Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\n+                        // create a copy as the new exchange to be routed in the splitter from the copy\n+                        Exchange newExchange = ExchangeHelper.createCopy(copy, true);\n                         if (part instanceof Message) {\n                             newExchange.setIn((Message)part);\n                         } else {\n", "nb_test": 3065, "linesAdd": 2, "jira_id": "3498", "singleLine": false, "nb_skipped": 0, "commit": "b4606700", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["VmMultipleConsumersRemoteRouteTest.testVmMultipleConsumersRemoteRoute:66 Timeout waiting for endpoints to receive enough messages. mock://route1 timed out.", "CircuitBreakerLoadBalancerTest>TestSupport.runBare:58->testHalfOpenCircuitClosesAfterTimeoutAsync:112->halfOpenCircuitClosesAfterTimeout:127->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Received message count. Expected: <2> but was: <3>", "CircuitBreakerLoadBalancerTest>TestSupport.runBare:58->testFailedMessagesOpenCircuitToPreventMessageThreeAsync:82->failedMessagesOpenCircuitToPreventMessageThree:98->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Received message count. Expected: <2> but was: <3>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java b/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\nindex b8e23b4..3e84e6e 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\n@@ -107,6 +107,13 @@ public boolean process(final Exchange exchange, final AsyncCallback callback) {\n \n         if (failures.get() >= threshold && System.currentTimeMillis() - lastFailure < halfOpenAfter) {\n             exchange.setException(new RejectedExecutionException(\"CircuitBreaker Open: failures: \" + failures + \", lastFailure: \" + lastFailure));\n+            /*\n+             * If the circuit opens, we have to prevent the execution of any processor.\n+             * The failures count can be set to 0.\n+             */\n+            failures.set(0);\n+            callback.done(true);\n+            return true;\n         }\n         Processor processor = getProcessors().get(0);\n         if (processor == null) {\n@@ -114,18 +121,20 @@ public boolean process(final Exchange exchange, final AsyncCallback callback) {\n         }\n \n         AsyncProcessor albp = AsyncProcessorConverterHelper.convert(processor);\n-        boolean sync = albp.process(exchange, callback);\n+        // Added a callback for processing the exchange in the callback\n+        boolean sync = albp.process(exchange, new CircuitBreakerCallback(exchange, callback));\n         \n+        // We need to check the exception here as albp is use sync call  \n+        if (sync) {\n             boolean failed = hasFailed(exchange);\n-\n             if (!failed) {\n                 failures.set(0);\n             } else {\n                 failures.incrementAndGet();\n                 lastFailure = System.currentTimeMillis();\n             }\n-\n-        if (!sync) {\n+        } else {\n+            // CircuitBreakerCallback can take care of failure check of the exchange\n             log.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n             return false;\n         }\n@@ -142,4 +151,28 @@ public String toString() {\n     public String getTraceLabel() {\n         return \"circuitbreaker\";\n     }\n+    \n+    class CircuitBreakerCallback implements AsyncCallback {\n+        private final AsyncCallback callback;\n+        private final Exchange exchange;\n+        CircuitBreakerCallback(Exchange exchange, AsyncCallback callback) {\n+            this.callback = callback;\n+            this.exchange = exchange;\n+        }\n+\n+        @Override\n+        public void done(boolean doneSync) {\n+            if (!doneSync) {\n+                boolean failed = hasFailed(exchange);\n+                if (!failed) {\n+                    failures.set(0);\n+                } else {\n+                    failures.incrementAndGet();\n+                    lastFailure = System.currentTimeMillis();\n+                }\n+            }\n+            callback.done(doneSync);\n+        }\n+        \n+    }\n }\n", "nb_test": 5103, "linesAdd": 30, "jira_id": "7973", "singleLine": false, "nb_skipped": 3, "commit": "799b45df", "nb_failure": 3, "linesRem": 4}, {"files": 3, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ManagedResourceTest>TestSupport.runBare:58->testManagedResource:91 \u00bb MBean An ..."], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\nindex 9d4ade2..ffe2f6d 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n@@ -308,6 +308,7 @@ public void setPurgeWhenStopping(boolean purgeWhenStopping) {\n         this.purgeWhenStopping = purgeWhenStopping;\n     }\n \n+    @ManagedAttribute(description = \"Singleton\")\n     public boolean isSingleton() {\n         return true;\n     }\n@@ -425,6 +426,11 @@ public String getCamelManagementName() {\n         return getCamelContext().getManagementName();\n     }\n \n+    @ManagedAttribute(description = \"Endpoint URI\", mask = true)\n+    public String getEndpointUri() {\n+        return super.getEndpointUri();\n+    }\n+\n     @ManagedAttribute(description = \"Endpoint service state\")\n     public String getState() {\n         return getStatus().name();\ndiff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementMBeanAssembler.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementMBeanAssembler.java\nindex 262b520..fde3592 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementMBeanAssembler.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementMBeanAssembler.java\n@@ -60,7 +60,7 @@ public ModelMBean assemble(MBeanServer mBeanServer, Object obj, ObjectName name)\n             if (custom != null && ObjectHelper.hasAnnotation(custom.getClass().getAnnotations(), ManagedResource.class)) {\n                 LOG.trace(\"Assembling MBeanInfo for: {} from custom @ManagedResource object: {}\", name, custom);\n                 // get the mbean info from the custom managed object\n-                mbi = assembler.getMBeanInfo(obj, custom, name.toString());\n+                mbi = assembler.getMBeanInfo(null, custom, name.toString());\n                 // and let the custom object be registered in JMX\n                 obj = custom;\n             }\ndiff --git a/camel-core/src/main/java/org/apache/camel/management/MBeanInfoAssembler.java b/camel-core/src/main/java/org/apache/camel/management/MBeanInfoAssembler.java\nindex 56b5a14..84f0470 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/MBeanInfoAssembler.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/MBeanInfoAssembler.java\n@@ -97,7 +97,7 @@ public void stop() throws Exception {\n      */\n     public ModelMBeanInfo getMBeanInfo(Object defaultManagedBean, Object customManagedBean, String objectName) throws JMException {\n         // skip proxy classes\n-        if (Proxy.isProxyClass(defaultManagedBean.getClass())) {\n+        if (defaultManagedBean != null && Proxy.isProxyClass(defaultManagedBean.getClass())) {\n             LOG.trace(\"Skip creating ModelMBeanInfo due proxy class {}\", defaultManagedBean.getClass());\n             return null;\n         }\n@@ -110,10 +110,12 @@ public ModelMBeanInfo getMBeanInfo(Object defaultManagedBean, Object customManag\n         Set<ModelMBeanNotificationInfo> mBeanNotifications = new LinkedHashSet<ModelMBeanNotificationInfo>();\n \n         // extract details from default managed bean\n+        if (defaultManagedBean != null) {\n             extractAttributesAndOperations(defaultManagedBean.getClass(), attributes, operations);\n             extractMbeanAttributes(defaultManagedBean, attributes, mBeanAttributes, mBeanOperations);\n             extractMbeanOperations(defaultManagedBean, operations, mBeanOperations);\n             extractMbeanNotifications(defaultManagedBean, mBeanNotifications);\n+        }\n \n         // extract details from custom managed bean\n         if (customManagedBean != null) {\n", "nb_test": 4762, "linesAdd": 10, "jira_id": "7018", "singleLine": false, "nb_skipped": 1, "commit": "3244c1e5", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testConsumeFileOnly(org.apache.camel.component.file.FileConsumeSingleDirectoryOnlyTest): mock://result Message with body Hello World was expected but not found in [Bye World]", "testSplitTokenizerWithImplicitNamespaces(org.apache.camel.processor.SplitTokenizerNamespaceTest): mock://split Received message count. Expected: <4> but was: <0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/support/TokenXMLPairExpressionIterator.java b/camel-core/src/main/java/org/apache/camel/support/TokenXMLPairExpressionIterator.java\nindex da5afaa..9ae1477 100644\n--- a/camel-core/src/main/java/org/apache/camel/support/TokenXMLPairExpressionIterator.java\n+++ b/camel-core/src/main/java/org/apache/camel/support/TokenXMLPairExpressionIterator.java\n@@ -41,6 +41,7 @@\n \n     private static final Pattern NAMESPACE_PATTERN = Pattern.compile(\"xmlns(:\\\\w+|)=\\\\\\\"(.*?)\\\\\\\"\");\n     private static final String SCAN_TOKEN_REGEX = \"(\\\\s+.*?|)>\";\n+    private static final String SCAN_TOKEN_NS_PREFIX_REGEX = \"(.{1,15}?:|)\";\n     protected final String inheritNamespaceToken;\n \n     public TokenXMLPairExpressionIterator(String startToken, String endToken, String inheritNamespaceToken) {\n@@ -81,15 +82,22 @@ public TokenXMLPairExpressionIterator(String startToken, String endToken, String\n         XMLTokenPairIterator(String startToken, String endToken, String inheritNamespaceToken, InputStream in, String charset) {\n             super(startToken, endToken, true, in, charset);\n \n-            // remove any ending > as we need to support attributes on the tags, so we need to use a reg exp pattern\n-            String token = startToken.substring(0, startToken.length() - 1) + SCAN_TOKEN_REGEX;\n-            this.startTokenPattern = Pattern.compile(token);\n-            this.scanEndToken = endToken.substring(0, endToken.length() - 1) + SCAN_TOKEN_REGEX;\n+            // remove any beginning < and ending > as we need to support ns prefixes and attributes, so we use a reg exp patterns\n+            StringBuilder tokenSb = new StringBuilder(\"<\").append(SCAN_TOKEN_NS_PREFIX_REGEX).\n+                                append(startToken.substring(1, startToken.length() - 1)).append(SCAN_TOKEN_REGEX);\n+            this.startTokenPattern = Pattern.compile(tokenSb.toString());\n+            \n+            tokenSb = new StringBuilder(\"</\").append(SCAN_TOKEN_NS_PREFIX_REGEX).\n+                                append(endToken.substring(2, endToken.length() - 1)).append(SCAN_TOKEN_REGEX);\n+            this.scanEndToken = tokenSb.toString();\n+            \n             this.inheritNamespaceToken = inheritNamespaceToken;\n             if (inheritNamespaceToken != null) {\n-                token = inheritNamespaceToken.substring(0, inheritNamespaceToken.length() - 1) + SCAN_TOKEN_REGEX;\n+                // the inherit namespace token may itself have a namespace prefix\n+                tokenSb = new StringBuilder(\"<\").append(SCAN_TOKEN_NS_PREFIX_REGEX).\n+                                append(inheritNamespaceToken.substring(1, inheritNamespaceToken.length() - 1)).append(SCAN_TOKEN_REGEX);  \n                 // the namespaces on the parent tag can be in multi line, so we need to instruct the dot to support multilines\n-                this.inheritNamespaceTokenPattern = Pattern.compile(token, Pattern.MULTILINE | Pattern.DOTALL);\n+                this.inheritNamespaceTokenPattern = Pattern.compile(tokenSb.toString(), Pattern.MULTILINE | Pattern.DOTALL);\n             }\n         }\n \n@@ -125,17 +133,26 @@ String getNext(boolean first) {\n                 next = next.substring(index);\n             }\n \n+            // make sure the end tag matches the begin tag if the tag has a namespace prefix\n+            String tag = ObjectHelper.before(next, \">\");\n+            StringBuilder endTagSb = new StringBuilder(\"</\");\n+            int firstSpaceIndex = tag.indexOf(\" \");\n+            if (firstSpaceIndex > 0) {\n+                endTagSb.append(tag.substring(1, firstSpaceIndex)).append(\">\");\n+            } else {\n+                endTagSb.append(tag.substring(1, tag.length())).append(\">\");\n+            }\n+            \n             // build answer accordingly to whether namespaces should be inherited or not\n             StringBuilder sb = new StringBuilder();\n             if (inheritNamespaceToken != null && rootTokenNamespaces != null) {\n                 // append root namespaces to local start token\n-                String tag = ObjectHelper.before(next, \">\");\n                 // grab the text\n                 String text = ObjectHelper.after(next, \">\");\n                 // build result with inherited namespaces\n-                next = sb.append(tag).append(rootTokenNamespaces).append(\">\").append(text).append(endToken).toString();\n+                next = sb.append(tag).append(rootTokenNamespaces).append(\">\").append(text).append(endTagSb.toString()).toString();\n             } else {\n-                next = sb.append(next).append(endToken).toString();\n+                next = sb.append(next).append(endTagSb.toString()).toString();\n             }\n \n             return next;\n", "nb_test": 4358, "linesAdd": 23, "jira_id": "5826", "singleLine": false, "nb_skipped": 1, "commit": "a04674f2", "nb_failure": 2, "linesRem": 8}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ManagedThrottlerTest>TestSupport.runBare:58->testThrottleVisableViaJmx:145 expected:<10> but was:<9>", "ThrottlerTest>TestSupport.runBare:58->testConfigurationWithChangingHeaderExpression:168->sendMessagesWithHeaderExpression:199 Should take at most 1200ms, was: 4700"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/Throttler.java b/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\nindex ae6bc26..6b51a2c 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\n@@ -116,6 +116,9 @@ protected long calculateDelay(Exchange exchange) {\n             if (maximumRequestsPerPeriod > 0 && longValue.longValue() != maximumRequestsPerPeriod) {\n                 log.debug(\"Throttler changed maximum requests per period from {} to {}\", maximumRequestsPerPeriod, longValue);\n             }\n+            if (maximumRequestsPerPeriod > longValue) {\n+                slot.capacity = 0;\n+            }\n             maximumRequestsPerPeriod = longValue;\n         }\n \n@@ -139,7 +142,7 @@ protected synchronized TimeSlot nextSlot() {\n         if (slot == null) {\n             slot = new TimeSlot();\n         }\n-        if (slot.isFull() || !slot.isActive()) {\n+        if (slot.isFull() || !slot.isPast()) {\n             slot = slot.next();\n         }\n         slot.assign();\n@@ -175,6 +178,11 @@ protected TimeSlot next() {\n             return new TimeSlot(Math.max(System.currentTimeMillis(), this.startTime + this.duration));\n         }\n \n+        protected boolean isPast() {\n+            long current = System.currentTimeMillis();\n+            return current < (startTime + duration);\n+        }\n+\n         protected boolean isActive() {\n             long current = System.currentTimeMillis();\n             return startTime <= current && current < (startTime + duration);\n", "nb_test": 4788, "linesAdd": 9, "jira_id": "7160", "singleLine": false, "nb_skipped": 3, "commit": "095fa2b4", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 5, "classification": {"singleLine": false}, "failing_tests": ["NIOConverterTest>TestSupport.runBare:58->testToByteBufferInteger:87 \u00bb BufferUnderflow", "NIOConverterTest>TestSupport.runBare:58->testToByteBufferFloat:105 \u00bb BufferUnderflow", "NIOConverterTest>TestSupport.runBare:58->testToByteBufferShort:81 \u00bb BufferUnderflow", "NIOConverterTest>TestSupport.runBare:58->testToByteBufferLong:93 \u00bb BufferUnderflow", "NIOConverterTest>TestSupport.runBare:58->testToByteBufferDouble:99 \u00bb BufferUnderflow"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\nindex 0bf08ac..41273b6 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n@@ -107,6 +107,7 @@ public static ByteBuffer toByteBuffer(String value, Exchange exchange) {\n     public static ByteBuffer toByteBuffer(Short value) {\n         ByteBuffer buf = ByteBuffer.allocate(2);\n         buf.putShort(value);\n+        buf.flip();\n         return buf;\n     }\n \n@@ -114,6 +115,7 @@ public static ByteBuffer toByteBuffer(Short value) {\n     public static ByteBuffer toByteBuffer(Integer value) {\n         ByteBuffer buf = ByteBuffer.allocate(4);\n         buf.putInt(value);\n+        buf.flip();\n         return buf;\n     }\n \n@@ -121,6 +123,7 @@ public static ByteBuffer toByteBuffer(Integer value) {\n     public static ByteBuffer toByteBuffer(Long value) {\n         ByteBuffer buf = ByteBuffer.allocate(8);\n         buf.putLong(value);\n+        buf.flip();\n         return buf;\n     }\n \n@@ -128,6 +131,7 @@ public static ByteBuffer toByteBuffer(Long value) {\n     public static ByteBuffer toByteBuffer(Float value) {\n         ByteBuffer buf = ByteBuffer.allocate(4);\n         buf.putFloat(value);\n+        buf.flip();\n         return buf;\n     }\n \n@@ -135,6 +139,7 @@ public static ByteBuffer toByteBuffer(Float value) {\n     public static ByteBuffer toByteBuffer(Double value) {\n         ByteBuffer buf = ByteBuffer.allocate(8);\n         buf.putDouble(value);\n+        buf.flip();\n         return buf;\n     }\n \n", "nb_test": 4805, "linesAdd": 5, "jira_id": "7213", "singleLine": false, "nb_skipped": 3, "commit": "336663c9", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FileConsumerIdempotentTest>TestSupport.runBare:58->testIdempotent:77 Should be no in-progress files expected:<0> but was:<1>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java\nindex c8452fd..02130d2 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java\n@@ -484,22 +484,32 @@ protected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T>\n             return false;\n         }\n \n+        boolean answer = true;\n+        String key = null;\n+        try {\n             // if its a file then check we have the file in the idempotent registry already\n             if (!isDirectory && endpoint.isIdempotent()) {\n                 // use absolute file path as default key, but evaluate if an expression key was configured\n-            String key = file.getAbsoluteFilePath();\n+                key = file.getAbsoluteFilePath();\n                 if (endpoint.getIdempotentKey() != null) {\n                     Exchange dummy = endpoint.createExchange(file);\n                     key = endpoint.getIdempotentKey().evaluate(dummy, String.class);\n                 }\n                 if (key != null && endpoint.getIdempotentRepository().contains(key)) {\n                     log.trace(\"This consumer is idempotent and the file has been consumed before. Will skip this file: {}\", file);\n-                return false;\n+                    answer = false;\n+                }\n+            }\n+        } finally {\n+            // ensure to run this in finally block in case of runtime exceptions being thrown\n+            if (!answer) {\n+                // remove file from the in progress list as its no longer in progress\n+                endpoint.getInProgressRepository().remove(key);\n             }\n         }\n \n         // file matched\n-        return true;\n+        return answer;\n     }\n \n     /**\n@@ -607,6 +617,7 @@ protected boolean isMatched(GenericFile<T> file, boolean isDirectory, List<T> fi\n      */\n     protected boolean isInProgress(GenericFile<T> file) {\n         String key = file.getAbsoluteFilePath();\n+        // must use add, to have operation as atomic\n         return !endpoint.getInProgressRepository().add(key);\n     }\n \n", "nb_test": 4742, "linesAdd": 11, "jira_id": "6936", "singleLine": false, "nb_skipped": 1, "commit": "4954d573", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ManagedBrowsableEndpointAsXmlFileTest>TestSupport.runBare:58->testBrowseableEndpointAsXmlAllIncludeBody:52 Should contain the body", "AggregateTimeoutTest>TestSupport.runBare:58->testAggregateTimeout:51 expected:<1> but was:<0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java b/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\nindex 3e38d23..c81b53b 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\n@@ -223,9 +223,11 @@ public static String extractBodyForLogging(Message message, String prepend, bool\n             } else if (obj instanceof Writer) {\n                 return prepend + \"[Body is instance of java.io.Writer]\";\n             } else if (obj instanceof WrappedFile || obj instanceof File) {\n+                if (!allowFiles) {\n                     return prepend + \"[Body is file based: \" + obj + \"]\";\n                 }\n             }\n+        }\n \n         if (!allowFiles) {\n             if (obj instanceof WrappedFile || obj instanceof File) {\n", "nb_test": 4755, "linesAdd": 2, "jira_id": "6987", "singleLine": false, "nb_skipped": 1, "commit": "37e0e6bb", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEndpointShutdown(org.apache.camel.impl.EndpointShutdownOnceTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex a8b9c80..f1dd98d 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -891,7 +891,8 @@ public void addService(Object object) throws Exception {\n             if (service instanceof IsSingleton) {\n                 singleton = ((IsSingleton) service).isSingleton();\n             }\n-            if (singleton) {\n+            // do not add endpoints as they have their own list\n+            if (singleton && !(service instanceof Endpoint)) {\n                 servicesToClose.add(service);\n             }\n         }\n", "nb_test": 3167, "linesAdd": 1, "jira_id": "3690", "singleLine": false, "nb_skipped": 0, "commit": "2a3f3392", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBeanLanguageInvalidOGNL(org.apache.camel.language.BeanLanguageInvalidOGNLTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/MethodNotFoundException.java b/camel-core/src/main/java/org/apache/camel/component/bean/MethodNotFoundException.java\nindex 8dceafd..e0ecab3 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/MethodNotFoundException.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/MethodNotFoundException.java\n@@ -30,10 +30,12 @@\n     private final Object bean;\n     private final String methodName;\n     @SuppressWarnings(\"rawtypes\")\n-    private final List<Class> parameterTypes;\n+    private List<Class> parameterTypes;\n \n     public MethodNotFoundException(Exchange exchange, Object pojo, String methodName) {\n-        this(exchange, pojo, methodName, null);\n+        super(\"Method with name: \" + methodName + \" not found on bean: \" + pojo, exchange);\n+        this.methodName = methodName;\n+        this.bean = pojo;\n     }\n     \n     @SuppressWarnings(\"rawtypes\")\n@@ -44,6 +46,12 @@ public MethodNotFoundException(Exchange exchange, Object pojo, String methodName\n         this.parameterTypes = parameterTypes;\n     }\n \n+    public MethodNotFoundException(Object pojo, String methodName, Throwable cause) {\n+        super(\"Method with name: \" + methodName + \" not found on bean: \" + pojo, null, cause);\n+        this.methodName = methodName;\n+        this.bean = pojo;\n+    }\n+\n     public String getMethodName() {\n         return methodName;\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java b/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\nindex 511b5ad..46aa7b7 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\n@@ -27,13 +27,16 @@\n \n import org.apache.camel.CamelContext;\n import org.apache.camel.Expression;\n+import org.apache.camel.ExpressionIllegalSyntaxException;\n import org.apache.camel.Predicate;\n import org.apache.camel.component.bean.BeanHolder;\n import org.apache.camel.component.bean.BeanInfo;\n import org.apache.camel.component.bean.MethodNotFoundException;\n import org.apache.camel.component.bean.RegistryBean;\n import org.apache.camel.language.bean.BeanExpression;\n+import org.apache.camel.language.bean.RuntimeBeanExpressionException;\n import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.OgnlHelper;\n \n /**\n  * For expressions and predicates using the\n@@ -127,22 +130,23 @@ public void setParameterType(Class parameterType) {\n     \n     @Override\n     public Expression createExpression(CamelContext camelContext) {\n+        Expression answer;\n         if (beanType != null) {\n             instance = ObjectHelper.newInstance(beanType);\n-            return new BeanExpression(instance, getMethod(), parameterType);\n+            answer = new BeanExpression(instance, getMethod(), parameterType);\n         } else if (instance != null) {\n-            return new BeanExpression(instance, getMethod(), parameterType);\n+            answer = new BeanExpression(instance, getMethod(), parameterType);\n         } else {\n             String ref = beanName();\n             // if its a ref then check that the ref exists\n             BeanHolder holder = new RegistryBean(camelContext, ref);\n             // get the bean which will check that it exists\n             instance = holder.getBean();\n-            // only validate when it was a ref for a bean, so we can eager check\n-            // this on startup of Camel\n-            validateHasMethod(camelContext, instance, getMethod(), parameterType);\n-            return new BeanExpression(ref, getMethod(), parameterType);\n+            answer = new BeanExpression(ref, getMethod(), parameterType);\n         }\n+\n+        validateHasMethod(camelContext, instance, getMethod(), parameterType);\n+        return answer;\n     }\n \n     @Override\n@@ -151,7 +155,9 @@ public Predicate createPredicate(CamelContext camelContext) {\n     }\n \n     /**\n-     * Validates the given bean has the method\n+     * Validates the given bean has the method.\n+     * <p/>\n+     * This implementation will skip trying to validate OGNL method name expressions.\n      *\n      * @param context  camel context\n      * @param bean     the bean instance\n@@ -164,6 +170,17 @@ protected void validateHasMethod(CamelContext context, Object bean, String metho\n             return;\n         }\n \n+        // do not try to validate ognl methods\n+        if (OgnlHelper.isValidOgnlExpression(method)) {\n+            return;\n+        }\n+\n+        // if invalid OGNL then fail\n+        if (OgnlHelper.isInvalidValidOgnlExpression(method)) {\n+            ExpressionIllegalSyntaxException cause = new ExpressionIllegalSyntaxException(method);\n+            throw ObjectHelper.wrapRuntimeCamelException(new MethodNotFoundException(bean, method, cause));\n+        }\n+\n         BeanInfo info = new BeanInfo(context, bean.getClass());\n         List<Class> parameterTypes = new ArrayList<Class>();\n         if (parameterType != null) {\n", "nb_test": 3091, "linesAdd": 29, "jira_id": "3545", "singleLine": false, "nb_skipped": 0, "commit": "050c542e", "nb_failure": 1, "linesRem": 6}, {"files": 2, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPolicy(org.apache.camel.management.ManagedCustomPolicyTest): expected:<3> but was:<1>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\nindex 4b3b7c8..adb508a 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.camel.processor;\n \n+import java.util.List;\n+\n import org.apache.camel.Processor;\n import org.apache.camel.util.ServiceHelper;\n \n@@ -38,6 +40,14 @@ public String toString() {\n     }\n \n     @Override\n+    public List<Processor> next() {\n+        // must include wrapped in navigate\n+        List<Processor> list = super.next();\n+        list.add(wrapped);\n+        return list;\n+    }\n+\n+    @Override\n     protected void doStart() throws Exception {\n         ServiceHelper.startService(wrapped);\n         super.doStart();\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/AsyncProcessorConverterHelper.java b/camel-core/src/main/java/org/apache/camel/util/AsyncProcessorConverterHelper.java\nindex 7a5a6f2..656136c 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/AsyncProcessorConverterHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/AsyncProcessorConverterHelper.java\n@@ -41,9 +41,8 @@ private AsyncProcessorConverterHelper() {\n     }\r\n \r\n     /**\r\n-     * Creates a AsnycProcossor that delegates to the given processor.\r\n-     * It is important that this implements DelegateProcessor\r\n-     *\r\n+     * Creates a {@link AsyncProcessor} that delegates to the given processor.\r\n+     * It is important that this implements {@link DelegateProcessor}\r\n      */\r\n     private static final class ProcessorToAsyncProcessorBridge implements DelegateProcessor, AsyncProcessor, Navigate<Processor>, Service {\r\n         protected Processor processor;\r\n", "nb_test": 3841, "linesAdd": 9, "jira_id": "4536", "singleLine": false, "nb_skipped": 0, "commit": "df9f4a6a", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["XMLTokenExpressionIteratorInvalidXMLTest.testExtractToken:58->invokeAndVerify:73 the error expected"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/support/XMLTokenExpressionIterator.java b/camel-core/src/main/java/org/apache/camel/support/XMLTokenExpressionIterator.java\nindex f233281..19cc2a6 100644\n--- a/camel-core/src/main/java/org/apache/camel/support/XMLTokenExpressionIterator.java\n+++ b/camel-core/src/main/java/org/apache/camel/support/XMLTokenExpressionIterator.java\n@@ -575,7 +575,8 @@ public Object next() {\n             try {\n                 nextToken = getNextToken();\n             } catch (XMLStreamException e) {\n-                //\n+                nextToken = null;\n+                throw new RuntimeException(e);\n             }\n             return o;\n         }\n", "nb_test": 5145, "linesAdd": 2, "jira_id": "8106", "singleLine": false, "nb_skipped": 3, "commit": "39ccf5d6", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["InterceptSendToEndpointNormalizePatternTest>TestSupport.runBare:58->testIntercept:33->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://intercept Received message count. Expected: <1> but was: <0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/InterceptSendToEndpointDefinition.java b/camel-core/src/main/java/org/apache/camel/model/InterceptSendToEndpointDefinition.java\nindex 9b8bdc3..be2dcb9 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/InterceptSendToEndpointDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/InterceptSendToEndpointDefinition.java\n@@ -22,6 +22,7 @@\n import javax.xml.bind.annotation.XmlAttribute;\n import javax.xml.bind.annotation.XmlRootElement;\n \n+import org.apache.camel.CamelContext;\n import org.apache.camel.Endpoint;\n import org.apache.camel.Predicate;\n import org.apache.camel.Processor;\n@@ -30,6 +31,7 @@\n import org.apache.camel.spi.EndpointStrategy;\n import org.apache.camel.spi.RouteContext;\n import org.apache.camel.util.EndpointHelper;\n+import org.apache.camel.util.URISupport;\n \n /**\n  * Represents an XML &lt;interceptToEndpoint/&gt; element\n@@ -95,7 +97,7 @@ public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\n                 if (endpoint instanceof InterceptSendToEndpoint) {\n                     // endpoint already decorated\n                     return endpoint;\n-                } else if (getUri() == null || EndpointHelper.matchEndpoint(routeContext.getCamelContext(), uri, getUri())) {\n+                } else if (getUri() == null || matchPattern(routeContext.getCamelContext(), uri, getUri())) {\n                     // only proxy if the uri is matched decorate endpoint with our proxy\n                     // should be false by default\n                     boolean skip = isSkipSendToOriginalEndpoint();\n@@ -121,6 +123,29 @@ public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\n     }\n \n     /**\n+     * Does the uri match the pattern.\n+     *\n+     * @param camelContext the CamelContext\n+     * @param uri the uri\n+     * @param pattern the pattern, which can be an endpoint uri as well\n+     * @return <tt>true</tt> if matched and we should intercept, <tt>false</tt> if not matched, and not intercept.\n+     */\n+    protected boolean matchPattern(CamelContext camelContext, String uri, String pattern) {\n+        // match using the pattern as-is\n+        boolean match = EndpointHelper.matchEndpoint(camelContext, uri, pattern);\n+        if (!match) {\n+            try {\n+                // the pattern could be an uri, so we need to normalize it before matching again\n+                pattern = URISupport.normalizeUri(pattern);\n+                match = EndpointHelper.matchEndpoint(camelContext, uri, pattern);\n+            } catch (Exception e) {\n+                // ignore\n+            }\n+        }\n+        return match;\n+    }\n+\n+    /**\n      * Applies this interceptor only if the given predicate is true\n      *\n      * @param predicate  the predicate\n", "nb_test": 4870, "linesAdd": 15, "jira_id": "7304", "singleLine": false, "nb_skipped": 3, "commit": "fa165d6b", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCacheStopExpired(org.apache.camel.impl.DefaultProducerCacheTest): expected:<3> but was:<0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java\nindex 16be6ab..cadb98a 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java\n@@ -27,7 +27,6 @@\n import org.apache.camel.support.ServiceSupport;\n import org.apache.camel.util.CamelContextHelper;\n import org.apache.camel.util.LRUCache;\n-import org.apache.camel.util.LRUSoftCache;\n import org.apache.camel.util.ServiceHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -60,14 +59,17 @@ public ConsumerCache(Object source, CamelContext camelContext, Map<String, Polli\n     /**\n      * Creates the {@link LRUCache} to be used.\n      * <p/>\n-     * This implementation returns a {@link org.apache.camel.util.LRUSoftCache} instance.\n+     * This implementation returns a {@link LRUCache} instance.\n \n      * @param cacheSize the cache size\n      * @return the cache\n      */\n     protected static LRUCache<String, PollingConsumer> createLRUCache(int cacheSize) {\n-        // We use a soft reference cache to allow the JVM to re-claim memory if it runs low on memory.\n-        return new LRUSoftCache<String, PollingConsumer>(cacheSize);\n+        // Use a regular cache as we want to ensure that the lifecycle of the consumers\n+        // being cache is properly handled, such as they are stopped when being evicted\n+        // or when this cache is stopped. This is needed as some consumers requires to\n+        // be stopped so they can shutdown internal resources that otherwise may cause leaks\n+        return new LRUCache<String, PollingConsumer>(cacheSize);\n     }\n \n     public synchronized PollingConsumer getConsumer(Endpoint endpoint) {\ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\nindex 89fadb0..8c5f976 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n@@ -37,7 +37,6 @@\n import org.apache.camel.util.CamelContextHelper;\n import org.apache.camel.util.EventHelper;\n import org.apache.camel.util.LRUCache;\n-import org.apache.camel.util.LRUSoftCache;\n import org.apache.camel.util.ServiceHelper;\n import org.apache.camel.util.StopWatch;\n import org.slf4j.Logger;\n@@ -78,14 +77,17 @@ public ProducerCache(Object source, CamelContext camelContext, ServicePool<Endpo\n     /**\n      * Creates the {@link LRUCache} to be used.\n      * <p/>\n-     * This implementation returns a {@link LRUSoftCache} instance.\n+     * This implementation returns a {@link LRUCache} instance.\n \n      * @param cacheSize the cache size\n      * @return the cache\n      */\n     protected static LRUCache<String, Producer> createLRUCache(int cacheSize) {\n-        // We use a soft reference cache to allow the JVM to re-claim memory if it runs low on memory.\n-        return new LRUSoftCache<String, Producer>(cacheSize);\n+        // Use a regular cache as we want to ensure that the lifecycle of the producers\n+        // being cache is properly handled, such as they are stopped when being evicted\n+        // or when this cache is stopped. This is needed as some producers requires to\n+        // be stopped so they can shutdown internal resources that otherwise may cause leaks\n+        return new LRUCache<String, Producer>(cacheSize);\n     }\n \n     public CamelContext getCamelContext() {\n", "nb_test": 4318, "linesAdd": 2, "jira_id": "5683", "singleLine": false, "nb_skipped": 1, "commit": "0c3c7d1b", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "camel", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["MDCResetTest>TestSupport.runBare:58->testMDC:38 \u00bb CamelExecution Exception occ...", "MDCResetTest>TestSupport.runBare:58->testMDCTwoMessages:47 \u00bb CamelExecution Ex..."], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/MDCUnitOfWork.java b/camel-core/src/main/java/org/apache/camel/impl/MDCUnitOfWork.java\nindex 62f6b16..1726b80 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/MDCUnitOfWork.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/MDCUnitOfWork.java\n@@ -217,13 +217,15 @@ public void done(boolean doneSync) {\n                     if (correlationId != null) {\n                         MDC.put(MDC_CORRELATION_ID, correlationId);\n                     }\n-                    if (routeId != null) {\n-                        MDC.put(MDC_ROUTE_ID, routeId);\n-                    }\n                     if (camelContextId != null) {\n                         MDC.put(MDC_CAMEL_CONTEXT_ID, camelContextId);\n                     }\n                 }\n+                // need to setup the routeId finally\n+                if (routeId != null) {\n+                    MDC.put(MDC_ROUTE_ID, routeId);\n+                }\n+                \n             } finally {\n                 // muse ensure delegate is invoked\n                 delegate.done(doneSync);\n", "nb_test": 5063, "linesAdd": 4, "jira_id": "7795", "singleLine": false, "nb_skipped": 3, "commit": "19b2aa31", "nb_failure": 0, "linesRem": 3}, {"files": 3, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testSayFoo(org.apache.camel.builder.ProxyBuilderSkipJavaLangObjectMethodsTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/AbstractCamelInvocationHandler.java b/camel-core/src/main/java/org/apache/camel/component/bean/AbstractCamelInvocationHandler.java\nindex 953d60e..21e407b 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/AbstractCamelInvocationHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/AbstractCamelInvocationHandler.java\n@@ -19,6 +19,9 @@\n import java.lang.reflect.InvocationHandler;\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n@@ -41,10 +44,16 @@\n public abstract class AbstractCamelInvocationHandler implements InvocationHandler {\n \n     private static final transient Logger LOG = LoggerFactory.getLogger(CamelInvocationHandler.class);\n+    private static final List<Method> EXCLUDED_METHODS = new ArrayList<Method>();\n     private static ExecutorService executorService;\n     protected final Endpoint endpoint;\n     protected final Producer producer;\n \n+    static {\n+        // exclude all java.lang.Object methods as we dont want to invoke them\n+        EXCLUDED_METHODS.addAll(Arrays.asList(Object.class.getMethods()));\n+    }\n+\n     public AbstractCamelInvocationHandler(Endpoint endpoint, Producer producer) {\n         this.endpoint = endpoint;\n         this.producer = producer;\n@@ -67,7 +76,26 @@ private static Object getBody(Exchange exchange, Class<?> type) throws InvalidPa\n         }\n     }\n \n-    protected Object invokeWithbody(final Method method, Object body, final ExchangePattern pattern) throws InterruptedException, Throwable {\n+    @Override\n+    public final Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n+        if (isValidMethod(method)) {\n+            return doInvokeProxy(proxy, method, args);\n+        } else {\n+            // invalid method then invoke methods on this instead\n+            if (\"toString\".equals(method.getName())) {\n+                return this.toString();\n+            } else if (\"hashCode\".equals(method.getName())) {\n+                return this.hashCode();\n+            } else if (\"equals\".equals(method.getName())) {\n+                return Boolean.FALSE;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public abstract Object doInvokeProxy(final Object proxy, final Method method, final Object[] args) throws Throwable;\n+\n+    protected Object invokeWithBody(final Method method, Object body, final ExchangePattern pattern) throws Throwable {\n         final Exchange exchange = new DefaultExchange(endpoint, pattern);\n         exchange.getIn().setBody(body);\n \n@@ -214,4 +242,15 @@ protected Throwable findSuitableException(Throwable cause, Method method) {\n         return null;\n     }\n \n+    protected boolean isValidMethod(Method method) {\n+        // must not be in the excluded list\n+        for (Method excluded : EXCLUDED_METHODS) {\n+            if (ObjectHelper.isOverridingMethod(excluded, method)) {\n+                // the method is overriding an excluded method so its not valid\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/bean/CamelInvocationHandler.java b/camel-core/src/main/java/org/apache/camel/component/bean/CamelInvocationHandler.java\nindex b78dcd3..55b993b 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/CamelInvocationHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/CamelInvocationHandler.java\n@@ -37,11 +37,12 @@ public CamelInvocationHandler(Endpoint endpoint, Producer producer, MethodInfoCa\n         this.methodInfoCache = methodInfoCache;\n     }\n \n-    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n+    @Override\n+    public Object doInvokeProxy(Object proxy, Method method, Object[] args) throws Throwable {\n         BeanInvocation invocation = new BeanInvocation(method, args);\n         MethodInfo methodInfo = methodInfoCache.getMethodInfo(method);\n         final ExchangePattern pattern = methodInfo != null ? methodInfo.getPattern() : ExchangePattern.InOut;\n-        return invokeWithbody(method, invocation, pattern);\n+        return invokeWithBody(method, invocation, pattern);\n     }\n \n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/bean/PojoMessageInvocationHandler.java b/camel-core/src/main/java/org/apache/camel/component/bean/PojoMessageInvocationHandler.java\nindex 906ad71..b97865a 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/PojoMessageInvocationHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/PojoMessageInvocationHandler.java\n@@ -24,7 +24,7 @@\n import org.apache.camel.RuntimeCamelException;\n \n /**\n- * Special InvocationHandler for methods that have only one parameter. This\n+ * Special {@link java.lang.reflect.InvocationHandler} for methods that have only one parameter. This\n  * parameter is directly sent to as the body of the message. The idea is to use\n  * that as a very open message format especially when combined with e.g. JAXB\n  * serialization.\n@@ -34,7 +35,8 @@ public PojoMessageInvocationHandler(Endpoint endpoint, Producer producer) {\n         super(endpoint, producer);\n     }\n \n-    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n+    @Override\n+    public Object doInvokeProxy(Object proxy, Method method, Object[] args) throws Throwable {\n         int argsLength = (args == null) ? 0 : args.length;\n         if (argsLength != 1) {\n             throw new RuntimeCamelException(String.format(\"Error creating proxy for %s.%s Number of arguments must be 1 but is %d\", \n@@ -42,7 +44,7 @@ public Object invoke(final Object proxy, final Method method, final Object[] arg\n                                                           method.getName(), argsLength));\n         }\n         final ExchangePattern pattern = method.getReturnType() != Void.TYPE ? ExchangePattern.InOut : ExchangePattern.InOnly;\n-        return invokeWithbody(method, args[0], pattern);\n+        return invokeWithBody(method, args[0], pattern);\n     }\n \n }\n", "nb_test": 4307, "linesAdd": 42, "jira_id": "5571", "singleLine": false, "nb_skipped": 1, "commit": "0e87b84f", "nb_failure": 0, "linesRem": 5}, {"files": 1, "project": "camel", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["StaxConverterTest>TestSupport.runBare:58->testEncodingXmlEventReader:64 \u00bb XMLStream", "StaxConverterTest>TestSupport.runBare:58->testEncodingXmlStreamReader:100 \u00bb XMLStream"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/jaxp/StaxConverter.java b/camel-core/src/main/java/org/apache/camel/converter/jaxp/StaxConverter.java\nindex 1cd33ae..5469df5 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/jaxp/StaxConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/jaxp/StaxConverter.java\n@@ -167,7 +167,7 @@ public XMLStreamReader createXMLStreamReader(InputStream in) throws XMLStreamExc\n     public XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {\n         XMLInputFactory factory = getInputFactory();\n         try {\n-            return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\n+            return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange, false));\n         } finally {\n             returnXMLInputFactory(factory);\n         }\n@@ -236,7 +236,7 @@ public XMLEventReader createXMLEventReader(InputStream in) throws XMLStreamExcep\n     public XMLEventReader createXMLEventReader(InputStream in, Exchange exchange) throws XMLStreamException {\n         XMLInputFactory factory = getInputFactory();\n         try {\n-            return factory.createXMLEventReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\n+            return factory.createXMLEventReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange, false));\n         } finally {\n             returnXMLInputFactory(factory);\n         }\n", "nb_test": 4714, "linesAdd": 2, "jira_id": "6779", "singleLine": false, "nb_skipped": 1, "commit": "f412d744", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ManagedRouteUpdateRouteFromXmlTest>TestSupport.runBare:58->testUpdateRouteFromXmlMismatchRouteId:138->TestSupport.assertIsInstanceOf:148 object should be a java.lang.IllegalArgumentException but was: org.apache.camel.FailedToStartRouteException: Failed to start route foo because of Multiple consumers for the same endpoint is not allowed: Endpoint[direct://start] with type: org.apache.camel.FailedToStartRouteException", "ManagedRouteUpdateRouteFromXmlTest>TestSupport.runBare:58->testUpdateRouteFromXmlWithoutRouteId:96 \u00bb MBean"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\nindex b1cc984..51ce287 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\n@@ -230,6 +230,16 @@ public void updateRouteFromXml(String xml) throws Exception {\n             return;\n         }\n \n+        // if the xml does not contain the route-id then we fix this by adding the actual route id\n+        // this may be needed if the route-id was auto-generated, as the intend is to update this route\n+        // and not add a new route, adding a new route, use the MBean operation on ManagedCamelContext instead.\n+        if (ObjectHelper.isEmpty(def.getId())) {\n+            def.setId(getRouteId());\n+        } else if (!def.getId().equals(getRouteId())) {\n+            throw new IllegalArgumentException(\"Cannot update route from XML as routeIds does not match. routeId: \"\n+                    + getRouteId() + \", routeId from XML: \" + def.getId());\n+        }\n+\n         // add will remove existing route first\n         context.addRouteDefinition(def);\n     }\n", "nb_test": 4766, "linesAdd": 7, "jira_id": "7016", "singleLine": false, "nb_skipped": 1, "commit": "4ed448c7", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SimpleTest>TestSupport.runBare:58->testHeaderAs:588 Should have thrown an exception"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\nindex 32a22b2..4eedcba 100644\n--- a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n@@ -238,7 +238,8 @@ private Expression createSimpleExpressionBodyOrHeader(String function, boolean s\n \n             String key = ObjectHelper.before(keyAndType, \",\");\n             String type = ObjectHelper.after(keyAndType, \",\");\n-            if (ObjectHelper.isEmpty(key) || ObjectHelper.isEmpty(type)) {\n+            remainder = ObjectHelper.after(remainder, \")\");\n+            if (ObjectHelper.isEmpty(key) || ObjectHelper.isEmpty(type) || ObjectHelper.isNotEmpty(remainder)) {\n                 throw new SimpleParserException(\"Valid syntax: ${headerAs(key, type)} was: \" + function, token.getIndex());\n             }\n             key = StringHelper.removeQuotes(key);\n", "nb_test": 4887, "linesAdd": 2, "jira_id": "7359", "singleLine": false, "nb_skipped": 3, "commit": "9cb09d14", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testMoveAbsolute(org.apache.camel.component.file.FileAbsolutePathIssueTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/xml/DefaultTransformErrorHandler.java b/camel-core/src/main/java/org/apache/camel/builder/xml/DefaultTransformErrorHandler.java\nindex 214ea39..6e6b59d 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/xml/DefaultTransformErrorHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/xml/DefaultTransformErrorHandler.java\n@@ -19,12 +19,13 @@\n import javax.xml.transform.ErrorListener;\n import javax.xml.transform.TransformerException;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.xml.sax.ErrorHandler;\n import org.xml.sax.SAXException;\n import org.xml.sax.SAXParseException;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n /**\n  * {@link ErrorHandler} and {@link ErrorListener} which will log warnings,\n  * and throws error and fatal as exception, which ensures those can be caught by Camel and dealt-with.\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/FileConsumer.java b/camel-core/src/main/java/org/apache/camel/component/file/FileConsumer.java\nindex 8e8b320..6d2c809 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/FileConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/FileConsumer.java\n@@ -137,10 +137,8 @@ protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileLis\n         answer.setAbsolute(FileUtil.isAbsolute(file));\n         answer.setAbsoluteFilePath(file.getAbsolutePath());\n         answer.setLastModified(file.lastModified());\n-        if (answer.isAbsolute()) {\n-            // use absolute path as relative\n-            answer.setRelativeFilePath(file.getAbsolutePath());\n-        } else {\n+\n+        // compute the file path as relative to the starting directory\n         File path;\n         String endpointNormalized = FileUtil.normalizePath(endpointPath);\n         if (file.getPath().startsWith(endpointNormalized)) {\n@@ -155,7 +153,6 @@ protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileLis\n         } else {\n             answer.setRelativeFilePath(path.getName());\n         }\n-        }\n \n         // the file name should be the relative path\n         answer.setFileName(answer.getRelativeFilePath());\n", "nb_test": 3122, "linesAdd": 4, "jira_id": "3617", "singleLine": false, "nb_skipped": 0, "commit": "02626724", "nb_failure": 0, "linesRem": 6}, {"files": 2, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["DumpModelAsXmlChoiceFilterRouteTest>TestSupport.runBare:58->testDumpModelAsXmAl:44 null"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ExpressionNode.java b/camel-core/src/main/java/org/apache/camel/model/ExpressionNode.java\nindex 41f97ce..ef64c2d 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ExpressionNode.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ExpressionNode.java\n@@ -143,5 +143,14 @@ protected void preCreateProcessor() {\n                 expression = clause.getExpressionType();\n             }\n         }\n+\n+        if (expression != null && expression.getExpression() == null) {\n+            // use toString from predicate or expression so we have some information to show in the route model\n+            if (expression.getPredicate() != null) {\n+                expression.setExpression(expression.getPredicate().toString());\n+            } else if (expression.getExpressionValue() != null) {\n+                expression.setExpression(expression.getExpressionValue().toString());\n+            }\n+        }\n     }\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/model/language/ExpressionDefinition.java b/camel-core/src/main/java/org/apache/camel/model/language/ExpressionDefinition.java\nindex b423afa..52b0d1c 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/language/ExpressionDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/language/ExpressionDefinition.java\n@@ -243,8 +243,6 @@ public boolean isTrim() {\n      * Returns some descriptive text to describe this node\n      */\n     public String getLabel() {\n-        String language = getExpression();\n-        if (ObjectHelper.isEmpty(language)) {\n         Predicate predicate = getPredicate();\n         if (predicate != null) {\n             return predicate.toString();\n@@ -253,10 +251,9 @@ public String getLabel() {\n         if (expressionValue != null) {\n             return expressionValue.toString();\n         }\n-        } else {\n-            return language;\n-        }\n-        return \"\";\n+\n+        String exp = getExpression();\n+        return exp != null ? exp : \"\";\n     }\n \n     /**\n", "nb_test": 4675, "linesAdd": 11, "jira_id": "6593", "singleLine": false, "nb_skipped": 1, "commit": "7f8a295a", "nb_failure": 1, "linesRem": 6}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testLifecycleStrategyService(org.apache.camel.impl.LifecycleStrategyServiceTest): expected:<true> but was:<false>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex c5dbd5c..ee33f8e 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -1415,6 +1415,7 @@ private void doStartCamel() throws Exception {\n         getManagementStrategy().start();\n \n         // start lifecycle strategies\n+        ServiceHelper.startServices(lifecycleStrategies);\n         Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();\n         while (it.hasNext()) {\n             LifecycleStrategy strategy = it.next();\n@@ -1526,6 +1527,8 @@ protected synchronized void doStop() throws Exception {\n \n         // shutdown management as the last one\n         shutdownServices(managementStrategy);\n+        shutdownServices(lifecycleStrategies);\n+        lifecycleStrategies.clear();\n \n         // stop the lazy created so they can be re-created on restart\n         forceStopLazyInitialization();\n", "nb_test": 3826, "linesAdd": 3, "jira_id": "4467", "singleLine": false, "nb_skipped": 0, "commit": "79168a23", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["PropertiesComponentOnExceptionDelayPatternTest>TestSupport.runBare:58->testDelayPattern:31 \u00bb CamelExecution"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/RedeliveryPolicyDefinition.java b/camel-core/src/main/java/org/apache/camel/model/RedeliveryPolicyDefinition.java\nindex 41e53e9..f695d26 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/RedeliveryPolicyDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/RedeliveryPolicyDefinition.java\n@@ -156,13 +156,13 @@ public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryP\n                 }\n             }\n             if (delayPattern != null) {\n-                answer.setDelayPattern(delayPattern);\n+                answer.setDelayPattern(CamelContextHelper.parseText(context, delayPattern));\n             }\n             if (allowRedeliveryWhileStopping != null) {\n                 answer.setAllowRedeliveryWhileStopping(CamelContextHelper.parseBoolean(context, allowRedeliveryWhileStopping));\n             }\n             if (exchangeFormatterRef != null) {\n-                answer.setExchangeFormatterRef(exchangeFormatterRef);\n+                answer.setExchangeFormatterRef(CamelContextHelper.parseText(context, exchangeFormatterRef));\n             }\n         } catch (Exception e) {\n             throw ObjectHelper.wrapRuntimeCamelException(e);\n", "nb_test": 5441, "linesAdd": 2, "jira_id": "9124", "singleLine": false, "nb_skipped": 4, "commit": "9da2c05a", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["FileConsumerPathWithAmpersandTest>TestSupport.runBare:58->testPathWithAmpersand:36 \u00bb ResolveEndpointFailed"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultComponent.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultComponent.java\nindex c7ab7ff..c6492ea 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultComponent.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultComponent.java\n@@ -196,12 +196,6 @@ protected void validateParameters(String uri, Map<String, Object> parameters, St\n      * @throws ResolveEndpointFailedException should be thrown if the URI validation failed\n      */\n     protected void validateURI(String uri, String path, Map<String, Object> parameters) {\n-        // check for uri containing & but no ? marker\n-        if (uri.contains(\"&\") && !uri.contains(\"?\")) {\n-            throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: no ? marker however the uri \"\n-                + \"has & parameter separators. Check the uri if its missing a ? marker.\");\n-        }\n-\n         // check for uri containing double && markers without include by RAW\n         if (uri.contains(\"&&\")) {\n             Pattern pattern = Pattern.compile(\"RAW(.*&&.*)\");\n", "nb_test": 5437, "linesAdd": 0, "jira_id": "9217", "singleLine": false, "nb_skipped": 4, "commit": "e7ac45b6", "nb_failure": 0, "linesRem": 5}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>", "MulticastParallelAllTimeoutAwareTest>TestSupport.runBare:58->testMulticastParallelAllTimeoutAware:46 expected:<2> but was:<0>", "MulticastParallelTwoTimeoutMiddleTest>TestSupport.runBare:58->testMulticastParallelTimeout:45->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Body of message: 0. Expected: <ACE> but was: <AC>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex 1d579cd..38e70bb 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -442,10 +442,7 @@ private void aggregateOnTheFly() throws InterruptedException, ExecutionException\n                     }\n                 }\n \n-                if (future == null && timedOut) {\n-                    // we are timed out and no more tasks complete so break out\n-                    break;\n-                } else if (future == null) {\n+                if (future == null) {\n                     // timeout occurred\n                     AggregationStrategy strategy = getAggregationStrategy(null);\n                     if (strategy instanceof TimeoutAwareAggregationStrategy) {\n", "nb_test": 5134, "linesAdd": 1, "jira_id": "8081", "singleLine": false, "nb_skipped": 3, "commit": "2e985f9b", "nb_failure": 3, "linesRem": 3}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testExchangeDeadLetterChannel(org.apache.camel.management.EventNotifierFailureHandledEventsTest): object should be a org.apache.camel.management.event.ExchangeSentEvent but was: ID-PRIMERGY-TX300-S7-57302-1467760701486-1882-1 exchange failed: Exchange[Message: Hello World] but was handled by dead letter channel: sendTo(Endpoint[mock://dead] InOnly) with type: org.apache.camel.management.event.ExchangeFailureHandledEvent", "testExchangeOnException(org.apache.camel.management.EventNotifierFailureHandledEventsTest): object should be a org.apache.camel.management.event.ExchangeSentEvent but was: ID-PRIMERGY-TX300-S7-57302-1467760701486-1883-1 exchange failed: Exchange[Message: Hello World] but was processed by: FatalFallbackErrorHandler[Channel[sendTo(Endpoint[mock://dead])]] with type: org.apache.camel.management.event.ExchangeFailureHandledEvent", "testExchangeRedeliverySync(org.apache.camel.management.EventNotifierRedeliveryEventsTest): object should be a org.apache.camel.management.event.ExchangeSentEvent but was: ID-PRIMERGY-TX300-S7-57302-1467760701486-1884-1 exchange failed: Exchange[Message: Hello World] but was handled by dead letter channel: sendTo(Endpoint[mock://dead] InOnly) with type: org.apache.camel.management.event.ExchangeFailureHandledEvent", "testAsyncEndpointEventNotifer(org.apache.camel.processor.async.AsyncEndpointEventNotifierTest): Should take about 1000 millis sec, was: 2", "testCounters(org.apache.camel.management.JmxInstrumentationWithConnectorTest): Failed to retrieve RMIServer stub: javax.naming.ServiceUnavailableException [Root exception is java.rmi.ConnectException: Connection refused to host: localhost; nested exception is:"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\nindex e9093a4..c8304d6 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n@@ -259,11 +259,12 @@ public Exchange send(Endpoint endpoint, ExchangePattern pattern, Processor proce\n      * @param producerCallback the producer template callback to be executed\n      * @return (doneSync) <tt>true</tt> to continue execute synchronously, <tt>false</tt> to continue being executed asynchronously\n      */\n-    public boolean doInAsyncProducer(Endpoint endpoint, Exchange exchange, ExchangePattern pattern, AsyncCallback callback, AsyncProducerCallback producerCallback) {\n+    public boolean doInAsyncProducer(final Endpoint endpoint, final Exchange exchange, final ExchangePattern pattern,\n+                                     final AsyncCallback callback, final AsyncProducerCallback producerCallback) {\n         boolean sync = true;\n \n         // get the producer and we do not mind if its pooled as we can handle returning it back to the pool\n-        Producer producer = doGetProducer(endpoint, true);\n+        final Producer producer = doGetProducer(endpoint, true);\n \n         if (producer == null) {\n             if (isStopped()) {\n@@ -274,23 +275,17 @@ public boolean doInAsyncProducer(Endpoint endpoint, Exchange exchange, ExchangeP\n             }\n         }\n \n-        StopWatch watch = null;\n-        if (exchange != null) {\n         // record timing for sending the exchange using the producer\n-            watch = new StopWatch();\n-        }\n+        final StopWatch watch = exchange != null ? new StopWatch() : null;\n \n         try {\n             // invoke the callback\n             AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter.convert(producer);\n-            sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, callback);\n-        } catch (Throwable e) {\n-            // ensure exceptions is caught and set on the exchange\n-            if (exchange != null) {\n-                exchange.setException(e);\n-            }\n-        } finally {\n-            if (exchange != null && exchange.getException() == null) {\n+            sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    try {\n+                        if (watch != null) {\n                             long timeTaken = watch.stop();\n                             // emit event that the exchange was sent to the endpoint\n                             EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);\n@@ -307,6 +303,16 @@ public boolean doInAsyncProducer(Endpoint endpoint, Exchange exchange, ExchangeP\n                                 LOG.warn(\"Error stopping producer: \" + producer, e);\n                             }\n                         }\n+                    } finally {\n+                        callback.done(doneSync);\n+                    }\n+                }\n+            });\n+        } catch (Throwable e) {\n+            // ensure exceptions is caught and set on the exchange\n+            if (exchange != null) {\n+                exchange.setException(e);\n+            }\n         }\n \n         return sync;\n", "nb_test": 3733, "linesAdd": 18, "jira_id": "4354", "singleLine": false, "nb_skipped": 0, "commit": "96e40c3c", "nb_failure": 4, "linesRem": 13}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPropertyPlaceholder(org.apache.camel.processor.intercept.TransactedPropertyPlaceholderIssueTest): mock://result Body of message: 0. Expected: <Camel> but was: <{{cool.name}}>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\nindex 2db4f13..38989d1 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n@@ -367,9 +367,29 @@ protected Processor createOutputsProcessor(RouteContext routeContext, Collection\n         List<Processor> list = new ArrayList<Processor>();\n         for (ProcessorDefinition<?> output : outputs) {\n \n+            // allow any custom logic before we create the processor\n+            output.preCreateProcessor();\n+\n             // resolve properties before we create the processor\n             resolvePropertyPlaceholders(routeContext, output);\n \n+            // resolve constant fields (eg Exchange.FILE_NAME)\n+            resolveKnownConstantFields(output);\n+\n+            // also resolve properties and constant fields on embedded expressions\n+            ProcessorDefinition<?> me = (ProcessorDefinition<?>) output;\n+            if (me instanceof ExpressionNode) {\n+                ExpressionNode exp = (ExpressionNode) me;\n+                ExpressionDefinition expressionDefinition = exp.getExpression();\n+                if (expressionDefinition != null) {\n+                    // resolve properties before we create the processor\n+                    resolvePropertyPlaceholders(routeContext, expressionDefinition);\n+\n+                    // resolve constant fields (eg Exchange.FILE_NAME)\n+                    resolveKnownConstantFields(expressionDefinition);\n+                }\n+            }\n+\n             Processor processor = null;\n             // at first use custom factory\n             if (routeContext.getCamelContext().getProcessorFactory() != null) {\n@@ -472,10 +492,9 @@ protected void resolvePropertyPlaceholders(RouteContext routeContext, Object def\n         // include additional properties which have the Camel placeholder QName\n         // and when the definition parameter is this (otherAttributes belong to this)\n         if (processorDefinition != null && processorDefinition.getOtherAttributes() != null) {\n-            for (Object key : processorDefinition.getOtherAttributes().keySet()) {\n-                QName qname = (QName) key;\n-                if (Constants.PLACEHOLDER_QNAME.equals(qname.getNamespaceURI())) {\n-                    String local = qname.getLocalPart();\n+            for (QName key : processorDefinition.getOtherAttributes().keySet()) {\n+                if (Constants.PLACEHOLDER_QNAME.equals(key.getNamespaceURI())) {\n+                    String local = key.getLocalPart();\n                     Object value = processorDefinition.getOtherAttributes().get(key);\n                     if (value != null && value instanceof String) {\n                         // value must be enclosed with placeholder tokens\n", "nb_test": 4353, "linesAdd": 18, "jira_id": "5796", "singleLine": false, "nb_skipped": 1, "commit": "de6dd425", "nb_failure": 1, "linesRem": 4}, {"files": 2, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testXPathSplitConcurrent(org.apache.camel.builder.xml.XPathTest): expected:<100> but was:<99>", "testSplitterAndVerifyException(org.apache.camel.processor.SplitterThrowExceptionFromExpressionTest): Exception occurred during execution on the exchange: Exchange[Message: Hello World]"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex 8727bef..f9b361e 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -797,6 +797,12 @@ protected Integer getExchangeIndex(Exchange exchange) {\n             result.add(createProcessorExchangePair(index++, processor, copy, routeContext));\n         }\n \n+        if (exchange.getException() != null) {\n+            // force any exceptions occurred during creation of exchange paris to be thrown\n+            // before returning the answer;\n+            throw exchange.getException();\n+        }\n+\n         return result;\n     }\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\nindex bb7783a..ce14657 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n@@ -98,14 +98,26 @@ public boolean process(Exchange exchange, final AsyncCallback callback) {\n     }\n \n     @Override\n-    protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) {\n+    protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {\n         Object value = expression.evaluate(exchange, Object.class);\n+        if (exchange.getException() != null) {\n+            // force any exceptions occurred during evaluation to be thrown\n+            throw exchange.getException();\n+        }\n \n+        Iterable<ProcessorExchangePair> answer;\n         if (isStreaming()) {\n-            return createProcessorExchangePairsIterable(exchange, value);\n+            answer = createProcessorExchangePairsIterable(exchange, value);\n         } else {\n-            return createProcessorExchangePairsList(exchange, value);\n+            answer = createProcessorExchangePairsList(exchange, value);\n+        }\n+        if (exchange.getException() != null) {\n+            // force any exceptions occurred during creation of exchange paris to be thrown\n+            // before returning the answer;\n+            throw exchange.getException();\n         }\n+\n+        return answer;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n", "nb_test": 3836, "linesAdd": 16, "jira_id": "4482", "singleLine": false, "nb_skipped": 0, "commit": "e38494f1", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "camel", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testConvertToBytesCharset(org.apache.camel.component.properties.PropertiesComponentEIPChoiceConvertBodyToTest)", "testNullBody(org.apache.camel.component.properties.PropertiesComponentEIPChoiceConvertBodyToTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\nindex a270651..67d135a 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n@@ -345,6 +345,10 @@ protected Channel createChannel(RouteContext routeContext) throws Exception {\n     protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition> outputs) throws Exception {\n         List<Processor> list = new ArrayList<Processor>();\n         for (ProcessorDefinition<?> output : outputs) {\n+\n+            // resolve properties before we create the processor\n+            resolvePropertyPlaceholders(routeContext, output);\n+\n             Processor processor = null;\n             // at first use custom factory\n             if (routeContext.getCamelContext().getProcessorFactory() != null) {\n@@ -383,7 +387,7 @@ protected Processor makeProcessor(RouteContext routeContext) throws Exception {\n         Processor processor = null;\n \n         // resolve properties before we create the processor\n-        resolvePropertyPlaceholders(routeContext);\n+        resolvePropertyPlaceholders(routeContext, this);\n \n         // at first use custom factory\n         if (routeContext.getCamelContext().getProcessorFactory() != null) {\n@@ -402,28 +406,29 @@ protected Processor makeProcessor(RouteContext routeContext) throws Exception {\n     }\n \n     /**\n-     * Inspects this processor definition and resolves any property placeholders from its properties.\n+     * Inspects the given processor definition and resolves any property placeholders from its properties.\n      * <p/>\n      * This implementation will check all the getter/setter pairs on this instance and for all the values\n      * (which is a String type) will be property placeholder resolved.\n      *\n      * @param routeContext the route context\n+     * @param definition   the processor definition\n      * @throws Exception is thrown if property placeholders was used and there was an error resolving them\n      * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)\n      * @see org.apache.camel.component.properties.PropertiesComponent\n      */\n-    protected void resolvePropertyPlaceholders(RouteContext routeContext) throws Exception {\n+    protected void resolvePropertyPlaceholders(RouteContext routeContext, ProcessorDefinition definition) throws Exception {\n         if (log.isTraceEnabled()) {\n-            log.trace(\"Resolving property placeholders for: \" + this);\n+            log.trace(\"Resolving property placeholders for: \" + definition);\n         }\n \n         // find all String getter/setter\n         Map<Object, Object> properties = new HashMap<Object, Object>();\n-        IntrospectionSupport.getProperties(this, properties, null);\n+        IntrospectionSupport.getProperties(definition, properties, null);\n \n         if (!properties.isEmpty()) {\n             if (log.isTraceEnabled()) {\n-                log.trace(\"There are \" + properties.size() + \" properties on: \" + this);\n+                log.trace(\"There are \" + properties.size() + \" properties on: \" + definition);\n             }\n \n             // lookup and resolve properties for String based properties\n@@ -437,7 +442,7 @@ protected void resolvePropertyPlaceholders(RouteContext routeContext) throws Exc\n                     text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);\n                     if (text != value) {\n                         // invoke setter as the text has changed\n-                        IntrospectionSupport.setProperty(this, name, text);\n+                        IntrospectionSupport.setProperty(definition, name, text);\n                         if (log.isDebugEnabled()) {\n                             log.debug(\"Changed property [\" + name + \"] from: \" + value + \" to: \" + text);\n                         }\n", "nb_test": 2924, "linesAdd": 9, "jira_id": "3314", "singleLine": false, "nb_skipped": 0, "commit": "4badd9c5", "nb_failure": 0, "linesRem": 6}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ValidatorIncludeEncodingRouteTest>TestSupport.runBare:58->testValidMessage:44 \u00bb CamelExecution"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/validator/DefaultLSResourceResolver.java b/camel-core/src/main/java/org/apache/camel/component/validator/DefaultLSResourceResolver.java\nindex 622e257..38fa704 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/validator/DefaultLSResourceResolver.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/validator/DefaultLSResourceResolver.java\n@@ -117,8 +117,7 @@ private String getInputUri() {\n         \n         @Override\n         public Reader getCharacterStream() {\n-            InputStream is = getByteStream();\n-            return camelContext.getTypeConverter().convertTo(Reader.class, is);\n+            return null;\n         }\n \n         @Override\n", "nb_test": 5096, "linesAdd": 1, "jira_id": "7883", "singleLine": false, "nb_skipped": 3, "commit": "d57f402b", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testAutoCreateDirectoryWithDot(org.apache.camel.component.file.FileConsumerAutoCreateDirectoryTest): Only directory is supported. Endpoint must be configured with a valid starting directory: target/file/foo.bar"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/FileEndpoint.java b/camel-core/src/main/java/org/apache/camel/component/file/FileEndpoint.java\nindex 8109971..b8aaff3 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/FileEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/FileEndpoint.java\n@@ -49,14 +49,8 @@ public FileConsumer createConsumer(Processor processor) throws Exception {\n         ObjectHelper.notNull(operations, \"operations\");\n         ObjectHelper.notNull(file, \"file\");\n \n-        // we assume its a file if the name has a dot in it (eg foo.txt)\n-        boolean isDirectory = file.isDirectory();\n-        if (!isDirectory && file.getName().contains(\".\")) {\n-            throw new IllegalArgumentException(\"Only directory is supported. Endpoint must be configured with a valid starting directory: \" + file);\n-        }\n-\n         // auto create starting directory if needed\n-        if (!file.exists() && !isDirectory) {\n+        if (!file.exists() && !file.isDirectory()) {\n             if (isAutoCreate()) {\n                 log.debug(\"Creating non existing starting directory: {}\", file);\n                 boolean absolute = FileUtil.isAbsolute(file);\n", "nb_test": 3836, "linesAdd": 1, "jira_id": "4474", "singleLine": false, "nb_skipped": 0, "commit": "06a8489a", "nb_failure": 0, "linesRem": 6}, {"files": 2, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testMulticastParalllelStopOnExceptionStop(org.apache.camel.processor.MulticastParallelStopOnExceptionTest): object should be a org.apache.camel.CamelExchangeException but was: java.util.concurrent.ExecutionException: org.apache.camel.CamelExchangeException: Parallel processing failed for number 1. Exchange[Message: Kaboom]. Caused by: [java.lang.IllegalArgumentException - Forced] with type: java.util.concurrent.ExecutionException", "testRecipientListAsBeanError(org.apache.camel.processor.RecipientListParallelFineGrainedErrorHandlingTest): object should be a org.apache.camel.CamelExchangeException but was: java.util.concurrent.ExecutionException: org.apache.camel.CamelExchangeException: Parallel processing failed for number 2. Exchange[Message: Hello World]. Caused by: [java.lang.IllegalArgumentException - Damn] with type: java.util.concurrent.ExecutionException", "testSplitParallelStopOnExceptionStop(org.apache.camel.processor.SplitterParallelStopOnExceptionTest): object should be a org.apache.camel.CamelExchangeException but was: java.util.concurrent.ExecutionException: org.apache.camel.CamelExchangeException: Parallel processing failed for number 2. Exchange[Message: Kaboom]. Caused by: [java.lang.IllegalArgumentException - Forced] with type: java.util.concurrent.ExecutionException", "testDoCatchDirectRoute(org.apache.camel.processor.onexception.DoCatchDirectRecipientListTest): Exception occurred during execution on the exchange: Exchange[Message: Hello World]"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex e538801..b2930f6 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -200,19 +200,11 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         final AtomicExchange result = new AtomicExchange();\n         final Iterable<ProcessorExchangePair> pairs;\n \n-        // multicast uses fine grained error handling on the output processors\n-        // so use try .. catch to cater for this\n-        boolean exhaust = false;\n         try {\n             boolean sync = true;\n \n             pairs = createProcessorExchangePairs(exchange);\n \n-            // after we have created the processors we consider the exchange as exhausted if an unhandled\n-            // exception was thrown, (used in the catch block)\n-            // if the processors is working in Streaming model, the exchange could not be processed at this point.\n-            exhaust = !isStreaming();\n-\n             if (isParallelProcessing()) {\n                 // ensure an executor is set when running in parallel\n                 ObjectHelper.notNull(executorService, \"executorService\", this);\n@@ -228,15 +220,16 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n             }\n         } catch (Throwable e) {\n             exchange.setException(e);\n+            // unexpected exception was thrown, maybe from iterator etc. so do not regard as exhausted\n             // and do the done work\n-            doDone(exchange, null, callback, true, exhaust);\n+            doDone(exchange, null, callback, true, false);\n             return true;\n         }\n \n         // multicasting was processed successfully\n         // and do the done work\n         Exchange subExchange = result.get() != null ? result.get() : null;\n-        doDone(exchange, subExchange, callback, true, exhaust);\n+        doDone(exchange, subExchange, callback, true, true);\n         return true;\n     }\n \n@@ -308,7 +301,8 @@ public Exchange call() throws Exception {\n                             // throw caused exception\n                             if (subExchange.getException() != null) {\n                                 // wrap in exception to explain where it failed\n-                                throw new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\n+                                CamelExchangeException cause = new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\n+                                subExchange.setException(cause);\n                             }\n                         }\n \n@@ -527,15 +521,15 @@ protected boolean doProcessSequential(Exchange original, AtomicExchange result,\n             if (stopOnException && !continueProcessing) {\n                 if (subExchange.getException() != null) {\n                     // wrap in exception to explain where it failed\n-                    throw new CamelExchangeException(\"Sequential processing failed for number \" + total.get(), subExchange, subExchange.getException());\n-                } else {\n+                    CamelExchangeException cause = new CamelExchangeException(\"Sequential processing failed for number \" + total.get(), subExchange, subExchange.getException());\n+                    subExchange.setException(cause);\n+                }\n                 // we want to stop on exception, and the exception was handled by the error handler\n                 // this is similar to what the pipeline does, so we should do the same to not surprise end users\n                 // so we should set the failed exchange as the result and be done\n                 result.set(subExchange);\n                 return true;\n             }\n-            }\n \n             LOG.trace(\"Sequential processing complete for number {} exchange: {}\", total, subExchange);\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\nindex 9c4b00d..6cac402 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\n@@ -361,6 +361,8 @@ protected boolean processNext(final Exchange exchange, final AsyncCallback callb\n             // give the rest of the pipeline another chance\n             exchange.setProperty(Exchange.EXCEPTION_CAUGHT, caught);\n             exchange.setException(null);\n+            // and we should not be regarded as exhausted as we are in a try .. catch block\n+            exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\n \n             // is the exception handled by the catch clause\n             final Boolean handled = catchClause.handles(exchange);\n", "nb_test": 4318, "linesAdd": 8, "jira_id": "5681", "singleLine": false, "nb_skipped": 1, "commit": "78c73502", "nb_failure": 3, "linesRem": 9}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["TokenizerTest>TestSupport.runBare:58->testTokenizeXMLPairWithSimilarChildNames:212 expected:<1> but was:<0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java b/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\nindex b8d4374..938b1d6 100644\n--- a/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\n+++ b/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\n@@ -47,7 +47,7 @@\n public class TokenXMLExpressionIterator extends ExpressionAdapter {\n     private static final Pattern NAMESPACE_PATTERN = Pattern.compile(\"xmlns(:\\\\w+|)\\\\s*=\\\\s*('[^']+'|\\\"[^\\\"]+\\\")\");\n     private static final String SCAN_TOKEN_NS_PREFIX_REGEX = \"([^:<>]{1,15}?:|)\";\n-    private static final String SCAN_BLOCK_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^/]*)?/>|<{0}(\\\\s+[^>]*)?>(?:(?!</{0}).)*</{0}\\\\s*>\";\n+    private static final String SCAN_BLOCK_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^/]*)?/>|<{0}(\\\\s+[^>]*)?>(?:(?!(</{0}\\\\s*>)).)*</{0}\\\\s*>\";\n     private static final String SCAN_PARENT_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^>]*\\\\s*)?>\";\n     \n     protected final String tagToken;\n", "nb_test": 4629, "linesAdd": 1, "jira_id": "6607", "singleLine": false, "nb_skipped": 1, "commit": "2d7051ed", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ValidatorRouteTest>TestSupport.runBare:58->testConcurrentUseNotASharedSchema:155 null", "ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/validation/ValidatingProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/validation/ValidatingProcessor.java\nindex bcbc671..2d9fa8e 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/validation/ValidatingProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/validation/ValidatingProcessor.java\n@@ -62,9 +64,9 @@\n     private static final Logger LOG = LoggerFactory.getLogger(ValidatingProcessor.class);\n     private XmlConverter converter = new XmlConverter();\n     private String schemaLanguage = XMLConstants.W3C_XML_SCHEMA_NS_URI;\n-    private Schema schema;\n+    private volatile Schema schema;\n     private Source schemaSource;\n-    private SchemaFactory schemaFactory;\n+    private volatile SchemaFactory schemaFactory;\n     private URL schemaUrl;\n     private File schemaFile;\n     private byte[] schemaAsByteArray;\n@@ -190,8 +192,12 @@ public void loadSchema() throws Exception {\n \n     public Schema getSchema() throws IOException, SAXException {\n         if (schema == null) {\n+            synchronized (this) {\n+                if (schema == null) {\n                     schema = createSchema();\n                 }\n+            }\n+        }\n         return schema;\n     }\n \n@@ -244,8 +250,12 @@ public void setSchemaAsByteArray(byte[] schemaAsByteArray) {\n \n     public SchemaFactory getSchemaFactory() {\n         if (schemaFactory == null) {\n+            synchronized (this) {\n+                if (schemaFactory == null) {\n                     schemaFactory = createSchemaFactory();\n                 }\n+            }\n+        }\n         return schemaFactory;\n     }\n \n@@ -336,22 +346,30 @@ protected Schema createSchema() throws SAXException, IOException {\n \n         URL url = getSchemaUrl();\n         if (url != null) {\n+            synchronized (this) {\n                 return factory.newSchema(url);\n             }\n+        }\n \n         File file = getSchemaFile();\n         if (file != null) {\n+            synchronized (this) {\n                 return factory.newSchema(file);\n             }\n+        }\n \n         byte[] bytes = getSchemaAsByteArray();\n         if (bytes != null) {\n+            synchronized (this) {\n                 return factory.newSchema(new StreamSource(new ByteArrayInputStream(schemaAsByteArray)));\n             }\n+        }\n \n         Source source = getSchemaSource();\n+        synchronized (this) {\n             return factory.newSchema(source);\n         }\n+    }\n \n     /**\n      * Checks whether we need an {@link InputStream} to access the message body or header.\n", "nb_test": 4848, "linesAdd": 18, "jira_id": "7239", "singleLine": false, "nb_skipped": 3, "commit": "ae419224", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SplitTokenizerTest>TestSupport.runBare:58->testSplitTokenizerEWithSlash:79 mock://split Received message count. Expected: <1> but was: <0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java b/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\nindex 3048c64..ba21a71 100644\n--- a/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\n+++ b/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\n@@ -47,7 +47,7 @@\n public class TokenXMLExpressionIterator extends ExpressionAdapter {\n     private static final Pattern NAMESPACE_PATTERN = Pattern.compile(\"xmlns(:\\\\w+|)\\\\s*=\\\\s*('[^']+'|\\\"[^\\\"]+\\\")\");\n     private static final String SCAN_TOKEN_NS_PREFIX_REGEX = \"([^:<>]{1,15}?:|)\";\n-    private static final String SCAN_BLOCK_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^/^>]*)?/>|<{0}(\\\\s+[^>]*)?>(?:(?!(</{0}\\\\s*>)).)*</{0}\\\\s*>\";\n+    private static final String SCAN_BLOCK_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^>]*)?/>|<{0}(\\\\s+[^>]*)?>(?:(?!(</{0}\\\\s*>)).)*</{0}\\\\s*>\";\n     private static final String SCAN_PARENT_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^>]*\\\\s*)?>\";\n     \n     protected final String tagToken;\n", "nb_test": 4795, "linesAdd": 1, "jira_id": "7125", "singleLine": false, "nb_skipped": 3, "commit": "6641f182", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRestart(org.apache.camel.impl.DefaultCamelContextWithLifecycleStrategyRestartTest): expected:<2> but was:<1>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex 5cc505b..7857a78 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -1560,7 +1560,7 @@ protected synchronized void doStop() throws Exception {\n         // shutdown management as the last one\n         shutdownServices(managementStrategy);\n         shutdownServices(lifecycleStrategies);\n-        lifecycleStrategies.clear();\n+        // do not clear lifecycleStrategies as we can start Camel again and get the route back as before\n \n         // stop the lazy created so they can be re-created on restart\n         forceStopLazyInitialization();\n", "nb_test": 3897, "linesAdd": 0, "jira_id": "4682", "singleLine": true, "nb_skipped": 0, "commit": "1e54865c", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSplitCorrelationId(org.apache.camel.issues.SplitterCorrelationIdIssueTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\nindex 1f51134..97e5178 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n@@ -137,7 +137,7 @@ public boolean hasNext() {\n \n                     public Object next() {\n                         Object part = iterator.next();\n-                        Exchange newExchange = exchange.copy();\n+                        Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\n                         if (part instanceof Message) {\n                             newExchange.setIn((Message)part);\n                         } else {\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\nindex 03ce98e..606a69a 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n@@ -168,6 +168,8 @@ public static Object getMandatoryOutBody(Exchange exchange) throws InvalidPayloa\n      * @param handover whether the on completion callbacks should be handed over to the new copy.\n      */\n     public static Exchange createCorrelatedCopy(Exchange exchange, boolean handover) {\n+        String id = exchange.getExchangeId();\n+\n         Exchange copy = exchange.copy();\n         // do not share the unit of work\n         copy.setUnitOfWork(null);\n@@ -177,7 +179,23 @@ public static Exchange createCorrelatedCopy(Exchange exchange, boolean handover)\n             uow.handoverSynchronization(copy);\n         }\n         // set a correlation id so we can track back the original exchange\n-        copy.setProperty(Exchange.CORRELATION_ID, exchange.getExchangeId());\n+        copy.setProperty(Exchange.CORRELATION_ID, id);\n+        return copy;\n+    }\n+\n+    /**\n+     * Creates a new instance and copies from the current message exchange so that it can be\n+     * forwarded to another destination as a new instance.\n+     *\n+     * @param exchange original copy of the exchange\n+     * @param preserveExchangeId whether or not the exchange id should be preserved\n+     * @return the copy\n+     */\n+    public static Exchange createCopy(Exchange exchange, boolean preserveExchangeId) {\n+        Exchange copy = exchange.copy();\n+        if (preserveExchangeId) {\n+            copy.setExchangeId(exchange.getExchangeId());\n+        }\n         return copy;\n     }\n \n", "nb_test": 3000, "linesAdd": 12, "jira_id": "3395", "singleLine": false, "nb_skipped": 0, "commit": "8433e6db", "nb_failure": 1, "linesRem": 2}, {"files": 3, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testProducerWithDifferentUri(org.apache.camel.issues.AdviceWithUrlIssueTest): Exception occurred during execution on the exchange: Exchange[Message: TESTING]"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaComponent.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaComponent.java\nindex ed0f066..23c70bd 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaComponent.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaComponent.java\n@@ -53,7 +53,7 @@ public int getConcurrentConsumers() {\n         return defaultConcurrentConsumers;\n     }\n \n-    public synchronized BlockingQueue<Exchange> createQueue(String uri, Map<String, Object> parameters) {\n+    public synchronized BlockingQueue<Exchange> getOrCreateQueue(String uri, Integer size) {\n         String key = getQueueKey(uri);\n \n         QueueReference ref = getQueues().get(key);\n@@ -65,7 +65,6 @@ public int getConcurrentConsumers() {\n \n         // create queue\n         BlockingQueue<Exchange> queue;\n-        Integer size = getAndRemoveParameter(parameters, \"size\", Integer.class);\n         if (size != null && size > 0) {\n             queue = new LinkedBlockingQueue<Exchange>(size);\n         } else {\n@@ -96,7 +95,8 @@ protected Endpoint createEndpoint(String uri, String remaining, Map<String, Obje\n             throw new IllegalArgumentException(\"The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than \"\n                     + maxConcurrentConsumers + \" was \" + consumers);\n         }\n-        SedaEndpoint answer = new SedaEndpoint(uri, this, createQueue(uri, parameters), consumers);\n+        Integer size = getAndRemoveParameter(parameters, \"size\", Integer.class);\n+        SedaEndpoint answer = new SedaEndpoint(uri, this, getOrCreateQueue(uri, size), consumers);\n         answer.configureProperties(parameters);\n         return answer;\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\nindex 2095a93..5b2d872 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n@@ -94,15 +94,27 @@ public Consumer createConsumer(Processor processor) throws Exception {\n \n     public synchronized BlockingQueue<Exchange> getQueue() {\n         if (queue == null) {\n-            if (size > 0) {\n-                queue = new LinkedBlockingQueue<Exchange>(size);\n+            // prefer to lookup queue from component, so if this endpoint is re-created or re-started\n+            // then the existing queue from the component can be used, so new producers and consumers\n+            // can use the already existing queue referenced from the component\n+            if (getComponent() != null) {\n+                queue = getComponent().getOrCreateQueue(getEndpointUri(), getSize());\n             } else {\n-                queue = new LinkedBlockingQueue<Exchange>();\n+                // fallback and create queue (as this endpoint has no component)\n+                queue = createQueue();\n             }\n         }\n         return queue;\n     }\n \n+    protected BlockingQueue<Exchange> createQueue() {\n+        if (size > 0) {\n+            return new LinkedBlockingQueue<Exchange>(size);\n+        } else {\n+            return new LinkedBlockingQueue<Exchange>();\n+        }\n+    }\n+\n     protected synchronized MulticastProcessor getConsumerMulticastProcessor() throws Exception {\n         if (!multicastStarted && consumerMulticastProcessor != null) {\n             // only start it on-demand to avoid starting it during stopping\n@@ -363,6 +375,10 @@ protected void doShutdown() throws Exception {\n             getCamelContext().getExecutorServiceManager().shutdownNow(multicastExecutor);\n             multicastExecutor = null;\n         }\n+\n+        // clear queue, as we are shutdown, so if re-created then the queue must be updated\n+        queue = null;\n+\n         super.doShutdown();\n     }\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\nindex 1067042..d39e39f 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n@@ -27,7 +27,6 @@\n import org.apache.camel.impl.DefaultAsyncProducer;\n import org.apache.camel.support.SynchronizationAdapter;\n import org.apache.camel.util.ExchangeHelper;\n-import org.apache.camel.util.URISupport;\n \n /**\n  * @version \n", "nb_test": 4199, "linesAdd": 17, "jira_id": "5261", "singleLine": false, "nb_skipped": 1, "commit": "55c2e2d8", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["RoutingSlipCreateProducerFailedTest>TestSupport.runBare:58->testRoutingSlipCreateProducerFailed:44 expected:<0> but was:<1>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\nindex 94a352f..4ece29f 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n@@ -267,20 +267,31 @@ public Exchange send(Endpoint endpoint, ExchangePattern pattern, Processor proce\n      */\n     public boolean doInAsyncProducer(final Endpoint endpoint, final Exchange exchange, final ExchangePattern pattern,\n                                      final AsyncCallback callback, final AsyncProducerCallback producerCallback) {\n-        boolean sync = true;\n \n+        Producer target;\n+        try {\n             // get the producer and we do not mind if its pooled as we can handle returning it back to the pool\n-        final Producer producer = doGetProducer(endpoint, true);\n+            target = doGetProducer(endpoint, true);\n \n-        if (producer == null) {\n+            if (target == null) {\n                 if (isStopped()) {\n                     LOG.warn(\"Ignoring exchange sent after processor is stopped: \" + exchange);\n-                return false;\n+                    callback.done(true);\n+                    return true;\n                 } else {\n-                throw new IllegalStateException(\"No producer, this processor has not been started: \" + this);\n+                    exchange.setException(new IllegalStateException(\"No producer, this processor has not been started: \" + this));\n+                    callback.done(true);\n+                    return true;\n+                }\n             }\n+        } catch (Throwable e) {\n+            exchange.setException(e);\n+            callback.done(true);\n+            return true;\n         }\n \n+        final Producer producer = target;\n+\n         // record timing for sending the exchange using the producer\n         final StopWatch watch = eventNotifierEnabled && exchange != null ? new StopWatch() : null;\n \n@@ -290,7 +301,7 @@ public boolean doInAsyncProducer(final Endpoint endpoint, final Exchange exchang\n             }\n             // invoke the callback\n             AsyncProcessor asyncProcessor = AsyncProcessorConverterHelper.convert(producer);\n-            sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, new AsyncCallback() {\n+            return producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, new AsyncCallback() {\n                 @Override\n                 public void done(boolean doneSync) {\n                     try {\n@@ -322,9 +333,9 @@ public void done(boolean doneSync) {\n             if (exchange != null) {\n                 exchange.setException(e);\n             }\n+            callback.done(true);\n+            return true;\n         }\n-\n-        return sync;\n     }\n \n     protected Exchange sendExchange(final Endpoint endpoint, ExchangePattern pattern,\n", "nb_test": 5040, "linesAdd": 19, "jira_id": "7736", "singleLine": false, "nb_skipped": 3, "commit": "7ad36e3d", "nb_failure": 1, "linesRem": 8}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ServicePoolAwareLeakyTest>TestSupport.runBare:58->testForMemoryLeak:232 Expected one transient producer as service expected:<1> but was:<1001>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\nindex 5b79954..586cc69 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n@@ -60,23 +60,31 @@\n     private boolean eventNotifierEnabled = true;\n     private boolean extendedStatistics;\n     private int maxCacheSize;\n+    private boolean stopServicePool;\n \n     public ProducerCache(Object source, CamelContext camelContext) {\n         this(source, camelContext, CamelContextHelper.getMaximumCachePoolSize(camelContext));\n     }\n \n     public ProducerCache(Object source, CamelContext camelContext, int cacheSize) {\n-        this(source, camelContext, camelContext.getProducerServicePool(), createLRUCache(cacheSize));\n+        this(source, camelContext, null, createLRUCache(cacheSize));\n     }\n \n     public ProducerCache(Object source, CamelContext camelContext, Map<String, Producer> cache) {\n-        this(source, camelContext, camelContext.getProducerServicePool(), cache);\n+        this(source, camelContext, null, cache);\n     }\n \n     public ProducerCache(Object source, CamelContext camelContext, ServicePool<Endpoint, Producer> producerServicePool, Map<String, Producer> cache) {\n         this.source = source;\n         this.camelContext = camelContext;\n+        if (producerServicePool == null) {\n+            // use shared producer pool which lifecycle is managed by CamelContext\n+            this.pool = camelContext.getProducerServicePool();\n+            this.stopServicePool = false;\n+        } else {\n             this.pool = producerServicePool;\n+            this.stopServicePool = true;\n+        }\n         this.producers = cache;\n         if (producers instanceof LRUCache) {\n             maxCacheSize = ((LRUCache) producers).getMaxCacheSize();\n@@ -468,7 +476,10 @@ protected void doStart() throws Exception {\n \n     protected void doStop() throws Exception {\n         // when stopping we intend to shutdown\n-        ServiceHelper.stopAndShutdownServices(statistics, pool);\n+        ServiceHelper.stopAndShutdownService(statistics);\n+        if (stopServicePool) {\n+            ServiceHelper.stopAndShutdownService(pool);\n+        }\n         try {\n             ServiceHelper.stopAndShutdownServices(producers.values());\n         } finally {\n", "nb_test": 5459, "linesAdd": 13, "jira_id": "9143", "singleLine": false, "nb_skipped": 4, "commit": "08077733", "nb_failure": 1, "linesRem": 3}, {"files": 2, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRecipientListParallelALot(org.apache.camel.processor.RecipientListParallelAggregateThreadPoolIssueTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex a427b25..3d4fec2 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -888,11 +888,22 @@ protected void doStart() throws Exception {\n             // keep at least one thread in the pool so we re-use the thread avoiding to create new threads because\n             // the pool shrank to zero.\n             String name = getClass().getSimpleName() + \"-AggregateTask\";\n-            aggregateExecutorService = camelContext.getExecutorServiceStrategy().newThreadPool(this, name, 1, Integer.MAX_VALUE);\n+            aggregateExecutorService = createAggregateExecutorService(name);\n         }\n         ServiceHelper.startServices(processors);\n     }\n \n+    /**\n+     * Strategy to create the thread pool for the aggregator background task which waits for and aggregates\n+     * completed tasks when running in parallel mode.\n+     *\n+     * @param name  the suggested name for the background thread\n+     * @return the thread pool\n+     */\n+    protected ExecutorService createAggregateExecutorService(String name) {\n+        return camelContext.getExecutorServiceStrategy().newThreadPool(this, name, 1, Integer.MAX_VALUE);\n+    }\n+\n     protected void doStop() throws Exception {\n         ServiceHelper.stopServices(processors);\n         errorHandlers.clear();\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/RecipientList.java b/camel-core/src/main/java/org/apache/camel/processor/RecipientList.java\nindex 8260c93..f2a163f 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RecipientList.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RecipientList.java\n@@ -55,6 +55,7 @@\n     private boolean streaming;\n     private long timeout;\n     private ExecutorService executorService;\n+    private ExecutorService aggregateExecutorService;\n     private AggregationStrategy aggregationStrategy = new UseLatestAggregationStrategy();\n \n     public RecipientList(CamelContext camelContext) {\n@@ -108,7 +109,16 @@ public boolean sendToRecipientList(Exchange exchange, Object recipientList, Asyn\n         Iterator<Object> iter = ObjectHelper.createIterator(recipientList, delimiter);\n \n         RecipientListProcessor rlp = new RecipientListProcessor(exchange.getContext(), producerCache, iter, getAggregationStrategy(),\n-                                                                isParallelProcessing(), getExecutorService(), isStreaming(), isStopOnException(), getTimeout());\n+                                                                isParallelProcessing(), getExecutorService(), isStreaming(), isStopOnException(), getTimeout()) {\n+            @Override\n+            protected ExecutorService createAggregateExecutorService(String name) {\n+                // use a shared executor service to avoid creating new thread pools\n+                if (aggregateExecutorService == null) {\n+                    aggregateExecutorService = super.createAggregateExecutorService(\"RecipientList-AggregateTask\");\n+                }\n+                return aggregateExecutorService;\n+            }\n+        };\n         rlp.setIgnoreInvalidEndpoints(isIgnoreInvalidEndpoints());\n \n         // start the service\n", "nb_test": 3235, "linesAdd": 15, "jira_id": "3727", "singleLine": false, "nb_skipped": 0, "commit": "ff2713d1", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "camel", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["testAggregateTimeout(org.apache.camel.processor.aggregator.AggregateTimeoutTest): expected:<1> but was:<0>", "testBodyOgnlReplace(org.apache.camel.language.simple.SimpleTest): Failed to invoke method: .replace(\"Kamel\", \"Camel\") on null due to: org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: replace(\"Kamel\", \"Camel\") on null due to: org.apache.camel.TypeConversionException: Error during type conversion from type: java.lang.String to the required type: char with value Kamel is a cool Kamel due java.lang.IllegalArgumentException: String must have exactly a length of 1: Kamel is a cool Kamel", "testBodyOgnlReplaceEscapedChar(org.apache.camel.language.simple.SimpleTest): Failed to invoke method: .replace('$', '-') on null due to: org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: replace('$', '-') on null due to: org.apache.camel.TypeConversionException: Error during type conversion from type: java.lang.String to the required type: char with value foo$bar$baz due java.lang.IllegalArgumentException: String must have exactly a length of 1: foo$bar$baz", "testBodyOgnlReplaceEscapedBackslashChar(org.apache.camel.language.simple.SimpleTest): Failed to invoke method: .replace('\\', '\\\\') on null due to: org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: replace('\\', '\\\\') on null due to: org.apache.camel.TypeConversionException: Error during type conversion from type: java.lang.String to the required type: char with value foo\\bar\\baz due java.lang.IllegalArgumentException: String must have exactly a length of 1: foo\\bar\\baz"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex 4a8ddef..880c400 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -52,8 +52,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.apache.camel.util.ExchangeHelper.convertToType;\n-\n /**\n  * Represents the metadata about a bean type created via a combination of\n  * introspection and annotations together with some useful sensible defaults\n@@ -572,7 +570,8 @@ private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<Me\n                     return methodInfo;\n                 }\n \n-                Object value = convertToType(exchange, methodInfo.getBodyParameterType(), body);\n+                // we should only try to convert, as we are looking for best match\n+                Object value = exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(), exchange, body);\n                 if (value != null) {\n                     if (LOG.isTraceEnabled()) {\n                         LOG.trace(\"Converted body from: {} to: {}\",\n", "nb_test": 4300, "linesAdd": 1, "jira_id": "5644", "singleLine": false, "nb_skipped": 1, "commit": "15d0fd9b", "nb_failure": 1, "linesRem": 3}, {"files": 3, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testAdvisedMockEndpoints(org.apache.camel.processor.interceptor.AdviceWithMockEndpointsHavingParameterTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/AdviceWithRouteBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/AdviceWithRouteBuilder.java\nindex cf6cf02..fb472a7 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/AdviceWithRouteBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/AdviceWithRouteBuilder.java\n@@ -68,7 +68,6 @@ public RouteDefinition getOriginalRoute() {\n      * @throws Exception can be thrown if error occurred\n      */\n     public void mockEndpoints() throws Exception {\n-        getContext().removeEndpoints(\"*\");\n         getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(null));\n     }\n \n@@ -80,7 +79,6 @@ public void mockEndpoints() throws Exception {\n      * @see org.apache.camel.util.EndpointHelper#matchEndpoint(String, String)\n      */\n     public void mockEndpoints(String pattern) throws Exception {\n-        getContext().removeEndpoints(pattern);\n         getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(pattern));\n     }\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToEndpoint.java b/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToEndpoint.java\nindex bd97de1..80c5b11 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToEndpoint.java\n@@ -114,6 +114,7 @@ public void process(Exchange exchange) throws Exception {\n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Sending to endpoint: \" + getEndpointUri() + \" is intercepted and detoured to: \" + detour + \" for exchange: \" + exchange);\n                 }\n+                LOG.info(\"Sending to endpoint: \" + getEndpointUri() + \" is intercepted and detoured to: \" + detour + \" for exchange: \" + exchange);\n                 // add header with the real endpoint uri\n                 exchange.getIn().setHeader(Exchange.INTERCEPTED_ENDPOINT, delegate.getEndpointUri());\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToMockEndpointStrategy.java b/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToMockEndpointStrategy.java\nindex e0b168c..e1d52d1 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToMockEndpointStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToMockEndpointStrategy.java\n@@ -21,6 +21,7 @@\n import org.apache.camel.component.mock.MockEndpoint;\n import org.apache.camel.spi.EndpointStrategy;\n import org.apache.camel.util.EndpointHelper;\n+import org.apache.camel.util.ObjectHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -73,6 +74,10 @@ public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\n             // create mock endpoint which we will use as interceptor\n             // replace :// from scheme to make it easy to lookup the mock endpoint without having double :// in uri\n             String key = \"mock:\" + endpoint.getEndpointKey().replaceFirst(\"://\", \":\");\n+            // strip off parameters as well\n+            if (key.contains(\"?\")) {\n+                key = ObjectHelper.before(key, \"?\");\n+            }\n             LOG.info(\"Adviced endpoint [\" + uri + \"] with mock endpoint [\" + key + \"]\");\n \n             MockEndpoint mock = endpoint.getCamelContext().getEndpoint(key, MockEndpoint.class);\n", "nb_test": 3243, "linesAdd": 5, "jira_id": "3757", "singleLine": false, "nb_skipped": 0, "commit": "c1b2f2f8", "nb_failure": 0, "linesRem": 2}, {"files": 3, "project": "camel", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>", "BacklogDebuggerTest>TestSupport.runBare:58->testBacklogDebuggerUpdateBodyAndHeaderType:205 \u00bb Reflection", "BacklogDebuggerTest>TestSupport.runBare:58->testBacklogDebuggerUpdateBodyAndHeader:128 \u00bb Reflection", "BacklogDebuggerTest>TestSupport.runBare:58->testBacklogDebuggerRemoveBodyAndHeader:284 \u00bb MBean"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedBacklogDebuggerMBean.java b/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedBacklogDebuggerMBean.java\nindex 02d2d96..036ef3d 100644\n--- a/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedBacklogDebuggerMBean.java\n+++ b/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedBacklogDebuggerMBean.java\n@@ -53,11 +53,23 @@\n     @ManagedOperation(description = \"Resume running from the suspended breakpoint at the given node id\")\n     void resumeBreakpoint(String nodeId);\n \n-    @ManagedOperation(description = \"Updates the message body on the suspended breakpoint at the given node id\")\n-    void setMessageBodyOnBreakpoint(String nodeId, String body);\n+    @ManagedOperation(description = \"Updates the message body (uses same type as old body) on the suspended breakpoint at the given node id\")\n+    void setMessageBodyOnBreakpoint(String nodeId, Object body);\n \n-    @ManagedOperation(description = \"Updates/adds the message header on the suspended breakpoint at the given node id\")\n-    void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value);\n+    @ManagedOperation(description = \"Updates the message body (with a new type) on the suspended breakpoint at the given node id\")\n+    void setMessageBodyOnBreakpoint(String nodeId, Object body, String type);\n+\n+    @ManagedOperation(description = \"Removes the message body on the suspended breakpoint at the given node id\")\n+    void removeMessageBodyOnBreakpoint(String nodeId);\n+\n+    @ManagedOperation(description = \"Updates/adds the message header (uses same type as old header value) on the suspended breakpoint at the given node id\")\n+    void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value);\n+\n+    @ManagedOperation(description = \"Removes the message header on the suspended breakpoint at the given node id\")\n+    void removeMessageHeaderOnBreakpoint(String nodeId, String headerName);\n+\n+    @ManagedOperation(description = \"Updates/adds the message header (with a new type) on the suspended breakpoint at the given node id\")\n+    void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value, String type);\n \n     @ManagedOperation(description = \"Resume running any suspended breakpoints, and exits step mode\")\n     void resumeAll();\ndiff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedBacklogDebugger.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedBacklogDebugger.java\nindex 33f1310..9f3a94c 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedBacklogDebugger.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedBacklogDebugger.java\n@@ -19,10 +19,12 @@\n import java.util.Set;\n \n import org.apache.camel.CamelContext;\n+import org.apache.camel.NoTypeConversionAvailableException;\n import org.apache.camel.api.management.ManagedResource;\n import org.apache.camel.api.management.mbean.ManagedBacklogDebuggerMBean;\n import org.apache.camel.processor.interceptor.BacklogDebugger;\n import org.apache.camel.spi.ManagementStrategy;\n+import org.apache.camel.util.ObjectHelper;\n \n @ManagedResource(description = \"Managed BacklogDebugger\")\n public class ManagedBacklogDebugger implements ManagedBacklogDebuggerMBean {\n@@ -91,12 +93,42 @@ public void resumeBreakpoint(String nodeId) {\n         backlogDebugger.resumeBreakpoint(nodeId);\n     }\n \n-    public void setMessageBodyOnBreakpoint(String nodeId, String body) {\n+    public void setMessageBodyOnBreakpoint(String nodeId, Object body) {\n         backlogDebugger.setMessageBodyOnBreakpoint(nodeId, body);\n     }\n \n-    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value) {\n+    public void setMessageBodyOnBreakpoint(String nodeId, Object body, String type) {\n+        try {\n+            Class<?> classType = camelContext.getClassResolver().resolveMandatoryClass(type);\n+            backlogDebugger.setMessageBodyOnBreakpoint(nodeId, body, classType);\n+        } catch (ClassNotFoundException e) {\n+            throw ObjectHelper.wrapRuntimeCamelException(e);\n+        }\n+    }\n+\n+    public void removeMessageBodyOnBreakpoint(String nodeId) {\n+        backlogDebugger.removeMessageBodyOnBreakpoint(nodeId);\n+    }\n+\n+    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value) {\n+        try {\n             backlogDebugger.setMessageHeaderOnBreakpoint(nodeId, headerName, value);\n+        } catch (NoTypeConversionAvailableException e) {\n+            throw ObjectHelper.wrapRuntimeCamelException(e);\n+        }\n+    }\n+\n+    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value, String type) {\n+        try {\n+            Class<?> classType = camelContext.getClassResolver().resolveMandatoryClass(type);\n+            backlogDebugger.setMessageHeaderOnBreakpoint(nodeId, headerName, value, classType);\n+        } catch (Exception e) {\n+            throw ObjectHelper.wrapRuntimeCamelException(e);\n+        }\n+    }\n+\n+    public void removeMessageHeaderOnBreakpoint(String nodeId, String headerName) {\n+        backlogDebugger.removeMessageHeaderOnBreakpoint(nodeId, headerName);\n     }\n \n     public void resumeAll() {\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/interceptor/BacklogDebugger.java b/camel-core/src/main/java/org/apache/camel/processor/interceptor/BacklogDebugger.java\nindex 3c2e290..571b174 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/interceptor/BacklogDebugger.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/interceptor/BacklogDebugger.java\n@@ -31,6 +31,7 @@\n import org.apache.camel.CamelContext;\n import org.apache.camel.Exchange;\n import org.apache.camel.LoggingLevel;\n+import org.apache.camel.NoTypeConversionAvailableException;\n import org.apache.camel.Predicate;\n import org.apache.camel.Processor;\n import org.apache.camel.api.management.mbean.BacklogTracerEventMessage;\n@@ -268,29 +269,108 @@ private void resumeBreakpoint(String nodeId, boolean stepMode) {\n         }\n     }\n \n-    public void setMessageBodyOnBreakpoint(String nodeId, String body) {\n+    public void setMessageBodyOnBreakpoint(String nodeId, Object body) {\n         SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n         if (se != null) {\n+            boolean remove = body == null;\n+            if (remove) {\n+                removeMessageBodyOnBreakpoint(nodeId);\n+            } else {\n+                Class oldType;\n+                if (se.getExchange().hasOut()) {\n+                    oldType = se.getExchange().getOut().getBody() != null ? se.getExchange().getOut().getBody().getClass() : null;\n+                } else {\n+                    oldType = se.getExchange().getIn().getBody() != null ? se.getExchange().getIn().getBody().getClass() : null;\n+                }\n+                setMessageBodyOnBreakpoint(nodeId, body, oldType);\n+            }\n+        }\n+    }\n+\n+    public void setMessageBodyOnBreakpoint(String nodeId, Object body, Class type) {\n+        SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n+        if (se != null) {\n+            boolean remove = body == null;\n+            if (remove) {\n+                removeMessageBodyOnBreakpoint(nodeId);\n+            } else {\n                 logger.log(\"Breakpoint at node \" + nodeId + \" is updating message body on exchangeId: \" + se.getExchange().getExchangeId() + \" with new body: \" + body);\n                 if (se.getExchange().hasOut()) {\n+                    // preserve type\n+                    if (type != null) {\n+                        se.getExchange().getOut().setBody(body, type);\n+                    } else {\n                         se.getExchange().getOut().setBody(body);\n+                    }\n+                } else {\n+                    if (type != null) {\n+                        se.getExchange().getIn().setBody(body, type);\n                     } else {\n                         se.getExchange().getIn().setBody(body);\n                     }\n                 }\n             }\n+        }\n+    }\n+\n+    public void removeMessageBodyOnBreakpoint(String nodeId) {\n+        SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n+        if (se != null) {\n+            logger.log(\"Breakpoint at node \" + nodeId + \" is removing message body on exchangeId: \" + se.getExchange().getExchangeId());\n+            if (se.getExchange().hasOut()) {\n+                se.getExchange().getOut().setBody(null);\n+            } else {\n+                se.getExchange().getIn().setBody(null);\n+            }\n+        }\n+    }\n \n-    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value) {\n+    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value) throws NoTypeConversionAvailableException {\n+        SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n+        if (se != null) {\n+            Class oldType;\n+            if (se.getExchange().hasOut()) {\n+                oldType = se.getExchange().getOut().getHeader(headerName) != null ? se.getExchange().getOut().getHeader(headerName).getClass() : null;\n+            } else {\n+                oldType = se.getExchange().getIn().getHeader(headerName) != null ? se.getExchange().getIn().getHeader(headerName).getClass() : null;\n+            }\n+            setMessageHeaderOnBreakpoint(nodeId, headerName, value, oldType);\n+        }\n+    }\n+\n+    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value, Class type) throws NoTypeConversionAvailableException {\n         SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n         if (se != null) {\n             logger.log(\"Breakpoint at node \" + nodeId + \" is updating message header on exchangeId: \" + se.getExchange().getExchangeId() + \" with header: \" + headerName + \" and value: \" + value);\n             if (se.getExchange().hasOut()) {\n+                if (type != null) {\n+                    Object convertedValue = se.getExchange().getContext().getTypeConverter().mandatoryConvertTo(type, se.getExchange(), value);\n+                    se.getExchange().getOut().setHeader(headerName, convertedValue);\n+                } else {\n                     se.getExchange().getOut().setHeader(headerName, value);\n+                }\n+            } else {\n+                if (type != null) {\n+                    Object convertedValue = se.getExchange().getContext().getTypeConverter().mandatoryConvertTo(type, se.getExchange(), value);\n+                    se.getExchange().getIn().setHeader(headerName, convertedValue);\n                 } else {\n                     se.getExchange().getIn().setHeader(headerName, value);\n                 }\n             }\n         }\n+    }\n+\n+    public void removeMessageHeaderOnBreakpoint(String nodeId, String headerName) {\n+        SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n+        if (se != null) {\n+            logger.log(\"Breakpoint at node \" + nodeId + \" is removing message header on exchangeId: \" + se.getExchange().getExchangeId() + \" with header: \" + headerName);\n+            if (se.getExchange().hasOut()) {\n+                se.getExchange().getOut().removeHeader(headerName);\n+            } else {\n+                se.getExchange().getIn().removeHeader(headerName);\n+            }\n+        }\n+    }\n \n     public void resumeAll() {\n         logger.log(\"Resume all\");\n", "nb_test": 4790, "linesAdd": 131, "jira_id": "7163", "singleLine": false, "nb_skipped": 3, "commit": "5f726d0b", "nb_failure": 1, "linesRem": 8}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ManagedInflightStatisticsTest>TestSupport.runBare:58->testManageStatisticsFailed:144 Expected: <null> but was: 1000"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\nindex d31e4e5..c4b6d85 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\n@@ -417,8 +417,8 @@ public String getOldestInflightExchangeId() {\n \n     @Override\n     public void init(ManagementStrategy strategy) {\n-        super.init(strategy);\n         exchangesInFlightStartTimestamps.clear();\n+        super.init(strategy);\n     }\n \n     @Override\n@@ -438,14 +438,23 @@ public synchronized void completedExchange(Exchange exchange, long time) {\n         super.completedExchange(exchange, time);\n     }\n \n+    @Override\n+    public synchronized void failedExchange(Exchange exchange) {\n+        InFlightKey key = exchangesInFlightKeys.remove(exchange.getExchangeId());\n+        if (key != null) {\n+            exchangesInFlightStartTimestamps.remove(key);\n+        }\n+        super.failedExchange(exchange);\n+    }\n+\n     private static class InFlightKey implements Comparable<InFlightKey> {\n \n         private final Long timeStamp;\n         private final String exchangeId;\n \n         InFlightKey(Long timeStamp, String exchangeId) {\n-            this.exchangeId = exchangeId;\n             this.timeStamp = timeStamp;\n+            this.exchangeId = exchangeId;\n         }\n \n         @Override\n", "nb_test": 5297, "linesAdd": 11, "jira_id": "8626", "singleLine": false, "nb_skipped": 4, "commit": "d063f471", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["org.apache.camel.processor.TrySetFaultFinallyTest.testSetFaultFinally(org.apache.camel.processor.TrySetFaultFinallyTest)", "Run 1: TrySetFaultFinallyTest>TestSupport.runBare:58->testSetFaultFinally:32->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://c Received message count. Expected: <1> but was: <0>", "Run 2: TrySetFaultFinallyTest>TestSupport.runBare:58->testSetFaultFinally:32->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://c Received message count. Expected: <1> but was: <0>", "Run 3: TrySetFaultFinallyTest>TestSupport.runBare:58->testSetFaultFinally:32->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://c Received message count. Expected: <1> but was: <0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/FinallyProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/FinallyProcessor.java\nindex b04e172..4fe21a6 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/FinallyProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/FinallyProcessor.java\n@@ -41,26 +41,80 @@ public FinallyProcessor(Processor processor) {\n \n     @Override\n     public boolean process(final Exchange exchange, final AsyncCallback callback) {\n-        // clear exception so finally block can be executed\n-        final Exception e = exchange.getException();\n+        // clear exception and fault so finally block can be executed\n+        final boolean fault;\n+        if (exchange.hasOut()) {\n+            fault = exchange.getOut().isFault();\n+            exchange.getOut().setFault(false);\n+        } else {\n+            fault = exchange.getIn().isFault();\n+            exchange.getIn().setFault(false);\n+        }\n+\n+        final Exception exception = exchange.getException();\n         exchange.setException(null);\n         // but store the caught exception as a property\n-        if (e != null) {\n-            exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\n+        if (exception != null) {\n+            exchange.setProperty(Exchange.EXCEPTION_CAUGHT, exception);\n         }\n+\n         // store the last to endpoint as the failure endpoint\n         if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {\n             exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n         }\n \n-        boolean sync = processor.process(exchange, new AsyncCallback() {\n+        // continue processing\n+        return processor.process(exchange, new FinallyAsyncCallback(exchange, callback, exception, fault));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Finally{\" + getProcessor() + \"}\";\n+    }\n+\n+    public String getTraceLabel() {\n+        return \"finally\";\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    private static final class FinallyAsyncCallback implements AsyncCallback {\n+\n+        private final Exchange exchange;\n+        private final AsyncCallback callback;\n+        private final Exception exception;\n+        private final boolean fault;\n+\n+        public FinallyAsyncCallback(Exchange exchange, AsyncCallback callback, Exception exception, boolean fault) {\n+            this.exchange = exchange;\n+            this.callback = callback;\n+            this.exception = exception;\n+            this.fault = fault;\n+        }\n+\n+        @Override\n         public void done(boolean doneSync) {\n-                if (e == null) {\n+            try {\n+                if (exception == null) {\n                     exchange.removeProperty(Exchange.FAILURE_ENDPOINT);\n                 } else {\n                     // set exception back on exchange\n-                    exchange.setException(e);\n-                    exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\n+                    exchange.setException(exception);\n+                    exchange.setProperty(Exchange.EXCEPTION_CAUGHT, exception);\n+                }\n+                // set fault flag back\n+                if (fault) {\n+                    if (exchange.hasOut()) {\n+                        exchange.getOut().setFault(true);\n+                    } else {\n+                        exchange.getIn().setFault(true);\n+                    }\n                 }\n \n                 if (!doneSync) {\n@@ -68,26 +122,16 @@ public void done(boolean doneSync) {\n                     ExchangeHelper.prepareOutToIn(exchange);\n                     LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n                 }\n+            } finally {\n+                // callback must always be called\n                 callback.done(doneSync);\n             }\n-        });\n-        return sync;\n         }\n \n         @Override\n         public String toString() {\n-        return \"Finally{\" + getProcessor() + \"}\";\n+            return \"FinallyAsyncCallback\";\n         }\n-\n-    public String getTraceLabel() {\n-        return \"finally\";\n-    }\n-\n-    public String getId() {\n-        return id;\n     }\n \n-    public void setId(String id) {\n-        this.id = id;\n-    }\n }\n", "nb_test": 5551, "linesAdd": 61, "jira_id": "9673", "singleLine": false, "nb_skipped": 4, "commit": "7944093f", "nb_failure": 1, "linesRem": 20}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["SimpleTest>TestSupport.runBare:58->testBodyOgnlSpaces:1249->LanguageTestSupport.assertExpression:69->LanguageTestSupport.assertExpression:62->ContextTestSupport.assertExpression:314->TestSupport.assertExpression:234 \u00bb RuntimeBeanExpression"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex 1c19945..fb9c533 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -311,8 +311,12 @@ private void introspect(Class<?> clazz) {\n             methods.addAll(extraMethods);\n         }\n \n-        // it may have duplicate methods already, even from declared or from interfaces + declared\n         Set<Method> overrides = new HashSet<Method>();\n+\n+        // do not remove duplicates form class from the Java itself as they have some \"duplicates\" we need\n+        boolean javaClass = clazz.getName().startsWith(\"java.\") || clazz.getName().startsWith(\"javax.\");\n+        if (!javaClass) {\n+            // it may have duplicate methods already, even from declared or from interfaces + declared\n             for (Method source : methods) {\n                 for (Method target : methods) {\n                     // skip ourselves\n@@ -327,6 +331,7 @@ private void introspect(Class<?> clazz) {\n             }\n             methods.removeAll(overrides);\n             overrides.clear();\n+        }\n \n         // if we are a public class, then add non duplicate interface classes also\n         if (Modifier.isPublic(clazz.getModifiers())) {\n", "nb_test": 5166, "linesAdd": 4, "jira_id": "8137", "singleLine": false, "nb_skipped": 4, "commit": "53b4e90c", "nb_failure": 0, "linesRem": 0}, {"files": 2, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ManagedCamelContextNewProxyTest>TestSupport.runBare:58->testNewProxy:37 \u00bb IllegalArgument"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedCamelContextMBean.java b/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedCamelContextMBean.java\nindex 700ae22..9a58c0d 100644\n--- a/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedCamelContextMBean.java\n+++ b/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedCamelContextMBean.java\n@@ -80,9 +80,6 @@\n     @ManagedAttribute(description = \"Tracing\")\n     void setTracing(Boolean tracing);\n \n-    @ManagedAttribute(description = \"Message History\")\n-    Boolean getMessageHistory();\n-\n     @ManagedAttribute(description = \"Current number of inflight Exchanges\")\n     Integer getInflightExchanges();\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedCamelContext.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedCamelContext.java\nindex a641b68..19a58c0 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedCamelContext.java\n@@ -127,10 +127,6 @@ public void setTracing(Boolean tracing) {\n         context.setTracing(tracing);\n     }\n \n-    public Boolean getMessageHistory() {\n-        return context.isMessageHistory();\n-    }\n-\n     public Integer getInflightExchanges() {\n         return context.getInflightRepository().size();\n     }\n@@ -212,7 +208,7 @@ public boolean isAllowUseOriginalMessage() {\n     }\n \n     public boolean isMessageHistory() {\n-        return context.isMessageHistory();\n+        return context.isMessageHistory() != null ? context.isMessageHistory() : false;\n     }\n \n     public boolean isUseMDCLogging() {\n", "nb_test": 5015, "linesAdd": 1, "jira_id": "7586", "singleLine": false, "nb_skipped": 3, "commit": "1f92fa42", "nb_failure": 0, "linesRem": 8}, {"files": 2, "project": "camel", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["FileProducerFileExistIgnoreTest>TestSupport.runBare:58->testIgnore:43->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Body of message: 0. Expected: <Hello World> but was: <null>", "VmMultipleConsumersMultipleContextTest>TestSupport.runBare:58->testVmMultipleConsumersDifferentEndpoints:145 mock://route1 Received message count. Expected: <100> but was: <31>", "ManagedThrottlerTest>TestSupport.runBare:58->testThrottleVisableViaJmx:145 expected:<10> but was:<9>", "AggregateCompletionOnlyOneTest>TestSupport.runBare:58->testOnlyOne:50 expected:<0> but was:<4>", "VmMultipleContextsStartStopTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb IllegalArgument", "VmQueueTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb FailedToCreateRoute", "VmShouldNotUseSameThreadTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:39->ContextTestSupport.setUp:117->ContextTestSupport.startCamelContext:174 \u00bb IllegalArgument"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\nindex 8fe24c5..e7a094f 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n@@ -481,8 +481,12 @@ protected Exchange onCompletion(final String key, final Exchange original, final\n         }\n         aggregated.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);\n \n+        // only remove if we have previous added (as we could potentially complete with only 1 exchange)\n+        // (if we have previous added then we have that as the original exchange)\n+        if (original != null) {\n             // remove from repository as its completed, we do this first as to trigger any OptimisticLockingException's\n             aggregationRepository.remove(aggregated.getContext(), key, original);\n+        }\n \n         if (!fromTimeout && timeoutMap != null) {\n             // cleanup timeout map if it was a incoming exchange which triggered the timeout (and not the timeout checker)\ndiff --git a/camel-core/src/main/java/org/apache/camel/spi/AggregationRepository.java b/camel-core/src/main/java/org/apache/camel/spi/AggregationRepository.java\nindex 669a956..ba1de6a 100644\n--- a/camel-core/src/main/java/org/apache/camel/spi/AggregationRepository.java\n+++ b/camel-core/src/main/java/org/apache/camel/spi/AggregationRepository.java\n@@ -32,6 +32,9 @@\n      * Add the given {@link Exchange} under the correlation key.\n      * <p/>\n      * Will replace any existing exchange.\n+     * <p/>\n+     * <b>Important:</b> This method is <b>not</b> invoked if only one exchange was completed, and therefore\n+     * the exchange does not need to be added to a repository, as its completed immediately.\n      *\n      * @param camelContext   the current CamelContext\n      * @param key            the correlation key\n@@ -42,6 +45,8 @@\n \n     /**\n      * Gets the given exchange with the correlation key\n+     * <p/>\n+     * This method is always invoked for any incoming exchange in the aggregator.\n      *\n      * @param camelContext   the current CamelContext\n      * @param key            the correlation key\n@@ -52,6 +57,9 @@\n     /**\n      * Removes the exchange with the given correlation key, which should happen\n      * when an {@link Exchange} is completed\n+     * <p/>\n+     * <b>Important:</b> This method is <b>not</b> invoked if only one exchange was completed, and therefore\n+     * the exchange does not need to be added to a repository, as its completed immediately.\n      *\n      * @param camelContext   the current CamelContext\n      * @param key            the correlation key\n@@ -61,6 +69,8 @@\n \n     /**\n      * Confirms the completion of the {@link Exchange}.\n+     * <p/>\n+     * This method is always invoked.\n      *\n      * @param camelContext  the current CamelContext\n      * @param exchangeId    exchange id to confirm\n", "nb_test": 4794, "linesAdd": 2, "jira_id": "7146", "singleLine": false, "nb_skipped": 3, "commit": "b6981cfd", "nb_failure": 4, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testDoneByIndex(org.apache.camel.builder.NotifyBuilderWhenDoneByIndexTest): expected:<true> but was:<false>", "testThreadNotUsedForEveryAggregatorWithCustomExecutorService(org.apache.camel.processor.aggregator.AggregateTimeoutWithExecutorServiceTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\nindex 547efab..d5a346c 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\n@@ -444,7 +444,7 @@ public boolean onExchangeCreated(Exchange exchange) {\n             @Override\n             public boolean onExchangeCompleted(Exchange exchange) {\n                 if (exchange.getExchangeId().equals(id)) {\n-                    done.set(false);\n+                    done.set(true);\n                 }\n                 return true;\n             }\n", "nb_test": 4322, "linesAdd": 1, "jira_id": "5707", "singleLine": false, "nb_skipped": 1, "commit": "3f70d612", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 3, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ErrorHandlerBuilderRefTest>TestSupport.runBare:58->testErrorHandlerBuilderRef:55->checkObjectSize:62 Get a wrong size of ErrorHandler expected:<1> but was:<2>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderRef.java b/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderRef.java\nindex 0cf9d57..4d06b7f 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderRef.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderRef.java\n@@ -51,6 +51,18 @@ public void addErrorHandlers(RouteContext routeContext, OnExceptionDefinition ex\n         super.addErrorHandlers(routeContext, exception);\n     }\n     \n+    @Override\n+    public boolean removeOnExceptionList(String id) {\n+        for (RouteContext routeContext : handlers.keySet()) {\n+            if (getRouteId(routeContext).equals(id)) {\n+                handlers.remove(routeContext);\n+                break;\n+            }\n+        }\n+        return super.removeOnExceptionList(id);\n+    }\n+    \n+\n     public Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception {\n         ErrorHandlerBuilder handler = handlers.get(routeContext);\n         if (handler == null) {\ndiff --git a/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderSupport.java b/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderSupport.java\nindex 747a6dd..365ebc0 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderSupport.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderSupport.java\n@@ -21,6 +21,7 @@\n import java.util.List;\n import java.util.Map;\n \n+import org.apache.camel.CamelContext;\n import org.apache.camel.model.OnExceptionDefinition;\n import org.apache.camel.processor.ErrorHandler;\n import org.apache.camel.processor.ErrorHandlerSupport;\n@@ -94,4 +95,28 @@ public void setExceptionPolicyStrategy(ExceptionPolicyStrategy exceptionPolicySt\n         ObjectHelper.notNull(exceptionPolicyStrategy, \"ExceptionPolicyStrategy\");\n         this.exceptionPolicyStrategy = exceptionPolicyStrategy;\n     }\n+    \n+    /**\n+     * Remove the OnExceptionList by look up the route id from the ErrorHandlerBuilder internal map\n+     * @param id the route id\n+     * @return true if the route context is found and removed\n+     */\n+    public boolean removeOnExceptionList(String id) {\n+        for (RouteContext routeContext : onExceptions.keySet()) {\n+            if (getRouteId(routeContext).equals(id)) {\n+                onExceptions.remove(routeContext);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    protected String getRouteId(RouteContext routeContext) {\n+        CamelContext context = routeContext.getCamelContext();\n+        if (context != null) {\n+            return routeContext.getRoute().idOrCreate(context.getNodeIdFactory());\n+        } else {\n+            return routeContext.getRoute().getId();\n+        }\n+    }\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex deba649..bd4488c 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -71,6 +71,7 @@\n import org.apache.camel.TypeConverter;\n import org.apache.camel.VetoCamelContextStartException;\n import org.apache.camel.builder.ErrorHandlerBuilder;\n+import org.apache.camel.builder.ErrorHandlerBuilderSupport;\n import org.apache.camel.component.properties.PropertiesComponent;\n import org.apache.camel.impl.converter.BaseTypeConverterRegistry;\n import org.apache.camel.impl.converter.DefaultTypeConverter;\n@@ -928,6 +928,11 @@ public synchronized void shutdownRoute(String routeId, long timeout, TimeUnit ti\n     }\n \n     public synchronized boolean removeRoute(String routeId) throws Exception {\n+        // remove the route from ErrorHandlerBuilder if possible\n+        if (getErrorHandlerBuilder() instanceof ErrorHandlerBuilderSupport) {\n+            ErrorHandlerBuilderSupport builder = (ErrorHandlerBuilderSupport)getErrorHandlerBuilder();\n+            builder.removeOnExceptionList(routeId);\n+        }\n         RouteService routeService = routeServices.get(routeId);\n         if (routeService != null) {\n             if (getRouteStatus(routeId).isStopped()) {\n", "nb_test": 5131, "linesAdd": 37, "jira_id": "8053", "singleLine": false, "nb_skipped": 3, "commit": "cac72b14", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testAsyncCallbackThreadsInOutProcessor(org.apache.camel.impl.DefaultProducerTemplateAsyncTest)", "testManagedThreadPool(org.apache.camel.management.ManagedThreadPoolTest): mock://result Received message count. Expected: <1> but was: <2>", "testManagedThreadPool(org.apache.camel.management.ManagedThreadPoolWithIdTest): mock://result Received message count. Expected: <1> but was: <2>", "testThreadsCoreAndMaxPoolKeepAliveTime(org.apache.camel.processor.ThreadsCoreAndMaxPoolKeepAliveTimeTest): mock://result Received message count. Expected: <1> but was: <2>", "testThreadsCoreAndMaxPool(org.apache.camel.processor.ThreadsCoreAndMaxPoolTest): mock://result Received message count. Expected: <1> but was: <2>", "testThreadsCorePool(org.apache.camel.processor.ThreadsCorePoolTest): mock://result Received message count. Expected: <1> but was: <2>", "testThreadsMaxQueueSize(org.apache.camel.processor.ThreadsMaxQueueSizeTest): mock://result Received message count. Expected: <1> but was: <2>", "testThreadsRejectedPolicy(org.apache.camel.processor.ThreadsRejectedPolicyTest): mock://result Received message count. Expected: <1> but was: <2>", "testThreadsInOut(org.apache.camel.processor.ThreadsRequestReplyTest): mock://result Received message count. Expected: <1> but was: <2>", "testThreads(org.apache.camel.builder.RouteBuilderTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\nindex 28b7eb9..3ba39cb 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n@@ -1130,7 +1130,7 @@ public ThreadsDefinition threads() {\n      * @return the builder\n      */\n     public ThreadsDefinition threads(int poolSize) {\n-        ThreadsDefinition answer = threads();\n+        ThreadsDefinition answer = new ThreadsDefinition();\n         answer.setPoolSize(poolSize);\n         addOutput(answer);\n         return answer;\n@@ -1144,7 +1144,7 @@ public ThreadsDefinition threads(int poolSize) {\n      * @return the builder\n      */\n     public ThreadsDefinition threads(int poolSize, int maxPoolSize) {\n-        ThreadsDefinition answer = threads();\n+        ThreadsDefinition answer = new ThreadsDefinition();\n         answer.setPoolSize(poolSize);\n         answer.setMaxPoolSize(maxPoolSize);\n         addOutput(answer);\n@@ -1160,7 +1160,7 @@ public ThreadsDefinition threads(int poolSize, int maxPoolSize) {\n      * @return the builder\n      */\n     public ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {\n-        ThreadsDefinition answer = threads();\n+        ThreadsDefinition answer = new ThreadsDefinition();\n         answer.setPoolSize(poolSize);\n         answer.setMaxPoolSize(maxPoolSize);\n         answer.setThreadName(threadName);\n", "nb_test": 4269, "linesAdd": 3, "jira_id": "5515", "singleLine": false, "nb_skipped": 1, "commit": "b3bb8670", "nb_failure": 9, "linesRem": 3}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testInterceptLog(org.apache.camel.processor.intercept.InterceptFromEndpointNotUriTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/FromDefinition.java b/camel-core/src/main/java/org/apache/camel/model/FromDefinition.java\nindex 63e4710..7fb6666 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/FromDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/FromDefinition.java\n@@ -77,8 +77,15 @@ public Endpoint resolveEndpoint(RouteContext context) {\n \n     // Properties\n     // -----------------------------------------------------------------------\n+\n     public String getUri() {\n+        if (uri != null) {\n             return uri;\n+        } else if (endpoint != null) {\n+            return endpoint.getEndpointUri();\n+        } else {\n+            return null;\n+        }\n     }\n \n     /**\n", "nb_test": 3226, "linesAdd": 7, "jira_id": "3709", "singleLine": false, "nb_skipped": 0, "commit": "4c37e773", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEvaluateAsPredicate(org.apache.camel.converter.ObjectHelperTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java b/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java\nindex 6bb393d..636c4a8 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java\n@@ -38,6 +38,7 @@\n import java.util.Properties;\n import java.util.Scanner;\n \n+import org.w3c.dom.Document;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n \n@@ -1118,6 +1119,14 @@ public static boolean evaluateValuePredicate(Object value) {\n             } else if (\"false\".equalsIgnoreCase((String)value)) {\n                 return false;\n             }\n+        } else if (value instanceof NodeList) {\n+            // is it an empty dom\n+            NodeList list = (NodeList) value;\n+            return list.getLength() > 0;\n+        } else if (value instanceof Collection) {\n+            // is it an empty collection\n+            Collection col = (Collection) value;\n+            return col.size() > 0;\n         }\n         return value != null;\n     }\n", "nb_test": 3323, "linesAdd": 7, "jira_id": "3531", "singleLine": false, "nb_skipped": 0, "commit": "41e4b5b9", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["CustomListAggregationStrategyEmptySplitTest>TestSupport.runBare:58->testCustomAggregationStrategy:44 \u00bb CamelExecution"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\nindex ad2ec8e..d4ff93f 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\n@@ -62,7 +62,7 @@ public boolean isStoreAsBodyOnCompletion() {\n \n     @SuppressWarnings(\"unchecked\")\n     public void onCompletion(Exchange exchange) {\n-        if (isStoreAsBodyOnCompletion()) {\n+        if (exchange != null && isStoreAsBodyOnCompletion()) {\n             List<V> list = (List<V>) exchange.removeProperty(Exchange.GROUPED_EXCHANGE);\n             if (list != null) {\n                 exchange.getIn().setBody(list);\n", "nb_test": 5294, "linesAdd": 1, "jira_id": "8592", "singleLine": false, "nb_skipped": 4, "commit": "57f72cd9", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["OnCompletionIssueTest>TestSupport.runBare:58->testOnCompletionIssue:39->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://complete Body of message: 1. Expected: <stop> but was: <except>", "ThrottlerNullEvalTest>TestSupport.runBare:58->testNoHeaderTest:66->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Received message count. Expected: <3> but was: <2>", "ThrottlerNullEvalTest>TestSupport.runBare:58->testNullEvalTest:56->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Received message count. Expected: <3> but was: <2>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/Throttler.java b/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\nindex f70325d..c986bf7 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\n@@ -108,7 +108,7 @@ public void setTimePeriodMillis(long timePeriodMillis) {\n     protected long calculateDelay(Exchange exchange) {\n         // evaluate as Object first to see if we get any result at all\n         Object result = maxRequestsPerPeriodExpression.evaluate(exchange, Object.class);\n-        if (result == null) {\n+        if (maximumRequestsPerPeriod == 0 && result == null) {\n             throw new RuntimeExchangeException(\"The max requests per period expression was evaluated as null: \" + maxRequestsPerPeriodExpression, exchange);\n         }\n \n", "nb_test": 5054, "linesAdd": 1, "jira_id": "7448", "singleLine": false, "nb_skipped": 3, "commit": "35bde2b2", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOnExceptionAfterRoute(org.apache.camel.processor.onexception.OnExceptionAfterRouteTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java\nindex 1300f7d..a5cd8d1 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java\n@@ -136,6 +136,9 @@ public RouteDefinition from(Endpoint... endpoints) {\n      * @return the current builder with the error handler configured\n      */\n     public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"errorHandler must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         setErrorHandlerBuilder(errorHandlerBuilder);\n         return this;\n@@ -147,6 +150,9 @@ public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {\n      * @return the builder\n      */\n     public InterceptDefinition intercept() {\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"intercept must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.intercept();\n     }\n@@ -157,6 +163,9 @@ public InterceptDefinition intercept() {\n      * @return the builder\n      */\n     public InterceptFromDefinition interceptFrom() {\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"interceptFrom must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.interceptFrom();\n     }\n@@ -168,6 +177,9 @@ public InterceptFromDefinition interceptFrom() {\n      * @return the builder\n      */\n     public InterceptFromDefinition interceptFrom(String uri) {\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"interceptFrom must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.interceptFrom(uri);\n     }\n@@ -179,6 +191,9 @@ public InterceptFromDefinition interceptFrom(String uri) {\n      * @return the builder\n      */\n     public InterceptSendToEndpointDefinition interceptSendToEndpoint(String uri) {\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"interceptSendToEndpoint must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.interceptSendToEndpoint(uri);\n     }\n@@ -191,6 +206,10 @@ public InterceptSendToEndpointDefinition interceptSendToEndpoint(String uri) {\n      * @return the builder\n      */\n     public OnExceptionDefinition onException(Class exception) {\n+        // is only allowed at the top currently\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"onException must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.onException(exception);\n     }\n@@ -217,6 +236,10 @@ public OnExceptionDefinition onException(Class... exceptions) {\n      * @return the builder\n      */\n     public OnCompletionDefinition onCompletion() {\n+        // is only allowed at the top currently\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"onCompletion must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.onCompletion();\n     }\n", "nb_test": 2913, "linesAdd": 21, "jira_id": "3281", "singleLine": false, "nb_skipped": 0, "commit": "f7dd2fff", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["org.apache.camel.component.seda.SedaDiscardIfNoConsumerTest.testDiscardUoW(org.apache.camel.component.seda.SedaDiscardIfNoConsumerTest)", "Run 1: SedaDiscardIfNoConsumerTest>TestSupport.runBare:58->testDiscardUoW:63 expected:<true> but was:<false>", "Run 2: SedaDiscardIfNoConsumerTest>TestSupport.runBare:58->testDiscardUoW:63 expected:<true> but was:<false>", "Run 3: SedaDiscardIfNoConsumerTest>TestSupport.runBare:58->testDiscardUoW:63 expected:<true> but was:<false>", "Flaked tests:", "org.apache.camel.management.ManagedThrottlerTest.testThrottleAsyncVisableViaJmx(org.apache.camel.management.ManagedThrottlerTest)", "Run 1: ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:180 expected:<10> but was:<9>", "Run 2: PASS"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\nindex a87ddf3..1e28eaa 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n@@ -122,7 +122,8 @@ public String toString() {\n \n             log.trace(\"Adding Exchange to queue: {}\", copy);\n             try {\n-                addToQueue(copy);\n+                // do not copy as we already did the copy\n+                addToQueue(copy, false);\n             } catch (SedaConsumerNotAvailableException e) {\n                 exchange.setException(e);\n                 callback.done(true);\n@@ -160,11 +161,8 @@ public String toString() {\n             }\n         } else {\n             // no wait, eg its a InOnly then just add to queue and return\n-            // handover the completion so its the copy which performs that, as we do not wait\n-            Exchange copy = prepareCopy(exchange, true);\n-            log.trace(\"Adding Exchange to queue: {}\", copy);\n             try {\n-                addToQueue(copy);\n+                addToQueue(exchange, true);\n             } catch (SedaConsumerNotAvailableException e) {\n                 exchange.setException(e);\n                 callback.done(true);\n@@ -205,8 +203,9 @@ protected void doStop() throws Exception {\n      * simply add which will throw exception if the queue is full\n      * \n      * @param exchange the exchange to add to the queue\n+     * @param copy     whether to create a copy of the exchange to use for adding to the queue\n      */\n-    protected void addToQueue(Exchange exchange) throws SedaConsumerNotAvailableException {\n+    protected void addToQueue(Exchange exchange, boolean copy) throws SedaConsumerNotAvailableException {\n         BlockingQueue<Exchange> queue = null;\n         QueueReference queueReference = endpoint.getQueueReference();\n         if (queueReference != null) {\n@@ -226,15 +225,23 @@ protected void addToQueue(Exchange exchange) throws SedaConsumerNotAvailableExce\n             }\n         }\n \n+        Exchange target = exchange;\n+\n+        // handover the completion so its the copy which performs that, as we do not wait\n+        if (copy) {\n+            target = prepareCopy(exchange, true);\n+        }\n+\n+        log.trace(\"Adding Exchange to queue: {}\", target);\n         if (blockWhenFull) {\n             try {\n-                queue.put(exchange);\n+                queue.put(target);\n             } catch (InterruptedException e) {\n                 // ignore\n                 log.debug(\"Put interrupted, are we stopping? {}\", isStopping() || isStopped());\n             }\n         } else {\n-            queue.add(exchange);\n+            queue.add(target);\n         }\n     }\n \n", "nb_test": 5570, "linesAdd": 12, "jira_id": "9700", "singleLine": false, "nb_skipped": 4, "commit": "4d03e9de", "nb_failure": 1, "linesRem": 7}, {"files": 1, "project": "camel", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["WireTapTest>TestSupport.runBare:58->setUp:54->ContextTestSupport.setUp:115 \u00bb IndexOutOfBounds", "WireTapTest>TestSupport.runBare:58->setUp:54->ContextTestSupport.setUp:115 \u00bb IndexOutOfBounds"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\nindex ff16150..9b93a1a 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n@@ -1027,7 +1028,12 @@ public Type id(String id) {\n                     }\n                 }\n             }\n+            if (!getOutputs().isEmpty()) {\n                 outputs.get(outputs.size() - 1).setId(id);\n+            } else {\n+                // the output could be empty\n+                setId(id);\n+            }\n         }\n \n         return (Type) this;\n", "nb_test": 4621, "linesAdd": 4, "jira_id": "6610", "singleLine": false, "nb_skipped": 1, "commit": "ed7e7c9f", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>", "KeyValueHolderTest.testEqualsAndHashCodeOnUnequalObjectsWithSameKeys:53 Should not be equals"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/KeyValueHolder.java b/camel-core/src/main/java/org/apache/camel/util/KeyValueHolder.java\nindex 3cf5bf9..a9baf00 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/KeyValueHolder.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/KeyValueHolder.java\n@@ -53,6 +53,8 @@ public boolean equals(Object o) {\n \n         if (key != null ? !key.equals(that.key) : that.key != null) {\n             return false;\n+        } else if (value != null ? !value.equals(that.value) : that.value != null) {\n+            return false;\n         }\n \n         return true;\n", "nb_test": 5014, "linesAdd": 2, "jira_id": "7611", "singleLine": false, "nb_skipped": 3, "commit": "e30f1c53", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testEmptyHeaderValueIn(org.apache.camel.builder.PredicateBuilderTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\nindex 5f73fe3..db029ec 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\n@@ -935,12 +935,16 @@ public String toString() {\n     public static Expression convertToExpression(final Expression expression, final Class type) {\n         return new ExpressionAdapter() {\n             public Object evaluate(Exchange exchange) {\n+                if (type != null) {\n                     return expression.evaluate(exchange, type);\n+                } else {\n+                    return expression;\n+                }\n             }\n \n             @Override\n             public String toString() {\n-                return \"\" + expression + \".convertTo(\" + type.getCanonicalName() + \".class)\";\n+                return \"\" + expression;\n             }\n         };\n     }\n@@ -952,12 +956,17 @@ public String toString() {\n     public static Expression convertToExpression(final Expression expression, final Expression type) {\n         return new ExpressionAdapter() {\n             public Object evaluate(Exchange exchange) {\n-                return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());\n+                Object result = type.evaluate(exchange, Object.class);\n+                if (result != null) {\n+                    return expression.evaluate(exchange, result.getClass());\n+                } else {\n+                    return expression;\n+                }\n             }\n \n             @Override\n             public String toString() {\n-                return \"\" + expression + \".convertToEvaluatedType(\" + type + \")\";\n+                return \"\" + expression;\n             }\n         };\n     }\n", "nb_test": 3008, "linesAdd": 12, "jira_id": "3433", "singleLine": false, "nb_skipped": 0, "commit": "e76d23b0", "nb_failure": 0, "linesRem": 3}, {"files": 4, "project": "camel", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["AggregateTimeoutTest>TestSupport.runBare:58->testAggregateTimeout:51 expected:<1> but was:<0>", "CamelPostProcessorHelperTest>TestSupport.runBare:58->testPropertyFieldInject:353 \u00bb RuntimeCamel", "CamelPostProcessorHelperTest>TestSupport.runBare:58->testPropertyFieldDefaultValueInject:373 \u00bb RuntimeCamel", "CamelPostProcessorHelperTest>TestSupport.runBare:58->testPropertyMethodInject:394 \u00bb RuntimeCamel"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/CamelPostProcessorHelper.java b/camel-core/src/main/java/org/apache/camel/impl/CamelPostProcessorHelper.java\nindex 04dbc4d..817a2f9 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/CamelPostProcessorHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/CamelPostProcessorHelper.java\n@@ -22,6 +22,7 @@\n \n import org.apache.camel.CamelContext;\n import org.apache.camel.CamelContextAware;\n+import org.apache.camel.Component;\n import org.apache.camel.Consume;\n import org.apache.camel.Consumer;\n import org.apache.camel.ConsumerTemplate;\n@@ -37,7 +38,6 @@\n import org.apache.camel.component.bean.BeanInfo;\n import org.apache.camel.component.bean.BeanProcessor;\n import org.apache.camel.component.bean.ProxyHelper;\n-import org.apache.camel.component.properties.PropertiesComponent;\n import org.apache.camel.processor.CamelInternalProcessor;\n import org.apache.camel.processor.UnitOfWorkProducer;\n import org.apache.camel.util.CamelContextHelper;\n@@ -227,17 +227,13 @@ public Object getInjectionValue(Class<?> type, String endpointUri, String endpoi\n     public Object getInjectionPropertyValue(Class<?> type, String propertyName, String propertyDefaultValue,\n                                             String injectionPointName, Object bean, String beanName) {\n         try {\n+            // enforce a properties component to be created if none existed\n+            CamelContextHelper.lookupPropertiesComponent(getCamelContext(), true);\n+\n             String key;\n             String prefix = getCamelContext().getPropertyPrefixToken();\n             String suffix = getCamelContext().getPropertySuffixToken();\n-\n-            if (prefix == null && suffix == null) {\n-                // if no custom prefix/suffix then use defaults\n-                prefix = PropertiesComponent.DEFAULT_PREFIX_TOKEN;\n-                suffix = PropertiesComponent.DEFAULT_SUFFIX_TOKEN;\n-            }\n-\n-            if (!propertyName.startsWith(prefix)) {\n+            if (!propertyName.contains(prefix)) {\n                 // must enclose the property name with prefix/suffix to have it resolved\n                 key = prefix + propertyName + suffix;\n             } else {\ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex 256fc8c..7eb7fe6 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -1458,23 +1457,8 @@ public String resolvePropertyPlaceholders(String text) throws Exception {\n         if (text != null && !text.startsWith(\"properties:\")) {\n             // No component, assume default tokens.\n             if (pc == null && text.contains(PropertiesComponent.DEFAULT_PREFIX_TOKEN)) {\n-\n-                // try to lookup component, as we may be initializing CamelContext itself\n-                Component existing = lookupPropertiesComponent();\n-                if (existing != null) {\n-                    if (existing instanceof PropertiesComponent) {\n-                        pc = (PropertiesComponent) existing;\n-                    } else {\n-                        // properties component must be expected type\n-                        throw new IllegalArgumentException(\"Found properties component of type: \" + existing.getClass() + \" instead of expected: \" + PropertiesComponent.class);\n-                    }\n-                }\n-\n-                if (pc == null) {\n-                    // create a default properties component to be used as there may be default values we can use\n-                    log.info(\"No existing PropertiesComponent has been configured, creating a new default PropertiesComponent with name: properties\");\n-                    pc = getComponent(\"properties\", PropertiesComponent.class);\n-                }\n+                // lookup existing properties component, or force create a new default component\n+                pc = (PropertiesComponent) CamelContextHelper.lookupPropertiesComponent(this, true);\n             }\n \n             if (pc != null && text.contains(pc.getPrefixToken())) {\n@@ -2111,7 +2095,7 @@ private void doStartCamel() throws Exception {\n \n         // eager lookup any configured properties component to avoid subsequent lookup attempts which may impact performance\n         // due we use properties component for property placeholder resolution at runtime\n-        Component existing = lookupPropertiesComponent();\n+        Component existing = CamelContextHelper.lookupPropertiesComponent(this, false);\n         if (existing != null) {\n             // store reference to the existing properties component\n             if (existing instanceof PropertiesComponent) {\n@@ -3075,16 +3059,12 @@ public DataFormatDefinition resolveDataFormatDefinition(String name) {\n         }\n     }\n \n+    /**\n+     * @deprecated use {@link org.apache.camel.util.CamelContextHelper#lookupPropertiesComponent(org.apache.camel.CamelContext, boolean)}\n+     */\n+    @Deprecated\n     protected Component lookupPropertiesComponent() {\n-        // no existing properties component so lookup and add as component if possible\n-        PropertiesComponent answer = (PropertiesComponent) hasComponent(\"properties\");\n-        if (answer == null) {\n-            answer = getRegistry().lookupByNameAndType(\"properties\", PropertiesComponent.class);\n-            if (answer != null) {\n-                addComponent(\"properties\", answer);\n-            }\n-        }\n-        return answer;\n+        return CamelContextHelper.lookupPropertiesComponent(this, false);\n     }\n \n     public ShutdownStrategy getShutdownStrategy() {\ndiff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\nindex 87689a3..5ba236b 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\n@@ -31,6 +31,7 @@\n import org.apache.camel.Exchange;\n import org.apache.camel.spi.ExecutorServiceManager;\n import org.apache.camel.spi.RouteContext;\n+import org.apache.camel.util.CamelContextHelper;\n import org.apache.camel.util.IntrospectionSupport;\n import org.apache.camel.util.ObjectHelper;\n import org.slf4j.Logger;\n@@ -524,6 +525,9 @@ public static void resolvePropertyPlaceholders(RouteContext routeContext, Object\n                     String local = key.getLocalPart();\n                     Object value = processorDefinition.getOtherAttributes().get(key);\n                     if (value != null && value instanceof String) {\n+                        // enforce a properties component to be created if none existed\n+                        CamelContextHelper.lookupPropertiesComponent(routeContext.getCamelContext(), true);\n+\n                         // value must be enclosed with placeholder tokens\n                         String s = (String) value;\n                         String prefixToken = routeContext.getCamelContext().getPropertyPrefixToken();\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/CamelContextHelper.java b/camel-core/src/main/java/org/apache/camel/util/CamelContextHelper.java\nindex ab829f6..097ed29 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/CamelContextHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/CamelContextHelper.java\n@@ -35,6 +35,7 @@\n import org.apache.camel.Exchange;\n import org.apache.camel.NoSuchBeanException;\n import org.apache.camel.NoSuchEndpointException;\n+import org.apache.camel.component.properties.PropertiesComponent;\n import org.apache.camel.spi.ClassResolver;\n import org.apache.camel.spi.RouteStartupOrder;\n import org.slf4j.Logger;\n@@ -477,4 +478,30 @@ public static int getRouteStartupOrder(CamelContext camelContext, String routeId\n         return 0;\n     }\n \n+    /**\n+     * Lookup the {@link org.apache.camel.component.properties.PropertiesComponent} from the {@link org.apache.camel.CamelContext}.\n+     * <p/>\n+     * @param camelContext the camel context\n+     * @param autoCreate whether to automatic create a new default {@link org.apache.camel.component.properties.PropertiesComponent} if no custom component\n+     *                   has been configured.\n+     * @return the properties component, or <tt>null</tt> if none has been defined, and auto create is <tt>false</tt>.\n+     */\n+    public static Component lookupPropertiesComponent(CamelContext camelContext, boolean autoCreate) {\n+        // no existing properties component so lookup and add as component if possible\n+        PropertiesComponent answer = (PropertiesComponent) camelContext.hasComponent(\"properties\");\n+        if (answer == null) {\n+            answer = camelContext.getRegistry().lookupByNameAndType(\"properties\", PropertiesComponent.class);\n+            if (answer != null) {\n+                camelContext.addComponent(\"properties\", answer);\n+            }\n+        }\n+        if (answer == null && autoCreate) {\n+            // create a default properties component to be used as there may be default values we can use\n+            LOG.info(\"No existing PropertiesComponent has been configured, creating a new default PropertiesComponent with name: properties\");\n+            answer = camelContext.getComponent(\"properties\", PropertiesComponent.class);\n+        }\n+        return answer;\n+    }\n+\n+\n }\n", "nb_test": 5161, "linesAdd": 28, "jira_id": "8125", "singleLine": false, "nb_skipped": 4, "commit": "36e7b668", "nb_failure": 1, "linesRem": 31}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testConcurrentAppend(org.apache.camel.component.file.FileSplitInSplitTest): Should be 4 lines expected:<4> but was:<3>", "testThreadNotUsedForEveryAggregatorWithCustomExecutorService(org.apache.camel.processor.aggregator.AggregateTimeoutWithExecutorServiceTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex b2930f6..3993086 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -1002,6 +1002,10 @@ protected void setAggregationStrategyOnExchange(Exchange exchange, AggregationSt\n         Map<Object, AggregationStrategy> map = CastUtils.cast(property);\n         if (map == null) {\n             map = new HashMap<Object, AggregationStrategy>();\n+        } else {\n+            // it is not safe to use the map directly as the exchange doesn't have the deep copy of it's properties\n+            // we just create a new copy if we need to change the map\n+            map = new HashMap<Object, AggregationStrategy>(map);\n         }\n         // store the strategy using this processor as the key\n         // (so we can store multiple strategies on the same exchange)\n", "nb_test": 4322, "linesAdd": 2, "jira_id": "5704", "singleLine": false, "nb_skipped": 1, "commit": "708e756d", "nb_failure": 1, "rtElixir": true, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRoutingSlipChild(org.apache.camel.processor.RoutingSlipNoSuchEndpointExceptionTest): mock://error Received message count. Expected: <1> but was: <0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java b/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\nindex 2c99425..24bcf36 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\n@@ -170,7 +170,7 @@ public Object next(Exchange exchange) {\n         };\n     }\n \n-    private boolean doRoutingSlip(Exchange exchange, AsyncCallback callback) {\n+    private boolean doRoutingSlip(final Exchange exchange, final AsyncCallback callback) {\n         Exchange current = exchange;\n         RoutingSlipIterator iter;\n         try {\n@@ -196,8 +196,8 @@ private boolean doRoutingSlip(Exchange exchange, AsyncCallback callback) {\n                 }\n             } catch (Exception e) {\n                 // error resolving endpoint so we should break out\n-                exchange.setException(e);\n-                return true;\n+                current.setException(e);\n+                break;\n             }\n \n             // prepare and process the routing slip\n", "nb_test": 3847, "linesAdd": 3, "jira_id": "4486", "singleLine": false, "nb_skipped": 0, "commit": "f98ac676", "nb_failure": 1, "linesRem": 3}, {"files": 6, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFileProducerCharsetUTFtoISO(org.apache.camel.component.file.FileProducerCharsetUTFtoISOTest): expected:<4> but was:<5>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/FileBinding.java b/camel-core/src/main/java/org/apache/camel/component/file/FileBinding.java\nindex 4fd0162..8a63748 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/FileBinding.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/FileBinding.java\n@@ -54,7 +54,7 @@ public void setBody(GenericFile<File> file, Object body) {\n     public void loadContent(Exchange exchange, GenericFile<?> file) throws IOException {\n         if (content == null) {\n             try {\n-                content = exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, file.getFile());\n+                content = exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, exchange, file.getFile());\n             } catch (NoTypeConversionAvailableException e) {\n                 throw new IOException(\"Cannot load file content: \" + file.getAbsoluteFilePath(), e);\n             }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java b/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\nindex f22056e..fbc60bc 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\n@@ -21,7 +21,10 @@\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.InputStreamReader;\n import java.io.RandomAccessFile;\n+import java.io.Reader;\n+import java.io.Writer;\n import java.nio.ByteBuffer;\n import java.nio.channels.FileChannel;\n import java.util.Date;\n@@ -29,6 +32,8 @@\n \n import org.apache.camel.Exchange;\n import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.converter.IOConverter;\n import org.apache.camel.util.FileUtil;\n import org.apache.camel.util.IOHelper;\n import org.apache.camel.util.ObjectHelper;\n@@ -173,10 +178,24 @@ public boolean storeFile(String fileName, Exchange exchange) throws GenericFileO\n         // 3. write stream to file\n         try {\n \n-            // is the body file based\n+            // determine charset, exchange property overrides endpoint configuration\n+            String charset = IOHelper.getCharsetName(exchange, false);\n+            if (charset == null) {\n+                charset = endpoint.getCharset();\n+            }\n+\n+            // we can optimize and use file based if no charset must be used, and the input body is a file\n             File source = null;\n-            // get the File Object from in message\n-            source = exchange.getIn().getBody(File.class);\n+            if (charset == null) {\n+                // if no charset, then we can try using file directly (optimized)\n+                Object body = exchange.getIn().getBody();\n+                if (body instanceof WrappedFile) {\n+                    body = ((WrappedFile) body).getFile();\n+                }\n+                if (body instanceof File) {\n+                    source = (File) body;\n+                }\n+            }\n \n             if (source != null) {\n                 // okay we know the body is a file type\n@@ -205,9 +224,22 @@ public boolean storeFile(String fileName, Exchange exchange) throws GenericFileO\n                 }\n             }\n \n+            if (charset != null) {\n+                // charset configured so we must use a reader so we can write with encoding\n+                Reader in = exchange.getIn().getBody(Reader.class);\n+                if (in == null) {\n+                    // okay no direct reader conversion, so use an input stream (which a lot can be converted as)\n+                    InputStream is = exchange.getIn().getMandatoryBody(InputStream.class);\n+                    in = new InputStreamReader(is);\n+                }\n+                // buffer the reader\n+                in = IOHelper.buffered(in);\n+                writeFileByReaderWithCharset(in, file, charset);\n+            } else {\n                 // fallback and use stream based\n                 InputStream in = exchange.getIn().getMandatoryBody(InputStream.class);\n                 writeFileByStream(in, file);\n+            }\n             // try to keep last modified timestamp if configured to do so\n             keepLastModified(exchange, file);\n             return true;\n@@ -286,6 +317,19 @@ private void writeFileByStream(InputStream in, File target) throws IOException {\n         }\n     }\n \n+    private void writeFileByReaderWithCharset(Reader in, File target, String charset) throws IOException {\n+        boolean append = endpoint.getFileExist() == GenericFileExist.Append;\n+        Writer out = IOConverter.toWriter(target, append, charset);\n+        try {\n+            LOG.trace(\"Using Reader to transfer from: {} to: {} with charset: {}\", new Object[]{in, out, charset});\n+            int size = endpoint.getBufferSize();\n+            IOHelper.copy(in, out, size);\n+        } finally {\n+            IOHelper.close(in, target.getName(), LOG);\n+            IOHelper.close(out, target.getName(), LOG);\n+        }\n+    }\n+\n     /**\n      * Creates and prepares the output file channel. Will position itself in correct position if the file is writable\n      * eg. it should append or override any existing content.\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConverter.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConverter.java\nindex 76bb929..49bc19d 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConverter.java\n@@ -17,7 +17,6 @@\n package org.apache.camel.component.file;\n \n import java.io.File;\n-import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.Serializable;\n@@ -25,9 +24,9 @@\n import org.apache.camel.Converter;\n import org.apache.camel.Exchange;\n import org.apache.camel.FallbackConverter;\n+import org.apache.camel.NoTypeConversionAvailableException;\n import org.apache.camel.TypeConverter;\n import org.apache.camel.spi.TypeConverterRegistry;\n-import org.apache.camel.util.IOHelper;\n \n /**\n  * A set of converter methods for working with generic file types\n@@ -64,11 +63,15 @@ public static Object convertTo(Class<?> type, Exchange exchange, Object value, T\n     }\n \n     @Converter\n-    public static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException {\n+    public static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException, NoTypeConversionAvailableException {\n         if (exchange != null) {\n-            // use a file input stream if its a java.io.File\n             if (file.getFile() instanceof java.io.File) {\n-                return IOHelper.buffered(new FileInputStream((File) file.getFile()));\n+                // prefer to use a file input stream if its a java.io.File (must use type converter to take care of encoding)\n+                File f = (File) file.getFile();\n+                InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, f);\n+                if (is != null) {\n+                    return is;\n+                }\n             }\n             // otherwise ensure the body is loaded as we want the input stream of the body\n             file.getBinding().loadContent(exchange, file);\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileProducer.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileProducer.java\nindex b00cdf0..feab07b 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileProducer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileProducer.java\n@@ -59,8 +59,6 @@ public String normalizePath(String name) {\n     }\n \n     public void process(Exchange exchange) throws Exception {\n-        endpoint.configureExchange(exchange);\n-\n         String target = createFileName(exchange);\n \n         // use lock for same file name to avoid concurrent writes to the same file\ndiff --git a/camel-core/src/main/java/org/apache/camel/converter/IOConverter.java b/camel-core/src/main/java/org/apache/camel/converter/IOConverter.java\nindex 0307aef..fcc6fc8 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/IOConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/IOConverter.java\n@@ -101,12 +101,16 @@ public static OutputStream toOutputStream(File file) throws FileNotFoundExceptio\n      */\n     @Deprecated\n     public static BufferedWriter toWriter(File file) throws IOException {\n-        return toWriter(file, null);\n+        return toWriter(file, false, IOHelper.getCharsetName(null, true));\n     }\n     \n     @Converter\n     public static BufferedWriter toWriter(File file, Exchange exchange) throws IOException {\n-        return IOHelper.buffered(new EncodingFileWriter(file, IOHelper.getCharsetName(exchange)));\n+        return toWriter(file, false, IOHelper.getCharsetName(exchange));\n+    }\n+\n+    public static BufferedWriter toWriter(File file, boolean append, String charset) throws IOException {\n+        return IOHelper.buffered(new EncodingFileWriter(file, append, charset));\n     }\n \n     /**\n@@ -434,6 +438,16 @@ public EncodingFileWriter(File file, String charset)\n             super(new FileOutputStream(file), charset);\n         }\n \n+        /**\n+         * @param file file to write\n+         * @param append whether to append to the file\n+         * @param charset character set to use\n+         */\n+        public EncodingFileWriter(File file, boolean append, String charset)\n+            throws FileNotFoundException, UnsupportedEncodingException {\n+            super(new FileOutputStream(file, append), charset);\n+        }\n+\n     }\n     \n     /**\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/IOHelper.java b/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\nindex 79aa06a..903ce19 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\n@@ -191,6 +191,20 @@ public static void copyAndCloseInput(InputStream input, OutputStream output, int\n         close(input, null, LOG);\n     }\n \n+    public static int copy(final Reader input, final Writer output, int bufferSize) throws IOException {\n+        final char[] buffer = new char[bufferSize];\n+        int n = input.read(buffer);\n+        int total = 0;\n+        while (-1 != n) {\n+            output.write(buffer, 0, n);\n+            total += n;\n+            n = input.read(buffer);\n+        }\n+        output.flush();\n+        return total;\n+    }\n+\n+\n     /**\n      * Forces any updates to this channel's file to be written to the storage device that contains it.\n      *\n", "nb_test": 4175, "linesAdd": 75, "jira_id": "5215", "singleLine": false, "nb_skipped": 1, "commit": "033eb6fe", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:189 expected:<10> but was:<9>", "XsltDTDTest>TestSupport.runBare:58->testSendEntityMessage:38 \u00bb CamelExecution ..."], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\nindex 8984828..3a7b9a4 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\n@@ -79,7 +79,7 @@\n     private URIResolver uriResolver;\n     private boolean deleteOutputFile;\n     private ErrorListener errorListener = new XsltErrorListener();\n-    private boolean allowStAX;\n+    private boolean allowStAX = true;\n \n     public XsltBuilder() {\n     }\n", "nb_test": 4781, "linesAdd": 1, "jira_id": "7130", "singleLine": false, "nb_skipped": 2, "commit": "7c9326f4", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FileProducerFileExistAppendTest>TestSupport.runBare:58->testAppend:43->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Body of message: 0. Expected: <Hello World", "Bye World> but was: <null>", "StreamCachingRecipientListTest>TestSupport.runBare:58->testByteArrayInputStream:33->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://bar Body of message: 0. Expected: <<hello/>> but was: <>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\nindex 92b3422..9a9bf91 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\n@@ -30,6 +30,7 @@\n import org.apache.camel.processor.aggregate.AggregationStrategy;\n import org.apache.camel.spi.RouteContext;\n import org.apache.camel.util.ExchangeHelper;\n+import org.apache.camel.util.MessageHelper;\n import org.apache.camel.util.ServiceHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -100,6 +101,8 @@ public void begin() {\n             // we have already acquired and prepare the producer\n             LOG.trace(\"RecipientProcessorExchangePair #{} begin: {}\", index, exchange);\n             exchange.setProperty(Exchange.RECIPIENT_LIST_ENDPOINT, endpoint.getEndpointUri());\n+            // ensure stream caching is reset\n+            MessageHelper.resetStreamCache(exchange.getIn());\n         }\n \n         public void done() {\n", "nb_test": 4619, "linesAdd": 2, "jira_id": "6604", "singleLine": false, "nb_skipped": 1, "commit": "4209fabb", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": true}, "failing_tests": ["XmlConverterTest>TestSupport.runBare:58->testToStreamSourceByByteBuffer:344 \u00bb TypeConversion"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\nindex 9a2b60a..0bf08ac 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n@@ -99,6 +99,7 @@ public static ByteBuffer toByteBuffer(String value, Exchange exchange) {\n             bytes = value.getBytes();\n         }\n         buf.put(bytes);\n+        buf.flip();\n         return buf;\n     }\n \n", "nb_test": 4801, "linesAdd": 1, "jira_id": "7209", "singleLine": true, "nb_skipped": 3, "commit": "5f78c646", "nb_failure": 0, "rtElixir": true, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["VmMultipleConsumersMultipleContextTest>TestSupport.runBare:58->testVmMultipleConsumersDifferentEndpoints:145 mock://route1 Received message count. Expected: <100> but was: <73>", "VmMultipleConsumersMultipleContextTest>TestSupport.runBare:58->testVmMultipleConsumersMultipleContext:96 mock://route1 Received message count. Expected: <100> but was: <105>", "OnCompletionIssueTest>TestSupport.runBare:58->testOnCompletionIssue:59->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://complete Received message count. Expected: <4> but was: <3>", "VmMultipleContextsStartStopTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb IllegalArgument", "VmQueueTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb FailedToCreateRoute", "VmShouldNotUseSameThreadTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:39->ContextTestSupport.setUp:117->ContextTestSupport.startCamelContext:174 \u00bb IllegalArgument"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java\nindex abbdcd0..6575cb2 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java\n@@ -131,6 +131,8 @@ protected static void doProcess(Processor processor, Exchange exchange) {\n         Object failureHandled = exchange.removeProperty(Exchange.FAILURE_HANDLED);\n         Object caught = exchange.removeProperty(Exchange.EXCEPTION_CAUGHT);\n         Object errorhandlerHandled = exchange.removeProperty(Exchange.ERRORHANDLER_HANDLED);\n+        Object rollbackOnly = exchange.removeProperty(Exchange.ROLLBACK_ONLY);\n+        Object rollbackOnlyLast = exchange.removeProperty(Exchange.ROLLBACK_ONLY_LAST);\n \n         Exception cause = exchange.getException();\n         exchange.setException(null);\n@@ -153,6 +155,12 @@ protected static void doProcess(Processor processor, Exchange exchange) {\n             if (errorhandlerHandled != null) {\n                 exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, errorhandlerHandled);\n             }\n+            if (rollbackOnly != null) {\n+                exchange.setProperty(Exchange.ROLLBACK_ONLY, rollbackOnly);\n+            }\n+            if (rollbackOnlyLast != null) {\n+                exchange.setProperty(Exchange.ROLLBACK_ONLY, rollbackOnlyLast);\n+            }\n             if (cause != null) {\n                 exchange.setException(cause);\n             }\n", "nb_test": 5063, "linesAdd": 8, "jira_id": "7568", "singleLine": false, "nb_skipped": 3, "commit": "b3377b16", "nb_failure": 3, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["TransformerIssueTest>TestSupport.runBare:58->testTransformer:30 \u00bb CamelExecution"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex d33eb7f..67a0893 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -759,6 +759,7 @@ private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<Me\n             MethodInfo matched = null;\n             int matchCounter = 0;\n             for (MethodInfo methodInfo : operationList) {\n+                if (methodInfo.getBodyParameterType() != null) {\n                     if (methodInfo.getBodyParameterType().isInstance(body)) {\n                         return methodInfo;\n                     }\n@@ -775,6 +776,7 @@ private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<Me\n                         matched = methodInfo;\n                     }\n                 }\n+            }\n             if (matchCounter > 1) {\n                 throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));\n             }\n", "nb_test": 5287, "linesAdd": 2, "jira_id": "8624", "singleLine": false, "nb_skipped": 4, "commit": "597883fa", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBatchConsumerSendEmptyMessageWhenIdle(org.apache.camel.processor.aggregator.AggregateCompletedByBatchConsumerSendEmptyMessageWhenIdleTest): mock://result Received message count 0, expected at least 1", "testPollEnrichMultipleDefaultNoWait(org.apache.camel.processor.enricher.PollEnricherTest): expected:<2> but was:<0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ScheduledBatchPollingConsumer.java b/camel-core/src/main/java/org/apache/camel/impl/ScheduledBatchPollingConsumer.java\nindex 5ff6208..c54240c 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ScheduledBatchPollingConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ScheduledBatchPollingConsumer.java\n@@ -20,6 +20,7 @@\n \n import org.apache.camel.BatchConsumer;\n import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n import org.apache.camel.Processor;\n import org.apache.camel.ShutdownRunningTask;\n import org.apache.camel.spi.ShutdownAware;\n@@ -112,4 +113,15 @@ public boolean isBatchAllowed() {\n         // we are shutting down so only continue if we are configured to complete all tasks\n         return ShutdownRunningTask.CompleteAllTasks == shutdownRunningTask;\n     }\n+\n+    @Override\n+    protected void processEmptyMessage() throws Exception {\n+        Exchange exchange = getEndpoint().createExchange();\n+        // enrich exchange, so we send an empty message with the batch details\n+        exchange.setProperty(Exchange.BATCH_INDEX, 0);\n+        exchange.setProperty(Exchange.BATCH_SIZE, 1);\n+        exchange.setProperty(Exchange.BATCH_COMPLETE, true);\n+        log.debug(\"Sending empty message as there were no messages from polling: {}\", this.getEndpoint());\n+        getProcessor().process(exchange);\n+    }\n }\n", "nb_test": 4243, "linesAdd": 11, "jira_id": "5437", "singleLine": false, "nb_skipped": 1, "commit": "da05f5aa", "nb_failure": 2, "linesRem": 0}, {"files": 3, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SendExchangePatternOptionTest>TestSupport.runBare:58->testExchangePatternOptionInOut:46->ContextTestSupport.assertMockEndpointsSatisfied:343 Assertion error at index 0 on mock mock://stub with predicate: exchangePattern == InOnly evaluated as: InOut == InOnly on Exchange[Message: Hello World]"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\nindex 1087da6..db6af86 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\n@@ -17,12 +17,11 @@\n package org.apache.camel.processor;\n \n import java.io.UnsupportedEncodingException;\n-import java.net.URI;\n+import java.net.MalformedURLException;\n import java.net.URISyntaxException;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n import java.util.concurrent.ExecutorService;\n \n import org.apache.camel.CamelContext;\n@@ -34,6 +33,7 @@\n import org.apache.camel.impl.ProducerCache;\n import org.apache.camel.processor.aggregate.AggregationStrategy;\n import org.apache.camel.spi.RouteContext;\n+import org.apache.camel.util.EndpointHelper;\n import org.apache.camel.util.ExchangeHelper;\n import org.apache.camel.util.MessageHelper;\n import org.apache.camel.util.ServiceHelper;\n@@ -191,7 +191,7 @@ public void setIgnoreInvalidEndpoints(boolean ignoreInvalidEndpoints) {\n             ExchangePattern pattern;\n             try {\n                 endpoint = resolveEndpoint(exchange, recipient);\n-                pattern = resolveExchangePattern(exchange, recipient);\n+                pattern = resolveExchangePattern(recipient);\n                 producer = producerCache.acquireProducer(endpoint);\n             } catch (Exception e) {\n                 if (isIgnoreInvalidEndpoints()) {\n@@ -254,18 +254,13 @@ protected static Endpoint resolveEndpoint(Exchange exchange, Object recipient) {\n         return ExchangeHelper.resolveEndpoint(exchange, recipient);\n     }\n \n-    protected ExchangePattern resolveExchangePattern(Exchange exchange, Object recipient) throws UnsupportedEncodingException, URISyntaxException {\n+    protected ExchangePattern resolveExchangePattern(Object recipient) throws UnsupportedEncodingException, URISyntaxException, MalformedURLException {\n         // trim strings as end users might have added spaces between separators\n         if (recipient instanceof String) {\n             String s = ((String) recipient).trim();\n             // see if exchangePattern is a parameter in the url\n             s = URISupport.normalizeUri(s);\n-            URI url = new URI(s);\n-            Map<String, Object> parameters = URISupport.parseParameters(url);\n-            String pattern = (String) parameters.get(\"exchangePattern\");\n-            if (pattern != null) {\n-                return ExchangePattern.asEnum(pattern);\n-            }\n+            return EndpointHelper.resolveExchangePatternFromUrl(s);\n         }\n         return null;\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\nindex d8e8803..efd6a60 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.camel.processor;\n \n+import java.net.URISyntaxException;\n import java.util.HashMap;\n \n import org.apache.camel.AsyncCallback;\n@@ -33,6 +34,7 @@\n import org.apache.camel.support.ServiceSupport;\n import org.apache.camel.util.AsyncProcessorConverterHelper;\n import org.apache.camel.util.AsyncProcessorHelper;\n+import org.apache.camel.util.EndpointHelper;\n import org.apache.camel.util.EventHelper;\n import org.apache.camel.util.ObjectHelper;\n import org.apache.camel.util.ServiceHelper;\n@@ -53,6 +55,7 @@\n     protected ProducerCache producerCache;\n     protected AsyncProcessor producer;\n     protected Endpoint destination;\n+    protected ExchangePattern destinationExchangePattern;\n     protected final boolean unhandleException;\n \n     public SendProcessor(Endpoint destination) {\n@@ -69,6 +72,12 @@ public SendProcessor(Endpoint destination, ExchangePattern pattern, boolean unha\n         this.camelContext = destination.getCamelContext();\n         this.pattern = pattern;\n         this.unhandleException = unhandleException;\n+        try {\n+            this.destinationExchangePattern = null;\n+            this.destinationExchangePattern = EndpointHelper.resolveExchangePatternFromUrl(destination.getEndpointUri());\n+        } catch (URISyntaxException e) {\n+            throw ObjectHelper.wrapRuntimeCamelException(e);\n+        }\n         ObjectHelper.notNull(this.camelContext, \"camelContext\");\n     }\n \n@@ -133,11 +142,9 @@ public void done(boolean doneSync) {\n                     }\n                 });\n             } catch (Throwable throwable) {\n-                if (exchange != null) {\n                 exchange.setException(throwable);\n                 checkException(exchange);\n-                }\n-\n+                callback.done(sync);\n             }\n \n             return sync;\n@@ -180,7 +187,10 @@ public ExchangePattern getPattern() {\n     }\n \n     protected Exchange configureExchange(Exchange exchange, ExchangePattern pattern) {\n-        if (pattern != null) {\n+        // destination exchange pattern overrides pattern\n+        if (destinationExchangePattern != null) {\n+            exchange.setPattern(destinationExchangePattern);\n+        } else if (pattern != null) {\n             exchange.setPattern(pattern);\n         }\n         // set property which endpoint we send to\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java\nindex 9df3ca2..18181b3 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.camel.util;\n \n+import java.net.URI;\n+import java.net.URISyntaxException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -29,6 +31,7 @@\n import org.apache.camel.DelegateEndpoint;\n import org.apache.camel.Endpoint;\n import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n import org.apache.camel.Message;\n import org.apache.camel.PollingConsumer;\n import org.apache.camel.Processor;\n@@ -487,4 +490,21 @@ public static String browseRangeMessagesAsXml(BrowsableEndpoint endpoint, Intege\n         return sb.toString();\n     }\n \n+    /**\n+     * Attempts to resolve if the url has an <tt>exchangePattern</tt> option configured\n+     *\n+     * @param url the url\n+     * @return the exchange pattern, or <tt>null</tt> if the url has no <tt>exchangePattern</tt> configured.\n+     * @throws URISyntaxException is thrown if uri is invalid\n+     */\n+    public static ExchangePattern resolveExchangePatternFromUrl(String url) throws URISyntaxException {\n+        URI uri = new URI(url);\n+        Map<String, Object> parameters = URISupport.parseParameters(uri);\n+        String pattern = (String) parameters.get(\"exchangePattern\");\n+        if (pattern != null) {\n+            return ExchangePattern.asEnum(pattern);\n+        }\n+        return null;\n+    }\n+\n }\n", "nb_test": 5190, "linesAdd": 31, "jira_id": "8227", "singleLine": false, "nb_skipped": 4, "commit": "54d7fc59", "nb_failure": 1, "linesRem": 14}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ManagedThrottlerTest>TestSupport.runBare:58->testThrottleVisableViaJmx:137 null", "XsltDTDTest>TestSupport.runBare:58->testSendingInputStreamMessage:43->sendEntityMessage:52 \u00bb CamelExecution"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\nindex 3a7b9a4..d4291b2 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\n@@ -452,9 +452,6 @@ protected Source getSource(Exchange exchange, Object body) {\n             return (Source) body;\n         }\n         Source source = null;\n-        if (body instanceof InputStream) {\n-            return new StreamSource((InputStream)body);\n-        }\n         if (body != null) {\n             if (isAllowStAX()) {\n                 source = exchange.getContext().getTypeConverter().tryConvertTo(StAXSource.class, exchange, body);\n", "nb_test": 4792, "linesAdd": 0, "jira_id": "7130", "singleLine": false, "nb_skipped": 2, "commit": "cc192f87", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "camel", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["BeanInfoTest.testMethodPatternUsingMethodAnnotationsOnInterface:75->assertMethodPattern:120 Could not find methodInfo for: public abstract void org.apache.camel.component.bean.BeanInfoTest$MyOneWayInterfaceWithOverloadedMethod.inOnlyMethod()", "BeanInfoTest.testMethodPatternUsingMethodAnnotations:61->assertMethodPattern:120 Could not find methodInfo for: public abstract void org.apache.camel.component.bean.BeanInfoTest$Foo.inOutMethod()", "BeanInfoTest.testMethodPatternUsingClassAnnotationsOnInterface:69->assertMethodPattern:120 Could not find methodInfo for: public abstract void org.apache.camel.component.bean.BeanInfoTest$MyOneWayInterface.inOnlyMethod()", "BeanInfoTest.testGetOperations:52 expected:<3> but was:<0>", "BeanInfoSingleMethodServiceTest>TestSupport.runBare:58->testBeanInfoSingleMethod:37 Should find the single method expected:<1> but was:<0>", "BeanPrivateClassWithInterfaceMethodTest>TestSupport.runBare:58->testPrivateClassBinding:56 \u00bb CamelExecution", "BeanPrivateClassWithInterfaceMethodTest>TestSupport.runBare:58->testPackagePrivateClassBinding:45 \u00bb CamelExecution", "SimpleOverrideMethodTest>TestSupport.runBare:58->testOverrideMethod:34->LanguageTestSupport.assertExpression:69->LanguageTestSupport.assertExpression:62->ContextTestSupport.assertExpression:314->TestSupport.assertExpression:234 \u00bb RuntimeBeanExpression"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex 1b34622..d3c7214 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -557,6 +557,12 @@ protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) t\n         final List<MethodInfo> localOperationsWithCustomAnnotation = new ArrayList<MethodInfo>(operationsWithCustomAnnotation);\n         final List<MethodInfo> localOperationsWithHandlerAnnotation = new ArrayList<MethodInfo>(operationsWithHandlerAnnotation);\n \n+        // remove all abstract methods\n+        removeAllAbstractMethods(localOperationsWithBody);\n+        removeAllAbstractMethods(localOperationsWithNoBody);\n+        removeAllAbstractMethods(localOperationsWithCustomAnnotation);\n+        removeAllAbstractMethods(localOperationsWithHandlerAnnotation);\n+\n         if (name != null) {\n             // filter all lists to only include methods with this name\n             removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\n@@ -831,11 +837,6 @@ protected boolean isValidMethod(Class<?> clazz, Method method) {\n             return false;\n         }\n \n-        // must not be abstract\n-        if (Modifier.isAbstract(method.getModifiers())) {\n-            return false;\n-        }\n-\n         // return type must not be an Exchange and it should not be a bridge method\n         if ((method.getReturnType() != null && Exchange.class.isAssignableFrom(method.getReturnType())) || method.isBridge()) {\n             return false;\n@@ -982,6 +983,17 @@ private void removeNonMatchingMethods(List<MethodInfo> methods, String name) {\n         }\n     }\n \n+    private void removeAllAbstractMethods(List<MethodInfo> methods) {\n+        Iterator<MethodInfo> it = methods.iterator();\n+        while (it.hasNext()) {\n+            MethodInfo info = it.next();\n+            if (Modifier.isAbstract(info.getMethod().getModifiers())) {\n+                // we cannot invoke an abstract method\n+                it.remove();\n+            }\n+        }\n+    }\n+\n     private boolean matchMethod(Method method, String methodName) {\n         if (methodName == null) {\n             return true;\n", "nb_test": 5412, "linesAdd": 15, "jira_id": "9032", "singleLine": false, "nb_skipped": 4, "commit": "108d94f7", "nb_failure": 5, "linesRem": 4}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["LogInputStreamTest>TestSupport.runBare:58->testB:49->ContextTestSupport.assertMockEndpointsSatisfied:343 Assertion error at index 0 on mock mock://b with predicate: body == Hello World evaluated as:  == Hello World on Exchange[Message: [Body is instance of java.io.InputStream]]"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java b/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\nindex 6576c98..502da6a 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\n@@ -17,6 +17,7 @@\n package org.apache.camel.util;\n \n import java.io.File;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.Reader;\n@@ -285,12 +286,15 @@ public static String extractValueForLogging(Object obj, Message message, String\n             }\n         }\n \n-        // is the body a stream cache\n-        StreamCache cache;\n+        // is the body a stream cache or input stream\n+        StreamCache cache = null;\n+        InputStream is = null;\n         if (obj instanceof StreamCache) {\n             cache = (StreamCache)obj;\n-        } else {\n+            is = null;\n+        } else if (obj instanceof InputStream) {\n             cache = null;\n+            is = (InputStream) obj;\n         }\n \n         // grab the message body as a string\n@@ -309,6 +313,12 @@ public static String extractValueForLogging(Object obj, Message message, String\n         // reset stream cache after use\n         if (cache != null) {\n             cache.reset();\n+        } else if (is != null && is.markSupported()) {\n+            try {\n+                is.reset();\n+            } catch (IOException e) {\n+                // ignore\n+            }\n         }\n \n         if (body == null) {\n", "nb_test": 5053, "linesAdd": 11, "jira_id": "7767", "singleLine": false, "nb_skipped": 3, "commit": "eab06182", "nb_failure": 1, "linesRem": 2}, {"files": 2, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["NestedChoiceIssueTest>TestSupport.runBare:58->testNestedChoiceLow:51->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://low Received message count. Expected: <1> but was: <0>", "NestedChoiceIssueTest>TestSupport.runBare:58->testNestedChoiceMed:41->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://low Received message count. Expected: <0> but was: <1>", "TripleNestedChoiceIssueTest>TestSupport.runBare:58->testNestedChoiceBig:43->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://low Received message count. Expected: <0> but was: <1>", "TripleNestedChoiceIssueTest>TestSupport.runBare:58->testNestedChoiceLow:65->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://low Received message count. Expected: <1> but was: <0>", "TripleNestedChoiceIssueTest>TestSupport.runBare:58->testNestedChoiceMed:54->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://med Received message count. Expected: <1> but was: <0>", "AsyncNestedTripleChoiceIssueTest>TestSupport.runBare:58->testNestedChoiceBig:43->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://low Received message count. Expected: <0> but was: <1>", "AsyncNestedTripleChoiceIssueTest>TestSupport.runBare:58->testNestedChoiceLow:65->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://low Received message count. Expected: <1> but was: <0>", "AsyncNestedTripleChoiceIssueTest>TestSupport.runBare:58->testNestedChoiceMed:54->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://med Received message count. Expected: <1> but was: <0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\nindex 45889c3..9998e51 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n@@ -1295,8 +1295,13 @@ public AOPDefinition aop() {\n      * @return the builder\n      */\n     public ChoiceDefinition endChoice() {\n-        // are we already a choice?\n+        // are we nested choice?\n         ProcessorDefinition<?> def = this;\n+        if (def.getParent() instanceof WhenDefinition) {\n+            return (ChoiceDefinition) def.getParent().getParent();\n+        }\n+\n+        // are we already a choice?\n         if (def instanceof ChoiceDefinition) {\n             return (ChoiceDefinition) def;\n         }\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\nindex 5af8b36..0310c9a 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\n@@ -30,10 +30,6 @@\n import org.apache.camel.util.AsyncProcessorConverterHelper;\n import org.apache.camel.util.AsyncProcessorHelper;\n import org.apache.camel.util.ServiceHelper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static org.apache.camel.processor.PipelineHelper.continueProcessing;\n \n /**\n  * Implements a Choice structure where one or more predicates are used which if\n@@ -43,7 +39,6 @@\n  * @version \n  */\n public class ChoiceProcessor extends ServiceSupport implements AsyncProcessor, Navigate<Processor>, Traceable {\n-    private static final Logger LOG = LoggerFactory.getLogger(ChoiceProcessor.class);\n     private final List<Processor> filters;\n     private final Processor otherwise;\n \n@@ -56,91 +51,61 @@ public void process(Exchange exchange) throws Exception {\n         AsyncProcessorHelper.process(this, exchange);\n     }\n \n-    public boolean process(Exchange exchange, AsyncCallback callback) {\n+    public boolean process(final Exchange exchange, final AsyncCallback callback) {\n         Iterator<Processor> processors = next().iterator();\n \n-        exchange.setProperty(Exchange.FILTER_MATCHED, false);\n-        while (continueRouting(processors, exchange)) {\n-            // get the next processor\n-            Processor processor = processors.next();\n-\n-            AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n-            boolean sync = process(exchange, callback, processors, async);\n-\n-            // continue as long its being processed synchronously\n-            if (!sync) {\n-                LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n-                // the remainder of the CBR will be completed async\n-                // so we break out now, then the callback will be invoked which then continue routing from where we left here\n-                return false;\n-            }\n-\n-            LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n-\n-            // check for error if so we should break out\n-            if (!continueProcessing(exchange, \"so breaking out of content based router\", LOG)) {\n-                break;\n+        // callback to restore existing FILTER_MATCHED property on the Exchange\n+        final Object existing = exchange.getProperty(Exchange.FILTER_MATCHED);\n+        final AsyncCallback choiceCallback = new AsyncCallback() {\n+            @Override\n+            public void done(boolean doneSync) {\n+                if (existing != null) {\n+                    exchange.setProperty(Exchange.FILTER_MATCHED, existing);\n+                } else {\n+                    exchange.removeProperty(Exchange.FILTER_MATCHED);\n                 }\n+                callback.done(doneSync);\n             }\n+        };\n \n-        LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n+        // as we only pick one processor to process, then no need to have async callback that has a while loop as well\n+        // as this should not happen, eg we pick the first filter processor that matches, or the otherwise (if present)\n+        // and if not, we just continue without using any processor\n+        while (processors.hasNext()) {\n+            // get the next processor\n+            Processor processor = processors.next();\n \n-        callback.done(true);\n+            // evaluate the predicate on filter predicate early to be faster\n+            // and avoid issues when having nested choices\n+            // as we should only pick one processor\n+            boolean matches = true;\n+            if (processor instanceof FilterProcessor) {\n+                FilterProcessor filter = (FilterProcessor) processor;\n+                try {\n+                    matches = filter.getPredicate().matches(exchange);\n+                    exchange.setProperty(Exchange.FILTER_MATCHED, matches);\n+                } catch (Throwable e) {\n+                    exchange.setException(e);\n+                    choiceCallback.done(true);\n                     return true;\n                 }\n-\n-    protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {\n-        boolean answer = it.hasNext();\n-        if (answer) {\n-            Object matched = exchange.getProperty(Exchange.FILTER_MATCHED);\n-            if (matched != null) {\n-                boolean hasMatched = exchange.getContext().getTypeConverter().convertTo(Boolean.class, matched);\n-                if (hasMatched) {\n-                    LOG.debug(\"ExchangeId: {} has been matched: {}\", exchange.getExchangeId(), exchange);\n-                    answer = false;\n+                // as we have pre evaluated the predicate then use its processor directly when routing\n+                processor = filter.getProcessor();\n             }\n-            }\n-        }\n-        LOG.trace(\"ExchangeId: {} should continue matching: {}\", exchange.getExchangeId(), answer);\n-        return answer;\n-    }\n-\n-    private boolean process(final Exchange exchange, final AsyncCallback callback,\n-                            final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {\n-        // this does the actual processing so log at trace level\n-        LOG.trace(\"Processing exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n-\n-        // implement asynchronous routing logic in callback so we can have the callback being\n-        // triggered and then continue routing where we left\n-        boolean sync = asyncProcessor.process(exchange, new AsyncCallback() {\n-            public void done(boolean doneSync) {\n-                // we only have to handle async completion of the pipeline\n-                if (doneSync) {\n-                    return;\n-                }\n-\n-                // continue processing the pipeline asynchronously\n-                while (continueRouting(processors, exchange)) {\n-                    AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\n \n-                    // check for error if so we should break out\n-                    if (!continueProcessing(exchange, \"so breaking out of pipeline\", LOG)) {\n-                        break;\n+            // if we did not match then continue to next filter\n+            if (!matches) {\n+                continue;\n             }\n \n-                    doneSync = process(exchange, callback, processors, processor);\n-                    if (!doneSync) {\n-                        LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n-                        return;\n-                    }\n-                }\n-\n-                LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n-                callback.done(false);\n+            // okay we found a filter or its the otherwise we are processing\n+            AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n+            return async.process(exchange, choiceCallback);\n         }\n-        });\n \n-        return sync;\n+        // when no filter matches and there is no otherwise, then just continue\n+        choiceCallback.done(true);\n+        return true;\n     }\n \n     @Override\n", "nb_test": 4665, "linesAdd": 33, "jira_id": "6447", "singleLine": false, "nb_skipped": 1, "commit": "020c451a", "nb_failure": 8, "linesRem": 65}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["AggregationStrategyBeanAdapterAllowNullTest>TestSupport.runBare:58->ContextTestSupport.setUp:117->ContextTestSupport.startCamelContext:174 \u00bb IllegalArgument"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregationStrategyBeanInfo.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregationStrategyBeanInfo.java\nindex f898be7..ed93a96e 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregationStrategyBeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregationStrategyBeanInfo.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.camel.processor.aggregate;\n \n+import java.lang.annotation.Annotation;\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.List;\n@@ -62,10 +63,11 @@ protected AggregationStrategyMethodInfo createMethodInfo() {\n         }\n \n         // must not have annotations as they are not supported (yet)\n-        for (int i = 0; i < size; i++) {\n-            Class<?> type = parameterTypes[i];\n-            if (type.getAnnotations().length > 0) {\n-                throw new IllegalArgumentException(\"Parameter annotations at index \" + i + \" is not supported on method: \" + method);\n+        Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n+        for (int i = 0; i < parameterAnnotations.length; i++) {\n+            Annotation[] annotations = parameterAnnotations[i];\n+            if (annotations.length > 0) {\n+                throw new IllegalArgumentException(\"Method parameter annotation: \" + annotations[0] + \" at index: \" + i + \" is not supported on method: \" + method);\n             }\n         }\n \n", "nb_test": 4979, "linesAdd": 6, "jira_id": "7513", "singleLine": false, "nb_skipped": 3, "commit": "85ced066", "nb_failure": 0, "linesRem": 4}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testInOnly(org.apache.camel.component.seda.SedaWaitForTaskCompleteTest)", "testInOnly(org.apache.camel.component.vm.VmWaitForTaskCompleteTest)", "testMulticastPipelineAggregateIssue(org.apache.camel.issues.MulticastPipelineAggregateIssueTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\nindex 0aa9501..7b59811 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n@@ -208,11 +208,15 @@ public static void copyResults(Exchange result, Exchange source) {\n                 // have created any OUT; such as a mock:endpoint\n                 // so lets assume the last IN is the OUT\n                 if (result.getPattern().isOutCapable()) {\n-                    // only set OUT if its OUT capable\n+                    // only set OUT if its OUT capable or already has OUT\n                     result.getOut().copyFrom(source.getIn());\n                 } else {\n                     // if not replace IN instead to keep the MEP\n                     result.getIn().copyFrom(source.getIn());\n+                    // clear any existing OUT as the result is on the IN\n+                    if (result.hasOut()) {\n+                        result.setOut(null);\n+                    }\n                 }\n             }\n \n", "nb_test": 2911, "linesAdd": 3, "jira_id": "3276", "singleLine": false, "nb_skipped": 0, "commit": "205420e2", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["BeanHandlerMethodTest>TestSupport.runBare:58->testInterfaceBeanMethod:38 expected:<[hello]> but was:<[doCompute]>", "VmMultipleConsumersMultipleContextTest>TestSupport.runBare:58->testVmMultipleConsumersDifferentEndpoints:145 mock://route1 Received message count. Expected: <100> but was: <76>", "VmMultipleContextsStartStopTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb IllegalArgument", "VmQueueTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:48 \u00bb FailedToCreateRoute", "VmShouldNotUseSameThreadTest>TestSupport.runBare:58->AbstractVmTestSupport.setUp:39->ContextTestSupport.setUp:117->ContextTestSupport.startCamelContext:174 \u00bb IllegalArgument"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex d3c7214..a2f6ce8 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -987,7 +987,9 @@ private void removeAllAbstractMethods(List<MethodInfo> methods) {\n         Iterator<MethodInfo> it = methods.iterator();\n         while (it.hasNext()) {\n             MethodInfo info = it.next();\n-            if (Modifier.isAbstract(info.getMethod().getModifiers())) {\n+            // if the class is an interface then keep the method\n+            boolean isFromInterface = Modifier.isInterface(info.getMethod().getDeclaringClass().getModifiers());\n+            if (!isFromInterface && Modifier.isAbstract(info.getMethod().getModifiers())) {\n                 // we cannot invoke an abstract method\n                 it.remove();\n             }\n", "nb_test": 5464, "linesAdd": 2, "jira_id": "9243", "singleLine": false, "nb_skipped": 4, "commit": "1957a828", "nb_failure": 2, "linesRem": 1}, {"files": 3, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["MessageHistoryCopyExchangeTest>TestSupport.runBare:58->testDefensiveCopyOfMessageHistory:44 expected not same"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\nindex b755b70..2c4a615 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\n@@ -26,6 +26,7 @@\n import org.apache.camel.Exchange;\n import org.apache.camel.ExchangePattern;\n import org.apache.camel.Message;\n+import org.apache.camel.MessageHistory;\n import org.apache.camel.spi.Synchronization;\n import org.apache.camel.spi.UnitOfWork;\n import org.apache.camel.util.ExchangeHelper;\n@@ -95,10 +96,18 @@ public Exchange copy() {\n         return exchange;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private static Map<String, Object> safeCopy(Map<String, Object> properties) {\n         if (properties == null) {\n             return null;\n         }\n+\n+        // safe copy message history using a defensive copy\n+        List<MessageHistory> history = (List<MessageHistory>) properties.remove(Exchange.MESSAGE_HISTORY);\n+        if (history != null) {\n+            properties.put(Exchange.MESSAGE_HISTORY, new ArrayList<MessageHistory>(history));\n+        }\n+\n         return new ConcurrentHashMap<String, Object>(properties);\n     }\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\nindex 76b5e02..a9dd334 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n@@ -252,6 +252,8 @@ private static Exchange copyExchangeNoAttachments(Exchange exchange, boolean pre\n         Exchange answer = ExchangeHelper.createCopy(exchange, preserveExchangeId);\n         // we do not want attachments for the splitted sub-messages\n         answer.getIn().setAttachments(null);\n+        // we do not want to copy the message history for splitted sub-messages\n+        answer.getProperties().remove(Exchange.MESSAGE_HISTORY);\n         return answer;\n     }\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\nindex b6f04d8..bc9943d 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n@@ -16,7 +16,9 @@\n  */\n package org.apache.camel.util;\n \n+import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ExecutionException;\n@@ -32,6 +34,7 @@\n import org.apache.camel.ExchangePattern;\n import org.apache.camel.InvalidPayloadException;\n import org.apache.camel.Message;\n+import org.apache.camel.MessageHistory;\n import org.apache.camel.NoSuchBeanException;\n import org.apache.camel.NoSuchEndpointException;\n import org.apache.camel.NoSuchHeaderException;\n@@ -813,10 +816,18 @@ public static Exchange copyExchangeAndSetCamelContext(Exchange exchange, CamelCo\n         return answer;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private static Map<String, Object> safeCopy(Map<String, Object> properties) {\n         if (properties == null) {\n             return null;\n         }\n+\n+        // safe copy message history using a defensive copy\n+        List<MessageHistory> history = (List<MessageHistory>) properties.remove(Exchange.MESSAGE_HISTORY);\n+        if (history != null) {\n+            properties.put(Exchange.MESSAGE_HISTORY, new ArrayList<MessageHistory>(history));\n+        }\n+\n         return new ConcurrentHashMap<String, Object>(properties);\n     }\n }\n", "nb_test": 4700, "linesAdd": 19, "jira_id": "6723", "singleLine": false, "nb_skipped": 1, "commit": "b92d6237", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["NotifyBuilderFromRouteTest>TestSupport.runBare:58->testDoneFromRoute:40 null"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\nindex 1c42ad9..e5933494 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\n@@ -154,6 +154,11 @@ public boolean isAbstract() {\n             @Override\n             public boolean onExchange(Exchange exchange) {\n                 String id = EndpointHelper.getRouteIdFromEndpoint(exchange.getFromEndpoint());\n+\n+                if (id == null) {\n+                    id = exchange.getFromRouteId();\n+                }\n+\n                 // filter non matching exchanges\n                 return EndpointHelper.matchPattern(id, routeId);\n             }\n", "nb_test": 5469, "linesAdd": 5, "jira_id": "9269", "singleLine": false, "nb_skipped": 4, "commit": "62b2042b", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["CircuitBreakerLoadBalancerTest>TestSupport.runBare:58->testHalfOpenAfterTimeoutSync:107->halfOpenAfterTimeout:129->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Received message count. Expected: <2> but was: <3>", "CircuitBreakerLoadBalancerTest>TestSupport.runBare:58->testHalfOpenAfterTimeoutAsync:112->halfOpenAfterTimeout:129->ContextTestSupport.assertMockEndpointsSatisfied:343 mock://result Received message count. Expected: <2> but was: <3>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java b/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\nindex f760311..645b477 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\n@@ -200,11 +200,6 @@ private boolean executeProcessor(final Exchange exchange, final AsyncCallback ca\n \n     private boolean rejectExchange(final Exchange exchange, final AsyncCallback callback) {\n         exchange.setException(new RejectedExecutionException(\"CircuitBreaker Open: failures: \" + failures + \", lastFailure: \" + lastFailure));\n-        /*\n-         * If the circuit opens, we have to prevent the execution of any\n-         * processor. The failures count can be set to 0.\n-         */\n-        failures.set(0);\n         callback.done(true);\n         return true;\n     }\n", "nb_test": 5293, "linesAdd": 0, "jira_id": "8584", "singleLine": true, "nb_skipped": 4, "commit": "dd0f74c0", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 5, "classification": {"singleLine": false}, "failing_tests": ["testManagedThreadPool(org.apache.camel.management.ManagedThreadPoolProfileTest)", "testManagedThreadPool(org.apache.camel.management.DualManagedThreadPoolProfileTest)", "testManagedThreadPool(org.apache.camel.management.ManagedThreadPoolTest)", "testManagedThreadPool(org.apache.camel.management.ManagedThreadPoolWithIdTest)", "testManagedThreadPool(org.apache.camel.management.DualManagedThreadPoolWithIdTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementNamingStrategy.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementNamingStrategy.java\nindex 473c07f..ef21e26 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementNamingStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementNamingStrategy.java\n@@ -254,11 +254,13 @@ public ObjectName getObjectNameForThreadPool(CamelContext context, ThreadPoolExe\n         buffer.append(domainName).append(\":\");\n         buffer.append(KEY_CONTEXT + \"=\").append(getContextId(context)).append(\",\");\n         buffer.append(KEY_TYPE + \"=\" + TYPE_THREAD_POOL + \",\");\n-        buffer.append(KEY_NAME + \"=\").append(id);\n+\n+        String name = id;\n         if (sourceId != null) {\n             // provide source id if we know it, this helps end user to know where the pool is used\n-            buffer.append(\"(\").append(sourceId).append(\")\");\n+            name = name + \"(\" + sourceId + \")\";\n         }\n+        buffer.append(KEY_NAME + \"=\").append(ObjectName.quote(name));\n         return createObjectName(buffer);\n     }\n \n", "nb_test": 3243, "linesAdd": 4, "jira_id": "3760", "singleLine": false, "nb_skipped": 0, "commit": "5225e6e3", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testOnExceptionStreamReset(org.apache.camel.processor.onexception.OnExceptionUseOriginalMessageTest)", "testOnExceptionError(org.apache.camel.processor.onexception.OnExceptionUseOriginalMessageTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\nindex 51fe6bf..d7f11e0 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\n@@ -591,18 +591,23 @@ protected boolean deliverToFailureProcessor(final Processor processor, final Exc\n         // is the a failure processor to process the Exchange\n         if (processor != null) {\n \n-            // reset cached streams so they can be read again\n-            MessageHelper.resetStreamCache(exchange.getIn());\n-\n             // prepare original IN body if it should be moved instead of current body\n             if (data.useOriginalInMessage) {\n                 if (log.isTraceEnabled()) {\n                     log.trace(\"Using the original IN message instead of current\");\n                 }\n-\n                 Message original = exchange.getUnitOfWork().getOriginalInMessage();\n                 exchange.setIn(original);\n+                if (exchange.hasOut()) {\n+                    if (log.isTraceEnabled()) {\n+                        log.trace(\"Removing the out message to avoid some uncertain behavior\");\n                     }\n+                    exchange.setOut(null);\n+                }\n+            }\n+            \n+            // reset cached streams so they can be read again\n+            MessageHelper.resetStreamCache(exchange.getIn());\n \n             if (log.isTraceEnabled()) {\n                 log.trace(\"Failure processor \" + processor + \" is processing Exchange: \" + exchange);\n", "nb_test": 3245, "linesAdd": 8, "jira_id": "3791", "singleLine": false, "nb_skipped": 0, "commit": "52106681", "nb_failure": 1, "linesRem": 3}, {"files": 2, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["RouteSedaSuspendResumeTest>TestSupport.runBare:58->testSuspendResume:48 expected:<S[uspend]ed> but was:<S[tart]ed>", "ManagedThrottlerTest>TestSupport.runBare:58->testThrottleAsyncVisableViaJmx:197 expected:<10> but was:<9>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex c24674e..0ed913a 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -984,6 +984,9 @@ public synchronized void resumeRoute(String routeId) throws Exception {\n         RouteService routeService = routeServices.get(routeId);\n         if (routeService != null) {\n             resumeRouteService(routeService);\n+            // must resume the route as well\n+            Route route = getRoute(routeId);\n+            ServiceHelper.resumeService(route);\n         }\n     }\n \n@@ -1125,12 +1128,15 @@ public synchronized void suspendRoute(String routeId) throws Exception {\n         RouteService routeService = routeServices.get(routeId);\n         if (routeService != null) {\n             List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);\n-            RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);\n+            Route route = routeService.getRoutes().iterator().next();\n+            RouteStartupOrder order = new DefaultRouteStartupOrder(1, route, routeService);\n             routes.add(order);\n \n             getShutdownStrategy().suspend(this, routes);\n             // must suspend route service as well\n             suspendRouteService(routeService);\n+            // must suspend the route as well\n+            ServiceHelper.suspendService(route);\n         }\n     }\n \n@@ -1143,12 +1149,15 @@ public synchronized void suspendRoute(String routeId, long timeout, TimeUnit tim\n         RouteService routeService = routeServices.get(routeId);\n         if (routeService != null) {\n             List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);\n-            RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);\n+            Route route = routeService.getRoutes().iterator().next();\n+            RouteStartupOrder order = new DefaultRouteStartupOrder(1, route, routeService);\n             routes.add(order);\n \n             getShutdownStrategy().suspend(this, routes, timeout, timeUnit);\n             // must suspend route service as well\n             suspendRouteService(routeService);\n+            // must suspend the route as well\n+            ServiceHelper.suspendService(route);\n         }\n     }\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/util/ServiceHelper.java b/camel-core/src/main/java/org/apache/camel/util/ServiceHelper.java\nindex 0a7df51..90b5ce9 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/ServiceHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/ServiceHelper.java\n@@ -260,7 +260,7 @@ public static void stopAndShutdownServices(Collection<?> services) throws Except\n      * If there's any exception being thrown while resuming the elements one after the\n      * other this method would rethrow the <b>first</b> such exception being thrown.\n      * \n-     * @see #resumeService(Service)\n+     * @see #resumeService(Object)\n      */\n     public static void resumeServices(Collection<?> services) throws Exception {\n         if (services == null) {\n@@ -308,7 +308,7 @@ public static void resumeServices(Collection<?> services) throws Exception {\n      * @throws Exception is thrown if error occurred\n      * @see #startService(Service)\n      */\n-    public static boolean resumeService(Service service) throws Exception {\n+    public static boolean resumeService(Object service) throws Exception {\n         if (service instanceof SuspendableService) {\n             SuspendableService ss = (SuspendableService) service;\n             if (ss.isSuspended()) {\n@@ -331,7 +331,7 @@ public static boolean resumeService(Service service) throws Exception {\n      * If there's any exception being thrown while suspending the elements one after the\n      * other this method would rethrow the <b>first</b> such exception being thrown.\n      * \n-     * @see #suspendService(Service)\n+     * @see #suspendService(Object)\n      */\n     public static void suspendServices(Collection<?> services) throws Exception {\n         if (services == null) {\n@@ -379,7 +379,7 @@ public static void suspendServices(Collection<?> services) throws Exception {\n      * @throws Exception is thrown if error occurred\n      * @see #stopService(Object)\n      */\n-    public static boolean suspendService(Service service) throws Exception {\n+    public static boolean suspendService(Object service) throws Exception {\n         if (service instanceof SuspendableService) {\n             SuspendableService ss = (SuspendableService) service;\n             if (!ss.isSuspended()) {\n", "nb_test": 5358, "linesAdd": 10, "jira_id": "8964", "singleLine": false, "nb_skipped": 4, "commit": "ea8ee025", "nb_failure": 2, "linesRem": 4}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testTimerSuspendResume(org.apache.camel.component.timer.TimerSuspendCamelContextTest): mock://result Received message count. Expected: <0> but was: <4>", "testThreadNotUsedForEveryAggregatorWithCustomExecutorService(org.apache.camel.processor.aggregator.AggregateTimeoutWithExecutorServiceTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/timer/TimerConsumer.java b/camel-core/src/main/java/org/apache/camel/component/timer/TimerConsumer.java\nindex a2cf79e..13be495 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/timer/TimerConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/timer/TimerConsumer.java\n@@ -50,6 +50,11 @@ protected void doStart() throws Exception {\n \n             @Override\n             public void run() {\n+                if (!isTaskRunAllowed()) {\n+                    // do not run timer task as it was not allowed\n+                    return;\n+                }\n+\n                 try {\n                     long count = counter.incrementAndGet();\n \n@@ -80,6 +85,14 @@ protected void doStop() throws Exception {\n         task = null;\n     }\n \n+    /**\n+     * Whether the timer task is allow to run or not\n+     */\n+    protected boolean isTaskRunAllowed() {\n+        // only allow running the timer task if we can run and are not suspended\n+        return isRunAllowed() && !isSuspended();\n+    }\n+\n     protected void configureTask(TimerTask task, Timer timer) {\n         if (endpoint.isFixedRate()) {\n             if (endpoint.getTime() != null) {\n", "nb_test": 4147, "linesAdd": 8, "jira_id": "5137", "singleLine": false, "nb_skipped": 0, "commit": "afa1d132", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testInclude(org.apache.camel.component.file.AntPathMatcherGenericFileFilterTest): mock://result1 Message with body Hello World was expected but not found in []", "testMessageShouldGoToError(org.apache.camel.issues.RedeliveryPolicyOnExceptionWhileRedeliveringIssueTest): mock://destination Received message count. Expected: <0> but was: <1>", "testAggregateTimeout(org.apache.camel.processor.aggregator.AggregateTimeoutTest): expected:<1> but was:<0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/OnExceptionDefinition.java b/camel-core/src/main/java/org/apache/camel/model/OnExceptionDefinition.java\nindex 50a41a3..f8e42b9 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/OnExceptionDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/OnExceptionDefinition.java\n@@ -144,7 +144,7 @@ public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryP\n             return CamelContextHelper.mandatoryLookup(context, redeliveryPolicyRef, RedeliveryPolicy.class);\n         } else if (redeliveryPolicy != null) {\n             return redeliveryPolicy.createRedeliveryPolicy(context, parentPolicy);\n-        } else if (!outputs.isEmpty() && parentPolicy.getMaximumRedeliveries() > 0) {\n+        } else if (!outputs.isEmpty() && parentPolicy.getMaximumRedeliveries() != 0) {\n             // if we have outputs, then do not inherit parent maximumRedeliveries\n             // as you would have to explicit configure maximumRedeliveries on this onException to use it\n             // this is the behavior Camel has always had\n", "nb_test": 4289, "linesAdd": 1, "jira_id": "5570", "singleLine": false, "nb_skipped": 1, "commit": "a57830ed", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testHandleMethod(org.apache.camel.component.bean.BeanHandlerMethodPredicateTest): mock://result Body of message: 0. Expected: <Hi Camel> but was: <true>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java\nindex 536a07f..f3e5485 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java\n@@ -89,9 +89,10 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         }\n \n         // do we have a custom adapter for this POJO to a Processor\n-        // should not be invoked if an explicit method has been set\n+        // but only do this if allowed\n+        if (allowProcessor(explicitMethodName, beanInfo)) {\n             Processor processor = getProcessor();\n-        if (explicitMethodName == null && processor != null) {\n+            if (processor != null) {\n                 LOG.trace(\"Using a custom adapter as bean invocation: {}\", processor);\n                 try {\n                     processor.process(exchange);\n@@ -101,6 +102,7 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n                 callback.done(true);\n                 return true;\n             }\n+        }\n \n         Message in = exchange.getIn();\n \n@@ -253,4 +255,23 @@ protected void doStart() throws Exception {\n     protected void doStop() throws Exception {\n         ServiceHelper.stopService(getProcessor());\n     }\n+\n+    private boolean allowProcessor(String explicitMethodName, BeanInfo info) {\n+        if (explicitMethodName != null) {\n+            // don't allow if explicit method name is given, as we then must invoke this method\n+            return false;\n+        }\n+\n+        // don't allow if any of the methods has a @Handler annotation\n+        // as the @Handler annotation takes precedence and is supposed to trigger invocation\n+        // of the given method\n+        for (MethodInfo method : info.getMethods()) {\n+            if (method.hasHandlerAnnotation()) {\n+                return false;\n+            }\n+        }\n+\n+        // fallback and allow using the processor\n+        return true;\n+    }\n }\n", "nb_test": 4146, "linesAdd": 17, "jira_id": "5140", "singleLine": false, "nb_skipped": 0, "commit": "8898d491", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "camel", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["AdviceWithOnExceptionTest>TestSupport.runBare:58->testAdviceWithOnException:31 \u00bb IllegalArgument"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/AdviceWithTasks.java b/camel-core/src/main/java/org/apache/camel/builder/AdviceWithTasks.java\nindex 69f5a0a..694841c 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/AdviceWithTasks.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/AdviceWithTasks.java\n@@ -312,7 +312,7 @@ public void task() throws Exception {\n     /**\n      * Gets the outputs from the given parent.\n      * <p/>\n-     * This implementation deals with that outputs can be abstract and retrieves the correct non-nested output.\n+     * This implementation deals with that outputs can be abstract and retrieves the <i>correct</i> parent output.\n      *\n      * @param parent the parent\n      * @return <tt>null</tt> if no parent\n@@ -323,13 +323,10 @@ public void task() throws Exception {\n             return null;\n         }\n         List<ProcessorDefinition> outputs = parent.getOutputs();\n-        if (outputs.size() >= 1) {\n-            // if the 1st output is abstract, then its onException,transacted,intercept etc so we should\n-            // get the 'actual' outputs from that\n-            if (outputs.get(0).isAbstract()) {\n+        if (outputs.size() == 1 && outputs.get(0).isAbstract()) {\n+            // if the output is abstract then get its output, as\n             outputs = outputs.get(0).getOutputs();\n         }\n-        }\n         return outputs;\n     }\n \n", "nb_test": 5022, "linesAdd": 1, "jira_id": "7622", "singleLine": false, "nb_skipped": 3, "commit": "faa20255", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFailure(org.apache.camel.processor.LogEipPropagateExceptionTest): mock://exceptionFailure Received message count. Expected: <1> but was: <0>"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/LogProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/LogProcessor.java\nindex 94a4246..ced8977 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/LogProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/LogProcessor.java\n@@ -43,8 +43,15 @@ public void process(Exchange exchange) throws Exception {\n \n     @Override\n     public boolean process(Exchange exchange, AsyncCallback callback) {\n+        try {\n             String msg = expression.evaluate(exchange, String.class);\n             logger.log(msg);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            // callback must be invoked\n+            callback.done(true);\n+        }\n         return true;\n     }\n \n", "nb_test": 3743, "linesAdd": 6, "jira_id": "4388", "singleLine": false, "nb_skipped": 0, "commit": "f39bc60d", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "camel", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMissThenAddTypeConverter(org.apache.camel.impl.TypeConverterRegistryMissesThenAddTest)"], "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/converter/BaseTypeConverterRegistry.java b/camel-core/src/main/java/org/apache/camel/impl/converter/BaseTypeConverterRegistry.java\nindex ec766af..b3de5e6 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/converter/BaseTypeConverterRegistry.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/converter/BaseTypeConverterRegistry.java\n@@ -223,9 +223,7 @@ protected Object doConvertTo(final Class type, final Exchange exchange, final Ob\n         }\n \n         // Could not find suitable conversion, so remember it\n-        synchronized (misses) {\n         misses.put(key, key);\n-        }\n \n         // Could not find suitable conversion, so return Void to indicate not found\n         return Void.TYPE;\n@@ -243,6 +241,8 @@ public void addTypeConverter(Class<?> toType, Class<?> fromType, TypeConverter t\n                     log.warn(\"Overriding type converter from: \" + converter + \" to: \" + typeConverter);\n                 }\n                 typeMappings.put(key, typeConverter);\n+                // remove any previous misses, as we added the new type converter\n+                misses.remove(key);\n             }\n         }\n     }\n", "nb_test": 3253, "linesAdd": 1, "jira_id": "3847", "singleLine": false, "nb_skipped": 0, "commit": "de9399f3", "nb_failure": 1, "linesRem": 2}, {"files": 5, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["DeleteRowsCommandTest.testBeginRowHelp:26 -b should say it is NOT inclusive", "MergeCommandTest.testBeginRowHelp:26 -b should say it is NOT inclusive", "FlushCommandTest.testBeginRowHelp:26 -b should say it is NOT inclusive", "CompactCommandTest.testBeginRowHelp:26 -b should say it is NOT inclusive"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\nindex 536d6e6..bcad3a3 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\n@@ -260,7 +260,7 @@ Text getMaxRow(String tableName, Authorizations auths, Text startRow, boolean st\n    * @param start\n    *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n    * @param end\n-   *          last tablet to be merged contains this row, null means the last tablet in table\n+   *          last tablet to be compacted contains this row, null means the last tablet in table\n    * @param flush\n    *          when true, table memory is flushed before compaction starts\n    * @param wait\n@@ -276,7 +276,7 @@ Text getMaxRow(String tableName, Authorizations auths, Text startRow, boolean st\n    * @param start\n    *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n    * @param end\n-   *          last tablet to be merged contains this row, null means the last tablet in table\n+   *          last tablet to be compacted contains this row, null means the last tablet in table\n    * @param iterators\n    *          A set of iterators that will be applied to each tablet compacted\n    * @param flush\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\nindex 64968f0..6ffa3f4 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\n@@ -54,9 +54,7 @@ public int numArgs() {\n   public Options getOptions() {\n     final Options o = new Options();\n     forceOpt = new Option(\"f\", \"force\", false, \"delete data even if start or end are not specified\");\n-    startRowOptExclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\n-    startRowOptExclusive.setArgName(\"begin-row\");\n-    o.addOption(startRowOptExclusive);\n+    o.addOption(OptUtil.startRowOpt());\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(OptUtil.tableOpt(\"table to delete a row range from\"));\n     o.addOption(forceOpt);\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\nindex 9213a06..18d519d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\n@@ -96,9 +96,7 @@ public Options getOptions() {\n     sizeOpt = new Option(\"s\", \"size\", true, \"merge tablets to the given size over the entire table\");\n     forceOpt = new Option(\"f\", \"force\", false, \"merge small tablets to large tablets, even if it goes over the given size\");\n     allOpt = new Option(\"\", \"all\", false, \"allow an entire table to be merged into one tablet without prompting the user for confirmation\");\n-    Option startRowOpt = OptUtil.startRowOpt();\n-    startRowOpt.setDescription(\"begin row (NOT inclusive)\");\n-    o.addOption(startRowOpt);\n+    o.addOption(OptUtil.startRowOpt());\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(OptUtil.tableOpt(\"table to be merged\"));\n     o.addOption(verboseOpt);\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\nindex 9915bdf..432f17a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n@@ -117,7 +117,7 @@ public static OptionGroup addListDeleteGroup(final String name) {\n   }\n \n   public static Option startRowOpt() {\n-    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\n+    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (NOT) inclusive\");\n     o.setArgName(\"begin-row\");\n     return o;\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\nindex 9a0026a..60ae0a7 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\n@@ -57,6 +57,7 @@\n \n   protected Option timestampOpt;\n   private Option optStartRowExclusive;\n+  private Option optStartRowInclusive;\n   private Option optEndRowExclusive;\n   private Option timeoutOption;\n   private Option profileOpt;\n@@ -318,7 +319,9 @@ public Options getOptions() {\n \n     o.addOption(scanOptAuths);\n     o.addOption(scanOptRow);\n-    o.addOption(OptUtil.startRowOpt());\n+    optStartRowInclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\n+    optStartRowInclusive.setArgName(\"begin-row\");\n+    o.addOption(optStartRowInclusive);\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(optStartRowExclusive);\n     o.addOption(optEndRowExclusive);\n", "nb_test": 722, "linesAdd": 7, "jira_id": "4138", "singleLine": false, "nb_skipped": 2, "commit": "50db442b", "nb_failure": 4, "linesRem": 8}, {"files": 1, "project": "accumulo", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testTracedException(org.apache.accumulo.cloudtrace.instrument.TracerTest): Unexpected exception, expected<java.io.IOException> but was<java.lang.reflect.InvocationTargetException>", "testUntracedException(org.apache.accumulo.cloudtrace.instrument.TracerTest): Unexpected exception, expected<java.io.IOException> but was<java.lang.reflect.InvocationTargetException>"], "patch": "diff --git a/src/trace/src/main/java/org/apache/accumulo/cloudtrace/instrument/TraceProxy.java b/src/trace/src/main/java/org/apache/accumulo/cloudtrace/instrument/TraceProxy.java\nindex 67c4463..6b71361 100644\n--- a/src/trace/src/main/java/org/apache/accumulo/cloudtrace/instrument/TraceProxy.java\n+++ b/src/trace/src/main/java/org/apache/accumulo/cloudtrace/instrument/TraceProxy.java\n@@ -17,11 +17,14 @@\n package org.apache.accumulo.cloudtrace.instrument;\n \n import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Proxy;\n \n+import org.apache.log4j.Logger;\n+\n public class TraceProxy {\n-  // private static final Logger log = Logger.getLogger(TraceProxy.class);\n+  private static final Logger log = Logger.getLogger(TraceProxy.class);\n \n   static final Sampler ALWAYS = new Sampler() {\n     @Override\n@@ -39,19 +42,29 @@ public boolean next() {\n     InvocationHandler handler = new InvocationHandler() {\n       @Override\n       public Object invoke(Object obj, Method method, Object[] args) throws Throwable {\n-        if (!sampler.next()) {\n-          return method.invoke(instance, args);\n+        Span span = null;\n+        if (sampler.next()) {\n+          span = Trace.on(method.getName());\n         }\n-        Span span = Trace.on(method.getName());\n         try {\n           return method.invoke(instance, args);\n-        } catch (Throwable ex) {\n-          ex.printStackTrace();\n-          throw ex;\n+          // Can throw RuntimeException, Error, or any checked exceptions of the method.\n+        } catch (InvocationTargetException ite) {\n+          Throwable cause = ite.getCause();\n+          if (cause == null) {\n+            // This should never happen, but account for it anyway\n+            log.error(\"Invocation exception during trace with null cause: \", ite);\n+            throw new RuntimeException(ite);\n+          }\n+          throw cause;\n+        } catch (IllegalAccessException e) {\n+          throw new RuntimeException(e);\n         } finally {\n+          if (span != null) {\n             span.stop();\n           }\n         }\n+      }\n     };\n     return (T) Proxy.newProxyInstance(instance.getClass().getClassLoader(), instance.getClass().getInterfaces(), handler);\n   }\n", "nb_test": 6, "linesAdd": 18, "jira_id": "2390", "singleLine": false, "nb_skipped": 0, "commit": "28294266", "nb_failure": 0, "linesRem": 6}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["readWriteBatchOneShotWithColumnFamilyOnly(org.apache.accumulo.proxy.TestProxyReadWrite): expected:<100000> but was:<50000>", "readWriteBatchOneShotWithFullColumn(org.apache.accumulo.proxy.TestProxyReadWrite): expected:<100000> but was:<50000>"], "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex 911d187..167cecc 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -819,7 +819,17 @@ public String createBatchScanner(ByteBuffer login, String tableName, BatchScanOp\n           }\n         }\n         scanner.setRanges(ranges);\n+\n+        if (opts.columns != null) {\n+          for (ScanColumn col : opts.columns) {\n+            if (col.isSetColQualifier())\n+              scanner.fetchColumn(ByteBufferUtil.toText(col.colFamily), ByteBufferUtil.toText(col.colQualifier));\n+            else\n+              scanner.fetchColumnFamily(ByteBufferUtil.toText(col.colFamily));\n+          }\n         }\n+      }\n+\n       UUID uuid = UUID.randomUUID();\n       \n       ScannerPlusIterator spi = new ScannerPlusIterator();\n", "nb_test": 24, "linesAdd": 10, "jira_id": "1183", "singleLine": false, "nb_skipped": 0, "commit": "742960f1", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test(org.apache.accumulo.core.cli.TestClientOpts): expected null, but was:<org.apache.accumulo.core.security.tokens.PasswordToken@fee189f1>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/cli/ClientOpts.java b/core/src/main/java/org/apache/accumulo/core/cli/ClientOpts.java\nindex 50d7398..e426c4a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/cli/ClientOpts.java\n+++ b/core/src/main/java/org/apache/accumulo/core/cli/ClientOpts.java\n@@ -104,7 +104,7 @@ public ColumnVisibility convert(String value) {\n   public String principal = System.getProperty(\"user.name\");\n   \n   @Parameter(names = \"-p\", converter = PasswordConverter.class, description = \"Connection password\")\n-  public Password password = new Password(\"secret\");\n+  public Password password = null;\n   \n   @Parameter(names = \"--password\", converter = PasswordConverter.class, description = \"Enter the connection password\", password = true)\n   public Password securePassword = null;\n@@ -112,7 +112,7 @@ public ColumnVisibility convert(String value) {\n   public SecurityToken getToken() {\n     PasswordToken pt = new PasswordToken();\n     if (securePassword == null) {\n-      if (password.value == null)\n+      if (password == null)\n         return null;\n       return pt.setPassword(password.value);\n     }\n", "nb_test": 364, "linesAdd": 2, "jira_id": "1120", "singleLine": false, "nb_skipped": 0, "commit": "474b2577", "nb_failure": 1, "linesRem": 2}, {"files": 3, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTableIdMap(org.apache.accumulo.core.client.mock.MockTableOperationsTest): Values should be different. Actual: foo"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockAccumulo.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockAccumulo.java\nindex 5977d1d..272d1af 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockAccumulo.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockAccumulo.java\n@@ -21,6 +21,7 @@\n import java.util.HashMap;\n import java.util.Map;\n import java.util.SortedSet;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.accumulo.core.Constants;\n import org.apache.accumulo.core.client.BatchScanner;\n@@ -38,6 +39,7 @@\n   final Map<String,String> systemProperties = new HashMap<String,String>();\n   Map<String,MockUser> users = new HashMap<String,MockUser>();\n   final FileSystem fs;\n+  final AtomicInteger tableIdCounter = new AtomicInteger(0);\n   \n   MockAccumulo(FileSystem fs) {\n     this.fs = fs;\n@@ -76,7 +78,7 @@ public BatchScanner createBatchScanner(String tableName, Authorizations authoriz\n   }\n   \n   public void createTable(String username, String tableName, boolean useVersions, TimeType timeType) {\n-    MockTable t = new MockTable(useVersions, timeType);\n+    MockTable t = new MockTable(useVersions, timeType, Integer.toString(tableIdCounter.incrementAndGet()));\n     t.userPermissions.put(username, EnumSet.allOf(TablePermission.class));\n     tables.put(tableName, t);\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex 3dcab11..2e13d84 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -89,9 +89,11 @@ public int compareTo(Key o) {\n   private TimeType timeType;\n   SortedSet<Text> splits = new ConcurrentSkipListSet<Text>();\n   Map<String,Set<Text>> localityGroups = new TreeMap<String, Set<Text>>();\n+  private String tableId;\n   \n-  MockTable(boolean limitVersion, TimeType timeType) {\n+  MockTable(boolean limitVersion, TimeType timeType, String tableId) {\n     this.timeType = timeType;\n+    this.tableId = tableId;\n     settings = IteratorUtil.generateInitialTableProperties(limitVersion);\n     for (Entry<String,String> entry : AccumuloConfiguration.getDefaultConfiguration()) {\n       String key = entry.getKey();\n@@ -143,4 +145,8 @@ public void merge(Text start, Text end) {\n     if (reAdd)\n       splits.add(start);\n   }\n+\n+  public String getTableId() {\n+    return this.tableId;\n+  }\n }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex 64f8225..5b15351 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -296,8 +296,8 @@ public void clearLocatorCache(String tableName) throws TableNotFoundException {\n   @Override\n   public Map<String,String> tableIdMap() {\n     Map<String,String> result = new HashMap<String,String>();\n-    for (String table : acu.tables.keySet()) {\n-      result.put(table, table);\n+    for (Entry<String,MockTable> entry : acu.tables.entrySet()) {\n+      result.put(entry.getKey(), entry.getValue().getTableId());\n     }\n     return result;\n   }\n", "nb_test": 413, "linesAdd": 12, "jira_id": "2857", "singleLine": false, "nb_skipped": 0, "commit": "9fcca2ed", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["multipleStopsIsAllowed(org.apache.accumulo.minicluster.MiniAccumuloClusterStartStopTest)"], "patch": "diff --git a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\nindex 7a9bc0d..8246c51 100644\n--- a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n+++ b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n@@ -53,6 +53,8 @@\n import org.apache.log4j.Logger;\n import org.apache.zookeeper.server.ZooKeeperServerMain;\n \n+import com.google.common.base.Preconditions;\n+\n /**\n  * A utility class that will create Zookeeper and Accumulo processes that write all of their data to a single local directory. This class makes it easy to test\n  * code against a real Accumulo instance. Its much more accurate for testing than MockAccumulo, but much slower than MockAccumulo.\n@@ -306,7 +308,7 @@ public MiniAccumuloCluster(MiniAccumuloConfig config) throws IOException {\n    * @throws IllegalStateException\n    *           if already started\n    */\n-  public void start() throws IOException, InterruptedException {\n+  public synchronized void start() throws IOException, InterruptedException {\n     if (zooKeeperProcess != null)\n       throw new IllegalStateException(\"Already started\");\n     \n@@ -365,10 +367,15 @@ public String getZooKeepers() {\n   }\n   \n   /**\n-   * Stops Accumulo and Zookeeper processes. If stop is not called, there is a shutdown hook that is setup to kill the processes. Howerver its probably best to\n+   * Stops Accumulo and Zookeeper processes. If stop is not called, there is a shutdown hook that is setup to kill the processes. However its probably best to\n    * call stop in a finally block as soon as possible.\n    */\n-  public void stop() throws IOException, InterruptedException {\n+  public synchronized void stop() throws IOException, InterruptedException {\n+    if (null == executor) {\n+      // keep repeated calls to stop() from failing\n+      return;\n+    }\n+\n     if (zooKeeperProcess != null) {\n       try {\n         stopProcessWithTimeout(zooKeeperProcess, 30, TimeUnit.SECONDS);\n@@ -436,6 +443,7 @@ protected ExecutorService getShutdownExecutor() {\n   }\n   \n   private int stopProcessWithTimeout(final Process proc, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n+    Preconditions.checkNotNull(executor, \"Executor was already null\");\n     FutureTask<Integer> future = new FutureTask<Integer>(new Callable<Integer>() {\n       @Override\n       public Integer call() throws InterruptedException {\n", "nb_test": 5, "linesAdd": 9, "jira_id": "3055", "singleLine": false, "nb_skipped": 0, "commit": "94c2a31f", "nb_failure": 0, "linesRem": 2}, {"files": 2, "project": "accumulo", "nb_error": 16, "classification": {"singleLine": false}, "failing_tests": ["test(org.apache.accumulo.core.client.mapred.AccumuloRowInputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testMap(org.apache.accumulo.core.client.mapred.AccumuloInputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testMap(org.apache.accumulo.core.client.mapred.AccumuloMultiTableInputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testMR(org.apache.accumulo.core.client.mapred.AccumuloOutputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testEmptyWrite(org.apache.accumulo.core.client.mapred.AccumuloFileOutputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testRealWrite(org.apache.accumulo.core.client.mapred.AccumuloFileOutputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "writeBadVisibility(org.apache.accumulo.core.client.mapred.AccumuloFileOutputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testMR(org.apache.accumulo.core.client.mapred.TokenFileTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "test(org.apache.accumulo.core.client.mapreduce.AccumuloRowInputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testMap(org.apache.accumulo.core.client.mapreduce.AccumuloInputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testMap(org.apache.accumulo.core.client.mapreduce.AccumuloMultiTableInputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testMR(org.apache.accumulo.core.client.mapreduce.AccumuloOutputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testEmptyWrite(org.apache.accumulo.core.client.mapreduce.AccumuloFileOutputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testRealWrite(org.apache.accumulo.core.client.mapreduce.AccumuloFileOutputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "writeBadVisibility(org.apache.accumulo.core.client.mapreduce.AccumuloFileOutputFormatTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000", "testMR(org.apache.accumulo.core.client.mapreduce.TokenFileTest): java.lang.RuntimeException: Failed to connect to zookeeper (localhost) within 2x zookeeper timeout period 30000"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapred/AbstractInputFormat.java b/core/src/main/java/org/apache/accumulo/core/client/mapred/AbstractInputFormat.java\nindex c89c5d7..eaf99cb 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapred/AbstractInputFormat.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapred/AbstractInputFormat.java\n@@ -371,6 +371,8 @@ public void initialize(InputSplit inSplit, JobConf job) throws IOException {\n         log.debug(\"Authorizations are: \" + authorizations);\n         if (tableConfig.isOfflineScan()) {\n           scanner = new OfflineScanner(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n+        } else if (instance instanceof MockInstance) {\n+          scanner = instance.getConnector(principal, token).createScanner(split.getTableName(), authorizations);\n         } else {\n           scanner = new ScannerImpl(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n         }\n@@ -382,7 +384,7 @@ public void initialize(InputSplit inSplit, JobConf job) throws IOException {\n           log.info(\"Using local iterators\");\n           scanner = new ClientSideIteratorScanner(scanner);\n         }\n-        setupIterators(job, scanner, split.getTableId());\n+        setupIterators(job, scanner, split.getTableName());\n       } catch (Exception e) {\n         throw new IOException(e);\n       }\n@@ -460,7 +462,11 @@ public float getProgress() throws IOException {\n       TabletLocator tl;\n       try {\n         // resolve table name to id once, and use id from this point forward\n-        tableId = Tables.getTableId(getInstance(job), tableName);\n+        Instance instance = getInstance(job);\n+        if (instance instanceof MockInstance)\n+          tableId = \"\";\n+        else\n+          tableId = Tables.getTableId(instance, tableName);\n         if (tableConfig.isOfflineScan()) {\n           binnedRanges = binOfflineTable(job, tableId, ranges);\n           while (binnedRanges == null) {\n@@ -469,7 +475,6 @@ public float getProgress() throws IOException {\n             binnedRanges = binOfflineTable(job, tableId, ranges);\n           }\n         } else {\n-          Instance instance = getInstance(job);\n           tl = getTabletLocator(job, tableId);\n           // its possible that the cache could contain complete, but old information about a tables tablets... so clear it\n           tl.invalidateCache();\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/AbstractInputFormat.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/AbstractInputFormat.java\nindex 74f8f8b..d426caf 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/AbstractInputFormat.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/AbstractInputFormat.java\n@@ -386,6 +386,8 @@ public void initialize(InputSplit inSplit, TaskAttemptContext attempt) throws IO\n         log.debug(\"Authorizations are: \" + authorizations);\n         if (tableConfig.isOfflineScan()) {\n           scanner = new OfflineScanner(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n+        } else if (instance instanceof MockInstance) {\n+          scanner = instance.getConnector(principal, token).createScanner(split.getTableName(), authorizations);\n         } else {\n           scanner = new ScannerImpl(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n         }\n@@ -397,7 +399,7 @@ public void initialize(InputSplit inSplit, TaskAttemptContext attempt) throws IO\n           log.info(\"Using local iterators\");\n           scanner = new ClientSideIteratorScanner(scanner);\n         }\n-        setupIterators(attempt, scanner, split.getTableId());\n+        setupIterators(attempt, scanner, split.getTableName());\n       } catch (Exception e) {\n         throw new IOException(e);\n       }\n@@ -488,7 +490,11 @@ public V getCurrentValue() throws IOException, InterruptedException {\n       TabletLocator tl;\n       try {\n         // resolve table name to id once, and use id from this point forward\n-        tableId = Tables.getTableId(getInstance(context), tableName);\n+        Instance instance = getInstance(context);\n+        if (instance instanceof MockInstance)\n+          tableId = \"\";\n+        else\n+          tableId = Tables.getTableId(instance, tableName);\n         if (tableConfig.isOfflineScan()) {\n           binnedRanges = binOfflineTable(context, tableId, ranges);\n           while (binnedRanges == null) {\n@@ -498,7 +504,6 @@ public V getCurrentValue() throws IOException, InterruptedException {\n \n           }\n         } else {\n-          Instance instance = getInstance(context);\n           tl = getTabletLocator(context, tableId);\n           // its possible that the cache could contain complete, but old information about a tables tablets... so clear it\n           tl.invalidateCache();\n", "nb_test": 510, "linesAdd": 16, "jira_id": "1732", "singleLine": false, "nb_skipped": 0, "commit": "941e3cb1", "nb_failure": 0, "linesRem": 6}, {"files": 0, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "", "nb_test": 4, "linesAdd": 0, "jira_id": "366", "singleLine": false, "nb_skipped": 0, "commit": "db4a291f", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAllFieldsWritable(org.apache.accumulo.core.client.mapred.RangeInputSplitTest): expected:<[name:SummingCombiner, priority:50, class:org.apache.accumulo.core.iterators.user.SummingCombiner, properties:{foo=bar}, name:WholeRowIterator, priority:100, class:org.apache.accumulo.core.iterators.user.WholeRowIterator, properties:{bar=foo}]> but was:<null>", "testAllFieldsWritable(org.apache.accumulo.core.client.mapreduce.RangeInputSplitTest): expected:<[name:SummingCombiner, priority:50, class:org.apache.accumulo.core.iterators.user.SummingCombiner, properties:{foo=bar}, name:WholeRowIterator, priority:100, class:org.apache.accumulo.core.iterators.user.WholeRowIterator, properties:{bar=foo}]> but was:<null>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\nindex 73c9b59..05316a1 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n@@ -205,6 +205,14 @@ public void readFields(DataInput in) throws IOException {\n     }\n \n     if (in.readBoolean()) {\n+      int numIterators = in.readInt();\n+      iterators = new ArrayList<IteratorSetting>(numIterators);\n+      for (int i = 0; i < numIterators; i++) {\n+        iterators.add(new IteratorSetting(in));\n+      }\n+    }\n+\n+    if (in.readBoolean()) {\n       level = Level.toLevel(in.readInt());\n     }\n   }\n@@ -275,6 +283,14 @@ public void write(DataOutput out) throws IOException {\n       out.writeUTF(zooKeepers);\n     }\n \n+    out.writeBoolean(null != iterators);\n+    if (null != iterators) {\n+      out.writeInt(iterators.size());\n+      for (IteratorSetting iterator : iterators) {\n+        iterator.write(out);\n+      }\n+    }\n+\n     out.writeBoolean(null != level);\n     if (null != level) {\n       out.writeInt(level.toInt());\n", "nb_test": 421, "linesAdd": 16, "jira_id": "2962", "singleLine": false, "nb_skipped": 0, "commit": "2fd7633f", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testUpdate(org.apache.accumulo.core.client.mock.MockConnectorTest): null expected:<[9]> but was:<[0]>"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex ae16709..2fe637a 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -69,9 +69,9 @@ public int compareTo(Key o) {\n       if (o instanceof MockMemKey) {\n         MockMemKey other = (MockMemKey) o;\n         if (count < other.count)\n-          return -1;\n-        if (count > other.count)\n           return 1;\n+        if (count > other.count)\n+          return -1;\n       } else {\n         return 1;\n       }\n", "nb_test": 270, "linesAdd": 2, "jira_id": "218", "singleLine": false, "nb_skipped": 0, "commit": "3d55560a", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test1(org.apache.accumulo.core.iterators.CombinerTest): expected:<[4]> but was:<[9]>"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\nindex 4da51d3..173b00d 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n@@ -152,15 +152,15 @@ public void next() throws IOException {\n   private Key workKey = new Key();\n   \n   /*\n-   * Sets the topKey and topValue based on the top key of the source. If the column of the source top key is in the set of combiners, or if there are no columns\n-   * in the set of combiners, topKey will be the top key of the source and topValue will be the result of the reduce method. Otherwise, topKey and topValue will\n-   * be null.\n+   * Sets the topKey and topValue based on the top key of the source. If the column of the source top key is in the set of combiners, topKey will be the top key\n+   * of the source and topValue will be the result of the reduce method. Otherwise, topKey and topValue will be unchanged. (They are always set to null before\n+   * this method is called.)\n    */\n   private void findTop() throws IOException {\n     // check if aggregation is needed\n     if (super.hasTop()) {\n       workKey.set(super.getTopKey());\n-      if (combiners.isEmpty() || combiners.contains(workKey)) {\n+      if (combiners.contains(workKey)) {\n         if (workKey.isDeleted())\n           return;\n         topKey = workKey;\n", "nb_test": 272, "linesAdd": 1, "jira_id": "151", "singleLine": false, "nb_skipped": 0, "commit": "b007b22e", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ZooAuthenticationKeyWatcherTest.missingKeyAfterGetChildren:333 \u00bb NoNode Keeper..."], "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/security/delegation/ZooAuthenticationKeyWatcher.java b/server/base/src/main/java/org/apache/accumulo/server/security/delegation/ZooAuthenticationKeyWatcher.java\nindex 2913343..fe4407e 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/security/delegation/ZooAuthenticationKeyWatcher.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/security/delegation/ZooAuthenticationKeyWatcher.java\n@@ -22,6 +22,7 @@\n \n import org.apache.accumulo.fate.zookeeper.ZooReader;\n import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.KeeperException.NoNodeException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.Watcher.Event.EventType;\n@@ -131,10 +132,15 @@ private int updateAuthKeys(String path) throws KeeperException, InterruptedExcep\n     int keysAdded = 0;\n     for (String child : zk.getChildren(path, this)) {\n       String childPath = path + \"/\" + child;\n+      try {\n         // Get the node data and reset the watcher\n         AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));\n         secretManager.addKey(key);\n         keysAdded++;\n+      } catch (NoNodeException e) {\n+        // The master expired(deleted) the key between when we saw it in getChildren() and when we went to add it to our secret manager.\n+        log.trace(\"{} was deleted when we tried to access it\", childPath);\n+      }\n     }\n     return keysAdded;\n   }\n", "nb_test": 290, "linesAdd": 5, "jira_id": "3634", "singleLine": false, "nb_skipped": 2, "commit": "9339ecf8", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["HistoryCommandTest.testCorrectNumbering:76 null"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/HistoryCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/HistoryCommand.java\nindex 9531d90..d6068ba 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/HistoryCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/HistoryCommand.java\n@@ -18,7 +18,6 @@\n \n import java.io.IOException;\n import java.util.Iterator;\n-import java.util.ListIterator;\n \n import jline.console.history.History.Entry;\n \n@@ -27,37 +26,31 @@\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.Option;\n import org.apache.commons.cli.Options;\n-import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+\n+import com.google.common.base.Function;\n+import com.google.common.collect.Iterators;\n \n public class HistoryCommand extends Command {\n   private Option clearHist;\n   private Option disablePaginationOpt;\n   \n-  @SuppressWarnings(\"unchecked\")\n   @Override\n   public int execute(final String fullCommand, final CommandLine cl, final Shell shellState) throws IOException {\n     if (cl.hasOption(clearHist.getOpt())) {\n       shellState.getReader().getHistory().clear();\n     } else {\n-      ListIterator<Entry> it = shellState.getReader().getHistory().entries();\n-      shellState.printLines(new HistoryLineIterator(it), !cl.hasOption(disablePaginationOpt.getOpt()));\n+      Iterator<Entry> source = shellState.getReader().getHistory().entries();\n+      Iterator<String> historyIterator = Iterators.transform(source, new Function<Entry,String>() {\n+        @Override\n+        public String apply(Entry input) {\n+          return String.format(\"%d: %s\", input.index() + 1, input.value());\n         }\n+      });\n \n-    return 0;\n+      shellState.printLines(historyIterator, !cl.hasOption(disablePaginationOpt.getOpt()));\n     }\n     \n-  /**\n-   * Decorator that converts an Iterator<History.Entry> to an Iterator<String>.\n-   */\n-  private static class HistoryLineIterator extends AbstractIteratorDecorator {\n-    public HistoryLineIterator(Iterator<Entry> iterator) {\n-      super(iterator);\n-    }\n-    \n-    @Override\n-    public String next() {\n-      return super.next().toString();\n-    }\n+    return 0;\n   }\n   \n   @Override\n", "nb_test": 640, "linesAdd": 11, "jira_id": "2742", "singleLine": false, "nb_skipped": 1, "commit": "1f7dd2d5", "nb_failure": 1, "linesRem": 15}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ClientConfigurationTest.testGetAllPropertiesWithPrefix:135 expected:<2> but was:<0>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java b/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\nindex a926d35..7aab80c 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\n@@ -302,8 +302,12 @@ private void checkType(ClientProperty property, PropertyType type) {\n   public Map<String,String> getAllPropertiesWithPrefix(ClientProperty property) {\n     checkType(property, PropertyType.PREFIX);\n \n-    Map<String,String> propMap = new HashMap<String,String>();\n-    Iterator<?> iter = this.getKeys(property.getKey());\n+    Map<String,String> propMap = new HashMap<>();\n+    String prefix = property.getKey();\n+    if (prefix.endsWith(\".\")) {\n+      prefix = prefix.substring(0, prefix.length() - 1);\n+    }\n+    Iterator<?> iter = this.getKeys(prefix);\n     while (iter.hasNext()) {\n       String p = (String) iter.next();\n       propMap.put(p, getString(p));\n", "nb_test": 786, "linesAdd": 6, "jira_id": "3746", "singleLine": false, "nb_skipped": 2, "commit": "47c64d9a", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["test1(org.apache.accumulo.core.iterators.user.RegExFilterTest)"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\nindex fcf77c4..0b3b73f 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n@@ -39,10 +39,10 @@\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n     RegExFilter result = new RegExFilter();\n     result.setSource(getSource().deepCopy(env));\n-    result.rowMatcher = rowMatcher.pattern().matcher(\"\");\n-    result.colfMatcher = colfMatcher.pattern().matcher(\"\");\n-    result.colqMatcher = colqMatcher.pattern().matcher(\"\");\n-    result.valueMatcher = valueMatcher.pattern().matcher(\"\");\n+    result.rowMatcher = copyMatcher(rowMatcher);\n+    result.colfMatcher = copyMatcher(colfMatcher);\n+    result.colqMatcher = copyMatcher(colqMatcher);\n+    result.valueMatcher = copyMatcher(valueMatcher);\n     result.orFields = orFields;\n     return result;\n   }\n@@ -61,6 +61,14 @@\n   \n   private ByteArrayBackedCharSequence babcs = new ByteArrayBackedCharSequence();\n   \n+  private Matcher copyMatcher(Matcher m)\n+  {\n+\t  if(m == null)\n+\t\t  return m;\n+\t  else\n+\t\t  return m.pattern().matcher(\"\");\n+  }\n+  \n   private boolean matches(Matcher matcher, ByteSequence bs) {\n     if (matcher != null) {\n       babcs.set(bs);\n", "nb_test": 279, "linesAdd": 12, "jira_id": "189", "singleLine": false, "nb_skipped": 0, "commit": "cd7feb4d", "nb_failure": 0, "linesRem": 4}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testTimestampFilter(org.apache.accumulo.core.iterators.user.FilterTest): java.text.ParseException: Unparseable date: \"100000101000000GMT\""], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java b/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\nindex 2dbfe66..49f0146 100644\n--- a/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\n@@ -17,8 +17,8 @@\n package org.apache.accumulo.core.iterators.user;\n \n import java.io.IOException;\n+import java.text.ParseException;\n import java.text.SimpleDateFormat;\n-import java.util.Date;\n import java.util.Map;\n import java.util.TimeZone;\n \n@@ -33,6 +33,7 @@\n  * A Filter that matches entries whose timestamps fall within a range.\n  */\n public class TimestampFilter extends Filter {\n+  private static final String LONG_PREFIX = \"LONG\";\n   private final SimpleDateFormat dateParser = initDateParser();\n   \n   private static SimpleDateFormat initDateParser() {\n@@ -86,10 +87,20 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n       throw new IllegalArgumentException(\"must have either start or end for \" + TimestampFilter.class.getName());\n     \n     try {\n-      if (hasStart)\n-        start = dateParser.parse(options.get(START)).getTime();\n-      if (hasEnd)\n-        end = dateParser.parse(options.get(END)).getTime();\n+      if (hasStart) {\n+        String s = options.get(START);\n+        if (s.startsWith(LONG_PREFIX))\n+          start = Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          start = dateParser.parse(s).getTime();\n+      }\n+      if (hasEnd) {\n+        String s = options.get(END);\n+        if (s.startsWith(LONG_PREFIX))\n+          end = Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          end = dateParser.parse(s).getTime();\n+      }\n     } catch (Exception e) {\n       throw new IllegalArgumentException(e);\n     }\n@@ -116,8 +127,8 @@ public IteratorOptions describeOptions() {\n     IteratorOptions io = super.describeOptions();\n     io.setName(\"tsfilter\");\n     io.setDescription(\"TimestampFilter displays entries with timestamps between specified values\");\n-    io.addNamedOption(\"start\", \"start timestamp (yyyyMMddHHmmssz)\");\n-    io.addNamedOption(\"end\", \"end timestamp (yyyyMMddHHmmssz)\");\n+    io.addNamedOption(\"start\", \"start timestamp (yyyyMMddHHmmssz or LONG<longstring>)\");\n+    io.addNamedOption(\"end\", \"end timestamp (yyyyMMddHHmmssz or LONG<longstring>)\");\n     io.addNamedOption(\"startInclusive\", \"true or false\");\n     io.addNamedOption(\"endInclusive\", \"true or false\");\n     return io;\n@@ -126,11 +137,27 @@ public IteratorOptions describeOptions() {\n   @Override\n   public boolean validateOptions(Map<String,String> options) {\n     super.validateOptions(options);\n+    boolean hasStart = false;\n+    boolean hasEnd = false;\n     try {\n-      if (options.containsKey(START))\n-        dateParser.parse(options.get(START));\n-      if (options.containsKey(END))\n-        dateParser.parse(options.get(END));\n+      if (options.containsKey(START)) {\n+        hasStart = true;\n+        String s = options.get(START);\n+        if (s.startsWith(LONG_PREFIX))\n+          Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          dateParser.parse(s);\n+      }\n+      if (options.containsKey(END)) {\n+        hasEnd = true;\n+        String s = options.get(END);\n+        if (s.startsWith(LONG_PREFIX))\n+          Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          dateParser.parse(s);\n+      }\n+      if (!hasStart && !hasEnd)\n+        return false;\n       if (options.get(START_INCL) != null)\n         Boolean.parseBoolean(options.get(START_INCL));\n       if (options.get(END_INCL) != null)\n@@ -185,8 +212,13 @@ public static void setRange(IteratorSetting is, String start, boolean startInclu\n    *          boolean indicating whether the start is inclusive\n    */\n   public static void setStart(IteratorSetting is, String start, boolean startInclusive) {\n-    is.addOption(START, start);\n-    is.addOption(START_INCL, Boolean.toString(startInclusive));\n+    SimpleDateFormat dateParser = initDateParser();\n+    try {\n+      long startTS = dateParser.parse(start).getTime();\n+      setStart(is, startTS, startInclusive);\n+    } catch (ParseException e) {\n+      throw new IllegalArgumentException(\"couldn't parse \" + start);\n+    }\n   }\n   \n   /**\n@@ -200,8 +232,13 @@ public static void setStart(IteratorSetting is, String start, boolean startInclu\n    *          boolean indicating whether the end is inclusive\n    */\n   public static void setEnd(IteratorSetting is, String end, boolean endInclusive) {\n-    is.addOption(END, end);\n-    is.addOption(END_INCL, Boolean.toString(endInclusive));\n+    SimpleDateFormat dateParser = initDateParser();\n+    try {\n+      long endTS = dateParser.parse(end).getTime();\n+      setEnd(is, endTS, endInclusive);\n+    } catch (ParseException e) {\n+      throw new IllegalArgumentException(\"couldn't parse \" + end);\n+    }\n   }\n   \n   /**\n@@ -248,8 +285,7 @@ public static void setRange(IteratorSetting is, long start, boolean startInclusi\n    *          boolean indicating whether the start is inclusive\n    */\n   public static void setStart(IteratorSetting is, long start, boolean startInclusive) {\n-    SimpleDateFormat dateParser = initDateParser();\n-    is.addOption(START, dateParser.format(new Date(start)));\n+    is.addOption(START, LONG_PREFIX + Long.toString(start));\n     is.addOption(START_INCL, Boolean.toString(startInclusive));\n   }\n   \n@@ -264,8 +300,7 @@ public static void setStart(IteratorSetting is, long start, boolean startInclusi\n    *          boolean indicating whether the end is inclusive\n    */\n   public static void setEnd(IteratorSetting is, long end, boolean endInclusive) {\n-    SimpleDateFormat dateParser = initDateParser();\n-    is.addOption(END, dateParser.format(new Date(end)));\n+    is.addOption(END, LONG_PREFIX + Long.toString(end));\n     is.addOption(END_INCL, Boolean.toString(endInclusive));\n   }\n }\n", "nb_test": 295, "linesAdd": 54, "jira_id": "776", "singleLine": false, "nb_skipped": 0, "commit": "dc9f23d9", "nb_failure": 0, "linesRem": 19}, {"files": 2, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testThrift_Invalid(org.apache.accumulo.core.data.KeyTest): Expected exception: java.lang.IllegalArgumentException", "testThrift_Invalid(org.apache.accumulo.core.data.MutationTest): Expected exception: java.lang.IllegalArgumentException"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\nindex cfb0b5c..b6cfad7 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n@@ -291,6 +291,19 @@ public Key(TKey tkey) {\n     this.colVisibility = toBytes(tkey.colVisibility);\n     this.timestamp = tkey.timestamp;\n     this.deleted = false;\n+\n+    if (row == null) {\n+      throw new IllegalArgumentException(\"null row\");\n+    }\n+    if (colFamily == null) {\n+      throw new IllegalArgumentException(\"null column family\");\n+    }\n+    if (colQualifier == null) {\n+      throw new IllegalArgumentException(\"null column qualifier\");\n+    }\n+    if (colVisibility == null) {\n+      throw new IllegalArgumentException(\"null column visibility\");\n+    }\n   }\n   \n   /**\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/data/Mutation.java b/src/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\nindex 3979da9..6b2c09f 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n@@ -187,6 +187,13 @@ public Mutation(TMutation tmutation) {\n     this.data = ByteBufferUtil.toBytes(tmutation.data);\n     this.entries = tmutation.entries;\n     this.values = ByteBufferUtil.toBytesList(tmutation.values);\n+\n+    if (this.row == null) {\n+      throw new IllegalArgumentException(\"null row\");\n+    }\n+    if (this.data == null) {\n+      throw new IllegalArgumentException(\"null serialized data\");\n+    }\n   }\n   \n   public Mutation(Mutation m) {\n", "nb_test": 341, "linesAdd": 20, "jira_id": "1986", "singleLine": false, "nb_skipped": 0, "commit": "adee0f12", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["testParseTree(org.apache.accumulo.core.security.ColumnVisibilityTest): expected:<8> but was:<6>", "testParseTreeWithMoreParentheses(org.apache.accumulo.core.security.ColumnVisibilityTest): expected:<8> but was:<6>", "testParseTreeWithParenthesizedChildren(org.apache.accumulo.core.security.ColumnVisibilityTest): expected:<12> but was:<6>", "testParseTreeWithParenthesesAndTwoChildren(org.apache.accumulo.core.security.ColumnVisibilityTest): expected:<8> but was:<2>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/security/ColumnVisibility.java b/core/src/main/java/org/apache/accumulo/core/security/ColumnVisibility.java\nindex 55763bc..f9c8382 100644\n--- a/core/src/main/java/org/apache/accumulo/core/security/ColumnVisibility.java\n+++ b/core/src/main/java/org/apache/accumulo/core/security/ColumnVisibility.java\n@@ -302,6 +302,7 @@ Node parse_(byte[] expression) {\n                 result.add(c);\n             else\n               result.add(child);\n+            result.end = index - 1;\n             return result;\n           }\n           case '\"': {\n", "nb_test": 510, "linesAdd": 1, "jira_id": "1730", "singleLine": true, "nb_skipped": 0, "commit": "872b6db3", "nb_failure": 4, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAllFieldsWritable(org.apache.accumulo.core.client.mapreduce.RangeInputSplitTest): expected:<table> but was:<null>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\nindex 05316a1..15c6185 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n@@ -144,6 +144,9 @@ public long getLength() throws IOException {\n   @Override\n   public void readFields(DataInput in) throws IOException {\n     range.readFields(in);\n+    if (in.readBoolean()) {\n+      table = in.readUTF();\n+    }\n     int numLocs = in.readInt();\n     locations = new String[numLocs];\n     for (int i = 0; i < numLocs; ++i)\n@@ -220,6 +223,12 @@ public void readFields(DataInput in) throws IOException {\n   @Override\n   public void write(DataOutput out) throws IOException {\n     range.write(out);\n+\n+    out.writeBoolean(null != table);\n+    if (null != table) {\n+      out.writeUTF(table);\n+    }\n+\n     out.writeInt(locations.length);\n     for (int i = 0; i < locations.length; ++i)\n       out.writeUTF(locations[i]);\n", "nb_test": 422, "linesAdd": 9, "jira_id": "3015", "singleLine": false, "nb_skipped": 0, "commit": "f848178e", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test3(org.apache.accumulo.core.iterators.FamilyIntersectingIteratorTest)", "test1(org.apache.accumulo.core.iterators.FamilyIntersectingIteratorTest)", "test2(org.apache.accumulo.core.iterators.FamilyIntersectingIteratorTest)"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\nindex 6df0e80..f870b30 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\n@@ -151,7 +151,7 @@ protected Key buildDocKey() {\n     if (log.isTraceEnabled())\n       log.trace(zeroIndex + \" \" + currentDocID.getLength());\n     Text colq = new Text();\n-    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);\n+    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 1);\n     Key k = new Key(currentPartition, colf, colq);\n     if (log.isTraceEnabled())\n       log.trace(\"built doc key for seek: \" + k.toString());\n", "nb_test": 272, "linesAdd": 1, "jira_id": "178", "singleLine": false, "nb_skipped": 0, "commit": "efef09b0", "nb_failure": 3, "linesRem": 1}, {"files": 5, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["MergeCommandTest.testBeginRowHelp:26 -b should say it is exclusive", "FlushCommandTest.testBeginRowHelp:26 -b should say it is exclusive", "CompactCommandTest.testBeginRowHelp:26 -b should say it is exclusive"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\nindex 536d6e6..bcad3a3 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\n@@ -260,7 +260,7 @@ Text getMaxRow(String tableName, Authorizations auths, Text startRow, boolean st\n    * @param start\n    *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n    * @param end\n-   *          last tablet to be merged contains this row, null means the last tablet in table\n+   *          last tablet to be compacted contains this row, null means the last tablet in table\n    * @param flush\n    *          when true, table memory is flushed before compaction starts\n    * @param wait\n@@ -276,7 +276,7 @@ Text getMaxRow(String tableName, Authorizations auths, Text startRow, boolean st\n    * @param start\n    *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n    * @param end\n-   *          last tablet to be merged contains this row, null means the last tablet in table\n+   *          last tablet to be compacted contains this row, null means the last tablet in table\n    * @param iterators\n    *          A set of iterators that will be applied to each tablet compacted\n    * @param flush\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\nindex 64968f0..6ffa3f4 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\n@@ -54,9 +54,7 @@ public int numArgs() {\n   public Options getOptions() {\n     final Options o = new Options();\n     forceOpt = new Option(\"f\", \"force\", false, \"delete data even if start or end are not specified\");\n-    startRowOptExclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\n-    startRowOptExclusive.setArgName(\"begin-row\");\n-    o.addOption(startRowOptExclusive);\n+    o.addOption(OptUtil.startRowOpt());\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(OptUtil.tableOpt(\"table to delete a row range from\"));\n     o.addOption(forceOpt);\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\nindex 9213a06..18d519d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\n@@ -96,9 +96,7 @@ public Options getOptions() {\n     sizeOpt = new Option(\"s\", \"size\", true, \"merge tablets to the given size over the entire table\");\n     forceOpt = new Option(\"f\", \"force\", false, \"merge small tablets to large tablets, even if it goes over the given size\");\n     allOpt = new Option(\"\", \"all\", false, \"allow an entire table to be merged into one tablet without prompting the user for confirmation\");\n-    Option startRowOpt = OptUtil.startRowOpt();\n-    startRowOpt.setDescription(\"begin row (NOT inclusive)\");\n-    o.addOption(startRowOpt);\n+    o.addOption(OptUtil.startRowOpt());\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(OptUtil.tableOpt(\"table to be merged\"));\n     o.addOption(verboseOpt);\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\nindex 9915bdf..99e09e3 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n@@ -117,7 +117,7 @@ public static OptionGroup addListDeleteGroup(final String name) {\n   }\n \n   public static Option startRowOpt() {\n-    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\n+    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\n     o.setArgName(\"begin-row\");\n     return o;\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\nindex 9a0026a..60ae0a7 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\n@@ -57,6 +57,7 @@\n \n   protected Option timestampOpt;\n   private Option optStartRowExclusive;\n+  private Option optStartRowInclusive;\n   private Option optEndRowExclusive;\n   private Option timeoutOption;\n   private Option profileOpt;\n@@ -318,7 +319,9 @@ public Options getOptions() {\n \n     o.addOption(scanOptAuths);\n     o.addOption(scanOptRow);\n-    o.addOption(OptUtil.startRowOpt());\n+    optStartRowInclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\n+    optStartRowInclusive.setArgName(\"begin-row\");\n+    o.addOption(optStartRowInclusive);\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(optStartRowExclusive);\n     o.addOption(optEndRowExclusive);\n", "nb_test": 722, "linesAdd": 7, "jira_id": "4138", "singleLine": false, "nb_skipped": 2, "commit": "eb0f9b41", "nb_failure": 3, "linesRem": 8}, {"files": 2, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test(org.apache.accumulo.core.util.shell.command.FormatterCommandTest): Failed to configure shell without error"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\nindex 5ff340b..0fbe879 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n@@ -44,15 +44,19 @@ public MockShell(InputStream in, Writer writer) throws IOException {\n     this.writer = writer;\n   }\n \n+  @Override\n   public boolean config(String... args) {\n-    configError = super.config(args);\n+    // If configuring the shell failed, fail quickly\n+    if (!super.config(args)) {\n+      return false;\n+    }\n \n     // Update the ConsoleReader with the input and output \"redirected\"\n     try {\n       this.reader = new ConsoleReader(in, writer);\n     } catch (Exception e) {\n       printException(e);\n-      configError = true;\n+      return false;\n     }\n \n     // Don't need this for testing purposes\n@@ -61,7 +65,7 @@ public boolean config(String... args) {\n \n     // Make the parsing from the client easier;\n     this.verbose = false;\n-    return configError;\n+    return true;\n   }\n \n   @Override\n@@ -71,9 +75,6 @@ protected void setInstance(CommandLine cl) {\n   }\n \n   public int start() throws IOException {\n-    if (configError)\n-      return 1;\n-\n     String input;\n     if (isVerbose())\n       printInfo();\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\nindex cc2053f..808d340 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n@@ -185,7 +185,6 @@\n   private Token rootToken;\n   public final Map<String,Command> commandFactory = new TreeMap<String,Command>();\n   public final Map<String,Command[]> commandGrouping = new TreeMap<String,Command[]>();\n-  protected boolean configError = false;\n \n   // exit if true\n   private boolean exit = false;\n@@ -215,7 +214,11 @@ public Shell(ConsoleReader reader, PrintWriter writer) {\n     this.writer = writer;\n   }\n \n-  // Not for client use\n+  /**\n+   * Configures the shell using the provided options. Not for client use.\n+   *\n+   * @return true if the shell was successfully configured, false otherwise.\n+   */\n   public boolean config(String... args) {\n \n     CommandLine cl;\n@@ -225,9 +228,9 @@ public boolean config(String... args) {\n         throw new ParseException(\"Unrecognized arguments: \" + cl.getArgList());\n \n       if (cl.hasOption(helpOpt.getOpt())) {\n-        configError = true;\n         printHelp(\"shell\", SHELL_DESCRIPTION, opts);\n-        return true;\n+        exitCode = 0;\n+        return false;\n       }\n \n       setDebugging(cl.hasOption(debugOption.getLongOpt()));\n@@ -238,10 +241,10 @@ public boolean config(String... args) {\n         throw new MissingArgumentException(zooKeeperInstance);\n \n     } catch (Exception e) {\n-      configError = true;\n       printException(e);\n       printHelp(\"shell\", SHELL_DESCRIPTION, opts);\n-      return true;\n+      exitCode = 1;\n+      return false;\n     }\n \n     // get the options that were parsed\n@@ -316,7 +319,8 @@ public void start() {\n \n     } catch (Exception e) {\n       printException(e);\n-      configError = true;\n+      exitCode = 1;\n+      return false;\n     }\n \n     // decide whether to execute commands from a file and quit\n@@ -373,7 +377,7 @@ public void start() {\n     for (Command cmd : otherCommands) {\n       commandFactory.put(cmd.getName(), cmd);\n     }\n-    return configError;\n+    return true;\n   }\n \n   protected void setInstance(CommandLine cl) {\n@@ -408,15 +412,14 @@ public Connector getConnector() {\n \n   public static void main(String args[]) throws IOException {\n     Shell shell = new Shell();\n-    shell.config(args);\n+    if (!shell.config(args)) {\n+      System.exit(shell.getExitCode());\n+    }\n \n     System.exit(shell.start());\n   }\n \n   public int start() throws IOException {\n-    if (configError)\n-      return 1;\n-\n     String input;\n     if (isVerbose())\n       printInfo();\n", "nb_test": 432, "linesAdd": 16, "jira_id": "3475", "singleLine": false, "nb_skipped": 0, "commit": "7651b777", "nb_failure": 1, "linesRem": 17}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPostDelegation(org.apache.accumulo.start.classloader.vfs.ContextManagerTest)", "differentContexts(org.apache.accumulo.start.classloader.vfs.ContextManagerTest): arrays first differed at element [0]; expected:<jar:file:///home/ylyu/parallel/accumulo/accumulo9/dataset/accumulo/ACCUMULO-1514_fb25913c5b9d1d9615dd32807b6583c558794e49/start/target/junit4545360540553368377/HelloWorld.jar!/> but was:<file:///home/ylyu/parallel/accumulo/accumulo9/dataset/accumulo/ACCUMULO-1514_fb25913c5b9d1d9615dd32807b6583c558794e49/start/target/junit4545360540553368377>", "testModifiedClass(org.apache.accumulo.start.classloader.vfs.AccumuloReloadingVFSClassLoaderTest): arrays first differed at element [0]; expected:<jar:file:///home/ylyu/parallel/accumulo/accumulo9/dataset/accumulo/ACCUMULO-1514_fb25913c5b9d1d9615dd32807b6583c558794e49/start/target/junit6214954286572045794/HelloWorld.jar!/> but was:<file:///home/ylyu/parallel/accumulo/accumulo9/dataset/accumulo/ACCUMULO-1514_fb25913c5b9d1d9615dd32807b6583c558794e49/start/target/junit6214954286572045794>", "testReloading(org.apache.accumulo.start.classloader.vfs.AccumuloReloadingVFSClassLoaderTest): arrays first differed at element [0]; expected:<jar:file:///home/ylyu/parallel/accumulo/accumulo9/dataset/accumulo/ACCUMULO-1514_fb25913c5b9d1d9615dd32807b6583c558794e49/start/target/junit3469370927152443111/HelloWorld.jar!/> but was:<file:///home/ylyu/parallel/accumulo/accumulo9/dataset/accumulo/ACCUMULO-1514_fb25913c5b9d1d9615dd32807b6583c558794e49/start/target/junit3469370927152443111>", "testConstructor(org.apache.accumulo.start.classloader.vfs.AccumuloReloadingVFSClassLoaderTest): arrays first differed at element [0]; expected:<jar:file:///home/ylyu/parallel/accumulo/accumulo9/dataset/accumulo/ACCUMULO-1514_fb25913c5b9d1d9615dd32807b6583c558794e49/start/target/junit4175051648314321909/HelloWorld.jar!/> but was:<file:///home/ylyu/parallel/accumulo/accumulo9/dataset/accumulo/ACCUMULO-1514_fb25913c5b9d1d9615dd32807b6583c558794e49/start/target/junit4175051648314321909>"], "patch": "diff --git a/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java b/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\nindex b1e829a..eb653bc 100644\n--- a/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\n+++ b/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\n@@ -134,10 +134,15 @@ public void run() {\n       \n       switch (fo.getType()) {\n         case FILE:\n-        case FOLDER:\n           classpath.add(fo);\n           pathsToMonitor.add(fo);\n           break;\n+        case FOLDER:\n+          pathsToMonitor.add(fo);\n+          for (FileObject child : fo.getChildren()) {\n+            classpath.add(child);\n+          }\n+          break;\n         case IMAGINARY:\n           // assume its a pattern\n           String pattern = fo.getName().getBaseName();\n", "nb_test": 30, "linesAdd": 6, "jira_id": "1514", "singleLine": false, "nb_skipped": 0, "commit": "fb25913c", "nb_failure": 5, "linesRem": 1}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["DefaultLoadBalancerTest.testUnevenAssignment:206 expected:<8> but was:<9>"], "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/master/balancer/DefaultLoadBalancer.java b/server/base/src/main/java/org/apache/accumulo/server/master/balancer/DefaultLoadBalancer.java\nindex 46b9b5f..3490405 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/master/balancer/DefaultLoadBalancer.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/master/balancer/DefaultLoadBalancer.java\n@@ -86,7 +86,7 @@ public TServerInstance getAssignment(SortedMap<TServerInstance,TabletServerStatu\n   \n   static class ServerCounts implements Comparable<ServerCounts> {\n     public final TServerInstance server;\n-    public final int count;\n+    public int count;\n     public final TabletServerStatus status;\n     \n     ServerCounts(int count, TServerInstance server, TabletServerStatus status) {\n@@ -145,7 +145,7 @@ public boolean getMigrations(Map<TServerInstance,TabletServerStatus> current, Li\n       int end = totals.size() - 1;\n       int movedAlready = 0;\n       int tooManyIndex = 0;\n-      while (tooManyIndex < totals.size() && end > tooManyIndex) {\n+      while (tooManyIndex < end) {\n         ServerCounts tooMany = totals.get(tooManyIndex);\n         int goal = even;\n         if (tooManyIndex < numServersOverEven) {\n@@ -255,7 +255,8 @@ public TableDiff(int diff, String table) {\n         tooLittleCount = 0;\n       }\n       tooLittleMap.put(table, tooLittleCount + 1);\n-      \n+      tooMuch.count--;\n+      tooLittle.count++;\n       result.add(new TabletMigration(extent, tooMuch.server, tooLittle.server));\n     }\n     return result;\n", "nb_test": 179, "linesAdd": 4, "jira_id": "2952", "singleLine": false, "nb_skipped": 2, "commit": "11d11e0d", "nb_failure": 1, "linesRem": 3}, {"files": 2, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDeletes(org.apache.accumulo.core.iterators.user.FilterTest): size = 2"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\nindex 94daf03..a9ed76c 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\n@@ -69,7 +69,7 @@ public void seek(Range range, Collection<ByteSequence> columnFamilies, boolean i\n    * Iterates over the source until an acceptable key/value pair is found.\n    */\n   protected void findTop() {\n-    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n+    while (getSource().hasTop() && !getSource().getTopKey().isDeleted() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n       try {\n         getSource().next();\n       } catch (IOException e) {\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\nindex 8bbf18a..edeaa1d 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\n@@ -59,7 +59,9 @@\n   boolean hasTop();\n   \n   /**\n-   * Advances to the next K,V pair.\n+   * Advances to the next K,V pair. Note that in minor compaction scope and in non-full major compaction scopes the iterator may see deletion entries. These\n+   * entries should be preserved by all iterators except ones that are strictly scan-time iterators that will never be configured for the minc or majc scopes.\n+   * Deletion entries are only removed during full major compactions.\n    * \n    * @throws IOException\n    *           if an I/O error occurs.\n@@ -88,7 +90,9 @@\n   void seek(Range range, Collection<ByteSequence> columnFamilies, boolean inclusive) throws IOException;\n   \n   /**\n-   * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop().\n+   * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop(). Note that in minor compaction scope and in non-full major\n+   * compaction scopes the iterator may see deletion entries. These entries should be preserved by all iterators except ones that are strictly scan-time\n+   * iterators that will never be configured for the minc or majc scopes. Deletion entries are only removed during full major compactions.\n    * \n    * @return <tt>K</tt>\n    * @exception IllegalStateException\n", "nb_test": 291, "linesAdd": 1, "jira_id": "414", "singleLine": false, "nb_skipped": 0, "commit": "ebf22df0", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": [], "patch": "diff --git a/server/master/src/main/java/org/apache/accumulo/master/tserverOps/ShutdownTServer.java b/server/master/src/main/java/org/apache/accumulo/master/tserverOps/ShutdownTServer.java\nindex 11cd91b..171e312 100644\n--- a/server/master/src/main/java/org/apache/accumulo/master/tserverOps/ShutdownTServer.java\n+++ b/server/master/src/main/java/org/apache/accumulo/master/tserverOps/ShutdownTServer.java\n@@ -58,6 +58,7 @@ public long isReady(long tid, Master master) throws Exception {\n     // only send this request once\n     if (!requestedShutdown) {\n       master.shutdownTServer(server);\n+      requestedShutdown = true;\n     }\n \n     if (master.onlineTabletServers().contains(server)) {\n", "nb_test": 0, "linesAdd": 1, "jira_id": "3897", "singleLine": true, "nb_skipped": 0, "commit": "699b8bf0", "nb_failure": 0, "linesRem": 0}, {"files": 2, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testTableNotFound(org.apache.accumulo.core.client.mock.MockTableOperationsTest)"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java b/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\nindex 96a31e7..31f7405 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\n@@ -48,6 +48,8 @@ public void attachIterator(String tableName, IteratorSetting setting) throws Acc\n   @Override\n   public void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException,\n       TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     Map<String,String> copy = new TreeMap<String,String>();\n     for (Entry<String,String> property : this.getProperties(tableName)) {\n       copy.put(property.getKey(), property.getValue());\n@@ -64,6 +66,8 @@ public void removeIterator(String tableName, String name, EnumSet<IteratorScope>\n   @Override\n   public IteratorSetting getIteratorSetting(String tableName, String name, IteratorScope scope) throws AccumuloSecurityException, AccumuloException,\n       TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     int priority = -1;\n     String classname = null;\n     Map<String,String> settings = new HashMap<String,String>();\n@@ -90,6 +94,8 @@ public IteratorSetting getIteratorSetting(String tableName, String name, Iterato\n   \n   @Override\n   public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     Set<String> result = new HashSet<String>();\n     Set<String> lifecycles = new HashSet<String>();\n     for (IteratorScope scope : IteratorScope.values())\n@@ -107,6 +113,8 @@ public IteratorSetting getIteratorSetting(String tableName, String name, Iterato\n   \n   @Override\n   public void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     for (IteratorScope scope : setting.getScopes()) {\n       String scopeStr = String.format(\"%s%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());\n       String nameStr = String.format(\"%s.%s\", scopeStr, setting.getName());\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex 4063b76..1b2a3d0 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -81,6 +81,8 @@ public void create(String tableName, boolean versioningIter, TimeType timeType)\n     if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\n       throw new IllegalArgumentException();\n     }\n+    if (exists(tableName))\n+      throw new TableExistsException(tableName, tableName, \"\");\n     acu.createTable(username, tableName, versioningIter, timeType);\n   }\n   \n@@ -90,30 +92,42 @@ public void create(String tableName, boolean versioningIter, TimeType timeType)\n   @Override\n   public void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException,\n       AccumuloException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     acu.addAggregators(tableName, aggregators);\n   }\n   \n   @Override\n-  public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {}\n+  public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n-  public Collection<Text> getSplits(String tableName) {\n+  public Collection<Text> getSplits(String tableName) throws TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     return Collections.emptyList();\n   }\n   \n   @Override\n-  public Collection<Text> getSplits(String tableName, int maxSplits) {\n-    return Collections.emptyList();\n+  public Collection<Text> getSplits(String tableName, int maxSplits) throws TableNotFoundException {\n+    return getSplits(tableName);\n   }\n   \n   @Override\n   public void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     acu.tables.remove(tableName);\n   }\n   \n   @Override\n   public void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException,\n       TableExistsException {\n+    if (!exists(oldTableName))\n+      throw new TableNotFoundException(oldTableName, oldTableName, \"\");\n+    if (exists(newTableName))\n+      throw new TableExistsException(newTableName, newTableName, \"\");\n     MockTable t = acu.tables.remove(oldTableName);\n     acu.tables.put(newTableName, t);\n   }\n@@ -133,15 +147,19 @@ public void removeProperty(String tableName, String property) throws AccumuloExc\n   \n   @Override\n   public Iterable<Entry<String,String>> getProperties(String tableName) throws TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     return acu.tables.get(tableName).settings.entrySet();\n   }\n   \n   @Override\n-  public void setLocalityGroups(String tableName, Map<String,Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {}\n+  public void setLocalityGroups(String tableName, Map<String,Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public Map<String,Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\n-    return null;\n+    throw new NotImplementedException();\n   }\n   \n   @Override\n@@ -163,13 +181,17 @@ public void importDirectory(String tableName, String dir, String failureDir, boo\n   }\n   \n   @Override\n-  public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {}\n+  public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public void online(String tableName) throws AccumuloSecurityException, AccumuloException {}\n   \n   @Override\n-  public void clearLocatorCache(String tableName) throws TableNotFoundException {}\n+  public void clearLocatorCache(String tableName) throws TableNotFoundException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public Map<String,String> tableIdMap() {\n", "nb_test": 270, "linesAdd": 38, "jira_id": "217", "singleLine": false, "nb_skipped": 0, "commit": "46f62443", "nb_failure": 0, "linesRem": 8}, {"files": 2, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testBadMutations(org.apache.accumulo.core.client.mock.MockConnectorTest)"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\nindex b33ebcb..d89a263 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\n@@ -19,6 +19,7 @@\n import org.apache.accumulo.core.client.BatchWriter;\n import org.apache.accumulo.core.client.MutationsRejectedException;\n import org.apache.accumulo.core.data.Mutation;\n+import org.apache.accumulo.core.util.ArgumentChecker;\n \n public class MockBatchWriter implements BatchWriter {\n   \n@@ -32,11 +33,13 @@\n   \n   @Override\n   public void addMutation(Mutation m) throws MutationsRejectedException {\n+    ArgumentChecker.notNull(m);\n     acu.addMutation(tablename, m);\n   }\n   \n   @Override\n   public void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\n+    ArgumentChecker.notNull(iterable);\n     for (Mutation m : iterable) {\n       acu.addMutation(tablename, m);\n     }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex 6d6d534..3dcab11 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -101,6 +101,8 @@ public int compareTo(Key o) {\n   }\n   \n   synchronized void addMutation(Mutation m) {\n+    if (m.size() == 0)\n+      throw new IllegalArgumentException(\"Can not add empty mutations\");\n     long now = System.currentTimeMillis();\n     mutationCount++;\n     for (ColumnUpdate u : m.getUpdates()) {\n", "nb_test": 391, "linesAdd": 5, "jira_id": "1505", "singleLine": false, "nb_skipped": 0, "commit": "994df698", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["BlockedIOStreamTest.testGiantWrite \u00bb StackOverflow"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/security/crypto/BlockedOutputStream.java b/core/src/main/java/org/apache/accumulo/core/security/crypto/BlockedOutputStream.java\nindex ca72055..3ce648e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/security/crypto/BlockedOutputStream.java\n+++ b/core/src/main/java/org/apache/accumulo/core/security/crypto/BlockedOutputStream.java\n@@ -72,15 +72,18 @@ public void write(int b) throws IOException {\n \n   @Override\n   public void write(byte b[], int off, int len) throws IOException {\n-    if (bb.remaining() >= len) {\n-      bb.put(b, off, len);\n-      if (bb.remaining() == 0)\n-        flush();\n-    } else {\n+    // Can't recurse here in case the len is large and the blocksize is small (and the stack is small)\n+    // So we'll just fill up the buffer over and over\n+    while (len >= bb.remaining()) {\n       int remaining = bb.remaining();\n-      write(b, off, remaining);\n-      write(b, off + remaining, len - remaining);\n+      bb.put(b, off, remaining);\n+      // This is guaranteed to have the buffer filled, so we'll just flush it. No check needed\n+      flush();\n+      off += remaining;\n+      len -= remaining;\n     }\n+    // And then write the remainder (and this is guaranteed to not fill the buffer, so we won't flush afteward\n+    bb.put(b, off, len);\n   }\n \n   @Override\n", "nb_test": 634, "linesAdd": 6, "jira_id": "2671", "singleLine": false, "nb_skipped": 1, "commit": "17344890", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["testRandomPorts(org.apache.accumulo.minicluster.MiniAccumuloClusterTest): Found no value for monitor.port.log4j"], "patch": "diff --git a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\nindex 8246c51..c9aa1f1 100644\n--- a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n+++ b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n@@ -270,6 +270,7 @@ public MiniAccumuloCluster(MiniAccumuloConfig config) throws IOException {\n     mergePropWithRandomPort(siteConfig, Property.TSERV_CLIENTPORT.getKey());\n     mergePropWithRandomPort(siteConfig, Property.MONITOR_PORT.getKey());\n     mergePropWithRandomPort(siteConfig, Property.GC_PORT.getKey());\n+    mergePropWithRandomPort(siteConfig, Property.MONITOR_LOG4J_PORT.getKey());\n     \n     // since there is a small amount of memory, check more frequently for majc... setting may not be needed in 1.5\n     appendProp(fileWriter, Property.TSERV_MAJC_DELAY, \"3\", siteConfig);\n", "nb_test": 6, "linesAdd": 1, "jira_id": "3150", "singleLine": true, "nb_skipped": 0, "commit": "72fd6bec", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testBadMutations(org.apache.accumulo.core.client.mock.MockConnectorTest)"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\nindex b33ebcb..d89a263 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\n@@ -19,6 +19,7 @@\n import org.apache.accumulo.core.client.BatchWriter;\n import org.apache.accumulo.core.client.MutationsRejectedException;\n import org.apache.accumulo.core.data.Mutation;\n+import org.apache.accumulo.core.util.ArgumentChecker;\n \n public class MockBatchWriter implements BatchWriter {\n   \n@@ -32,11 +33,13 @@\n   \n   @Override\n   public void addMutation(Mutation m) throws MutationsRejectedException {\n+    ArgumentChecker.notNull(m);\n     acu.addMutation(tablename, m);\n   }\n   \n   @Override\n   public void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\n+    ArgumentChecker.notNull(iterable);\n     for (Mutation m : iterable) {\n       acu.addMutation(tablename, m);\n     }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex 6d6d534..3dcab11 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -101,6 +101,8 @@ public int compareTo(Key o) {\n   }\n   \n   synchronized void addMutation(Mutation m) {\n+    if (m.size() == 0)\n+      throw new IllegalArgumentException(\"Can not add empty mutations\");\n     long now = System.currentTimeMillis();\n     mutationCount++;\n     for (ColumnUpdate u : m.getUpdates()) {\n", "nb_test": 366, "linesAdd": 5, "jira_id": "1505", "singleLine": false, "nb_skipped": 0, "commit": "b082fc1e", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["authsTest(org.apache.accumulo.core.util.shell.ShellTest): y,z,x present in ylyu@fake> getauths(..)"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/security/Authorizations.java b/core/src/main/java/org/apache/accumulo/core/security/Authorizations.java\nindex 5933325..a677f3f 100644\n--- a/core/src/main/java/org/apache/accumulo/core/security/Authorizations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/security/Authorizations.java\n@@ -23,10 +23,9 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Set;\n-import java.util.TreeSet;\n \n import org.apache.accumulo.core.data.ArrayByteSequence;\n import org.apache.accumulo.core.data.ByteSequence;\n@@ -38,7 +37,7 @@\n   \n   private static final long serialVersionUID = 1L;\n   \n-  private Set<ByteSequence> auths = new TreeSet<ByteSequence>();\n+  private HashSet<ByteSequence> auths = new HashSet<ByteSequence>();\n   private List<byte[]> authsList = new ArrayList<byte[]>();\n   private List<byte[]> immutableList = Collections.unmodifiableList(authsList);\n   \n@@ -177,7 +176,6 @@ private void setAuthorizations(Charset charset, String... authorizations) {\n     return ByteBufferUtil.toByteBuffers(immutableList);\n   }\n   \n-  @Override\n   public String toString() {\n     StringBuilder sb = new StringBuilder();\n     String sep = \"\";\n@@ -198,7 +196,6 @@ public boolean contains(ByteSequence auth) {\n     return auths.contains(auth);\n   }\n   \n-  @Override\n   public boolean equals(Object o) {\n     if (o == null) {\n       return false;\n@@ -213,7 +210,6 @@ public boolean equals(Object o) {\n     return false;\n   }\n   \n-  @Override\n   public int hashCode() {\n     int result = 0;\n     for (ByteSequence b : auths)\n", "nb_test": 362, "linesAdd": 2, "jira_id": "1051", "singleLine": false, "nb_skipped": 0, "commit": "25cf3ccd", "nb_failure": 1, "linesRem": 6}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testUpdate(org.apache.accumulo.core.client.mock.MockConnectorTest): null expected:<[9]> but was:<[0]>"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex ae16709..2fe637a 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -69,9 +69,9 @@ public int compareTo(Key o) {\n       if (o instanceof MockMemKey) {\n         MockMemKey other = (MockMemKey) o;\n         if (count < other.count)\n-          return -1;\n-        if (count > other.count)\n           return 1;\n+        if (count > other.count)\n+          return -1;\n       } else {\n         return 1;\n       }\n", "nb_test": 284, "linesAdd": 2, "jira_id": "218", "singleLine": false, "nb_skipped": 0, "commit": "15476a0d", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testClear(org.apache.accumulo.core.util.StatTest): expected:<0> but was:<9792>", "testGetStdDev(org.apache.accumulo.core.util.StatTest): expected:<2073.7656569632> but was:<1919.9339274345573>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Stat.java b/core/src/main/java/org/apache/accumulo/core/util/Stat.java\nindex e65265c..d2d560e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Stat.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Stat.java\n@@ -16,54 +16,66 @@\n  */\n package org.apache.accumulo.core.util;\n \n-public class Stat {\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.StandardDeviation;\n+import org.apache.commons.math.stat.descriptive.rank.Max;\n+import org.apache.commons.math.stat.descriptive.rank.Min;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n \n-  long max = Long.MIN_VALUE;\n-  long min = Long.MAX_VALUE;\n-  long sum = 0;\n-  int count = 0;\n-  double partialStdDev = 0;\n+public class Stat {\n+  Min min;\n+  Max max;\n+  Sum sum;\n+  Mean mean;\n+  StandardDeviation sd;\n \n-  public void addStat(long stat) {\n-    if (stat > max)\n-      max = stat;\n-    if (stat < min)\n-      min = stat;\n+  StorelessUnivariateStatistic[] stats;\n \n-    sum += stat;\n+  public Stat() {\n+    min = new Min();\n+    max = new Max();\n+    sum = new Sum();\n+    mean = new Mean();\n+    sd = new StandardDeviation();\n \n-    partialStdDev += stat * stat;\n+    stats = new StorelessUnivariateStatistic[] {min, max, sum, mean, sd};\n+  }\n \n-    count++;\n+  public void addStat(long stat) {\n+    for (StorelessUnivariateStatistic statistic : stats) {\n+      statistic.increment(stat);\n+    }\n   }\n \n   public long getMin() {\n-    return min;\n+    return (long) min.getResult();\n   }\n \n   public long getMax() {\n-    return max;\n+    return (long) max.getResult();\n+  }\n+\n+  public long getSum() {\n+    return (long) sum.getResult();\n   }\n \n   public double getAverage() {\n-    return ((double) sum) / count;\n+    return mean.getResult();\n   }\n \n   public double getStdDev() {\n-    return Math.sqrt(partialStdDev / count - getAverage() * getAverage());\n+    return sd.getResult();\n   }\n \n   public String toString() {\n-    return String.format(\"%,d %,d %,.2f %,d\", getMin(), getMax(), getAverage(), count);\n+    return String.format(\"%,d %,d %,.2f %,d\", getMin(), getMax(), getAverage(), mean.getN());\n   }\n \n   public void clear() {\n-    sum = 0;\n-    count = 0;\n-    partialStdDev = 0;\n+    for (StorelessUnivariateStatistic statistic : stats) {\n+      statistic.clear();\n     }\n-  \n-  public long getSum() {\n-    return sum;\n   }\n+\n }\n", "nb_test": 411, "linesAdd": 37, "jira_id": "2494", "singleLine": false, "nb_skipped": 0, "commit": "0dc92ca1", "nb_failure": 2, "linesRem": 25}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testVisibilityFollowingKey(org.apache.accumulo.core.data.KeyTest): bad character (0) near index 1(..)"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\nindex 3d1f92d..afab887 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n@@ -22,6 +22,8 @@\n  * \n  */\n \n+import static org.apache.accumulo.core.util.ByteBufferUtil.toBytes;\n+\n import java.io.DataInput;\n import java.io.DataOutput;\n import java.io.IOException;\n@@ -38,8 +40,6 @@\n import org.apache.hadoop.io.WritableComparator;\n import org.apache.hadoop.io.WritableUtils;\n \n-import static org.apache.accumulo.core.util.ByteBufferUtil.toBytes;\n-\n public class Key implements WritableComparable<Key>, Cloneable {\n   \n   protected byte[] row;\n@@ -444,8 +444,10 @@ public int hashCode() {\n   }\n   \n   public static String toPrintableString(byte ba[], int offset, int len, int maxLen) {\n-    StringBuilder sb = new StringBuilder();\n+    return appendPrintableString(ba, offset, len, maxLen, new StringBuilder()).toString();\n+  }\n   \n+  public static StringBuilder appendPrintableString(byte ba[], int offset, int len, int maxLen, StringBuilder sb) {\n     int plen = Math.min(len, maxLen);\n     \n     for (int i = 0; i < plen; i++) {\n@@ -460,26 +462,33 @@ public static String toPrintableString(byte ba[], int offset, int len, int maxLe\n       sb.append(\"... TRUNCATED\");\n     }\n     \n-    return sb.toString();\n+    return sb;\n   }\n   \n-  public String toString() {\n-    String labelString = new ColumnVisibility(colVisibility).toString();\n+  private StringBuilder rowColumnStringBuilder() {\n+    StringBuilder sb = new StringBuilder();\n+    appendPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\" \");\n+    appendPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\":\");\n+    appendPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\" [\");\n+    appendPrintableString(colVisibility, 0, colVisibility.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\"]\");\n+    return sb;\n+  }\n   \n-    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \"\n-        + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\"\n-        + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \"\n-        + deleted;\n-    return s;\n+  public String toString() {\n+    StringBuilder sb = rowColumnStringBuilder();\n+    sb.append(\" \");\n+    sb.append(Long.toString(timestamp));\n+    sb.append(\" \");\n+    sb.append(deleted);\n+    return sb.toString();\n   }\n   \n   public String toStringNoTime() {\n-    \n-    String labelString = new ColumnVisibility(colVisibility).toString();\n-    \n-    String s = new String(row, 0, row.length) + \" \" + new String(colFamily, 0, colFamily.length) + \":\" + new String(colQualifier, 0, colQualifier.length) + \" \"\n-        + labelString;\n-    return s;\n+    return rowColumnStringBuilder().toString();\n   }\n   \n   public int getLength() {\n", "nb_test": 278, "linesAdd": 26, "jira_id": "193", "singleLine": false, "nb_skipped": 0, "commit": "8ad5a888", "nb_failure": 0, "linesRem": 17}, {"files": 2, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["tableNotFound(org.apache.accumulo.proxy.SimpleTest)"], "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex 926c413..c0dee9a 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -50,6 +50,8 @@\n import org.apache.accumulo.core.client.admin.ActiveCompaction;\n import org.apache.accumulo.core.client.admin.ActiveScan;\n import org.apache.accumulo.core.client.admin.TimeType;\n+import org.apache.accumulo.core.client.impl.thrift.TableOperationExceptionType;\n+import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.client.mock.MockInstance;\n import org.apache.accumulo.core.client.security.SecurityErrorCode;\n import org.apache.accumulo.core.client.security.tokens.AuthenticationToken;\n@@ -178,6 +180,12 @@ private TException translateException(Exception ex) {\n       logger.debug(e, e);\n       return new org.apache.accumulo.proxy.thrift.MutationsRejectedException(e.toString());\n     } catch (AccumuloException e) {\n+      if (e.getCause() instanceof ThriftTableOperationException) {\n+        ThriftTableOperationException ttoe = (ThriftTableOperationException) e.getCause();\n+        if (ttoe.type == TableOperationExceptionType.NOTFOUND) {\n+          return new org.apache.accumulo.proxy.thrift.TableNotFoundException(e.toString());\n+        }\n+      }\n       logger.debug(e, e);\n       return new org.apache.accumulo.proxy.thrift.AccumuloException(e.toString());\n     } catch (AccumuloSecurityException e) {\ndiff --git a/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java b/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\nindex 857320a..f53b6ac 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\n@@ -104,17 +104,17 @@\n \n     public void onlineTable(ByteBuffer login, String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n-    public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;\n+    public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n     public void removeIterator(ByteBuffer login, String tableName, String iterName, Set<IteratorScope> scopes) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n-    public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;\n+    public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n     public void renameTable(ByteBuffer login, String oldTableName, String newTableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, TableExistsException, org.apache.thrift.TException;\n \n     public void setLocalityGroups(ByteBuffer login, String tableName, Map<String,Set<String>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n-    public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;\n+    public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n     public Set<Range> splitRangeByTablets(ByteBuffer login, String tableName, Range range, int maxSplits) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n@@ -1206,7 +1206,7 @@ public void recv_onlineTable() throws AccumuloException, AccumuloSecurityExcepti\n       return;\n     }\n \n-    public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       send_removeConstraint(login, tableName, constraint);\n       recv_removeConstraint();\n@@ -1221,7 +1221,7 @@ public void send_removeConstraint(ByteBuffer login, String tableName, int constr\n       sendBase(\"removeConstraint\", args);\n     }\n \n-    public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       removeConstraint_result result = new removeConstraint_result();\n       receiveBase(result, \"removeConstraint\");\n@@ -1231,6 +1231,9 @@ public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityEx\n       if (result.ouch2 != null) {\n         throw result.ouch2;\n       }\n+      if (result.ouch3 != null) {\n+        throw result.ouch3;\n+      }\n       return;\n     }\n \n@@ -1266,7 +1269,7 @@ public void recv_removeIterator() throws AccumuloException, AccumuloSecurityExce\n       return;\n     }\n \n-    public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       send_removeTableProperty(login, tableName, property);\n       recv_removeTableProperty();\n@@ -1281,7 +1284,7 @@ public void send_removeTableProperty(ByteBuffer login, String tableName, String\n       sendBase(\"removeTableProperty\", args);\n     }\n \n-    public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       removeTableProperty_result result = new removeTableProperty_result();\n       receiveBase(result, \"removeTableProperty\");\n@@ -1291,6 +1294,9 @@ public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurit\n       if (result.ouch2 != null) {\n         throw result.ouch2;\n       }\n+      if (result.ouch3 != null) {\n+        throw result.ouch3;\n+      }\n       return;\n     }\n \n@@ -1359,7 +1365,7 @@ public void recv_setLocalityGroups() throws AccumuloException, AccumuloSecurityE\n       return;\n     }\n \n-    public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       send_setTableProperty(login, tableName, property, value);\n       recv_setTableProperty();\n@@ -1375,7 +1381,7 @@ public void send_setTableProperty(ByteBuffer login, String tableName, String pro\n       sendBase(\"setTableProperty\", args);\n     }\n \n-    public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       setTableProperty_result result = new setTableProperty_result();\n       receiveBase(result, \"setTableProperty\");\n@@ -1385,6 +1391,9 @@ public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityEx\n       if (result.ouch2 != null) {\n         throw result.ouch2;\n       }\n+      if (result.ouch3 != null) {\n+        throw result.ouch3;\n+      }\n       return;\n     }\n \n@@ -3575,7 +3584,7 @@ public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apa\n         prot.writeMessageEnd();\n       }\n \n-      public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n+      public void getResult() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException {\n         if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n           throw new IllegalStateException(\"Method call not finished!\");\n         }\n@@ -3654,7 +3663,7 @@ public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apa\n         prot.writeMessageEnd();\n       }\n \n-      public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n+      public void getResult() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException {\n         if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n           throw new IllegalStateException(\"Method call not finished!\");\n         }\n@@ -3771,7 +3780,7 @@ public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apa\n         prot.writeMessageEnd();\n       }\n \n-      public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n+      public void getResult() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException {\n         if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n           throw new IllegalStateException(\"Method call not finished!\");\n         }\n@@ -5983,6 +5992,8 @@ public removeConstraint_result getResult(I iface, removeConstraint_args args) th\n           result.ouch1 = ouch1;\n         } catch (AccumuloSecurityException ouch2) {\n           result.ouch2 = ouch2;\n+        } catch (TableNotFoundException ouch3) {\n+          result.ouch3 = ouch3;\n         }\n         return result;\n       }\n@@ -6037,6 +6048,8 @@ public removeTableProperty_result getResult(I iface, removeTableProperty_args ar\n           result.ouch1 = ouch1;\n         } catch (AccumuloSecurityException ouch2) {\n           result.ouch2 = ouch2;\n+        } catch (TableNotFoundException ouch3) {\n+          result.ouch3 = ouch3;\n         }\n         return result;\n       }\n@@ -6121,6 +6134,8 @@ public setTableProperty_result getResult(I iface, setTableProperty_args args) th\n           result.ouch1 = ouch1;\n         } catch (AccumuloSecurityException ouch2) {\n           result.ouch2 = ouch2;\n+        } catch (TableNotFoundException ouch3) {\n+          result.ouch3 = ouch3;\n         }\n         return result;\n       }\n@@ -39944,6 +39959,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_arg\n \n     private static final org.apache.thrift.protocol.TField OUCH1_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch1\", org.apache.thrift.protocol.TType.STRUCT, (short)1);\n     private static final org.apache.thrift.protocol.TField OUCH2_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch2\", org.apache.thrift.protocol.TType.STRUCT, (short)2);\n+    private static final org.apache.thrift.protocol.TField OUCH3_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch3\", org.apache.thrift.protocol.TType.STRUCT, (short)3);\n \n     private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();\n     static {\n@@ -39953,11 +39969,13 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_arg\n \n     public AccumuloException ouch1; // required\n     public AccumuloSecurityException ouch2; // required\n+    public TableNotFoundException ouch3; // required\n \n     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */\n     @SuppressWarnings(\"all\") public enum _Fields implements org.apache.thrift.TFieldIdEnum {\n       OUCH1((short)1, \"ouch1\"),\n-      OUCH2((short)2, \"ouch2\");\n+      OUCH2((short)2, \"ouch2\"),\n+      OUCH3((short)3, \"ouch3\");\n \n       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();\n \n@@ -39976,6 +39994,8 @@ public static _Fields findByThriftId(int fieldId) {\n             return OUCH1;\n           case 2: // OUCH2\n             return OUCH2;\n+          case 3: // OUCH3\n+            return OUCH3;\n           default:\n             return null;\n         }\n@@ -40023,6 +40043,8 @@ public String getFieldName() {\n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       tmpMap.put(_Fields.OUCH2, new org.apache.thrift.meta_data.FieldMetaData(\"ouch2\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n+      tmpMap.put(_Fields.OUCH3, new org.apache.thrift.meta_data.FieldMetaData(\"ouch3\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       metaDataMap = Collections.unmodifiableMap(tmpMap);\n       org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(removeConstraint_result.class, metaDataMap);\n     }\n@@ -40032,11 +40054,13 @@ public removeConstraint_result() {\n \n     public removeConstraint_result(\n       AccumuloException ouch1,\n-      AccumuloSecurityException ouch2)\n+      AccumuloSecurityException ouch2,\n+      TableNotFoundException ouch3)\n     {\n       this();\n       this.ouch1 = ouch1;\n       this.ouch2 = ouch2;\n+      this.ouch3 = ouch3;\n     }\n \n     /**\n@@ -40049,6 +40073,9 @@ public removeConstraint_result(removeConstraint_result other) {\n       if (other.isSetOuch2()) {\n         this.ouch2 = new AccumuloSecurityException(other.ouch2);\n       }\n+      if (other.isSetOuch3()) {\n+        this.ouch3 = new TableNotFoundException(other.ouch3);\n+      }\n     }\n \n     public removeConstraint_result deepCopy() {\n@@ -40059,6 +40086,7 @@ public removeConstraint_result deepCopy() {\n     public void clear() {\n       this.ouch1 = null;\n       this.ouch2 = null;\n+      this.ouch3 = null;\n     }\n \n     public AccumuloException getOuch1() {\n@@ -40109,6 +40137,30 @@ public void setOuch2IsSet(boolean value) {\n       }\n     }\n \n+    public TableNotFoundException getOuch3() {\n+      return this.ouch3;\n+    }\n+\n+    public removeConstraint_result setOuch3(TableNotFoundException ouch3) {\n+      this.ouch3 = ouch3;\n+      return this;\n+    }\n+\n+    public void unsetOuch3() {\n+      this.ouch3 = null;\n+    }\n+\n+    /** Returns true if field ouch3 is set (has been assigned a value) and false otherwise */\n+    public boolean isSetOuch3() {\n+      return this.ouch3 != null;\n+    }\n+\n+    public void setOuch3IsSet(boolean value) {\n+      if (!value) {\n+        this.ouch3 = null;\n+      }\n+    }\n+\n     public void setFieldValue(_Fields field, Object value) {\n       switch (field) {\n       case OUCH1:\n@@ -40127,6 +40179,14 @@ public void setFieldValue(_Fields field, Object value) {\n         }\n         break;\n \n+      case OUCH3:\n+        if (value == null) {\n+          unsetOuch3();\n+        } else {\n+          setOuch3((TableNotFoundException)value);\n+        }\n+        break;\n+\n       }\n     }\n \n@@ -40138,6 +40198,9 @@ public Object getFieldValue(_Fields field) {\n       case OUCH2:\n         return getOuch2();\n \n+      case OUCH3:\n+        return getOuch3();\n+\n       }\n       throw new IllegalStateException();\n     }\n@@ -40153,6 +40216,8 @@ public boolean isSet(_Fields field) {\n         return isSetOuch1();\n       case OUCH2:\n         return isSetOuch2();\n+      case OUCH3:\n+        return isSetOuch3();\n       }\n       throw new IllegalStateException();\n     }\n@@ -40188,6 +40253,15 @@ public boolean equals(removeConstraint_result that) {\n           return false;\n       }\n \n+      boolean this_present_ouch3 = true && this.isSetOuch3();\n+      boolean that_present_ouch3 = true && that.isSetOuch3();\n+      if (this_present_ouch3 || that_present_ouch3) {\n+        if (!(this_present_ouch3 && that_present_ouch3))\n+          return false;\n+        if (!this.ouch3.equals(that.ouch3))\n+          return false;\n+      }\n+\n       return true;\n     }\n \n@@ -40224,6 +40298,16 @@ public int compareTo(removeConstraint_result other) {\n           return lastComparison;\n         }\n       }\n+      lastComparison = Boolean.valueOf(isSetOuch3()).compareTo(typedOther.isSetOuch3());\n+      if (lastComparison != 0) {\n+        return lastComparison;\n+      }\n+      if (isSetOuch3()) {\n+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch3, typedOther.ouch3);\n+        if (lastComparison != 0) {\n+          return lastComparison;\n+        }\n+      }\n       return 0;\n     }\n \n@@ -40259,6 +40343,14 @@ public String toString() {\n         sb.append(this.ouch2);\n       }\n       first = false;\n+      if (!first) sb.append(\", \");\n+      sb.append(\"ouch3:\");\n+      if (this.ouch3 == null) {\n+        sb.append(\"null\");\n+      } else {\n+        sb.append(this.ouch3);\n+      }\n+      first = false;\n       sb.append(\")\");\n       return sb.toString();\n     }\n@@ -40320,6 +40412,15 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, removeConstraint_re\n                 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n               }\n               break;\n+            case 3: // OUCH3\n+              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n+                struct.ouch3 = new TableNotFoundException();\n+                struct.ouch3.read(iprot);\n+                struct.setOuch3IsSet(true);\n+              } else { \n+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n+              }\n+              break;\n             default:\n               org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n           }\n@@ -40345,6 +40446,11 @@ public void write(org.apache.thrift.protocol.TProtocol oprot, removeConstraint_r\n           struct.ouch2.write(oprot);\n           oprot.writeFieldEnd();\n         }\n+        if (struct.ouch3 != null) {\n+          oprot.writeFieldBegin(OUCH3_FIELD_DESC);\n+          struct.ouch3.write(oprot);\n+          oprot.writeFieldEnd();\n+        }\n         oprot.writeFieldStop();\n         oprot.writeStructEnd();\n       }\n@@ -40369,19 +40475,25 @@ public void write(org.apache.thrift.protocol.TProtocol prot, removeConstraint_re\n         if (struct.isSetOuch2()) {\n           optionals.set(1);\n         }\n-        oprot.writeBitSet(optionals, 2);\n+        if (struct.isSetOuch3()) {\n+          optionals.set(2);\n+        }\n+        oprot.writeBitSet(optionals, 3);\n         if (struct.isSetOuch1()) {\n           struct.ouch1.write(oprot);\n         }\n         if (struct.isSetOuch2()) {\n           struct.ouch2.write(oprot);\n         }\n+        if (struct.isSetOuch3()) {\n+          struct.ouch3.write(oprot);\n+        }\n       }\n \n       @Override\n       public void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {\n         TTupleProtocol iprot = (TTupleProtocol) prot;\n-        BitSet incoming = iprot.readBitSet(2);\n+        BitSet incoming = iprot.readBitSet(3);\n         if (incoming.get(0)) {\n           struct.ouch1 = new AccumuloException();\n           struct.ouch1.read(iprot);\n@@ -40392,6 +40504,11 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_res\n           struct.ouch2.read(iprot);\n           struct.setOuch2IsSet(true);\n         }\n+        if (incoming.get(2)) {\n+          struct.ouch3 = new TableNotFoundException();\n+          struct.ouch3.read(iprot);\n+          struct.setOuch3IsSet(true);\n+        }\n       }\n     }\n \n@@ -42244,6 +42361,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_\n \n     private static final org.apache.thrift.protocol.TField OUCH1_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch1\", org.apache.thrift.protocol.TType.STRUCT, (short)1);\n     private static final org.apache.thrift.protocol.TField OUCH2_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch2\", org.apache.thrift.protocol.TType.STRUCT, (short)2);\n+    private static final org.apache.thrift.protocol.TField OUCH3_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch3\", org.apache.thrift.protocol.TType.STRUCT, (short)3);\n \n     private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();\n     static {\n@@ -42253,11 +42371,13 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_\n \n     public AccumuloException ouch1; // required\n     public AccumuloSecurityException ouch2; // required\n+    public TableNotFoundException ouch3; // required\n \n     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */\n     @SuppressWarnings(\"all\") public enum _Fields implements org.apache.thrift.TFieldIdEnum {\n       OUCH1((short)1, \"ouch1\"),\n-      OUCH2((short)2, \"ouch2\");\n+      OUCH2((short)2, \"ouch2\"),\n+      OUCH3((short)3, \"ouch3\");\n \n       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();\n \n@@ -42276,6 +42396,8 @@ public static _Fields findByThriftId(int fieldId) {\n             return OUCH1;\n           case 2: // OUCH2\n             return OUCH2;\n+          case 3: // OUCH3\n+            return OUCH3;\n           default:\n             return null;\n         }\n@@ -42323,6 +42445,8 @@ public String getFieldName() {\n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       tmpMap.put(_Fields.OUCH2, new org.apache.thrift.meta_data.FieldMetaData(\"ouch2\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n+      tmpMap.put(_Fields.OUCH3, new org.apache.thrift.meta_data.FieldMetaData(\"ouch3\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       metaDataMap = Collections.unmodifiableMap(tmpMap);\n       org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(removeTableProperty_result.class, metaDataMap);\n     }\n@@ -42332,11 +42456,13 @@ public removeTableProperty_result() {\n \n     public removeTableProperty_result(\n       AccumuloException ouch1,\n-      AccumuloSecurityException ouch2)\n+      AccumuloSecurityException ouch2,\n+      TableNotFoundException ouch3)\n     {\n       this();\n       this.ouch1 = ouch1;\n       this.ouch2 = ouch2;\n+      this.ouch3 = ouch3;\n     }\n \n     /**\n@@ -42349,6 +42475,9 @@ public removeTableProperty_result(removeTableProperty_result other) {\n       if (other.isSetOuch2()) {\n         this.ouch2 = new AccumuloSecurityException(other.ouch2);\n       }\n+      if (other.isSetOuch3()) {\n+        this.ouch3 = new TableNotFoundException(other.ouch3);\n+      }\n     }\n \n     public removeTableProperty_result deepCopy() {\n@@ -42359,6 +42488,7 @@ public removeTableProperty_result deepCopy() {\n     public void clear() {\n       this.ouch1 = null;\n       this.ouch2 = null;\n+      this.ouch3 = null;\n     }\n \n     public AccumuloException getOuch1() {\n@@ -42409,6 +42539,30 @@ public void setOuch2IsSet(boolean value) {\n       }\n     }\n \n+    public TableNotFoundException getOuch3() {\n+      return this.ouch3;\n+    }\n+\n+    public removeTableProperty_result setOuch3(TableNotFoundException ouch3) {\n+      this.ouch3 = ouch3;\n+      return this;\n+    }\n+\n+    public void unsetOuch3() {\n+      this.ouch3 = null;\n+    }\n+\n+    /** Returns true if field ouch3 is set (has been assigned a value) and false otherwise */\n+    public boolean isSetOuch3() {\n+      return this.ouch3 != null;\n+    }\n+\n+    public void setOuch3IsSet(boolean value) {\n+      if (!value) {\n+        this.ouch3 = null;\n+      }\n+    }\n+\n     public void setFieldValue(_Fields field, Object value) {\n       switch (field) {\n       case OUCH1:\n@@ -42427,6 +42581,14 @@ public void setFieldValue(_Fields field, Object value) {\n         }\n         break;\n \n+      case OUCH3:\n+        if (value == null) {\n+          unsetOuch3();\n+        } else {\n+          setOuch3((TableNotFoundException)value);\n+        }\n+        break;\n+\n       }\n     }\n \n@@ -42438,6 +42600,9 @@ public Object getFieldValue(_Fields field) {\n       case OUCH2:\n         return getOuch2();\n \n+      case OUCH3:\n+        return getOuch3();\n+\n       }\n       throw new IllegalStateException();\n     }\n@@ -42453,6 +42618,8 @@ public boolean isSet(_Fields field) {\n         return isSetOuch1();\n       case OUCH2:\n         return isSetOuch2();\n+      case OUCH3:\n+        return isSetOuch3();\n       }\n       throw new IllegalStateException();\n     }\n@@ -42488,6 +42655,15 @@ public boolean equals(removeTableProperty_result that) {\n           return false;\n       }\n \n+      boolean this_present_ouch3 = true && this.isSetOuch3();\n+      boolean that_present_ouch3 = true && that.isSetOuch3();\n+      if (this_present_ouch3 || that_present_ouch3) {\n+        if (!(this_present_ouch3 && that_present_ouch3))\n+          return false;\n+        if (!this.ouch3.equals(that.ouch3))\n+          return false;\n+      }\n+\n       return true;\n     }\n \n@@ -42524,6 +42700,16 @@ public int compareTo(removeTableProperty_result other) {\n           return lastComparison;\n         }\n       }\n+      lastComparison = Boolean.valueOf(isSetOuch3()).compareTo(typedOther.isSetOuch3());\n+      if (lastComparison != 0) {\n+        return lastComparison;\n+      }\n+      if (isSetOuch3()) {\n+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch3, typedOther.ouch3);\n+        if (lastComparison != 0) {\n+          return lastComparison;\n+        }\n+      }\n       return 0;\n     }\n \n@@ -42559,6 +42745,14 @@ public String toString() {\n         sb.append(this.ouch2);\n       }\n       first = false;\n+      if (!first) sb.append(\", \");\n+      sb.append(\"ouch3:\");\n+      if (this.ouch3 == null) {\n+        sb.append(\"null\");\n+      } else {\n+        sb.append(this.ouch3);\n+      }\n+      first = false;\n       sb.append(\")\");\n       return sb.toString();\n     }\n@@ -42620,6 +42814,15 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, removeTableProperty\n                 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n               }\n               break;\n+            case 3: // OUCH3\n+              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n+                struct.ouch3 = new TableNotFoundException();\n+                struct.ouch3.read(iprot);\n+                struct.setOuch3IsSet(true);\n+              } else { \n+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n+              }\n+              break;\n             default:\n               org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n           }\n@@ -42645,6 +42848,11 @@ public void write(org.apache.thrift.protocol.TProtocol oprot, removeTablePropert\n           struct.ouch2.write(oprot);\n           oprot.writeFieldEnd();\n         }\n+        if (struct.ouch3 != null) {\n+          oprot.writeFieldBegin(OUCH3_FIELD_DESC);\n+          struct.ouch3.write(oprot);\n+          oprot.writeFieldEnd();\n+        }\n         oprot.writeFieldStop();\n         oprot.writeStructEnd();\n       }\n@@ -42669,19 +42877,25 @@ public void write(org.apache.thrift.protocol.TProtocol prot, removeTableProperty\n         if (struct.isSetOuch2()) {\n           optionals.set(1);\n         }\n-        oprot.writeBitSet(optionals, 2);\n+        if (struct.isSetOuch3()) {\n+          optionals.set(2);\n+        }\n+        oprot.writeBitSet(optionals, 3);\n         if (struct.isSetOuch1()) {\n           struct.ouch1.write(oprot);\n         }\n         if (struct.isSetOuch2()) {\n           struct.ouch2.write(oprot);\n         }\n+        if (struct.isSetOuch3()) {\n+          struct.ouch3.write(oprot);\n+        }\n       }\n \n       @Override\n       public void read(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_result struct) throws org.apache.thrift.TException {\n         TTupleProtocol iprot = (TTupleProtocol) prot;\n-        BitSet incoming = iprot.readBitSet(2);\n+        BitSet incoming = iprot.readBitSet(3);\n         if (incoming.get(0)) {\n           struct.ouch1 = new AccumuloException();\n           struct.ouch1.read(iprot);\n@@ -42692,6 +42906,11 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_\n           struct.ouch2.read(iprot);\n           struct.setOuch2IsSet(true);\n         }\n+        if (incoming.get(2)) {\n+          struct.ouch3 = new TableNotFoundException();\n+          struct.ouch3.read(iprot);\n+          struct.setOuch3IsSet(true);\n+        }\n       }\n     }\n \n@@ -45818,6 +46037,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_arg\n \n     private static final org.apache.thrift.protocol.TField OUCH1_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch1\", org.apache.thrift.protocol.TType.STRUCT, (short)1);\n     private static final org.apache.thrift.protocol.TField OUCH2_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch2\", org.apache.thrift.protocol.TType.STRUCT, (short)2);\n+    private static final org.apache.thrift.protocol.TField OUCH3_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch3\", org.apache.thrift.protocol.TType.STRUCT, (short)3);\n \n     private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();\n     static {\n@@ -45827,11 +46047,13 @@ public void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_arg\n \n     public AccumuloException ouch1; // required\n     public AccumuloSecurityException ouch2; // required\n+    public TableNotFoundException ouch3; // required\n \n     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */\n     @SuppressWarnings(\"all\") public enum _Fields implements org.apache.thrift.TFieldIdEnum {\n       OUCH1((short)1, \"ouch1\"),\n-      OUCH2((short)2, \"ouch2\");\n+      OUCH2((short)2, \"ouch2\"),\n+      OUCH3((short)3, \"ouch3\");\n \n       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();\n \n@@ -45850,6 +46072,8 @@ public static _Fields findByThriftId(int fieldId) {\n             return OUCH1;\n           case 2: // OUCH2\n             return OUCH2;\n+          case 3: // OUCH3\n+            return OUCH3;\n           default:\n             return null;\n         }\n@@ -45897,6 +46121,8 @@ public String getFieldName() {\n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       tmpMap.put(_Fields.OUCH2, new org.apache.thrift.meta_data.FieldMetaData(\"ouch2\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n+      tmpMap.put(_Fields.OUCH3, new org.apache.thrift.meta_data.FieldMetaData(\"ouch3\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       metaDataMap = Collections.unmodifiableMap(tmpMap);\n       org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(setTableProperty_result.class, metaDataMap);\n     }\n@@ -45906,11 +46132,13 @@ public setTableProperty_result() {\n \n     public setTableProperty_result(\n       AccumuloException ouch1,\n-      AccumuloSecurityException ouch2)\n+      AccumuloSecurityException ouch2,\n+      TableNotFoundException ouch3)\n     {\n       this();\n       this.ouch1 = ouch1;\n       this.ouch2 = ouch2;\n+      this.ouch3 = ouch3;\n     }\n \n     /**\n@@ -45923,6 +46151,9 @@ public setTableProperty_result(setTableProperty_result other) {\n       if (other.isSetOuch2()) {\n         this.ouch2 = new AccumuloSecurityException(other.ouch2);\n       }\n+      if (other.isSetOuch3()) {\n+        this.ouch3 = new TableNotFoundException(other.ouch3);\n+      }\n     }\n \n     public setTableProperty_result deepCopy() {\n@@ -45933,6 +46164,7 @@ public setTableProperty_result deepCopy() {\n     public void clear() {\n       this.ouch1 = null;\n       this.ouch2 = null;\n+      this.ouch3 = null;\n     }\n \n     public AccumuloException getOuch1() {\n@@ -45983,6 +46215,30 @@ public void setOuch2IsSet(boolean value) {\n       }\n     }\n \n+    public TableNotFoundException getOuch3() {\n+      return this.ouch3;\n+    }\n+\n+    public setTableProperty_result setOuch3(TableNotFoundException ouch3) {\n+      this.ouch3 = ouch3;\n+      return this;\n+    }\n+\n+    public void unsetOuch3() {\n+      this.ouch3 = null;\n+    }\n+\n+    /** Returns true if field ouch3 is set (has been assigned a value) and false otherwise */\n+    public boolean isSetOuch3() {\n+      return this.ouch3 != null;\n+    }\n+\n+    public void setOuch3IsSet(boolean value) {\n+      if (!value) {\n+        this.ouch3 = null;\n+      }\n+    }\n+\n     public void setFieldValue(_Fields field, Object value) {\n       switch (field) {\n       case OUCH1:\n@@ -46001,6 +46257,14 @@ public void setFieldValue(_Fields field, Object value) {\n         }\n         break;\n \n+      case OUCH3:\n+        if (value == null) {\n+          unsetOuch3();\n+        } else {\n+          setOuch3((TableNotFoundException)value);\n+        }\n+        break;\n+\n       }\n     }\n \n@@ -46012,6 +46276,9 @@ public Object getFieldValue(_Fields field) {\n       case OUCH2:\n         return getOuch2();\n \n+      case OUCH3:\n+        return getOuch3();\n+\n       }\n       throw new IllegalStateException();\n     }\n@@ -46027,6 +46294,8 @@ public boolean isSet(_Fields field) {\n         return isSetOuch1();\n       case OUCH2:\n         return isSetOuch2();\n+      case OUCH3:\n+        return isSetOuch3();\n       }\n       throw new IllegalStateException();\n     }\n@@ -46062,6 +46331,15 @@ public boolean equals(setTableProperty_result that) {\n           return false;\n       }\n \n+      boolean this_present_ouch3 = true && this.isSetOuch3();\n+      boolean that_present_ouch3 = true && that.isSetOuch3();\n+      if (this_present_ouch3 || that_present_ouch3) {\n+        if (!(this_present_ouch3 && that_present_ouch3))\n+          return false;\n+        if (!this.ouch3.equals(that.ouch3))\n+          return false;\n+      }\n+\n       return true;\n     }\n \n@@ -46098,6 +46376,16 @@ public int compareTo(setTableProperty_result other) {\n           return lastComparison;\n         }\n       }\n+      lastComparison = Boolean.valueOf(isSetOuch3()).compareTo(typedOther.isSetOuch3());\n+      if (lastComparison != 0) {\n+        return lastComparison;\n+      }\n+      if (isSetOuch3()) {\n+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch3, typedOther.ouch3);\n+        if (lastComparison != 0) {\n+          return lastComparison;\n+        }\n+      }\n       return 0;\n     }\n \n@@ -46133,6 +46421,14 @@ public String toString() {\n         sb.append(this.ouch2);\n       }\n       first = false;\n+      if (!first) sb.append(\", \");\n+      sb.append(\"ouch3:\");\n+      if (this.ouch3 == null) {\n+        sb.append(\"null\");\n+      } else {\n+        sb.append(this.ouch3);\n+      }\n+      first = false;\n       sb.append(\")\");\n       return sb.toString();\n     }\n@@ -46194,6 +46490,15 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, setTableProperty_re\n                 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n               }\n               break;\n+            case 3: // OUCH3\n+              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n+                struct.ouch3 = new TableNotFoundException();\n+                struct.ouch3.read(iprot);\n+                struct.setOuch3IsSet(true);\n+              } else { \n+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n+              }\n+              break;\n             default:\n               org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n           }\n@@ -46219,6 +46524,11 @@ public void write(org.apache.thrift.protocol.TProtocol oprot, setTableProperty_r\n           struct.ouch2.write(oprot);\n           oprot.writeFieldEnd();\n         }\n+        if (struct.ouch3 != null) {\n+          oprot.writeFieldBegin(OUCH3_FIELD_DESC);\n+          struct.ouch3.write(oprot);\n+          oprot.writeFieldEnd();\n+        }\n         oprot.writeFieldStop();\n         oprot.writeStructEnd();\n       }\n@@ -46243,19 +46553,25 @@ public void write(org.apache.thrift.protocol.TProtocol prot, setTableProperty_re\n         if (struct.isSetOuch2()) {\n           optionals.set(1);\n         }\n-        oprot.writeBitSet(optionals, 2);\n+        if (struct.isSetOuch3()) {\n+          optionals.set(2);\n+        }\n+        oprot.writeBitSet(optionals, 3);\n         if (struct.isSetOuch1()) {\n           struct.ouch1.write(oprot);\n         }\n         if (struct.isSetOuch2()) {\n           struct.ouch2.write(oprot);\n         }\n+        if (struct.isSetOuch3()) {\n+          struct.ouch3.write(oprot);\n+        }\n       }\n \n       @Override\n       public void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_result struct) throws org.apache.thrift.TException {\n         TTupleProtocol iprot = (TTupleProtocol) prot;\n-        BitSet incoming = iprot.readBitSet(2);\n+        BitSet incoming = iprot.readBitSet(3);\n         if (incoming.get(0)) {\n           struct.ouch1 = new AccumuloException();\n           struct.ouch1.read(iprot);\n@@ -46266,6 +46582,11 @@ public void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_res\n           struct.ouch2.read(iprot);\n           struct.setOuch2IsSet(true);\n         }\n+        if (incoming.get(2)) {\n+          struct.ouch3 = new TableNotFoundException();\n+          struct.ouch3.read(iprot);\n+          struct.setOuch3IsSet(true);\n+        }\n       }\n     }\n \n", "nb_test": 27, "linesAdd": 350, "jira_id": "1199", "singleLine": false, "nb_skipped": 0, "commit": "813109d7", "nb_failure": 0, "linesRem": 24}, {"files": 2, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["execFileTest(org.apache.accumulo.core.util.shell.ShellTest): Unknown command present in Unknown command \"foo\".  Enter \"help\" for a list possible commands.(..)"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\nindex 1a3c518..4469d5c 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n@@ -78,8 +78,13 @@ public int start() throws IOException {\n     \n     if (execFile != null) {\n       java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n-      while (scanner.hasNextLine())\n+      try {\n+        while (scanner.hasNextLine() && !hasExited()) {\n           execCommand(scanner.nextLine(), true, isVerbose());\n+        }\n+      } finally {\n+        scanner.close();\n+      }\n     } else if (execCommand != null) {\n       for (String command : execCommand.split(\"\\n\")) {\n         execCommand(command, true, isVerbose());\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\nindex ab08c32..75f7bd0 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n@@ -447,8 +447,9 @@ public int start() throws IOException {\n     if (execFile != null) {\n       java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n       try {\n-        while (scanner.hasNextLine())\n+        while (scanner.hasNextLine() && !hasExited()) {\n           execCommand(scanner.nextLine(), true, isVerbose());\n+        }\n       } finally {\n         scanner.close();\n       }\n", "nb_test": 367, "linesAdd": 8, "jira_id": "1348", "singleLine": false, "nb_skipped": 0, "commit": "6ff92b12", "nb_failure": 1, "linesRem": 2}, {"files": 2, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["execFileTest(org.apache.accumulo.core.util.shell.ShellTest): Unknown command present in Unknown command \"foo\".  Enter \"help\" for a list possible commands.(..)"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\nindex 1a3c518..4469d5c 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n@@ -78,8 +78,13 @@ public int start() throws IOException {\n     \n     if (execFile != null) {\n       java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n-      while (scanner.hasNextLine())\n+      try {\n+        while (scanner.hasNextLine() && !hasExited()) {\n           execCommand(scanner.nextLine(), true, isVerbose());\n+        }\n+      } finally {\n+        scanner.close();\n+      }\n     } else if (execCommand != null) {\n       for (String command : execCommand.split(\"\\n\")) {\n         execCommand(command, true, isVerbose());\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\nindex abb324e..7efe5e6 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n@@ -438,8 +438,13 @@ public int start() throws IOException {\n     \n     if (execFile != null) {\n       java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n-      while (scanner.hasNextLine())\n+      try {\n+        while (scanner.hasNextLine() && !hasExited()) {\n           execCommand(scanner.nextLine(), true, isVerbose());\n+        }\n+      } finally {\n+        scanner.close();\n+      }\n     } else if (execCommand != null) {\n       for (String command : execCommand.split(\"\\n\")) {\n         execCommand(command, true, isVerbose());\n", "nb_test": 362, "linesAdd": 12, "jira_id": "1348", "singleLine": false, "nb_skipped": 0, "commit": "ef0f6ddc", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["handlesFilenamesWithMoreThanOneDot(org.apache.accumulo.core.file.FileOperationsTest): File does not exist: target/test.file.rf"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java b/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\nindex 9f60725..17e540b 100644\n--- a/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\n@@ -44,14 +44,13 @@ private FileOperations findFileFactory(String file) {\n     if (name.startsWith(Constants.MAPFILE_EXTENSION + \"_\")) {\n       return new MapFileOperations();\n     }\n-    \n     String[] sp = name.split(\"\\\\.\");\n     \n-    if (sp.length != 2) {\n+    if (sp.length < 2) {\n       throw new IllegalArgumentException(\"File name \" + name + \" has no extension\");\n     }\n     \n-    String extension = sp[1];\n+    String extension = sp[sp.length - 1];\n     \n     if (extension.equals(Constants.MAPFILE_EXTENSION) || extension.equals(Constants.MAPFILE_EXTENSION + \"_tmp\")) {\n       return new MapFileOperations();\n", "nb_test": 367, "linesAdd": 2, "jira_id": "1518", "singleLine": false, "nb_skipped": 0, "commit": "dc95cb69", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["duPatternTest(org.apache.accumulo.core.util.shell.ShellTest): 0 [t, tt] present in ylyu@fake tt> du -p t.*(..)", "duTest(org.apache.accumulo.core.util.shell.ShellTest): expected:<1> but was:<0>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java b/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\nindex 64d5970..6a61c50 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\n@@ -144,12 +144,17 @@ public static void printDiskUsage(AccumuloConfiguration acuConf, Collection<Stri\n       tdu.addTable(tableId);\n     \n     HashSet<String> tablesReferenced = new HashSet<String>(tableIds);\n+    HashSet<String> emptyTableIds = new HashSet<String>();\n     \n     for (String tableId : tableIds) {\n       Scanner mdScanner = conn.createScanner(Constants.METADATA_TABLE_NAME, Constants.NO_AUTHS);\n       mdScanner.fetchColumnFamily(Constants.METADATA_DATAFILE_COLUMN_FAMILY);\n       mdScanner.setRange(new KeyExtent(new Text(tableId), null, null).toMetadataRange());\n       \n+      if(!mdScanner.iterator().hasNext()) {\n+        emptyTableIds.add(tableId);\n+      }\n+      \n       for (Entry<Key,Value> entry : mdScanner) {\n         String file = entry.getKey().getColumnQualifier().toString();\n         if (file.startsWith(\"../\")) {\n@@ -216,6 +221,14 @@ public int compare(TreeSet<String> o1, TreeSet<String> o2) {\n       usage.put(tableNames, entry.getValue());\n     }\n \n+    if(!emptyTableIds.isEmpty()) {\n+      TreeSet<String> emptyTables = new TreeSet<String>();\n+      for (String tableId : emptyTableIds) {\n+        emptyTables.add(reverseTableIdMap.get(tableId));\n+      }\n+      usage.put(emptyTables, 0L);\n+    }\n+    \n     for (Entry<TreeSet<String>,Long> entry : usage.entrySet())\n       printer.print(String.format(\"%,24d %s\", entry.getValue(), entry.getKey()));\n     \n", "nb_test": 366, "linesAdd": 13, "jira_id": "1192", "singleLine": false, "nb_skipped": 0, "commit": "9476b877", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testDeleteRowsWithNullKeys(org.apache.accumulo.core.client.mock.MockTableOperationsTest)"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex dc4a619..64f8225 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -314,8 +314,8 @@ public void deleteRows(String tableName, Text start, Text end) throws AccumuloEx\n     if (!exists(tableName))\n       throw new TableNotFoundException(tableName, tableName, \"\");\n     MockTable t = acu.tables.get(tableName);\n-    Text startText = new Text(start);\n-    Text endText = new Text(end);\n+    Text startText = start != null ? new Text(start) : new Text();\n+    Text endText = end != null ? new Text(end) : new Text(t.table.lastKey().getRow().getBytes());\n     startText.append(ZERO, 0, 1);\n     endText.append(ZERO, 0, 1);\n     Set<Key> keep = new TreeSet<Key>(t.table.subMap(new Key(startText), new Key(endText)).keySet());\n", "nb_test": 412, "linesAdd": 2, "jira_id": "2748", "singleLine": false, "nb_skipped": 0, "commit": "ff8c2383", "nb_failure": 0, "linesRem": 2}, {"files": 6, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java b/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\nindex 4f95e1a..83283ac 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\n@@ -65,7 +65,6 @@\n   MASTER_RECOVERY_POOL(\"master.recovery.pool\", \"recovery\", PropertyType.STRING, \"Priority queue to use for log recovery map/reduce jobs.\"),\n   MASTER_RECOVERY_SORT_MAPREDUCE(\"master.recovery.sort.mapreduce\", \"false\", PropertyType.BOOLEAN,\n       \"If true, use map/reduce to sort write-ahead logs during recovery\"),\n-  MASTER_BULK_SERVERS(\"master.bulk.server.max\", \"4\", PropertyType.COUNT, \"The number of servers to use during a bulk load\"),\n   MASTER_BULK_RETRIES(\"master.bulk.retries\", \"3\", PropertyType.COUNT, \"The number of attempts to bulk-load a file before giving up.\"),\n   MASTER_BULK_THREADPOOL_SIZE(\"master.bulk.threadpool.size\", \"5\", PropertyType.COUNT, \"The number of threads to use when coordinating a bulk-import.\"),\n   MASTER_MINTHREADS(\"master.server.threads.minimum\", \"2\", PropertyType.COUNT, \"The minimum number of threads to use to handle incoming requests.\"),\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\nindex 5e82a7d..bb4ae64 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\n@@ -42,14 +42,13 @@\n import org.apache.hadoop.conf.Configuration;\n import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.Mapper;\n-import org.apache.log4j.Logger;\n \n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n \n public class WikipediaPartitionedMapper extends Mapper<Text,Article,Text,Mutation> {\n   \n-  private static final Logger log = Logger.getLogger(WikipediaPartitionedMapper.class);\n+  // private static final Logger log = Logger.getLogger(WikipediaPartitionedMapper.class);\n   \n   public final static Charset UTF8 = Charset.forName(\"UTF-8\");\n   public static final String DOCUMENT_COLUMN_FAMILY = \"d\";\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\nindex 82af9fd..3507108 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\n@@ -23,40 +23,21 @@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStreamReader;\n-import java.io.StringReader;\n import java.nio.charset.Charset;\n-import java.util.HashSet;\n-import java.util.IllegalFormatException;\n-import java.util.Map.Entry;\n-import java.util.Set;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-import org.apache.accumulo.core.data.Mutation;\n-import org.apache.accumulo.core.data.Value;\n-import org.apache.accumulo.core.security.ColumnVisibility;\n import org.apache.accumulo.examples.wikisearch.ingest.ArticleExtractor.Article;\n import org.apache.accumulo.examples.wikisearch.ingest.WikipediaInputFormat.WikipediaInputSplit;\n-import org.apache.accumulo.examples.wikisearch.normalizer.LcNoDiacriticsNormalizer;\n-import org.apache.accumulo.examples.wikisearch.protobuf.Uid;\n-import org.apache.accumulo.examples.wikisearch.protobuf.Uid.List.Builder;\n-import org.apache.commons.codec.binary.Base64;\n-import org.apache.commons.lang.StringUtils;\n import org.apache.hadoop.conf.Configuration;\n import org.apache.hadoop.io.LongWritable;\n import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.Mapper;\n import org.apache.hadoop.mapreduce.lib.input.FileSplit;\n-import org.apache.log4j.Logger;\n-import org.apache.lucene.analysis.tokenattributes.TermAttribute;\n-import org.apache.lucene.wikipedia.analysis.WikipediaTokenizer;\n-\n-import com.google.common.collect.HashMultimap;\n-import com.google.common.collect.Multimap;\n \n public class WikipediaPartitioner extends Mapper<LongWritable,Text,Text,Article> {\n   \n-  private static final Logger log = Logger.getLogger(WikipediaPartitioner.class);\n+  // private static final Logger log = Logger.getLogger(WikipediaPartitioner.class);\n   \n   public final static Charset UTF8 = Charset.forName(\"UTF-8\");\n   public static final String DOCUMENT_COLUMN_FAMILY = \"d\";\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\nindex d8c57c2..2738e2c 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\n@@ -4,20 +4,18 @@\n \n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.data.Mutation;\n-import org.apache.accumulo.examples.wikisearch.ingest.WikipediaMapper;\n import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.JobContext;\n import org.apache.hadoop.mapreduce.OutputCommitter;\n import org.apache.hadoop.mapreduce.OutputFormat;\n import org.apache.hadoop.mapreduce.RecordWriter;\n import org.apache.hadoop.mapreduce.TaskAttemptContext;\n-import org.apache.hadoop.fs.FileSystem;\n-import org.apache.hadoop.io.Text;\n-import org.apache.log4j.Logger;\n \n public class SortingRFileOutputFormat extends OutputFormat<Text,Mutation> {\n \n-  private static final Logger log = Logger.getLogger(SortingRFileOutputFormat.class);\n+  // private static final Logger log = Logger.getLogger(SortingRFileOutputFormat.class);\n \n   public static final String PATH_NAME = \"sortingrfileoutputformat.path\";\n   public static final String MAX_BUFFER_SIZE = \"sortingrfileoutputformat.max.buffer.size\";\ndiff --git a/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java b/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\nindex 071b8bd..4ee5371 100644\n--- a/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\n+++ b/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\n@@ -38,8 +38,8 @@\n import org.apache.accumulo.core.client.Instance;\n import org.apache.accumulo.core.client.impl.ServerClient;\n import org.apache.accumulo.core.client.impl.TabletLocator;\n-import org.apache.accumulo.core.client.impl.Translator;\n import org.apache.accumulo.core.client.impl.TabletLocator.TabletLocation;\n+import org.apache.accumulo.core.client.impl.Translator;\n import org.apache.accumulo.core.client.impl.thrift.ClientService;\n import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n@@ -150,7 +150,7 @@ public void run() {\n             } catch (Exception ex) {\n               log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\n             }\n-            \n+            log.debug(\"Map file \" + mapFile + \" found to overlap \" + tabletsToAssignMapFileTo.size() + \" tablets\");\n             if (tabletsToAssignMapFileTo.size() == 0) {\n               List<KeyExtent> empty = Collections.emptyList();\n               completeFailures.put(mapFile, empty);\n@@ -652,33 +652,41 @@ public String toString() {\n     return findOverlappingTablets(acuConf, fs, locator, file, start, failed.getEndRow());\n   }\n   \n+  final static byte[] byte0 = {0};\n+\n   public static List<TabletLocation> findOverlappingTablets(AccumuloConfiguration acuConf, FileSystem fs, TabletLocator locator, Path file, Text startRow,\n       Text endRow) throws Exception {\n     List<TabletLocation> result = new ArrayList<TabletLocation>();\n-    \n     Collection<ByteSequence> columnFamilies = Collections.emptyList();\n-    \n-    FileSKVIterator reader = FileOperations.getInstance().openReader(file.toString(), true, fs, fs.getConf(), acuConf);\n+    String filename = file.toString();\n+    // log.debug(filename + \" finding overlapping tablets \" + startRow + \" -> \" + endRow);\n+    FileSKVIterator reader = FileOperations.getInstance().openReader(filename, true, fs, fs.getConf(), acuConf);\n     try {\n       Text row = startRow;\n       if (row == null)\n         row = new Text();\n       while (true) {\n+        // log.debug(filename + \" Seeking to row \" + row);\n         reader.seek(new Range(row, null), columnFamilies, false);\n-        if (!reader.hasTop())\n+        if (!reader.hasTop()) {\n+          // log.debug(filename + \" not found\");\n           break;\n+        }\n         row = reader.getTopKey().getRow();\n         TabletLocation tabletLocation = locator.locateTablet(row, false, true);\n+        // log.debug(filename + \" found row \" + row + \" at location \" + tabletLocation);\n         result.add(tabletLocation);\n         row = tabletLocation.tablet_extent.getEndRow();\n-        if (row != null && (endRow == null || row.compareTo(endRow) < 0))\n-          row = Range.followingPrefix(row);\n-        else\n+        if (row != null && (endRow == null || row.compareTo(endRow) < 0)) {\n+          row = new Text(row);\n+          row.append(byte0, 0, byte0.length);\n+        } else\n           break;\n       }\n     } finally {\n       reader.close();\n     }\n+    // log.debug(filename + \" to be sent to \" + result);\n     return result;\n   }\n   \ndiff --git a/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java b/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\nindex c4a3f50..05c353d 100644\n--- a/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\n+++ b/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\n@@ -19,11 +19,15 @@\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n import java.util.concurrent.LinkedBlockingQueue;\n@@ -41,12 +45,13 @@\n import org.apache.accumulo.core.client.impl.thrift.TableOperationExceptionType;\n import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.conf.SiteConfiguration;\n import org.apache.accumulo.core.file.FileOperations;\n import org.apache.accumulo.core.master.state.tables.TableState;\n import org.apache.accumulo.core.security.thrift.AuthInfo;\n import org.apache.accumulo.core.util.CachedConfiguration;\n import org.apache.accumulo.core.util.Daemon;\n-import org.apache.accumulo.core.util.LoggingRunnable;\n+import org.apache.accumulo.core.util.ThriftUtil;\n import org.apache.accumulo.core.util.UtilWaitThread;\n import org.apache.accumulo.server.ServerConstants;\n import org.apache.accumulo.server.client.HdfsZooInstance;\n@@ -370,7 +375,7 @@ public LoadFiles(String tableId, String source, String bulk, String errorDir, bo\n   \n   @Override\n   public Repo<Master> call(final long tid, Master master) throws Exception {\n-    \n+    final SiteConfiguration conf = ServerConfiguration.getSiteConfiguration();\n     FileSystem fs = TraceFileSystem.wrap(org.apache.accumulo.core.file.FileUtil.getFileSystem(CachedConfiguration.getInstance(),\n         ServerConfiguration.getSiteConfiguration()));\n     List<FileStatus> files = new ArrayList<FileStatus>();\n@@ -389,42 +394,68 @@ public LoadFiles(String tableId, String source, String bulk, String errorDir, bo\n     }\n     fs.delete(writable, false);\n     \n-    // group files into N-sized chunks, send the chunks to random servers\n-    final int SERVERS_TO_USE = Math.min(ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_SERVERS), master.onlineTabletServers()\n-        .size());\n-    \n-    log.debug(\"tid \" + tid + \" using \" + SERVERS_TO_USE + \" servers\");\n-    // wait for success, repeat failures R times\n     final List<String> filesToLoad = Collections.synchronizedList(new ArrayList<String>());\n     for (FileStatus f : files)\n       filesToLoad.add(f.getPath().toString());\n     \n-    final int RETRIES = Math.max(1, ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_RETRIES));\n-    for (int i = 0; i < RETRIES && filesToLoad.size() > 0; i++) {\n-      List<Future<?>> results = new ArrayList<Future<?>>();\n-      for (List<String> chunk : groupFiles(filesToLoad, SERVERS_TO_USE)) {\n-        final List<String> attempt = chunk;\n-        results.add(threadPool.submit(new LoggingRunnable(log, new Runnable() {\n+\n+    final int RETRIES = Math.max(1, conf.getCount(Property.MASTER_BULK_RETRIES));\n+    for (int attempt = 0; attempt < RETRIES && filesToLoad.size() > 0; attempt++) {\n+      List<Future<List<String>>> results = new ArrayList<Future<List<String>>>();\n+      \n+      // Figure out which files will be sent to which server\n+      Set<TServerInstance> currentServers = Collections.synchronizedSet(new HashSet<TServerInstance>(master.onlineTabletServers()));\n+      Map<String,List<String>> loadAssignments = new HashMap<String,List<String>>();\n+      for (TServerInstance server : currentServers) {\n+        loadAssignments.put(server.hostPort(), new ArrayList<String>());\n+      }\n+      int i = 0;\n+      List<Entry<String,List<String>>> entries = new ArrayList<Entry<String,List<String>>>(loadAssignments.entrySet());\n+      for (String file : filesToLoad) {\n+        entries.get(i % entries.size()).getValue().add(file);\n+        i++;\n+      }\n+      \n+      // Use the threadpool to assign files one-at-a-time to the server\n+      for (Entry<String,List<String>> entry : entries) {\n+        if (entry.getValue().isEmpty()) {\n+          continue;\n+        }\n+        final Entry<String,List<String>> finalEntry = entry;\n+        results.add(threadPool.submit(new Callable<List<String>>() {\n           @Override\n-          public void run() {\n+          public List<String> call() {\n+            if (log.isDebugEnabled()) {\n+              log.debug(\"Asking \" + finalEntry.getKey() + \" to load \" + sampleList(finalEntry.getValue(), 10));\n+            }\n+            List<String> failures = new ArrayList<String>();\n             ClientService.Iface client = null;\n             try {\n-              client = ServerClient.getConnection(HdfsZooInstance.getInstance());\n+              client = ThriftUtil.getTServerClient(finalEntry.getKey(), conf);\n+              for (String file : finalEntry.getValue()) {\n+                List<String> attempt = Collections.singletonList(file);\n+                log.debug(\"Asking \" + finalEntry.getKey() + \" to bulk import \" + file);\n                 List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\n-              attempt.removeAll(fail);\n-              filesToLoad.removeAll(attempt);\n+                if (fail.isEmpty()) {\n+                  filesToLoad.remove(file);\n+                } else {\n+                  failures.addAll(fail);\n+                }\n+              }\n             } catch (Exception ex) {\n               log.error(ex, ex);\n             } finally {\n               ServerClient.close(client);\n             }\n+            return failures;\n           }\n-        })));\n+        }));\n       }\n-      for (Future<?> f : results)\n-        f.get();\n+      Set<String> failures = new HashSet<String>();\n+      for (Future<List<String>> f : results)\n+        failures.addAll(f.get());\n       if (filesToLoad.size() > 0) {\n-        log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + filesToLoad + \" failed\");\n+        log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + sampleList(filesToLoad, 10) + \" failed\");\n         UtilWaitThread.sleep(100);\n       }\n     }\n@@ -449,16 +480,24 @@ public void run() {\n     return new CompleteBulkImport(tableId, source, bulk, errorDir);\n   }\n   \n-  private List<List<String>> groupFiles(List<String> files, int groups) {\n-    List<List<String>> result = new ArrayList<List<String>>();\n-    Iterator<String> iter = files.iterator();\n-    for (int i = 0; i < groups && iter.hasNext(); i++) {\n-      List<String> group = new ArrayList<String>();\n-      for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {\n-        group.add(iter.next());\n+  static String sampleList(Collection<?> potentiallyLongList, int max) {\n+    StringBuffer result = new StringBuffer();\n+    result.append(\"[\");\n+    int i = 0;\n+    for (Object obj : potentiallyLongList) {\n+      result.append(obj);\n+      if (i >= max) {\n+        result.append(\"...\");\n+        break;\n+      } else {\n+        result.append(\", \");\n       }\n-      result.add(group);\n+      i++;\n     }\n-    return result;\n+    if (i < max)\n+      result.delete(result.length() - 2, result.length());\n+    result.append(\"]\");\n+    return result.toString();\n   }\n+\n }\n", "nb_test": 4, "linesAdd": 83, "jira_id": "412", "singleLine": false, "nb_skipped": 0, "commit": "5594b2e0", "nb_failure": 0, "linesRem": 67}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDelete(org.apache.accumulo.proxy.SimpleTest): expected:<0> but was:<1>"], "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex 3c5c88a..c6e74f1 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -1126,15 +1126,15 @@ private void addCellsToWriter(Map<ByteBuffer,List<ColumnUpdate>> cells, BatchWri\n           if (update.isSetDeleteCell()) {\n             m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n           } else {\n+            m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, update.getTimestamp(), new Value(value));\n+            }\n+        } else {\n           if (update.isSetDeleteCell()) {\n-              m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n+            m.putDelete(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz);\n           } else {\n-              m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);\n+            m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, new Value(value));\n           }\n         }\n-        } else {\n-          m.put(update.getColFamily(), update.getColQualifier(), viz, value);\n-        }\n       }\n       try {\n         bwpe.writer.addMutation(m);\n", "nb_test": 33, "linesAdd": 5, "jira_id": "1800", "singleLine": false, "nb_skipped": 0, "commit": "3143b9c5", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["handlesFilenamesWithMoreThanOneDot(org.apache.accumulo.core.file.FileOperationsTest): File does not exist: target/test.file.rf"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java b/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\nindex 9f60725..17e540b 100644\n--- a/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\n@@ -44,14 +44,13 @@ private FileOperations findFileFactory(String file) {\n     if (name.startsWith(Constants.MAPFILE_EXTENSION + \"_\")) {\n       return new MapFileOperations();\n     }\n-    \n     String[] sp = name.split(\"\\\\.\");\n     \n-    if (sp.length != 2) {\n+    if (sp.length < 2) {\n       throw new IllegalArgumentException(\"File name \" + name + \" has no extension\");\n     }\n     \n-    String extension = sp[1];\n+    String extension = sp[sp.length - 1];\n     \n     if (extension.equals(Constants.MAPFILE_EXTENSION) || extension.equals(Constants.MAPFILE_EXTENSION + \"_tmp\")) {\n       return new MapFileOperations();\n", "nb_test": 393, "linesAdd": 2, "jira_id": "1518", "singleLine": false, "nb_skipped": 0, "commit": "df4b1985", "nb_failure": 0, "linesRem": 3}, {"files": 2, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testTableNotFound(org.apache.accumulo.core.client.mock.MockTableOperationsTest)"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java b/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\nindex b533beb..dfb75ba 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\n@@ -48,6 +48,8 @@ public void attachIterator(String tableName, IteratorSetting setting) throws Acc\n   @Override\n   public void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException,\n       TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     Map<String,String> copy = new HashMap<String,String>();\n     for (Entry<String,String> property : this.getProperties(tableName)) {\n       copy.put(property.getKey(), property.getValue());\n@@ -64,6 +66,8 @@ public void removeIterator(String tableName, String name, EnumSet<IteratorScope>\n   @Override\n   public IteratorSetting getIteratorSetting(String tableName, String name, IteratorScope scope) throws AccumuloSecurityException, AccumuloException,\n       TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     int priority = -1;\n     String classname = null;\n     Map<String,String> settings = new HashMap<String,String>();\n@@ -90,6 +94,8 @@ public IteratorSetting getIteratorSetting(String tableName, String name, Iterato\n   \n   @Override\n   public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     Set<String> result = new HashSet<String>();\n     Set<String> lifecycles = new HashSet<String>();\n     for (IteratorScope scope : IteratorScope.values())\n@@ -107,6 +113,8 @@ public IteratorSetting getIteratorSetting(String tableName, String name, Iterato\n   \n   @Override\n   public void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     for (IteratorScope scope : setting.getScopes()) {\n       String scopeStr = String.format(\"%s%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());\n       String nameStr = String.format(\"%s.%s\", scopeStr, setting.getName());\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex 4353ab1..f2f32df 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -82,6 +82,8 @@ public void create(String tableName, boolean versioningIter, TimeType timeType)\n     if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\n       throw new IllegalArgumentException();\n     }\n+    if (exists(tableName))\n+      throw new TableExistsException(tableName, tableName, \"\");\n     acu.createTable(username, tableName, versioningIter, timeType);\n   }\n   \n@@ -91,30 +93,42 @@ public void create(String tableName, boolean versioningIter, TimeType timeType)\n   @Override\n   public void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException,\n       AccumuloException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     acu.addAggregators(tableName, aggregators);\n   }\n   \n   @Override\n-  public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {}\n+  public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n-  public Collection<Text> getSplits(String tableName) {\n+  public Collection<Text> getSplits(String tableName) throws TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     return Collections.emptyList();\n   }\n   \n   @Override\n-  public Collection<Text> getSplits(String tableName, int maxSplits) {\n-    return Collections.emptyList();\n+  public Collection<Text> getSplits(String tableName, int maxSplits) throws TableNotFoundException {\n+    return getSplits(tableName);\n   }\n   \n   @Override\n   public void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     acu.tables.remove(tableName);\n   }\n   \n   @Override\n   public void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException,\n       TableExistsException {\n+    if (!exists(oldTableName))\n+      throw new TableNotFoundException(oldTableName, oldTableName, \"\");\n+    if (exists(newTableName))\n+      throw new TableExistsException(newTableName, newTableName, \"\");\n     MockTable t = acu.tables.remove(oldTableName);\n     acu.tables.put(newTableName, t);\n   }\n@@ -134,15 +148,19 @@ public void removeProperty(String tableName, String property) throws AccumuloExc\n   \n   @Override\n   public Iterable<Entry<String,String>> getProperties(String tableName) throws TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     return acu.tables.get(tableName).settings.entrySet();\n   }\n   \n   @Override\n-  public void setLocalityGroups(String tableName, Map<String,Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {}\n+  public void setLocalityGroups(String tableName, Map<String,Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public Map<String,Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\n-    return null;\n+    throw new NotImplementedException();\n   }\n   \n   @Override\n@@ -164,13 +182,17 @@ public void importDirectory(String tableName, String dir, String failureDir, boo\n   }\n   \n   @Override\n-  public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {}\n+  public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public void online(String tableName) throws AccumuloSecurityException, AccumuloException {}\n   \n   @Override\n-  public void clearLocatorCache(String tableName) throws TableNotFoundException {}\n+  public void clearLocatorCache(String tableName) throws TableNotFoundException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public Map<String,String> tableIdMap() {\n", "nb_test": 285, "linesAdd": 38, "jira_id": "217", "singleLine": false, "nb_skipped": 0, "commit": "add180fb", "nb_failure": 0, "linesRem": 8}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["org.apache.accumulo.minicluster.MiniAccumuloClusterTest: Could not set master goal state, process returned 1"], "patch": "diff --git a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\nindex 7c27dd8..43fa6cb 100644\n--- a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n+++ b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n@@ -337,7 +337,7 @@ public void run() {\n     if (!initialized) {\n       // sleep a little bit to let zookeeper come up before calling init, seems to work better\n       UtilWaitThread.sleep(250);\n-      Process initProcess = exec(Initialize.class, \"--instance-name\", config.getInstanceName(), \"--password\", config.getRootPassword(), \"--username\", \"root\");\n+      Process initProcess = exec(Initialize.class, \"--instance-name\", config.getInstanceName(), \"--password\", config.getRootPassword());\n       int ret = initProcess.waitFor();\n       if (ret != 0) {\n         throw new RuntimeException(\"Initialize process returned \" + ret);\n", "nb_test": 4, "linesAdd": 1, "jira_id": "1544", "singleLine": false, "nb_skipped": 0, "commit": "0cf2ff72", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["readWriteBatchOneShotWithColumnFamilyOnly(org.apache.accumulo.proxy.TestProxyReadWrite): expected:<100000> but was:<50000>", "readWriteBatchOneShotWithFullColumn(org.apache.accumulo.proxy.TestProxyReadWrite): expected:<100000> but was:<50000>"], "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex 911d187..167cecc 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -819,7 +819,17 @@ public String createBatchScanner(ByteBuffer login, String tableName, BatchScanOp\n           }\n         }\n         scanner.setRanges(ranges);\n+\n+        if (opts.columns != null) {\n+          for (ScanColumn col : opts.columns) {\n+            if (col.isSetColQualifier())\n+              scanner.fetchColumn(ByteBufferUtil.toText(col.colFamily), ByteBufferUtil.toText(col.colQualifier));\n+            else\n+              scanner.fetchColumnFamily(ByteBufferUtil.toText(col.colFamily));\n+          }\n         }\n+      }\n+\n       UUID uuid = UUID.randomUUID();\n       \n       ScannerPlusIterator spi = new ScannerPlusIterator();\n", "nb_test": 24, "linesAdd": 10, "jira_id": "1183", "singleLine": false, "nb_skipped": 0, "commit": "cfbf5999", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testThrift_Invalid(org.apache.accumulo.core.data.MutationTest): Expected exception: java.lang.IllegalArgumentException"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\nindex 407dbc0..56ae7a6 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n@@ -223,6 +223,13 @@ public Mutation(TMutation tmutation) {\n     this.data = ByteBufferUtil.toBytes(tmutation.data);\n     this.entries = tmutation.entries;\n     this.values = ByteBufferUtil.toBytesList(tmutation.values);\n+    \n+    if (this.row == null) {\n+      throw new IllegalArgumentException(\"null row\");\n+    }\n+    if (this.data == null) {\n+      throw new IllegalArgumentException(\"null serialized data\");\n+    }\n   }\n   \n   public Mutation(Mutation m) {\n", "nb_test": 399, "linesAdd": 7, "jira_id": "1986", "singleLine": false, "nb_skipped": 0, "commit": "2d97b875", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDeleteRows(org.apache.accumulo.core.client.mock.MockTableOperationsTest)"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex f088b1f..dc4a619 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -55,9 +55,9 @@\n import org.apache.hadoop.io.Text;\n \n public class MockTableOperations extends TableOperationsHelper {\n-\n-  final private MockAccumulo acu;\n-  final private String username;\n+  private static final byte[] ZERO = {0};\n+  private final MockAccumulo acu;\n+  private final String username;\n \n   MockTableOperations(MockAccumulo acu, String username) {\n     this.acu = acu;\n@@ -314,7 +314,11 @@ public void deleteRows(String tableName, Text start, Text end) throws AccumuloEx\n     if (!exists(tableName))\n       throw new TableNotFoundException(tableName, tableName, \"\");\n     MockTable t = acu.tables.get(tableName);\n-    Set<Key> keep = new TreeSet<Key>(t.table.tailMap(new Key(start)).headMap(new Key(end)).keySet());\n+    Text startText = new Text(start);\n+    Text endText = new Text(end);\n+    startText.append(ZERO, 0, 1);\n+    endText.append(ZERO, 0, 1);\n+    Set<Key> keep = new TreeSet<Key>(t.table.subMap(new Key(startText), new Key(endText)).keySet());\n     t.table.keySet().removeAll(keep);\n   }\n \n", "nb_test": 411, "linesAdd": 8, "jira_id": "2544", "singleLine": false, "nb_skipped": 0, "commit": "7ec60f1b", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testVisibilityFollowingKey(org.apache.accumulo.core.data.KeyTest): bad character (0) near index 1"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\nindex 3d1f92d..afab887 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n@@ -22,6 +22,8 @@\n  * \n  */\n \n+import static org.apache.accumulo.core.util.ByteBufferUtil.toBytes;\n+\n import java.io.DataInput;\n import java.io.DataOutput;\n import java.io.IOException;\n@@ -38,8 +40,6 @@\n import org.apache.hadoop.io.WritableComparator;\n import org.apache.hadoop.io.WritableUtils;\n \n-import static org.apache.accumulo.core.util.ByteBufferUtil.toBytes;\n-\n public class Key implements WritableComparable<Key>, Cloneable {\n   \n   protected byte[] row;\n@@ -444,8 +444,10 @@ public int hashCode() {\n   }\n   \n   public static String toPrintableString(byte ba[], int offset, int len, int maxLen) {\n-    StringBuilder sb = new StringBuilder();\n+    return appendPrintableString(ba, offset, len, maxLen, new StringBuilder()).toString();\n+  }\n   \n+  public static StringBuilder appendPrintableString(byte ba[], int offset, int len, int maxLen, StringBuilder sb) {\n     int plen = Math.min(len, maxLen);\n     \n     for (int i = 0; i < plen; i++) {\n@@ -460,26 +462,33 @@ public static String toPrintableString(byte ba[], int offset, int len, int maxLe\n       sb.append(\"... TRUNCATED\");\n     }\n     \n-    return sb.toString();\n+    return sb;\n   }\n   \n-  public String toString() {\n-    String labelString = new ColumnVisibility(colVisibility).toString();\n+  private StringBuilder rowColumnStringBuilder() {\n+    StringBuilder sb = new StringBuilder();\n+    appendPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\" \");\n+    appendPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\":\");\n+    appendPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\" [\");\n+    appendPrintableString(colVisibility, 0, colVisibility.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\"]\");\n+    return sb;\n+  }\n   \n-    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \"\n-        + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\"\n-        + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \"\n-        + deleted;\n-    return s;\n+  public String toString() {\n+    StringBuilder sb = rowColumnStringBuilder();\n+    sb.append(\" \");\n+    sb.append(Long.toString(timestamp));\n+    sb.append(\" \");\n+    sb.append(deleted);\n+    return sb.toString();\n   }\n   \n   public String toStringNoTime() {\n-    \n-    String labelString = new ColumnVisibility(colVisibility).toString();\n-    \n-    String s = new String(row, 0, row.length) + \" \" + new String(colFamily, 0, colFamily.length) + \":\" + new String(colQualifier, 0, colQualifier.length) + \" \"\n-        + labelString;\n-    return s;\n+    return rowColumnStringBuilder().toString();\n   }\n   \n   public int getLength() {\n", "nb_test": 265, "linesAdd": 26, "jira_id": "193", "singleLine": false, "nb_skipped": 0, "commit": "c831e44d", "nb_failure": 0, "linesRem": 17}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test1(org.apache.accumulo.core.iterators.user.RegExFilterTest)"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\nindex 0b3b73f..fb53801 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n@@ -17,6 +17,7 @@\n package org.apache.accumulo.core.iterators.user;\n \n import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n import java.util.Map;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n@@ -28,7 +29,6 @@\n import org.apache.accumulo.core.iterators.Filter;\n import org.apache.accumulo.core.iterators.IteratorEnvironment;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n-import org.apache.accumulo.core.util.ByteArrayBackedCharSequence;\n \n /**\n  * A Filter that matches entries based on Java regular expressions.\n@@ -52,6 +52,9 @@\n   public static final String COLQ_REGEX = \"colqRegex\";\n   public static final String VALUE_REGEX = \"valueRegex\";\n   public static final String OR_FIELDS = \"orFields\";\n+  public static final String ENCODING = \"encoding\";\n+  \n+  public static final String ENCODING_DEFAULT = \"UTF-8\";\n   \n   private Matcher rowMatcher;\n   private Matcher colfMatcher;\n@@ -59,10 +62,9 @@\n   private Matcher valueMatcher;\n   private boolean orFields = false;\n   \n-  private ByteArrayBackedCharSequence babcs = new ByteArrayBackedCharSequence();\n+  private String encoding = ENCODING_DEFAULT;\n   \n-  private Matcher copyMatcher(Matcher m)\n-  {\n+  private Matcher copyMatcher(Matcher m) {\n     if (m == null)\n       return m;\n     else\n@@ -71,21 +73,25 @@ private Matcher copyMatcher(Matcher m)\n   \n   private boolean matches(Matcher matcher, ByteSequence bs) {\n     if (matcher != null) {\n-      babcs.set(bs);\n-      matcher.reset(babcs);\n+      try {\n+        matcher.reset(new String(bs.getBackingArray(), bs.offset(), bs.length(), encoding));\n         return matcher.matches();\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+      }\n     }\n-    \n     return !orFields;\n   }\n   \n   private boolean matches(Matcher matcher, byte data[], int offset, int len) {\n     if (matcher != null) {\n-      babcs.set(data, offset, len);\n-      matcher.reset(babcs);\n+      try {\n+        matcher.reset(new String(data, offset, len, encoding));\n         return matcher.matches();\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+      }\n     }\n-    \n     return !orFields;\n   }\n   \n@@ -130,6 +136,10 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n     } else {\n       orFields = false;\n     }\n+    \n+    if (options.containsKey(ENCODING)) {\n+      encoding = options.get(ENCODING);\n+    }\n   }\n   \n   @Override\n@@ -142,6 +152,7 @@ public IteratorOptions describeOptions() {\n     io.addNamedOption(RegExFilter.COLQ_REGEX, \"regular expression on column qualifier\");\n     io.addNamedOption(RegExFilter.VALUE_REGEX, \"regular expression on value\");\n     io.addNamedOption(RegExFilter.OR_FIELDS, \"use OR instread of AND when multiple regexes given\");\n+    io.addNamedOption(RegExFilter.ENCODING, \"character encoding of byte array value (default is \" + ENCODING_DEFAULT + \")\");\n     return io;\n   }\n   \n@@ -160,6 +171,17 @@ public boolean validateOptions(Map<String,String> options) {\n     if (options.containsKey(VALUE_REGEX))\n       Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\n     \n+    if (options.containsKey(ENCODING)) {\n+      try {\n+        this.encoding = options.get(ENCODING);\n+        @SuppressWarnings(\"unused\")\n+        String test = new String(\"test\".getBytes(), encoding);\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+        return false;\n+      }\n+    }\n+    \n     return true;\n   }\n   \n@@ -192,4 +214,19 @@ public static void setRegexs(IteratorSetting si, String rowTerm, String cfTerm,\n       si.addOption(RegExFilter.OR_FIELDS, \"true\");\n     }\n   }\n+  \n+  /**\n+   * Set the encoding string to use when interpreting characters\n+   * \n+   * @param si\n+   *          ScanIterator config to be updated\n+   * @param encoding\n+   *          the encoding string to use for character interpretation.\n+   * \n+   */\n+  public static void setEncoding(IteratorSetting si, String encoding) {\n+    if (!encoding.isEmpty()) {\n+      si.addOption(RegExFilter.ENCODING, encoding);\n+    }\n+  }\n }\n", "nb_test": 266, "linesAdd": 38, "jira_id": "209", "singleLine": false, "nb_skipped": 0, "commit": "76d727f0", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testThrift_Invalid(org.apache.accumulo.core.data.KeyTest): Expected exception: java.lang.IllegalArgumentException"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/Key.java b/core/src/main/java/org/apache/accumulo/core/data/Key.java\nindex de9e22d..4b6867f 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/Key.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/Key.java\n@@ -291,6 +291,19 @@ public Key(TKey tkey) {\n     this.colVisibility = toBytes(tkey.colVisibility);\n     this.timestamp = tkey.timestamp;\n     this.deleted = false;\n+\n+    if (row == null) {\n+      throw new IllegalArgumentException(\"null row\");\n+    }\n+    if (colFamily == null) {\n+      throw new IllegalArgumentException(\"null column family\");\n+    }\n+    if (colQualifier == null) {\n+      throw new IllegalArgumentException(\"null column qualifier\");\n+    }\n+    if (colVisibility == null) {\n+      throw new IllegalArgumentException(\"null column visibility\");\n+    }\n   }\n   \n   /**\n", "nb_test": 386, "linesAdd": 13, "jira_id": "1986", "singleLine": false, "nb_skipped": 0, "commit": "a5e3ed3b", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PreciseNumberTypeTest.test:29 expected:<1[,000]> but was:<1[.00K]>"], "patch": "diff --git a/server/monitor/src/main/java/org/apache/accumulo/monitor/servlets/PreciseNumberType.java b/server/monitor/src/main/java/org/apache/accumulo/monitor/servlets/PreciseNumberType.java\nindex 66f97e1..1642fc2 100644\n--- a/server/monitor/src/main/java/org/apache/accumulo/monitor/servlets/PreciseNumberType.java\n+++ b/server/monitor/src/main/java/org/apache/accumulo/monitor/servlets/PreciseNumberType.java\n@@ -24,9 +24,16 @@ public PreciseNumberType(int warnMin, int warnMax, int errMin, int errMax) {\n     super(warnMin, warnMax, errMin, errMax);\n   }\n   \n-  public PreciseNumberType() {}\n-  \n-  public static String bigNumber(long big, String[] SUFFIXES, long base) {\n-    return String.format(\"%,d\", big);\n+  @Override\n+  public String format(Object obj) {\n+    int i = (Integer)obj;\n+    String display = String.format(\"%,d\", obj);\n+    if (i < errMin || i > errMax)\n+      return String.format(\"<span class='error'>%s</span>\", display);\n+    if (i < warnMin || i > warnMax)\n+      return String.format(\"<span class='warning'>%s</span>\", display);\n+    return display;\n   }\n+\n+  public PreciseNumberType() {}\n }\ndiff --git a/server/monitor/src/main/java/org/apache/accumulo/monitor/util/celltypes/NumberType.java b/server/monitor/src/main/java/org/apache/accumulo/monitor/util/celltypes/NumberType.java\nindex d311603..b285727 100644\n--- a/server/monitor/src/main/java/org/apache/accumulo/monitor/util/celltypes/NumberType.java\n+++ b/server/monitor/src/main/java/org/apache/accumulo/monitor/util/celltypes/NumberType.java\n@@ -20,7 +20,7 @@\n \n public class NumberType<T extends Number> extends CellType<T> {\n   \n-  private T warnMin, warnMax, errMin, errMax;\n+  protected final T warnMin, warnMax, errMin, errMax;\n   \n   public NumberType(T warnMin, T warnMax, T errMin, T errMax) {\n     this.warnMin = warnMin;\n", "nb_test": 4, "linesAdd": 12, "jira_id": "3408", "singleLine": false, "nb_skipped": 0, "commit": "81d25bc2", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["AccumuloVFSClassLoaderTest.testCacheDirectoryConfigured:204 null"], "patch": "diff --git a/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java b/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\nindex 983ad7c..bd1f943 100644\n--- a/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\n+++ b/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\n@@ -92,8 +92,6 @@ public void run() {\n \n   public static final String VFS_CACHE_DIR = \"general.vfs.cache.dir\";\n   \n-  public static final AtomicInteger uniqueDirectoryGenerator = new AtomicInteger(0);\n-\n   private static ClassLoader parent = null;\n   private static volatile ReloadingClassLoader loader = null;\n   private static final Object lock = new Object();\n@@ -279,10 +277,7 @@ public static FileSystemManager generateVfs() throws FileSystemException {\n     vfs.addMimeTypeMap(\"application/zip\", \"zip\");\n     vfs.setFileContentInfoFactory(new FileContentInfoFilenameFactory());\n     vfs.setFilesCache(new SoftRefFilesCache());\n-    String cacheDirPath = AccumuloClassLoader.getAccumuloString(VFS_CACHE_DIR, \"\");\n     File cacheDir = computeTopCacheDir(); \n-    if (!cacheDirPath.isEmpty())\n-      cacheDir = new File(cacheDirPath, \"\" + uniqueDirectoryGenerator.getAndIncrement());\n     vfs.setReplicator(new UniqueFileReplicator(cacheDir));\n     vfs.setCacheStrategy(CacheStrategy.ON_RESOLVE);\n     vfs.init();\n@@ -291,8 +286,9 @@ public static FileSystemManager generateVfs() throws FileSystemException {\n   }\n \n   private static File computeTopCacheDir() {\n+    String cacheDirPath = AccumuloClassLoader.getAccumuloString(VFS_CACHE_DIR, System.getProperty(\"java.io.tmpdir\"));\n     String procName = ManagementFactory.getRuntimeMXBean().getName();\n-    return new File(System.getProperty(\"java.io.tmpdir\"), \"accumulo-vfs-cache-\" + procName + \"-\" + System.getProperty(\"user.name\", \"nouser\"));\n+    return new File(cacheDirPath, \"accumulo-vfs-cache-\" + procName + \"-\" + System.getProperty(\"user.name\", \"nouser\"));\n   }\n \n   public interface Printer {\n", "nb_test": 33, "linesAdd": 2, "jira_id": "3383", "singleLine": false, "nb_skipped": 1, "commit": "97f16db4", "nb_failure": 1, "linesRem": 6}, {"files": 2, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ZooKeeperConnectionInfoTest.testEquality:27 expected:<org.apache.accumulo.fate.zookeeper.ZooUtil$ZooKeeperConnectionInfo@528ef256> but was:<org.apache.accumulo.fate.zookeeper.ZooUtil$ZooKeeperConnectionInfo@26c81672>"], "patch": "diff --git a/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooCache.java b/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooCache.java\nindex b3dd19a..d72ac08 100644\n--- a/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooCache.java\n+++ b/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooCache.java\n@@ -162,7 +162,7 @@ private synchronized void retry(ZooRunnable op) {\n         if (code == Code.NONODE) {\n           log.error(\"Looked up non-existent node in cache \" + e.getPath(), e);\n         } else if (code == Code.CONNECTIONLOSS || code == Code.OPERATIONTIMEOUT || code == Code.SESSIONEXPIRED) {\n-          log.warn(\"Saw (possibly) transient exception communicating with ZooKeeper, wil retry\", e);\n+          log.warn(\"Saw (possibly) transient exception communicating with ZooKeeper, will retry\", e);\n           continue;\n         }\n         log.warn(\"Zookeeper error, will retry\", e);\ndiff --git a/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooUtil.java b/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooUtil.java\nindex 674c1d8..1a3af6b 100644\n--- a/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooUtil.java\n+++ b/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooUtil.java\n@@ -18,9 +18,11 @@\n \n import java.math.BigInteger;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n \n+import org.apache.commons.lang.builder.HashCodeBuilder;\n import org.apache.log4j.Logger;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n@@ -32,6 +34,8 @@\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n \n+import com.google.common.base.Preconditions;\n+\n public class ZooUtil {\n   private static final Logger log = Logger.getLogger(ZooUtil.class);\n \n@@ -87,11 +91,68 @@ public String toString() {\n     byte[] auth;\n \n     public ZooKeeperConnectionInfo(String keepers, int timeout, String scheme, byte[] auth) {\n+      Preconditions.checkNotNull(keepers);\n       this.keepers = keepers;\n       this.timeout = timeout;\n       this.scheme = scheme;\n       this.auth = auth;\n     }\n+\n+    @Override\n+    public int hashCode() {\n+      final HashCodeBuilder hcb = new HashCodeBuilder(31, 47);\n+      hcb.append(keepers).append(timeout);\n+      if (null != scheme) {\n+        hcb.append(scheme);\n+      }\n+      if (null != auth) {\n+        hcb.append(auth);\n+      }\n+      return hcb.toHashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof ZooKeeperConnectionInfo) {\n+        ZooKeeperConnectionInfo other = (ZooKeeperConnectionInfo) o;\n+        if (!keepers.equals(other.keepers) || timeout != other.timeout) {\n+          return false;\n+        }\n+\n+        if (null != scheme) {\n+          if (null == other.scheme) {\n+            // Ours is non-null, theirs is null\n+            return false;\n+          } else if (!scheme.equals(other.scheme)) {\n+            // Both non-null but not equal\n+            return false;\n+          }\n+        }\n+\n+        if (null != auth) {\n+          if (null == other.auth) {\n+            return false;\n+          } else if (!Arrays.equals(auth, other.auth)) {\n+            // both non-null but not equal\n+            return false;\n+          }\n+        }\n+\n+        return true;\n+      }\n+\n+      return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      StringBuilder sb = new StringBuilder(64);\n+      sb.append(\"zookeepers=\").append(keepers);\n+      sb.append(\", timeout=\").append(timeout);\n+      sb.append(\", scheme=\").append(scheme);\n+      sb.append(\", auth=\").append(null == auth ? \"null\" : \"REDACTED\");\n+      return sb.toString();\n+    }\n   }\n \n   public static final List<ACL> PRIVATE;\n@@ -206,8 +267,7 @@ public static boolean putPersistentData(ZooKeeperConnectionInfo info, String zPa\n   }\n \n   public static boolean putPersistentData(ZooKeeperConnectionInfo info, String zPath, byte[] data, int version, NodeExistsPolicy policy)\n-      throws KeeperException,\n-      InterruptedException {\n+      throws KeeperException, InterruptedException {\n     return putData(info, zPath, data, CreateMode.PERSISTENT, version, policy, PUBLIC);\n   }\n \n@@ -216,8 +276,7 @@ public static boolean putPersistentData(ZooKeeperConnectionInfo info, String zPa\n     return putData(info, zPath, data, CreateMode.PERSISTENT, version, policy, acls);\n   }\n \n-  private static boolean putData(ZooKeeperConnectionInfo info, String zPath, byte[] data, CreateMode mode, int version,\n-      NodeExistsPolicy policy, List<ACL> acls)\n+  private static boolean putData(ZooKeeperConnectionInfo info, String zPath, byte[] data, CreateMode mode, int version, NodeExistsPolicy policy, List<ACL> acls)\n       throws KeeperException, InterruptedException {\n     if (policy == null)\n       policy = NodeExistsPolicy.FAIL;\n@@ -347,11 +406,12 @@ public static void recursiveCopyPersistent(ZooKeeperConnectionInfo info, String\n           }\n           retry.waitForNextAttempt();\n         }\n-        for (String child : children)\n+        for (String child : children) {\n           recursiveCopyPersistent(info, source + \"/\" + child, destination + \"/\" + child, policy);\n         }\n       }\n     }\n+  }\n \n   public static boolean putPrivatePersistentData(ZooKeeperConnectionInfo info, String zPath, byte[] data, NodeExistsPolicy policy) throws KeeperException,\n       InterruptedException {\n", "nb_test": 49, "linesAdd": 63, "jira_id": "3242", "singleLine": false, "nb_skipped": 0, "commit": "15e83709", "nb_failure": 1, "linesRem": 6}, {"files": 2, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testBatchWriter(org.apache.accumulo.proxy.SimpleTest)"], "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex ed8c71f..859b948 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -104,11 +104,19 @@\n     public Iterator<Map.Entry<Key,Value>> iterator;\n   }\n   \n-  static class CloseWriter implements RemovalListener<UUID,BatchWriter> {\n+  static protected class BatchWriterPlusException {\n+    public BatchWriter writer;\n+    public MutationsRejectedException exception = null;\n+  }\n+  \n+  static class CloseWriter implements RemovalListener<UUID,BatchWriterPlusException> {\n     @Override\n-    public void onRemoval(RemovalNotification<UUID,BatchWriter> notification) {\n+    public void onRemoval(RemovalNotification<UUID,BatchWriterPlusException> notification) {\n       try {\n-        notification.getValue().close();\n+        BatchWriterPlusException value = notification.getValue();\n+        if (value.exception != null)\n+          throw value.exception;\n+        notification.getValue().writer.close();\n       } catch (MutationsRejectedException e) {\n         logger.warn(e, e);\n       }\n@@ -131,7 +139,7 @@ public CloseScanner() {}\n   }\n   \n   protected Cache<UUID,ScannerPlusIterator> scannerCache;\n-  protected Cache<UUID,BatchWriter> writerCache;\n+  protected Cache<UUID,BatchWriterPlusException> writerCache;\n   \n   public ProxyServer(Properties props) {\n \n@@ -904,10 +912,12 @@ public void closeScanner(String uuid) throws TException {\n   @Override\n   public void updateAndFlush(ByteBuffer login, String tableName, Map<ByteBuffer,List<ColumnUpdate>> cells) throws TException {\n     try {\n-      BatchWriter writer = getWriter(login, tableName, null);\n-      addCellsToWriter(cells, writer);\n-      writer.flush();\n-      writer.close();\n+      BatchWriterPlusException bwpe = getWriter(login, tableName, null);\n+      addCellsToWriter(cells, bwpe);\n+      if (bwpe.exception != null)\n+        throw bwpe.exception;\n+      bwpe.writer.flush();\n+      bwpe.writer.close();\n     } catch (Exception e) {\n       throw translateException(e);\n     }\n@@ -915,7 +925,10 @@ public void updateAndFlush(ByteBuffer login, String tableName, Map<ByteBuffer,Li\n   \n   private static final ColumnVisibility EMPTY_VIS = new ColumnVisibility();\n   \n-  private void addCellsToWriter(Map<ByteBuffer,List<ColumnUpdate>> cells, BatchWriter writer) throws MutationsRejectedException {\n+  private void addCellsToWriter(Map<ByteBuffer,List<ColumnUpdate>> cells, BatchWriterPlusException bwpe) throws MutationsRejectedException {\n+    if (bwpe.exception != null)\n+      return;\n+    \n     HashMap<Text,ColumnVisibility> vizMap = new HashMap<Text,ColumnVisibility>();\n     \n     for (Entry<ByteBuffer,List<ColumnUpdate>> entry : cells.entrySet()) {\n@@ -947,14 +960,18 @@ private void addCellsToWriter(Map<ByteBuffer,List<ColumnUpdate>> cells, BatchWri\n           m.put(update.getColFamily(), update.getColQualifier(), viz, value);\n         }\n       }\n-      writer.addMutation(m);\n+      try {\n+        bwpe.writer.addMutation(m);\n+      } catch (MutationsRejectedException mre) {\n+        bwpe.exception = mre;\n+      }\n     }\n   }\n   \n   @Override\n   public String createWriter(ByteBuffer login, String tableName, WriterOptions opts) throws TException {\n     try {\n-      BatchWriter writer = getWriter(login, tableName, opts);\n+      BatchWriterPlusException writer = getWriter(login, tableName, opts);\n       UUID uuid = UUID.randomUUID();\n       writerCache.put(uuid, writer);\n       return uuid.toString();\n@@ -966,11 +983,11 @@ public String createWriter(ByteBuffer login, String tableName, WriterOptions opt\n   @Override\n   public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws TException {\n     try {\n-      BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\n-      if (batchwriter == null) {\n+      BatchWriterPlusException bwpe = writerCache.getIfPresent(UUID.fromString(writer));\n+      if (bwpe == null) {\n         throw new UnknownWriter(\"Writer never existed or no longer exists\");\n       }\n-      addCellsToWriter(cells, batchwriter);\n+      addCellsToWriter(cells, bwpe);\n     } catch (Exception e) {\n       throw translateException(e);\n     }\n@@ -979,11 +996,13 @@ public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) thro\n   @Override\n   public void flush(String writer) throws TException {\n     try {\n-      BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\n-      if (batchwriter == null) {\n+      BatchWriterPlusException bwpe = writerCache.getIfPresent(UUID.fromString(writer));\n+      if (bwpe == null) {\n         throw new UnknownWriter(\"Writer never existed or no longer exists\");\n       }\n-      batchwriter.flush();\n+      if (bwpe.exception != null)\n+        throw bwpe.exception;\n+      bwpe.writer.flush();\n     } catch (Exception e) {\n       throw translateException(e);\n     }\n@@ -992,18 +1011,20 @@ public void flush(String writer) throws TException {\n   @Override\n   public void closeWriter(String writer) throws TException {\n     try {\n-      BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\n-      if (batchwriter == null) {\n+      BatchWriterPlusException bwpe = writerCache.getIfPresent(UUID.fromString(writer));\n+      if (bwpe == null) {\n         throw new UnknownWriter(\"Writer never existed or no longer exists\");\n       }\n-      batchwriter.close();\n+      if (bwpe.exception != null)\n+        throw bwpe.exception;\n+      bwpe.writer.close();\n       writerCache.invalidate(UUID.fromString(writer));\n     } catch (Exception e) {\n       throw translateException(e);\n     }\n   }\n   \n-  private BatchWriter getWriter(ByteBuffer login, String tableName, WriterOptions opts) throws Exception {\n+  private BatchWriterPlusException getWriter(ByteBuffer login, String tableName, WriterOptions opts) throws Exception {\n     BatchWriterConfig cfg = new BatchWriterConfig();\n     if (opts != null) {\n       if (opts.maxMemory != 0)\n@@ -1015,7 +1036,9 @@ private BatchWriter getWriter(ByteBuffer login, String tableName, WriterOptions\n       if (opts.latencyMs != 0)\n         cfg.setMaxLatency(opts.latencyMs, TimeUnit.MILLISECONDS);\n     }\n-    return getConnector(login).createBatchWriter(tableName, cfg);\n+    BatchWriterPlusException result = new BatchWriterPlusException();\n+    result.writer = getConnector(login).createBatchWriter(tableName, cfg);\n+    return result;\n   }\n   \n   private IteratorSetting getIteratorSetting(org.apache.accumulo.proxy.thrift.IteratorSetting setting) {\ndiff --git a/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java b/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\nindex 28d7e02..cc244f3 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\n@@ -182,7 +182,7 @@\n \n     public String createWriter(ByteBuffer login, String tableName, WriterOptions opts) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n-    public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException;\n+    public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws org.apache.thrift.TException;\n \n     public void flush(String writer) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException;\n \n@@ -2358,10 +2358,9 @@ public String recv_createWriter() throws AccumuloException, AccumuloSecurityExce\n       throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, \"createWriter failed: unknown result\");\n     }\n \n-    public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException\n+    public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws org.apache.thrift.TException\n     {\n       send_update(writer, cells);\n-      recv_update();\n     }\n \n     public void send_update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws org.apache.thrift.TException\n@@ -2372,19 +2371,6 @@ public void send_update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells)\n       sendBase(\"update\", args);\n     }\n \n-    public void recv_update() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException\n-    {\n-      update_result result = new update_result();\n-      receiveBase(result, \"update\");\n-      if (result.ouch1 != null) {\n-        throw result.ouch1;\n-      }\n-      if (result.ouch2 != null) {\n-        throw result.ouch2;\n-      }\n-      return;\n-    }\n-\n     public void flush(String writer) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException\n     {\n       send_flush(writer);\n@@ -4994,7 +4980,7 @@ public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells, org.\n       private String writer;\n       private Map<ByteBuffer,List<ColumnUpdate>> cells;\n       public update_call(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells, org.apache.thrift.async.AsyncMethodCallback<update_call> resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {\n-        super(client, protocolFactory, transport, resultHandler, false);\n+        super(client, protocolFactory, transport, resultHandler, true);\n         this.writer = writer;\n         this.cells = cells;\n       }\n@@ -5008,13 +4994,12 @@ public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apa\n         prot.writeMessageEnd();\n       }\n \n-      public void getResult() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\n+      public void getResult() throws org.apache.thrift.TException {\n         if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n           throw new IllegalStateException(\"Method call not finished!\");\n         }\n         org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n         org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n-        (new Client(prot)).recv_update();\n       }\n     }\n \n@@ -7007,19 +6992,12 @@ public update_args getEmptyArgsInstance() {\n       }\n \n       protected boolean isOneway() {\n-        return false;\n+        return true;\n       }\n \n-      public update_result getResult(I iface, update_args args) throws org.apache.thrift.TException {\n-        update_result result = new update_result();\n-        try {\n+      public org.apache.thrift.TBase getResult(I iface, update_args args) throws org.apache.thrift.TException {\n         iface.update(args.writer, args.cells);\n-        } catch (UnknownWriter ouch1) {\n-          result.ouch1 = ouch1;\n-        } catch (MutationsRejectedException ouch2) {\n-          result.ouch2 = ouch2;\n-        }\n-        return result;\n+        return null;\n       }\n     }\n \n@@ -81630,464 +81608,6 @@ public void read(org.apache.thrift.protocol.TProtocol prot, update_args struct)\n \n   }\n \n-  public static class update_result implements org.apache.thrift.TBase<update_result, update_result._Fields>, java.io.Serializable, Cloneable   {\n-    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct(\"update_result\");\n-\n-    private static final org.apache.thrift.protocol.TField OUCH1_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch1\", org.apache.thrift.protocol.TType.STRUCT, (short)1);\n-    private static final org.apache.thrift.protocol.TField OUCH2_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch2\", org.apache.thrift.protocol.TType.STRUCT, (short)2);\n-\n-    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();\n-    static {\n-      schemes.put(StandardScheme.class, new update_resultStandardSchemeFactory());\n-      schemes.put(TupleScheme.class, new update_resultTupleSchemeFactory());\n-    }\n-\n-    public UnknownWriter ouch1; // required\n-    public MutationsRejectedException ouch2; // required\n-\n-    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */\n-    @SuppressWarnings(\"all\") public enum _Fields implements org.apache.thrift.TFieldIdEnum {\n-      OUCH1((short)1, \"ouch1\"),\n-      OUCH2((short)2, \"ouch2\");\n-\n-      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();\n-\n-      static {\n-        for (_Fields field : EnumSet.allOf(_Fields.class)) {\n-          byName.put(field.getFieldName(), field);\n-        }\n-      }\n-\n-      /**\n-       * Find the _Fields constant that matches fieldId, or null if its not found.\n-       */\n-      public static _Fields findByThriftId(int fieldId) {\n-        switch(fieldId) {\n-          case 1: // OUCH1\n-            return OUCH1;\n-          case 2: // OUCH2\n-            return OUCH2;\n-          default:\n-            return null;\n-        }\n-      }\n-\n-      /**\n-       * Find the _Fields constant that matches fieldId, throwing an exception\n-       * if it is not found.\n-       */\n-      public static _Fields findByThriftIdOrThrow(int fieldId) {\n-        _Fields fields = findByThriftId(fieldId);\n-        if (fields == null) throw new IllegalArgumentException(\"Field \" + fieldId + \" doesn't exist!\");\n-        return fields;\n-      }\n-\n-      /**\n-       * Find the _Fields constant that matches name, or null if its not found.\n-       */\n-      public static _Fields findByName(String name) {\n-        return byName.get(name);\n-      }\n-\n-      private final short _thriftId;\n-      private final String _fieldName;\n-\n-      _Fields(short thriftId, String fieldName) {\n-        _thriftId = thriftId;\n-        _fieldName = fieldName;\n-      }\n-\n-      public short getThriftFieldId() {\n-        return _thriftId;\n-      }\n-\n-      public String getFieldName() {\n-        return _fieldName;\n-      }\n-    }\n-\n-    // isset id assignments\n-    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;\n-    static {\n-      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);\n-      tmpMap.put(_Fields.OUCH1, new org.apache.thrift.meta_data.FieldMetaData(\"ouch1\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n-          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n-      tmpMap.put(_Fields.OUCH2, new org.apache.thrift.meta_data.FieldMetaData(\"ouch2\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n-          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n-      metaDataMap = Collections.unmodifiableMap(tmpMap);\n-      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(update_result.class, metaDataMap);\n-    }\n-\n-    public update_result() {\n-    }\n-\n-    public update_result(\n-      UnknownWriter ouch1,\n-      MutationsRejectedException ouch2)\n-    {\n-      this();\n-      this.ouch1 = ouch1;\n-      this.ouch2 = ouch2;\n-    }\n-\n-    /**\n-     * Performs a deep copy on <i>other</i>.\n-     */\n-    public update_result(update_result other) {\n-      if (other.isSetOuch1()) {\n-        this.ouch1 = new UnknownWriter(other.ouch1);\n-      }\n-      if (other.isSetOuch2()) {\n-        this.ouch2 = new MutationsRejectedException(other.ouch2);\n-      }\n-    }\n-\n-    public update_result deepCopy() {\n-      return new update_result(this);\n-    }\n-\n-    @Override\n-    public void clear() {\n-      this.ouch1 = null;\n-      this.ouch2 = null;\n-    }\n-\n-    public UnknownWriter getOuch1() {\n-      return this.ouch1;\n-    }\n-\n-    public update_result setOuch1(UnknownWriter ouch1) {\n-      this.ouch1 = ouch1;\n-      return this;\n-    }\n-\n-    public void unsetOuch1() {\n-      this.ouch1 = null;\n-    }\n-\n-    /** Returns true if field ouch1 is set (has been assigned a value) and false otherwise */\n-    public boolean isSetOuch1() {\n-      return this.ouch1 != null;\n-    }\n-\n-    public void setOuch1IsSet(boolean value) {\n-      if (!value) {\n-        this.ouch1 = null;\n-      }\n-    }\n-\n-    public MutationsRejectedException getOuch2() {\n-      return this.ouch2;\n-    }\n-\n-    public update_result setOuch2(MutationsRejectedException ouch2) {\n-      this.ouch2 = ouch2;\n-      return this;\n-    }\n-\n-    public void unsetOuch2() {\n-      this.ouch2 = null;\n-    }\n-\n-    /** Returns true if field ouch2 is set (has been assigned a value) and false otherwise */\n-    public boolean isSetOuch2() {\n-      return this.ouch2 != null;\n-    }\n-\n-    public void setOuch2IsSet(boolean value) {\n-      if (!value) {\n-        this.ouch2 = null;\n-      }\n-    }\n-\n-    public void setFieldValue(_Fields field, Object value) {\n-      switch (field) {\n-      case OUCH1:\n-        if (value == null) {\n-          unsetOuch1();\n-        } else {\n-          setOuch1((UnknownWriter)value);\n-        }\n-        break;\n-\n-      case OUCH2:\n-        if (value == null) {\n-          unsetOuch2();\n-        } else {\n-          setOuch2((MutationsRejectedException)value);\n-        }\n-        break;\n-\n-      }\n-    }\n-\n-    public Object getFieldValue(_Fields field) {\n-      switch (field) {\n-      case OUCH1:\n-        return getOuch1();\n-\n-      case OUCH2:\n-        return getOuch2();\n-\n-      }\n-      throw new IllegalStateException();\n-    }\n-\n-    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */\n-    public boolean isSet(_Fields field) {\n-      if (field == null) {\n-        throw new IllegalArgumentException();\n-      }\n-\n-      switch (field) {\n-      case OUCH1:\n-        return isSetOuch1();\n-      case OUCH2:\n-        return isSetOuch2();\n-      }\n-      throw new IllegalStateException();\n-    }\n-\n-    @Override\n-    public boolean equals(Object that) {\n-      if (that == null)\n-        return false;\n-      if (that instanceof update_result)\n-        return this.equals((update_result)that);\n-      return false;\n-    }\n-\n-    public boolean equals(update_result that) {\n-      if (that == null)\n-        return false;\n-\n-      boolean this_present_ouch1 = true && this.isSetOuch1();\n-      boolean that_present_ouch1 = true && that.isSetOuch1();\n-      if (this_present_ouch1 || that_present_ouch1) {\n-        if (!(this_present_ouch1 && that_present_ouch1))\n-          return false;\n-        if (!this.ouch1.equals(that.ouch1))\n-          return false;\n-      }\n-\n-      boolean this_present_ouch2 = true && this.isSetOuch2();\n-      boolean that_present_ouch2 = true && that.isSetOuch2();\n-      if (this_present_ouch2 || that_present_ouch2) {\n-        if (!(this_present_ouch2 && that_present_ouch2))\n-          return false;\n-        if (!this.ouch2.equals(that.ouch2))\n-          return false;\n-      }\n-\n-      return true;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return 0;\n-    }\n-\n-    public int compareTo(update_result other) {\n-      if (!getClass().equals(other.getClass())) {\n-        return getClass().getName().compareTo(other.getClass().getName());\n-      }\n-\n-      int lastComparison = 0;\n-      update_result typedOther = (update_result)other;\n-\n-      lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\n-      if (lastComparison != 0) {\n-        return lastComparison;\n-      }\n-      if (isSetOuch1()) {\n-        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\n-        if (lastComparison != 0) {\n-          return lastComparison;\n-        }\n-      }\n-      lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\n-      if (lastComparison != 0) {\n-        return lastComparison;\n-      }\n-      if (isSetOuch2()) {\n-        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\n-        if (lastComparison != 0) {\n-          return lastComparison;\n-        }\n-      }\n-      return 0;\n-    }\n-\n-    public _Fields fieldForId(int fieldId) {\n-      return _Fields.findByThriftId(fieldId);\n-    }\n-\n-    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {\n-      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);\n-    }\n-\n-    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {\n-      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);\n-      }\n-\n-    @Override\n-    public String toString() {\n-      StringBuilder sb = new StringBuilder(\"update_result(\");\n-      boolean first = true;\n-\n-      sb.append(\"ouch1:\");\n-      if (this.ouch1 == null) {\n-        sb.append(\"null\");\n-      } else {\n-        sb.append(this.ouch1);\n-      }\n-      first = false;\n-      if (!first) sb.append(\", \");\n-      sb.append(\"ouch2:\");\n-      if (this.ouch2 == null) {\n-        sb.append(\"null\");\n-      } else {\n-        sb.append(this.ouch2);\n-      }\n-      first = false;\n-      sb.append(\")\");\n-      return sb.toString();\n-    }\n-\n-    public void validate() throws org.apache.thrift.TException {\n-      // check for required fields\n-      // check for sub-struct validity\n-    }\n-\n-    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {\n-      try {\n-        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));\n-      } catch (org.apache.thrift.TException te) {\n-        throw new java.io.IOException(te);\n-      }\n-    }\n-\n-    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {\n-      try {\n-        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));\n-      } catch (org.apache.thrift.TException te) {\n-        throw new java.io.IOException(te);\n-      }\n-    }\n-\n-    private static class update_resultStandardSchemeFactory implements SchemeFactory {\n-      public update_resultStandardScheme getScheme() {\n-        return new update_resultStandardScheme();\n-      }\n-    }\n-\n-    private static class update_resultStandardScheme extends StandardScheme<update_result> {\n-\n-      public void read(org.apache.thrift.protocol.TProtocol iprot, update_result struct) throws org.apache.thrift.TException {\n-        org.apache.thrift.protocol.TField schemeField;\n-        iprot.readStructBegin();\n-        while (true)\n-        {\n-          schemeField = iprot.readFieldBegin();\n-          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { \n-            break;\n-          }\n-          switch (schemeField.id) {\n-            case 1: // OUCH1\n-              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n-                struct.ouch1 = new UnknownWriter();\n-                struct.ouch1.read(iprot);\n-                struct.setOuch1IsSet(true);\n-              } else { \n-                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n-              }\n-              break;\n-            case 2: // OUCH2\n-              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n-                struct.ouch2 = new MutationsRejectedException();\n-                struct.ouch2.read(iprot);\n-                struct.setOuch2IsSet(true);\n-              } else { \n-                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n-              }\n-              break;\n-            default:\n-              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n-          }\n-          iprot.readFieldEnd();\n-        }\n-        iprot.readStructEnd();\n-\n-        // check for required fields of primitive type, which can't be checked in the validate method\n-        struct.validate();\n-      }\n-\n-      public void write(org.apache.thrift.protocol.TProtocol oprot, update_result struct) throws org.apache.thrift.TException {\n-        struct.validate();\n-\n-        oprot.writeStructBegin(STRUCT_DESC);\n-        if (struct.ouch1 != null) {\n-          oprot.writeFieldBegin(OUCH1_FIELD_DESC);\n-          struct.ouch1.write(oprot);\n-          oprot.writeFieldEnd();\n-        }\n-        if (struct.ouch2 != null) {\n-          oprot.writeFieldBegin(OUCH2_FIELD_DESC);\n-          struct.ouch2.write(oprot);\n-          oprot.writeFieldEnd();\n-        }\n-        oprot.writeFieldStop();\n-        oprot.writeStructEnd();\n-      }\n-\n-    }\n-\n-    private static class update_resultTupleSchemeFactory implements SchemeFactory {\n-      public update_resultTupleScheme getScheme() {\n-        return new update_resultTupleScheme();\n-      }\n-    }\n-\n-    private static class update_resultTupleScheme extends TupleScheme<update_result> {\n-\n-      @Override\n-      public void write(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\n-        TTupleProtocol oprot = (TTupleProtocol) prot;\n-        BitSet optionals = new BitSet();\n-        if (struct.isSetOuch1()) {\n-          optionals.set(0);\n-        }\n-        if (struct.isSetOuch2()) {\n-          optionals.set(1);\n-        }\n-        oprot.writeBitSet(optionals, 2);\n-        if (struct.isSetOuch1()) {\n-          struct.ouch1.write(oprot);\n-        }\n-        if (struct.isSetOuch2()) {\n-          struct.ouch2.write(oprot);\n-        }\n-      }\n-\n-      @Override\n-      public void read(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\n-        TTupleProtocol iprot = (TTupleProtocol) prot;\n-        BitSet incoming = iprot.readBitSet(2);\n-        if (incoming.get(0)) {\n-          struct.ouch1 = new UnknownWriter();\n-          struct.ouch1.read(iprot);\n-          struct.setOuch1IsSet(true);\n-        }\n-        if (incoming.get(1)) {\n-          struct.ouch2 = new MutationsRejectedException();\n-          struct.ouch2.read(iprot);\n-          struct.setOuch2IsSet(true);\n-        }\n-      }\n-    }\n-\n-  }\n-\n   public static class flush_args implements org.apache.thrift.TBase<flush_args, flush_args._Fields>, java.io.Serializable, Cloneable   {\n     private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct(\"flush_args\");\n \n", "nb_test": 25, "linesAdd": 52, "jira_id": "1190", "singleLine": false, "nb_skipped": 0, "commit": "e29dc4f5", "nb_failure": 0, "linesRem": 488}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ShellConfigTest.testTokenWithoutOptions:77 null"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\nindex b187a76..a7ab8db 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n@@ -286,8 +286,7 @@ public boolean config(String... args) {\n \n     // process default parameters if unspecified\n     try {\n-      boolean hasToken = (token != null);\n-      boolean hasTokenOptions = !loginOptions.isEmpty();\n+      final boolean hasToken = (token != null);\n \n       if (hasToken && password != null) {\n         throw new ParameterException(\"Can not supply '--pass' option with '--tokenClass' option\");\n@@ -300,16 +299,15 @@ public void run() {\n         }\n       });\n \n-      // Need either both a token and options, or neither, but not just one.\n-      if (hasToken != hasTokenOptions) {\n-        throw new ParameterException(\"Must supply either both or neither of '--tokenClass' and '--tokenProperty'\");\n-      } else if (hasToken) { // implied hasTokenOptions\n+      if (hasToken) { // implied hasTokenOptions\n         // Fully qualified name so we don't shadow java.util.Properties\n         org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties props;\n         // and line wrap it because the package name is so long\n         props = new org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties();\n \n+        if (!loginOptions.isEmpty()) {\n           props.putAllStrings(loginOptions);\n+        }\n         token.init(props);\n       } else {\n         // Read password if the user explicitly asked for it, or didn't specify anything at all\n", "nb_test": 697, "linesAdd": 4, "jira_id": "3424", "singleLine": false, "nb_skipped": 2, "commit": "27d4ee21", "nb_failure": 1, "linesRem": 5}, {"files": 2, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test(org.apache.accumulo.core.client.mock.TestBatchScanner821): expected:<[a,b,c,d]> but was:<[]>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchScanner.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchScanner.java\nindex c33599b..351fdf9 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchScanner.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchScanner.java\n@@ -24,10 +24,12 @@\n import java.util.Map.Entry;\n \n import org.apache.accumulo.core.client.BatchScanner;\n+import org.apache.accumulo.core.client.mock.MockScanner.RangeFilter;\n import org.apache.accumulo.core.data.Key;\n import org.apache.accumulo.core.data.Range;\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.iterators.Filter;\n+import org.apache.accumulo.core.iterators.IteratorEnvironment;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n import org.apache.accumulo.core.iterators.SortedMapIterator;\n import org.apache.accumulo.core.security.Authorizations;\n@@ -53,7 +55,11 @@ public void setRanges(Collection<Range> ranges) {\n   static class RangesFilter extends Filter {\n     List<Range> ranges;\n     \n-    RangesFilter(SortedKeyValueIterator<Key,Value> iterator, List<Range> ranges) {\n+    public RangesFilter deepCopy(IteratorEnvironment env) {\n+      return new RangesFilter(getSource().deepCopy(env), ranges);\n+    }\n+    \n+    public RangesFilter(SortedKeyValueIterator<Key,Value> iterator, List<Range> ranges) {\n       setSource(iterator);\n       this.ranges = ranges;\n     }\n@@ -77,9 +83,9 @@ public boolean accept(Key k, Value v) {\n \n     IteratorChain chain = new IteratorChain();\n     for (Range range : ranges) {\n-      SortedKeyValueIterator<Key,Value> i = new SortedMapIterator(table.table);\n+      SortedKeyValueIterator<Key,Value> i = new RangesFilter(new SortedMapIterator(table.table), ranges);\n       try {\n-        i = new RangesFilter(createFilter(i), ranges);\n+        i = createFilter(i);\n         i.seek(range, createColumnBSS(fetchedColumns), !fetchedColumns.isEmpty());\n         chain.addIterator(new IteratorAdapter(i));\n       } catch (IOException e) {\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockScanner.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockScanner.java\nindex 82b9b19..2d78bbf 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockScanner.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockScanner.java\n@@ -26,8 +26,10 @@\n import org.apache.accumulo.core.data.Range;\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.iterators.Filter;\n+import org.apache.accumulo.core.iterators.IteratorEnvironment;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n import org.apache.accumulo.core.iterators.SortedMapIterator;\n+import org.apache.accumulo.core.iterators.system.DeletingIterator;\n import org.apache.accumulo.core.security.Authorizations;\n \n public class MockScanner extends MockScannerBase implements Scanner {\n", "nb_test": 296, "linesAdd": 11, "jira_id": "821", "singleLine": false, "nb_skipped": 0, "commit": "a450ac2f", "nb_failure": 1, "linesRem": 3}, {"files": 8, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java b/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\nindex 4f95e1a..83283ac 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\n@@ -65,7 +65,6 @@\n   MASTER_RECOVERY_POOL(\"master.recovery.pool\", \"recovery\", PropertyType.STRING, \"Priority queue to use for log recovery map/reduce jobs.\"),\n   MASTER_RECOVERY_SORT_MAPREDUCE(\"master.recovery.sort.mapreduce\", \"false\", PropertyType.BOOLEAN,\n       \"If true, use map/reduce to sort write-ahead logs during recovery\"),\n-  MASTER_BULK_SERVERS(\"master.bulk.server.max\", \"4\", PropertyType.COUNT, \"The number of servers to use during a bulk load\"),\n   MASTER_BULK_RETRIES(\"master.bulk.retries\", \"3\", PropertyType.COUNT, \"The number of attempts to bulk-load a file before giving up.\"),\n   MASTER_BULK_THREADPOOL_SIZE(\"master.bulk.threadpool.size\", \"5\", PropertyType.COUNT, \"The number of threads to use when coordinating a bulk-import.\"),\n   MASTER_MINTHREADS(\"master.server.threads.minimum\", \"2\", PropertyType.COUNT, \"The minimum number of threads to use to handle incoming requests.\"),\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\nindex 94daf03..a9ed76c 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\n@@ -69,7 +69,7 @@ public void seek(Range range, Collection<ByteSequence> columnFamilies, boolean i\n    * Iterates over the source until an acceptable key/value pair is found.\n    */\n   protected void findTop() {\n-    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n+    while (getSource().hasTop() && !getSource().getTopKey().isDeleted() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n       try {\n         getSource().next();\n       } catch (IOException e) {\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\nindex 8bbf18a..edeaa1d 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\n@@ -59,7 +59,9 @@\n   boolean hasTop();\n   \n   /**\n-   * Advances to the next K,V pair.\n+   * Advances to the next K,V pair. Note that in minor compaction scope and in non-full major compaction scopes the iterator may see deletion entries. These\n+   * entries should be preserved by all iterators except ones that are strictly scan-time iterators that will never be configured for the minc or majc scopes.\n+   * Deletion entries are only removed during full major compactions.\n    * \n    * @throws IOException\n    *           if an I/O error occurs.\n@@ -88,7 +90,9 @@\n   void seek(Range range, Collection<ByteSequence> columnFamilies, boolean inclusive) throws IOException;\n   \n   /**\n-   * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop().\n+   * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop(). Note that in minor compaction scope and in non-full major\n+   * compaction scopes the iterator may see deletion entries. These entries should be preserved by all iterators except ones that are strictly scan-time\n+   * iterators that will never be configured for the minc or majc scopes. Deletion entries are only removed during full major compactions.\n    * \n    * @return <tt>K</tt>\n    * @exception IllegalStateException\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\nindex 5e82a7d..bb4ae64 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\n@@ -42,14 +42,13 @@\n import org.apache.hadoop.conf.Configuration;\n import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.Mapper;\n-import org.apache.log4j.Logger;\n \n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n \n public class WikipediaPartitionedMapper extends Mapper<Text,Article,Text,Mutation> {\n   \n-  private static final Logger log = Logger.getLogger(WikipediaPartitionedMapper.class);\n+  // private static final Logger log = Logger.getLogger(WikipediaPartitionedMapper.class);\n   \n   public final static Charset UTF8 = Charset.forName(\"UTF-8\");\n   public static final String DOCUMENT_COLUMN_FAMILY = \"d\";\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\nindex 82af9fd..3507108 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\n@@ -23,40 +23,21 @@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStreamReader;\n-import java.io.StringReader;\n import java.nio.charset.Charset;\n-import java.util.HashSet;\n-import java.util.IllegalFormatException;\n-import java.util.Map.Entry;\n-import java.util.Set;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-import org.apache.accumulo.core.data.Mutation;\n-import org.apache.accumulo.core.data.Value;\n-import org.apache.accumulo.core.security.ColumnVisibility;\n import org.apache.accumulo.examples.wikisearch.ingest.ArticleExtractor.Article;\n import org.apache.accumulo.examples.wikisearch.ingest.WikipediaInputFormat.WikipediaInputSplit;\n-import org.apache.accumulo.examples.wikisearch.normalizer.LcNoDiacriticsNormalizer;\n-import org.apache.accumulo.examples.wikisearch.protobuf.Uid;\n-import org.apache.accumulo.examples.wikisearch.protobuf.Uid.List.Builder;\n-import org.apache.commons.codec.binary.Base64;\n-import org.apache.commons.lang.StringUtils;\n import org.apache.hadoop.conf.Configuration;\n import org.apache.hadoop.io.LongWritable;\n import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.Mapper;\n import org.apache.hadoop.mapreduce.lib.input.FileSplit;\n-import org.apache.log4j.Logger;\n-import org.apache.lucene.analysis.tokenattributes.TermAttribute;\n-import org.apache.lucene.wikipedia.analysis.WikipediaTokenizer;\n-\n-import com.google.common.collect.HashMultimap;\n-import com.google.common.collect.Multimap;\n \n public class WikipediaPartitioner extends Mapper<LongWritable,Text,Text,Article> {\n   \n-  private static final Logger log = Logger.getLogger(WikipediaPartitioner.class);\n+  // private static final Logger log = Logger.getLogger(WikipediaPartitioner.class);\n   \n   public final static Charset UTF8 = Charset.forName(\"UTF-8\");\n   public static final String DOCUMENT_COLUMN_FAMILY = \"d\";\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\nindex d8c57c2..2738e2c 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\n@@ -4,20 +4,18 @@\n \n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.data.Mutation;\n-import org.apache.accumulo.examples.wikisearch.ingest.WikipediaMapper;\n import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.JobContext;\n import org.apache.hadoop.mapreduce.OutputCommitter;\n import org.apache.hadoop.mapreduce.OutputFormat;\n import org.apache.hadoop.mapreduce.RecordWriter;\n import org.apache.hadoop.mapreduce.TaskAttemptContext;\n-import org.apache.hadoop.fs.FileSystem;\n-import org.apache.hadoop.io.Text;\n-import org.apache.log4j.Logger;\n \n public class SortingRFileOutputFormat extends OutputFormat<Text,Mutation> {\n \n-  private static final Logger log = Logger.getLogger(SortingRFileOutputFormat.class);\n+  // private static final Logger log = Logger.getLogger(SortingRFileOutputFormat.class);\n \n   public static final String PATH_NAME = \"sortingrfileoutputformat.path\";\n   public static final String MAX_BUFFER_SIZE = \"sortingrfileoutputformat.max.buffer.size\";\ndiff --git a/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java b/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\nindex 071b8bd..4ee5371 100644\n--- a/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\n+++ b/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\n@@ -38,8 +38,8 @@\n import org.apache.accumulo.core.client.Instance;\n import org.apache.accumulo.core.client.impl.ServerClient;\n import org.apache.accumulo.core.client.impl.TabletLocator;\n-import org.apache.accumulo.core.client.impl.Translator;\n import org.apache.accumulo.core.client.impl.TabletLocator.TabletLocation;\n+import org.apache.accumulo.core.client.impl.Translator;\n import org.apache.accumulo.core.client.impl.thrift.ClientService;\n import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n@@ -150,7 +150,7 @@ public void run() {\n             } catch (Exception ex) {\n               log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\n             }\n-            \n+            log.debug(\"Map file \" + mapFile + \" found to overlap \" + tabletsToAssignMapFileTo.size() + \" tablets\");\n             if (tabletsToAssignMapFileTo.size() == 0) {\n               List<KeyExtent> empty = Collections.emptyList();\n               completeFailures.put(mapFile, empty);\n@@ -652,33 +652,41 @@ public String toString() {\n     return findOverlappingTablets(acuConf, fs, locator, file, start, failed.getEndRow());\n   }\n   \n+  final static byte[] byte0 = {0};\n+\n   public static List<TabletLocation> findOverlappingTablets(AccumuloConfiguration acuConf, FileSystem fs, TabletLocator locator, Path file, Text startRow,\n       Text endRow) throws Exception {\n     List<TabletLocation> result = new ArrayList<TabletLocation>();\n-    \n     Collection<ByteSequence> columnFamilies = Collections.emptyList();\n-    \n-    FileSKVIterator reader = FileOperations.getInstance().openReader(file.toString(), true, fs, fs.getConf(), acuConf);\n+    String filename = file.toString();\n+    // log.debug(filename + \" finding overlapping tablets \" + startRow + \" -> \" + endRow);\n+    FileSKVIterator reader = FileOperations.getInstance().openReader(filename, true, fs, fs.getConf(), acuConf);\n     try {\n       Text row = startRow;\n       if (row == null)\n         row = new Text();\n       while (true) {\n+        // log.debug(filename + \" Seeking to row \" + row);\n         reader.seek(new Range(row, null), columnFamilies, false);\n-        if (!reader.hasTop())\n+        if (!reader.hasTop()) {\n+          // log.debug(filename + \" not found\");\n           break;\n+        }\n         row = reader.getTopKey().getRow();\n         TabletLocation tabletLocation = locator.locateTablet(row, false, true);\n+        // log.debug(filename + \" found row \" + row + \" at location \" + tabletLocation);\n         result.add(tabletLocation);\n         row = tabletLocation.tablet_extent.getEndRow();\n-        if (row != null && (endRow == null || row.compareTo(endRow) < 0))\n-          row = Range.followingPrefix(row);\n-        else\n+        if (row != null && (endRow == null || row.compareTo(endRow) < 0)) {\n+          row = new Text(row);\n+          row.append(byte0, 0, byte0.length);\n+        } else\n           break;\n       }\n     } finally {\n       reader.close();\n     }\n+    // log.debug(filename + \" to be sent to \" + result);\n     return result;\n   }\n   \ndiff --git a/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java b/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\nindex c4a3f50..05c353d 100644\n--- a/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\n+++ b/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\n@@ -19,11 +19,15 @@\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n import java.util.concurrent.LinkedBlockingQueue;\n@@ -41,12 +45,13 @@\n import org.apache.accumulo.core.client.impl.thrift.TableOperationExceptionType;\n import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.conf.SiteConfiguration;\n import org.apache.accumulo.core.file.FileOperations;\n import org.apache.accumulo.core.master.state.tables.TableState;\n import org.apache.accumulo.core.security.thrift.AuthInfo;\n import org.apache.accumulo.core.util.CachedConfiguration;\n import org.apache.accumulo.core.util.Daemon;\n-import org.apache.accumulo.core.util.LoggingRunnable;\n+import org.apache.accumulo.core.util.ThriftUtil;\n import org.apache.accumulo.core.util.UtilWaitThread;\n import org.apache.accumulo.server.ServerConstants;\n import org.apache.accumulo.server.client.HdfsZooInstance;\n@@ -370,7 +375,7 @@ public LoadFiles(String tableId, String source, String bulk, String errorDir, bo\n   \n   @Override\n   public Repo<Master> call(final long tid, Master master) throws Exception {\n-    \n+    final SiteConfiguration conf = ServerConfiguration.getSiteConfiguration();\n     FileSystem fs = TraceFileSystem.wrap(org.apache.accumulo.core.file.FileUtil.getFileSystem(CachedConfiguration.getInstance(),\n         ServerConfiguration.getSiteConfiguration()));\n     List<FileStatus> files = new ArrayList<FileStatus>();\n@@ -389,42 +394,68 @@ public LoadFiles(String tableId, String source, String bulk, String errorDir, bo\n     }\n     fs.delete(writable, false);\n     \n-    // group files into N-sized chunks, send the chunks to random servers\n-    final int SERVERS_TO_USE = Math.min(ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_SERVERS), master.onlineTabletServers()\n-        .size());\n-    \n-    log.debug(\"tid \" + tid + \" using \" + SERVERS_TO_USE + \" servers\");\n-    // wait for success, repeat failures R times\n     final List<String> filesToLoad = Collections.synchronizedList(new ArrayList<String>());\n     for (FileStatus f : files)\n       filesToLoad.add(f.getPath().toString());\n     \n-    final int RETRIES = Math.max(1, ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_RETRIES));\n-    for (int i = 0; i < RETRIES && filesToLoad.size() > 0; i++) {\n-      List<Future<?>> results = new ArrayList<Future<?>>();\n-      for (List<String> chunk : groupFiles(filesToLoad, SERVERS_TO_USE)) {\n-        final List<String> attempt = chunk;\n-        results.add(threadPool.submit(new LoggingRunnable(log, new Runnable() {\n+\n+    final int RETRIES = Math.max(1, conf.getCount(Property.MASTER_BULK_RETRIES));\n+    for (int attempt = 0; attempt < RETRIES && filesToLoad.size() > 0; attempt++) {\n+      List<Future<List<String>>> results = new ArrayList<Future<List<String>>>();\n+      \n+      // Figure out which files will be sent to which server\n+      Set<TServerInstance> currentServers = Collections.synchronizedSet(new HashSet<TServerInstance>(master.onlineTabletServers()));\n+      Map<String,List<String>> loadAssignments = new HashMap<String,List<String>>();\n+      for (TServerInstance server : currentServers) {\n+        loadAssignments.put(server.hostPort(), new ArrayList<String>());\n+      }\n+      int i = 0;\n+      List<Entry<String,List<String>>> entries = new ArrayList<Entry<String,List<String>>>(loadAssignments.entrySet());\n+      for (String file : filesToLoad) {\n+        entries.get(i % entries.size()).getValue().add(file);\n+        i++;\n+      }\n+      \n+      // Use the threadpool to assign files one-at-a-time to the server\n+      for (Entry<String,List<String>> entry : entries) {\n+        if (entry.getValue().isEmpty()) {\n+          continue;\n+        }\n+        final Entry<String,List<String>> finalEntry = entry;\n+        results.add(threadPool.submit(new Callable<List<String>>() {\n           @Override\n-          public void run() {\n+          public List<String> call() {\n+            if (log.isDebugEnabled()) {\n+              log.debug(\"Asking \" + finalEntry.getKey() + \" to load \" + sampleList(finalEntry.getValue(), 10));\n+            }\n+            List<String> failures = new ArrayList<String>();\n             ClientService.Iface client = null;\n             try {\n-              client = ServerClient.getConnection(HdfsZooInstance.getInstance());\n+              client = ThriftUtil.getTServerClient(finalEntry.getKey(), conf);\n+              for (String file : finalEntry.getValue()) {\n+                List<String> attempt = Collections.singletonList(file);\n+                log.debug(\"Asking \" + finalEntry.getKey() + \" to bulk import \" + file);\n                 List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\n-              attempt.removeAll(fail);\n-              filesToLoad.removeAll(attempt);\n+                if (fail.isEmpty()) {\n+                  filesToLoad.remove(file);\n+                } else {\n+                  failures.addAll(fail);\n+                }\n+              }\n             } catch (Exception ex) {\n               log.error(ex, ex);\n             } finally {\n               ServerClient.close(client);\n             }\n+            return failures;\n           }\n-        })));\n+        }));\n       }\n-      for (Future<?> f : results)\n-        f.get();\n+      Set<String> failures = new HashSet<String>();\n+      for (Future<List<String>> f : results)\n+        failures.addAll(f.get());\n       if (filesToLoad.size() > 0) {\n-        log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + filesToLoad + \" failed\");\n+        log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + sampleList(filesToLoad, 10) + \" failed\");\n         UtilWaitThread.sleep(100);\n       }\n     }\n@@ -449,16 +480,24 @@ public void run() {\n     return new CompleteBulkImport(tableId, source, bulk, errorDir);\n   }\n   \n-  private List<List<String>> groupFiles(List<String> files, int groups) {\n-    List<List<String>> result = new ArrayList<List<String>>();\n-    Iterator<String> iter = files.iterator();\n-    for (int i = 0; i < groups && iter.hasNext(); i++) {\n-      List<String> group = new ArrayList<String>();\n-      for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {\n-        group.add(iter.next());\n+  static String sampleList(Collection<?> potentiallyLongList, int max) {\n+    StringBuffer result = new StringBuffer();\n+    result.append(\"[\");\n+    int i = 0;\n+    for (Object obj : potentiallyLongList) {\n+      result.append(obj);\n+      if (i >= max) {\n+        result.append(\"...\");\n+        break;\n+      } else {\n+        result.append(\", \");\n       }\n-      result.add(group);\n+      i++;\n     }\n-    return result;\n+    if (i < max)\n+      result.delete(result.length() - 2, result.length());\n+    result.append(\"]\");\n+    return result.toString();\n   }\n+\n }\n", "nb_test": 4, "linesAdd": 84, "jira_id": "412", "singleLine": false, "nb_skipped": 0, "commit": "be2fdba7", "nb_failure": 0, "linesRem": 68}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test3(org.apache.accumulo.core.iterators.FamilyIntersectingIteratorTest)", "test1(org.apache.accumulo.core.iterators.FamilyIntersectingIteratorTest)", "test2(org.apache.accumulo.core.iterators.FamilyIntersectingIteratorTest)"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\nindex 6df0e80..f870b30 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\n@@ -151,7 +151,7 @@ protected Key buildDocKey() {\n     if (log.isTraceEnabled())\n       log.trace(zeroIndex + \" \" + currentDocID.getLength());\n     Text colq = new Text();\n-    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);\n+    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 1);\n     Key k = new Key(currentPartition, colf, colq);\n     if (log.isTraceEnabled())\n       log.trace(\"built doc key for seek: \" + k.toString());\n", "nb_test": 259, "linesAdd": 1, "jira_id": "178", "singleLine": false, "nb_skipped": 0, "commit": "2f0643a9", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testBadDeletes(org.apache.accumulo.gc.GarbageCollectionTest): /"], "patch": "diff --git a/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectionAlgorithm.java b/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectionAlgorithm.java\nindex 464d0d9..40fb847 100644\n--- a/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectionAlgorithm.java\n+++ b/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectionAlgorithm.java\n@@ -85,10 +85,7 @@ private String makeRelative(String path, int expectedLen) {\n       tokens = tmp.toArray(new String[tmp.size()]);\n     }\n \n-    if (tokens.length > 3) {\n-      if (!path.contains(\":\"))\n-        throw new IllegalArgumentException(path);\n-\n+    if (tokens.length > 3 && path.contains(\":\")) {\n       if (tokens[tokens.length - 4].equals(ServerConstants.TABLE_DIR) && (expectedLen == 0 || expectedLen == 3)) {\n         relPath = tokens[tokens.length - 3] + \"/\" + tokens[tokens.length - 2] + \"/\" + tokens[tokens.length - 1];\n       } else if (tokens[tokens.length - 3].equals(ServerConstants.TABLE_DIR) && (expectedLen == 0 || expectedLen == 2)) {\n@@ -96,9 +93,9 @@ private String makeRelative(String path, int expectedLen) {\n       } else {\n         throw new IllegalArgumentException(path);\n       }\n-    } else if (tokens.length == 3 && (expectedLen == 0 || expectedLen == 3)) {\n+    } else if (tokens.length == 3 && (expectedLen == 0 || expectedLen == 3) && !path.contains(\":\")) {\n       relPath = tokens[0] + \"/\" + tokens[1] + \"/\" + tokens[2];\n-    } else if (tokens.length == 2 && (expectedLen == 0 || expectedLen == 2)) {\n+    } else if (tokens.length == 2 && (expectedLen == 0 || expectedLen == 2) && !path.contains(\":\")) {\n       relPath = tokens[0] + \"/\" + tokens[1];\n     } else {\n       throw new IllegalArgumentException(path);\n@@ -112,7 +109,13 @@ private String makeRelative(String path, int expectedLen) {\n     SortedMap<String,String> ret = new TreeMap<String,String>();\n \n     for (String candidate : candidates) {\n-      String relPath = makeRelative(candidate, 0);\n+      String relPath;\n+      try {\n+        relPath = makeRelative(candidate, 0);\n+      } catch (IllegalArgumentException iae) {\n+        log.warn(\"Ingoring invalid deletion candidate \" + candidate);\n+        continue;\n+      }\n       ret.put(relPath, candidate);\n     }\n \n", "nb_test": 14, "linesAdd": 10, "jira_id": "2520", "singleLine": false, "nb_skipped": 0, "commit": "a64151e6", "nb_failure": 0, "linesRem": 7}, {"files": 8, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["test2(org.apache.accumulo.core.iterators.user.FilterTest): expected:<100> but was:<900>", "testDeepCopy(org.apache.accumulo.core.iterators.user.CombinerTest)"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\nindex 5281f4d..8532e56 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n@@ -228,6 +228,20 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n   }\n   \n   @Override\n+  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n+    Combiner newInstance;\n+    try {\n+      newInstance = this.getClass().newInstance();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+    newInstance.setSource(getSource().deepCopy(env));\n+    newInstance.combiners = combiners;\n+    newInstance.combineAllColumns = combineAllColumns;\n+    return newInstance;\n+  }\n+  \n+  @Override\n   public IteratorOptions describeOptions() {\n     IteratorOptions io = new IteratorOptions(\"comb\", \"Combiners apply reduce functions to values with identical keys\", null, null);\n     io.addNamedOption(ALL_OPTION, \"set to true to apply Combiner to every column, otherwise leave blank. if true, \" + COLUMNS_OPTION\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/TypedValueCombiner.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/TypedValueCombiner.java\nindex 628c9dd..7b8d636 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/TypedValueCombiner.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/TypedValueCombiner.java\n@@ -145,6 +145,14 @@ protected void testEncoder(V v) {\n     }\n   }\n   \n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n+    TypedValueCombiner<V> newInstance = (TypedValueCombiner<V>) super.deepCopy(env);\n+    newInstance.setEncoder(encoder);\n+    return newInstance;\n+  }\n+  \n   @Override\n   public Value reduce(Key key, Iterator<Value> iter) {\n     return new Value(encoder.encode(typedReduce(key, new VIterator<V>(iter, encoder))));\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/VersioningIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/VersioningIterator.java\nindex e38c68e..9d92db3 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/VersioningIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/VersioningIterator.java\n@@ -29,6 +29,8 @@\n   public VersioningIterator() {}\n   \n   public VersioningIterator(SortedKeyValueIterator<Key,Value> iterator, int maxVersions) {\n-    super(iterator, maxVersions);\n+    super();\n+    this.setSource(iterator);\n+    this.maxVersions = maxVersions;\n   }\n }\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/AgeOffFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/AgeOffFilter.java\nindex 9feffd8..486e6cb 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/AgeOffFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/AgeOffFilter.java\n@@ -37,26 +37,6 @@\n   private long threshold;\n   private long currentTime;\n   \n-  public AgeOffFilter() {}\n-  \n-  /**\n-   * Constructs a filter that omits entries read from a source iterator if the Key's timestamp is less than currentTime - threshold.\n-   * \n-   * @param iterator\n-   *          The source iterator.\n-   * \n-   * @param threshold\n-   *          Maximum age in milliseconds of data to keep.\n-   * \n-   * @param threshold\n-   *          Current time in milliseconds.\n-   */\n-  private AgeOffFilter(SortedKeyValueIterator<Key,Value> iterator, long threshold, long currentTime) {\n-    setSource(iterator);\n-    this.threshold = threshold;\n-    this.currentTime = currentTime;\n-  }\n-  \n   /**\n    * Accepts entries whose timestamps are less than currentTime - threshold.\n    * \n@@ -93,7 +73,10 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n   \n   @Override\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n-    return new AgeOffFilter(getSource(), threshold, currentTime);\n+    AgeOffFilter copy = (AgeOffFilter) super.deepCopy(env);\n+    copy.currentTime = currentTime;\n+    copy.threshold = threshold;\n+    return copy;\n   }\n   \n   @Override\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/ColumnAgeOffFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/ColumnAgeOffFilter.java\nindex 4bffbcb..8c95728 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/ColumnAgeOffFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/ColumnAgeOffFilter.java\n@@ -36,15 +36,6 @@\n  * Different thresholds are set for each column.\n  */\n public class ColumnAgeOffFilter extends Filter {\n-  \n-  public ColumnAgeOffFilter() {}\n-  \n-  private ColumnAgeOffFilter(SortedKeyValueIterator<Key,Value> iterator, TTLSet ttls, long currentTime) {\n-    setSource(iterator);\n-    this.ttls = ttls;\n-    this.currentTime = currentTime;\n-  }\n-  \n   public static class TTLSet extends ColumnToClassMapping<Long> {\n     public TTLSet(Map<String,String> objectStrings) {\n       super();\n@@ -87,7 +78,10 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n   \n   @Override\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n-    return new ColumnAgeOffFilter(getSource(), ttls, currentTime);\n+    ColumnAgeOffFilter copy = (ColumnAgeOffFilter) super.deepCopy(env);\n+    copy.currentTime = currentTime;\n+    copy.ttls = ttls;\n+    return copy;\n   }\n   \n   public void overrideCurrentTime(long ts) {\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\nindex fb53801..e508631 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n@@ -37,8 +37,7 @@\n   \n   @Override\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n-    RegExFilter result = new RegExFilter();\n-    result.setSource(getSource().deepCopy(env));\n+    RegExFilter result = (RegExFilter) super.deepCopy(env);\n     result.rowMatcher = copyMatcher(rowMatcher);\n     result.colfMatcher = copyMatcher(colfMatcher);\n     result.colqMatcher = copyMatcher(colqMatcher);\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\nindex 5b652aa..2dbfe66 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\n@@ -54,17 +54,6 @@ private static SimpleDateFormat initDateParser() {\n   \n   public TimestampFilter() {}\n   \n-  private TimestampFilter(SortedKeyValueIterator<Key,Value> iterator, boolean hasStart, long start, boolean startInclusive, boolean hasEnd, long end,\n-      boolean endInclusive) {\n-    setSource(iterator);\n-    this.start = start;\n-    this.startInclusive = startInclusive;\n-    this.hasStart = true;\n-    this.end = end;\n-    this.endInclusive = endInclusive;\n-    this.hasEnd = true;\n-  }\n-  \n   @Override\n   public boolean accept(Key k, Value v) {\n     long ts = k.getTimestamp();\n@@ -112,7 +101,14 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n   \n   @Override\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n-    return new TimestampFilter(getSource(), hasStart, start, startInclusive, hasEnd, end, endInclusive);\n+    TimestampFilter copy = (TimestampFilter) super.deepCopy(env);\n+    copy.hasStart = hasStart;\n+    copy.start = start;\n+    copy.startInclusive = startInclusive;\n+    copy.hasEnd = hasEnd;\n+    copy.end = end;\n+    copy.endInclusive = endInclusive;\n+    return copy;\n   }\n   \n   @Override\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/VersioningIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/VersioningIterator.java\nindex 0b2c767..53833f4 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/VersioningIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/VersioningIterator.java\n@@ -37,25 +37,14 @@\n   \n   private Key currentKey = new Key();\n   private int numVersions;\n-  private int maxVersions;\n+  protected int maxVersions;\n   \n   @Override\n   public VersioningIterator deepCopy(IteratorEnvironment env) {\n-    return new VersioningIterator(this, env);\n-  }\n-  \n-  private VersioningIterator(VersioningIterator other, IteratorEnvironment env) {\n-    setSource(other.getSource().deepCopy(env));\n-    maxVersions = other.maxVersions;\n-  }\n-  \n-  public VersioningIterator() {}\n-  \n-  public VersioningIterator(SortedKeyValueIterator<Key,Value> iterator, int maxVersions) {\n-    if (maxVersions < 1)\n-      throw new IllegalArgumentException(\"maxVersions for versioning iterator must be >= 1\");\n-    this.setSource(iterator);\n-    this.maxVersions = maxVersions;\n+    VersioningIterator copy = new VersioningIterator();\n+    copy.setSource(getSource().deepCopy(env));\n+    copy.maxVersions = maxVersions;\n+    return copy;\n   }\n   \n   @Override\n", "nb_test": 273, "linesAdd": 47, "jira_id": "334", "singleLine": false, "nb_skipped": 0, "commit": "9d8cc45d", "nb_failure": 1, "linesRem": 50}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDelete(org.apache.accumulo.proxy.SimpleTest): expected:<0> but was:<1>"], "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex cec8cfc..ee993b9 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -1174,14 +1174,14 @@ private void addUpdatesToMutation(HashMap<Text,ColumnVisibility> vizMap, Mutatio\n         if (update.isSetDeleteCell()) {\n           m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n         } else {\n-          if (update.isSetDeleteCell()) {\n-            m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n-          } else {\n           m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);\n         }\n-        }\n       } else {\n-        m.put(update.getColFamily(), update.getColQualifier(), viz, value);\n+        if (update.isSetDeleteCell()) {\n+          m.putDelete(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz);\n+        } else {\n+          m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, new Value(value));\n+        }\n       }\n     }\n   }\n", "nb_test": 34, "linesAdd": 5, "jira_id": "1800", "singleLine": false, "nb_skipped": 0, "commit": "8ec4cb84", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["duPatternTest(org.apache.accumulo.core.util.shell.ShellTest): 0 [t, tt] present in ylyu@fake tt> du -p t.*(..)", "duTest(org.apache.accumulo.core.util.shell.ShellTest): expected:<1> but was:<0>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java b/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\nindex 64d5970..6a61c50 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\n@@ -144,12 +144,17 @@ public static void printDiskUsage(AccumuloConfiguration acuConf, Collection<Stri\n       tdu.addTable(tableId);\n     \n     HashSet<String> tablesReferenced = new HashSet<String>(tableIds);\n+    HashSet<String> emptyTableIds = new HashSet<String>();\n     \n     for (String tableId : tableIds) {\n       Scanner mdScanner = conn.createScanner(Constants.METADATA_TABLE_NAME, Constants.NO_AUTHS);\n       mdScanner.fetchColumnFamily(Constants.METADATA_DATAFILE_COLUMN_FAMILY);\n       mdScanner.setRange(new KeyExtent(new Text(tableId), null, null).toMetadataRange());\n       \n+      if(!mdScanner.iterator().hasNext()) {\n+        emptyTableIds.add(tableId);\n+      }\n+      \n       for (Entry<Key,Value> entry : mdScanner) {\n         String file = entry.getKey().getColumnQualifier().toString();\n         if (file.startsWith(\"../\")) {\n@@ -216,6 +221,14 @@ public int compare(TreeSet<String> o1, TreeSet<String> o2) {\n       usage.put(tableNames, entry.getValue());\n     }\n \n+    if(!emptyTableIds.isEmpty()) {\n+      TreeSet<String> emptyTables = new TreeSet<String>();\n+      for (String tableId : emptyTableIds) {\n+        emptyTables.add(reverseTableIdMap.get(tableId));\n+      }\n+      usage.put(emptyTables, 0L);\n+    }\n+    \n     for (Entry<TreeSet<String>,Long> entry : usage.entrySet())\n       printer.print(String.format(\"%,24d %s\", entry.getValue(), entry.getKey()));\n     \n", "nb_test": 367, "linesAdd": 13, "jira_id": "1192", "singleLine": false, "nb_skipped": 0, "commit": "c489d866", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["sumAllColumns(org.apache.accumulo.core.iterators.user.CombinerTest): expected:<[2]> but was:<[6]>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java b/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\nindex 6e72073..584eb14 100644\n--- a/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n+++ b/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n@@ -63,7 +63,7 @@\n      */\n     public ValueIterator(SortedKeyValueIterator<Key,Value> source) {\n       this.source = source;\n-      topKey = source.getTopKey();\n+      topKey = new Key(source.getTopKey());\n       hasNext = _hasNext();\n     }\n     \n", "nb_test": 305, "linesAdd": 1, "jira_id": "907", "singleLine": false, "nb_skipped": 0, "commit": "4aeaeb2a", "nb_failure": 1, "linesRem": 1}, {"files": 5, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\nindex 5c1194a..d4a2d4f 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n@@ -529,8 +529,15 @@ else if (path.startsWith(\"/\"))\n \n   @Override\n   public Path getFullPath(FileType fileType, String path) {\n-    if (path.contains(\":\"))\n+    int colon = path.indexOf(':');\n+    if (colon > -1) {\n+      // Check if this is really an absolute path or if this is a 1.4 style relative path for a WAL\n+      if (fileType == FileType.WAL && path.charAt(colon + 1) != '/') {\n+        path = path.substring(path.indexOf('/'));\n+      } else {\n         return new Path(path);\n+      }\n+    }\n \n     // normalize the path\n     Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\ndiff --git a/server/base/src/main/java/org/apache/accumulo/server/master/recovery/RecoveryPath.java b/server/base/src/main/java/org/apache/accumulo/server/master/recovery/RecoveryPath.java\nindex 1da945d..4a6638a 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/master/recovery/RecoveryPath.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/master/recovery/RecoveryPath.java\n@@ -34,8 +34,11 @@ public static Path getRecoveryPath(VolumeManager fs, Path walPath) throws IOExce\n       String uuid = walPath.getName();\n       // drop uuid\n       walPath = walPath.getParent();\n+      // recovered 1.4 WALs won't have a server component\n+      if (!walPath.getName().equals(FileType.WAL.getDirectory())) {\n         // drop server\n         walPath = walPath.getParent();\n+      }\n   \n       if (!walPath.getName().equals(FileType.WAL.getDirectory()))\n         throw new IllegalArgumentException(\"Bad path \" + walPath);\ndiff --git a/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java b/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java\nindex ae850af..56a0fd5 100644\n--- a/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java\n+++ b/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java\n@@ -281,7 +281,9 @@ private int removeMetadataEntries(Map<String,Path>  nameToFileMap, Map<String, P\n \n     while (iterator.hasNext()) {\n       for (String entry : iterator.next().logSet) {\n-        String uuid = new Path(entry).getName();\n+        // old style WALs will have the IP:Port of their logger and new style will either be a Path either absolute or relative, in all cases\n+        // the last \"/\" will mark a UUID file name.\n+        String uuid = entry.substring(entry.lastIndexOf(\"/\") + 1);\n         if (!isUUID(uuid)) {\n           // fully expect this to be a uuid, if its not then something is wrong and walog GC should not proceed!\n           throw new IllegalArgumentException(\"Expected uuid, but got \" + uuid + \" from \" + entry);\n@@ -327,8 +329,8 @@ int scanServers(String[] walDirs, Map<Path,String> fileToServerMap, Map<String,P\n         continue;\n       for (FileStatus status : listing) {\n         String server = status.getPath().getName();\n-        servers.add(server);\n         if (status.isDir()) {\n+          servers.add(server);\n           for (FileStatus file : fs.listStatus(new Path(walRoot, server))) {\n             if (isUUID(file.getPath().getName())) {\n               fileToServerMap.put(file.getPath(), server);\n@@ -339,7 +341,9 @@ int scanServers(String[] walDirs, Map<Path,String> fileToServerMap, Map<String,P\n           }\n         } else if (isUUID(server)) {\n           // old-style WAL are not under a directory\n+          servers.add(\"\");\n           fileToServerMap.put(status.getPath(), \"\");\n+          nameToFileMap.put(server, status.getPath());\n         } else {\n           log.info(\"Ignoring file \" + status.getPath() + \" because it doesn't look like a uuid\");\n         }\ndiff --git a/server/tserver/src/main/java/org/apache/accumulo/tserver/Tablet.java b/server/tserver/src/main/java/org/apache/accumulo/tserver/Tablet.java\nindex f73d4ca..36b2289 100644\n--- a/server/tserver/src/main/java/org/apache/accumulo/tserver/Tablet.java\n+++ b/server/tserver/src/main/java/org/apache/accumulo/tserver/Tablet.java\n@@ -1357,6 +1357,8 @@ public void sessionExpired() {\n     tabletResources.setTablet(this, acuTableConf);\n     if (!logEntries.isEmpty()) {\n       log.info(\"Starting Write-Ahead Log recovery for \" + this.extent);\n+      // count[0] = entries used on tablet\n+      // count[1] = track max time from walog entries wihtout timestamps\n       final long[] count = new long[2];\n       final CommitSession commitSession = tabletMemory.getCommitSession();\n       count[1] = Long.MIN_VALUE;\n@@ -1388,6 +1390,7 @@ public void receive(Mutation m) {\n         commitSession.updateMaxCommittedTime(tabletTime.getTime());\n \n         if (count[0] == 0) {\n+          log.debug(\"No replayed mutations applied, removing unused entries for \" + extent);\n           MetadataTableUtil.removeUnusedWALEntries(extent, logEntries, tabletServer.getLock());\n           logEntries.clear();\n         }\n@@ -1403,7 +1406,7 @@ public void receive(Mutation m) {\n       currentLogs = new HashSet<DfsLogger>();\n       for (LogEntry logEntry : logEntries) {\n         for (String log : logEntry.logSet) {\n-          currentLogs.add(new DfsLogger(tabletServer.getServerConfig(), log));\n+          currentLogs.add(new DfsLogger(tabletServer.getServerConfig(), log, logEntry.getColumnQualifier().toString()));\n         }\n       }\n \n@@ -3661,12 +3664,12 @@ public void importMapFiles(long tid, Map<FileRef,MapFileInfo> fileMap, boolean s\n \n       for (DfsLogger logger : otherLogs) {\n         otherLogsCopy.add(logger.toString());\n-        doomed.add(logger.toString());\n+        doomed.add(logger.getMeta());\n       }\n \n       for (DfsLogger logger : currentLogs) {\n         currentLogsCopy.add(logger.toString());\n-        doomed.remove(logger.toString());\n+        doomed.remove(logger.getMeta());\n       }\n \n       otherLogs = Collections.emptySet();\n@@ -3684,6 +3687,10 @@ public void importMapFiles(long tid, Map<FileRef,MapFileInfo> fileMap, boolean s\n       log.debug(\"Logs for current memory: \" + getExtent() + \" \" + logger);\n     }\n \n+    for (String logger : doomed) {\n+      log.debug(\"Logs to be destroyed: \" + getExtent() + \" \" + logger);\n+    }\n+\n     return doomed;\n   }\n \ndiff --git a/server/tserver/src/main/java/org/apache/accumulo/tserver/log/DfsLogger.java b/server/tserver/src/main/java/org/apache/accumulo/tserver/log/DfsLogger.java\nindex cca2953..b152380 100644\n--- a/server/tserver/src/main/java/org/apache/accumulo/tserver/log/DfsLogger.java\n+++ b/server/tserver/src/main/java/org/apache/accumulo/tserver/log/DfsLogger.java\n@@ -220,13 +220,21 @@ public int hashCode() {\n   private String logPath;\n   private Daemon syncThread;\n \n+  /* Track what's actually in +r/!0 for this logger ref */\n+  private String metaReference;\n+\n   public DfsLogger(ServerResources conf) throws IOException {\n     this.conf = conf;\n   }\n \n-  public DfsLogger(ServerResources conf, String filename) throws IOException {\n+  /**\n+   * Refernce a pre-existing log file.\n+   * @param meta the cq for the \"log\" entry in +r/!0\n+   */\n+  public DfsLogger(ServerResources conf, String filename, String meta) throws IOException {\n     this.conf = conf;\n     this.logPath = filename;\n+    metaReference = meta;\n   }\n \n   public static DFSLoggerInputStreams readHeaderAndReturnStream(VolumeManager fs, Path path, AccumuloConfiguration conf) throws IOException {\n@@ -315,6 +323,7 @@ public synchronized void open(String address) throws IOException {\n     VolumeManager fs = conf.getFileSystem();\n \n     logPath = fs.choose(ServerConstants.getWalDirs()) + \"/\" + logger + \"/\" + filename;\n+    metaReference = toString();\n     try {\n       short replication = (short) conf.getConfiguration().getCount(Property.TSERV_WAL_REPLICATION);\n       if (replication == 0)\n@@ -400,6 +409,16 @@ public String toString() {\n     return fileName;\n   }\n \n+  /**\n+   * get the cq needed to reference this logger's entry in +r/!0\n+   */\n+  public String getMeta() {\n+    if (null == metaReference) {\n+      throw new IllegalStateException(\"logger doesn't have meta reference. \" + this);\n+    }\n+    return metaReference;\n+  }\n+\n   public String getFileName() {\n     return logPath.toString();\n   }\n", "nb_test": 6, "linesAdd": 33, "jira_id": "2899", "singleLine": false, "nb_skipped": 0, "commit": "31aea2ad", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDefaultEquality(org.apache.accumulo.core.client.BatchWriterConfigTest): expected:<org.apache.accumulo.core.client.BatchWriterConfig@37073255> but was:<org.apache.accumulo.core.client.BatchWriterConfig@397986ac>", "testManualEquality(org.apache.accumulo.core.client.BatchWriterConfigTest): expected:<org.apache.accumulo.core.client.BatchWriterConfig@38981d47> but was:<org.apache.accumulo.core.client.BatchWriterConfig@aaa3d58>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/BatchWriterConfig.java b/core/src/main/java/org/apache/accumulo/core/client/BatchWriterConfig.java\nindex d3ad3fe..28955f5 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/BatchWriterConfig.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/BatchWriterConfig.java\n@@ -24,6 +24,7 @@\n import java.util.List;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.commons.lang.builder.HashCodeBuilder;\n import org.apache.hadoop.io.Writable;\n import org.apache.hadoop.util.StringUtils;\n \n@@ -223,4 +224,70 @@ public void readFields(DataInput in) throws IOException {\n       }\n     }\n   }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (o instanceof BatchWriterConfig) {\n+      BatchWriterConfig other = (BatchWriterConfig) o;\n+\n+      if (null != maxMemory) {\n+        if (!maxMemory.equals(other.maxMemory)) {\n+          return false;\n+        }\n+      } else {\n+        if (null != other.maxMemory) {\n+          return false;\n+        }\n+      }\n+\n+      if (null != maxLatency) {\n+        if (!maxLatency.equals(other.maxLatency)) {\n+          return false;\n+        }\n+      } else {\n+        if (null != other.maxLatency) {\n+          return false;\n+        }\n+      }\n+\n+      if (null != maxWriteThreads) {\n+        if (!maxWriteThreads.equals(other.maxWriteThreads)) {\n+          return false;\n+        }\n+      } else {\n+        if (null != other.maxWriteThreads) {\n+          return false;\n+        }\n+      }\n+\n+      if (null != timeout) {\n+        if (!timeout.equals(other.timeout)) {\n+          return false;\n+        }\n+      } else {\n+        if (null != other.timeout) {\n+          return false;\n+        }\n+      }\n+\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    HashCodeBuilder hcb = new HashCodeBuilder();\n+    hcb.append(maxMemory).append(maxLatency).append(maxWriteThreads).append(timeout);\n+    return hcb.toHashCode();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder(32);\n+    sb.append(\"[maxMemory=\").append(getMaxMemory()).append(\", maxLatency=\").append(getMaxLatency(TimeUnit.MILLISECONDS)).append(\", maxWriteThreads=\")\n+        .append(getMaxWriteThreads()).append(\", timeout=\").append(getTimeout(TimeUnit.MILLISECONDS)).append(\"]\");\n+    return sb.toString();\n+  }\n }\n", "nb_test": 415, "linesAdd": 67, "jira_id": "2928", "singleLine": false, "nb_skipped": 0, "commit": "f99b5654", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test1(org.apache.accumulo.core.iterators.user.RegExFilterTest)"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\nindex 0b3b73f..86b2bde 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n@@ -17,6 +17,7 @@\n package org.apache.accumulo.core.iterators.user;\n \n import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n import java.util.Map;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n@@ -28,7 +29,6 @@\n import org.apache.accumulo.core.iterators.Filter;\n import org.apache.accumulo.core.iterators.IteratorEnvironment;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n-import org.apache.accumulo.core.util.ByteArrayBackedCharSequence;\n \n /**\n  * A Filter that matches entries based on Java regular expressions.\n@@ -52,6 +52,9 @@\n   public static final String COLQ_REGEX = \"colqRegex\";\n   public static final String VALUE_REGEX = \"valueRegex\";\n   public static final String OR_FIELDS = \"orFields\";\n+  public static final String ENCODING = \"encoding\";\n+  \n+  public static final String ENCODING_DEFAULT = \"UTF-8\";\n   \n   private Matcher rowMatcher;\n   private Matcher colfMatcher;\n@@ -59,10 +62,9 @@\n   private Matcher valueMatcher;\n   private boolean orFields = false;\n   \n-  private ByteArrayBackedCharSequence babcs = new ByteArrayBackedCharSequence();\n+  private String encoding = ENCODING_DEFAULT;\n   \n-  private Matcher copyMatcher(Matcher m)\n-  {\n+  private Matcher copyMatcher(Matcher m) {\n     if (m == null)\n       return m;\n     else\n@@ -71,21 +73,25 @@ private Matcher copyMatcher(Matcher m)\n   \n   private boolean matches(Matcher matcher, ByteSequence bs) {\n     if (matcher != null) {\n-      babcs.set(bs);\n-      matcher.reset(babcs);\n+      try {\n+        matcher.reset(new String(bs.getBackingArray(), encoding));\n         return matcher.matches();\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+      }\n     }\n-    \n     return !orFields;\n   }\n   \n   private boolean matches(Matcher matcher, byte data[], int offset, int len) {\n     if (matcher != null) {\n-      babcs.set(data, offset, len);\n-      matcher.reset(babcs);\n+      try {\n+        matcher.reset(new String(data, offset, len, encoding));\n         return matcher.matches();\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+      }\n     }\n-    \n     return !orFields;\n   }\n   \n@@ -130,6 +136,10 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n     } else {\n       orFields = false;\n     }\n+    \n+    if (options.containsKey(ENCODING)) {\n+      encoding = options.get(ENCODING);\n+    }\n   }\n   \n   @Override\n@@ -142,6 +152,7 @@ public IteratorOptions describeOptions() {\n     io.addNamedOption(RegExFilter.COLQ_REGEX, \"regular expression on column qualifier\");\n     io.addNamedOption(RegExFilter.VALUE_REGEX, \"regular expression on value\");\n     io.addNamedOption(RegExFilter.OR_FIELDS, \"use OR instread of AND when multiple regexes given\");\n+    io.addNamedOption(RegExFilter.ENCODING, \"character encoding of byte array value (default is \" + ENCODING_DEFAULT + \")\");\n     return io;\n   }\n   \n@@ -160,6 +171,17 @@ public boolean validateOptions(Map<String,String> options) {\n     if (options.containsKey(VALUE_REGEX))\n       Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\n     \n+    if (options.containsKey(ENCODING)) {\n+      try {\n+        this.encoding = options.get(ENCODING);\n+        @SuppressWarnings(\"unused\")\n+        String test = new String(\"test\".getBytes(), encoding);\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+        return false;\n+      }\n+    }\n+    \n     return true;\n   }\n   \n@@ -192,4 +214,19 @@ public static void setRegexs(IteratorSetting si, String rowTerm, String cfTerm,\n       si.addOption(RegExFilter.OR_FIELDS, \"true\");\n     }\n   }\n+  \n+  /**\n+   * Set the encoding string to use when interpreting characters\n+   * \n+   * @param si\n+   *          ScanIterator config to be updated\n+   * @param encoding\n+   *          the encoding string to use for character interpretation.\n+   * \n+   */\n+  public static void setEncoding(IteratorSetting si, String encoding) {\n+    if (!encoding.isEmpty()) {\n+      si.addOption(RegExFilter.ENCODING, encoding);\n+    }\n+  }\n }\n", "nb_test": 279, "linesAdd": 38, "jira_id": "209", "singleLine": false, "nb_skipped": 0, "commit": "397f86f6", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "accumulo", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["test1(org.apache.accumulo.core.iterators.FirstEntryInRowTest)", "test2(org.apache.accumulo.core.iterators.FirstEntryInRowTest)"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/iterators/FirstEntryInRowIterator.java b/core/src/main/java/org/apache/accumulo/core/iterators/FirstEntryInRowIterator.java\nindex 96c7b80..7507bff 100644\n--- a/core/src/main/java/org/apache/accumulo/core/iterators/FirstEntryInRowIterator.java\n+++ b/core/src/main/java/org/apache/accumulo/core/iterators/FirstEntryInRowIterator.java\n@@ -75,6 +75,8 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n   // this is only ever called immediately after getting \"next\" entry\n   @Override\n   protected void consume() throws IOException {\n+    if (lastRowFound == null)\n+      return;\n     int count = 0;\n     while (getSource().hasTop() && lastRowFound.equals(getSource().getTopKey().getRow())) {\n       \n@@ -101,10 +103,17 @@ public void seek(Range range, Collection<ByteSequence> columnFamilies, boolean i\n     latestRange = range;\n     latestColumnFamilies = columnFamilies;\n     latestInclusive = inclusive;\n+    lastRowFound = null;\n     \n-    // seek to first possible pattern in range\n-    super.seek(range, columnFamilies, inclusive);\n-    lastRowFound = getSource().hasTop() ? getSource().getTopKey().getRow() : null;\n+    Key startKey = range.getStartKey();\n+    Range seekRange = new Range(startKey == null ? null : new Key(startKey.getRow()), true, range.getEndKey(), range.isEndKeyInclusive());\n+    super.seek(seekRange, columnFamilies, inclusive);\n+    \n+    if (getSource().hasTop()) {\n+      lastRowFound = getSource().getTopKey().getRow();\n+      if (range.beforeStartKey(getSource().getTopKey()))\n+        consume();\n+    }\n   }\n   \n   @Override\n", "nb_test": 281, "linesAdd": 12, "jira_id": "633", "singleLine": false, "nb_skipped": 0, "commit": "8dad5e0f", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "accumulo", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testNullByteBufferConstructor(org.apache.accumulo.core.data.ValueTest): Expected exception: java.lang.NullPointerException", "testNullBytesConstructor(org.apache.accumulo.core.data.ValueTest): Expected exception: java.lang.NullPointerException", "testNullSet(org.apache.accumulo.core.data.ValueTest): Expected exception: java.lang.NullPointerException", "testGetSizeDefault(org.apache.accumulo.core.data.ValueTest): Uninitialized. Null constructor called w/o accompanying readFields invocation", "testDefault(org.apache.accumulo.core.data.ValueTest): Uninitialized. Null constructor called w/o accompanying readFields invocation"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/Value.java b/core/src/main/java/org/apache/accumulo/core/data/Value.java\nindex 39ebbd0..11e60e1 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/Value.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/Value.java\n@@ -25,6 +25,8 @@\n import java.nio.ByteBuffer;\n import java.util.List;\n \n+import com.google.common.base.Preconditions;\n+\n import org.apache.accumulo.core.Constants;\n import org.apache.hadoop.io.BytesWritable;\n import org.apache.hadoop.io.WritableComparable;\n@@ -36,39 +38,52 @@\n  * 'immutable'.\n  */\n public class Value implements WritableComparable<Object> {\n+  private static final byte[] EMPTY = new byte[0];\n   protected byte[] value;\n \n   /**\n    * Create a zero-size sequence.\n    */\n   public Value() {\n-    super();\n+    this(EMPTY, false);\n   }\n   \n   /**\n    * Create a Value using the byte array as the initial value.\n    * \n-   * @param bytes\n-   *          This array becomes the backing storage for the object.\n+   * @param bytes May not be null\n    */\n-  \n   public Value(byte[] bytes) {\n     this(bytes, false);\n   }\n   \n+  /**\n+   * Create a Value using a copy of the ByteBuffer's content.\n+   * \n+   * @param bytes May not be null\n+   */\n   public Value(ByteBuffer bytes) {\n+    /* TODO ACCUMULO-2509 right now this uses the entire backing array, which must be accessible. */\n     this(toBytes(bytes), false);\n   }\n   \n   /**\n+   * @param bytes may not be null\n    * @deprecated A copy of the bytes in the buffer is always made. Use {@link #Value(ByteBuffer)} instead.\n    */\n   @Deprecated\n   public Value(ByteBuffer bytes, boolean copy) {\n+    /* TODO ACCUMULO-2509 right now this uses the entire backing array, which must be accessible. */\n     this(toBytes(bytes), false);\n   }\n   \n+  /**\n+   * Create a Value based on the given bytes.\n+   * @param bytes may not be null\n+   * @param copy signal if Value must make its own copy of bytes, or if it can use the array directly.\n+   */\n   public Value(byte[] bytes, boolean copy) {\n+    Preconditions.checkNotNull(bytes);\n     if (!copy) {\n       this.value = bytes;\n     } else {\n@@ -81,8 +96,7 @@ public Value(byte[] bytes, boolean copy) {\n   /**\n    * Set the new Value to a copy of the contents of the passed <code>ibw</code>.\n    * \n-   * @param ibw\n-   *          the value to set this Value to.\n+   * @param ibw may not be null.\n    */\n   public Value(final Value ibw) {\n     this(ibw.get(), 0, ibw.getSize());\n@@ -91,55 +105,49 @@ public Value(final Value ibw) {\n   /**\n    * Set the value to a copy of the given byte range\n    * \n-   * @param newData\n-   *          the new values to copy in\n+   * @param newData source of copy, may not be null\n    * @param offset\n    *          the offset in newData to start at\n    * @param length\n    *          the number of bytes to copy\n    */\n   public Value(final byte[] newData, final int offset, final int length) {\n+    Preconditions.checkNotNull(newData);\n     this.value = new byte[length];\n     System.arraycopy(newData, offset, this.value, 0, length);\n   }\n   \n   /**\n-   * Get the data from the BytesWritable.\n-   * \n-   * @return The data is only valid between 0 and getSize() - 1.\n+   * @return the underlying byte array directly.\n    */\n   public byte[] get() {\n-    if (this.value == null) {\n-      throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n-    }\n+    assert(null != value);\n     return this.value;\n   }\n   \n   /**\n-   * @param b\n-   *          Use passed bytes as backing array for this instance.\n+   * @param b Use passed bytes as backing array for this instance, may not be null.\n    */\n   public void set(final byte[] b) {\n+    Preconditions.checkNotNull(b);\n     this.value = b;\n   }\n   \n   /**\n    * \n-   * @param b\n-   *          copy bytes\n+   * @param b copy the given byte array, may not be null.\n    */\n   public void copy(byte[] b) {\n+    Preconditions.checkNotNull(b);\n     this.value = new byte[b.length];\n     System.arraycopy(b, 0, this.value, 0, b.length);\n   }\n   \n   /**\n-   * @return the current size of the buffer.\n+   * @return the current size of the underlying buffer.\n    */\n   public int getSize() {\n-    if (this.value == null) {\n-      throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n-    }\n+    assert(null != value);\n     return this.value.length;\n   }\n   \n", "nb_test": 601, "linesAdd": 10, "jira_id": "2487", "singleLine": false, "nb_skipped": 1, "commit": "f2920c26", "nb_failure": 3, "linesRem": 8}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCheck(org.apache.accumulo.server.constraints.MetadataConstraintsTest)"], "patch": "diff --git a/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java b/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\nindex bd19d1f..463b7b0 100644\n--- a/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\n+++ b/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\n@@ -34,6 +34,7 @@\n import org.apache.accumulo.server.client.HdfsZooInstance;\n import org.apache.accumulo.server.zookeeper.ZooCache;\n import org.apache.accumulo.server.zookeeper.ZooLock;\n+import org.apache.accumulo.server.zookeeper.TransactionWatcher.ZooArbitrator;\n import org.apache.hadoop.io.Text;\n import org.apache.log4j.Logger;\n \n@@ -72,6 +73,22 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n     return false;\n   }\n   \n+  static private ArrayList<Short> addViolation(ArrayList<Short> lst, int violation) {\n+    if (lst == null)\n+      lst = new ArrayList<Short>();\n+    lst.add((short)violation);\n+    return lst;\n+  }\n+  \n+  static private ArrayList<Short> addIfNotPresent(ArrayList<Short> lst, int intViolation) {\n+    if (lst == null)\n+      return addViolation(lst, intViolation);\n+    short violation = (short)intViolation;\n+    if (!lst.contains(violation))\n+      return addViolation(lst, intViolation);\n+    return lst;\n+  }\n+  \n   public List<Short> check(Environment env, Mutation mutation) {\n     \n     ArrayList<Short> violations = null;\n@@ -96,44 +113,30 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n         break;\n       \n       if (!validTableNameChars[0xff & b]) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     if (!containsSemiC) {\n       // see if last row char is <\n       if (row.length == 0 || row[row.length - 1] != '<') {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     } else {\n       if (row.length == 0) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     if (row.length > 0 && row[0] == '!') {\n       if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     // ensure row is not less than Constants.METADATA_TABLE_ID\n     if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {\n-      if (violations == null)\n-        violations = new ArrayList<Short>();\n-      violations.add((short) 5);\n+      violations = addViolation(violations, 5);\n     }\n     \n     for (ColumnUpdate columnUpdate : colUpdates) {\n@@ -141,17 +144,13 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n       \n       if (columnUpdate.isDeleted()) {\n         if (!isValidColumn(columnUpdate)) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 2);\n+          violations = addViolation(violations, 2);\n         }\n         continue;\n       }\n       \n       if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        violations.add((short) 6);\n+        violations = addViolation(violations, 6);\n       }\n       \n       if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {\n@@ -159,26 +158,49 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           DataFileValue dfv = new DataFileValue(columnUpdate.getValue());\n           \n           if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 1);\n+            violations = addViolation(violations, 1);\n           }\n         } catch (NumberFormatException nfe) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 1);\n+          violations = addViolation(violations, 1);\n         } catch (ArrayIndexOutOfBoundsException aiooe) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 1);\n+          violations = addViolation(violations, 1);\n         }\n       } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n         \n+      } else if (columnFamily.equals(Constants.METADATA_BULKFILE_COLUMN_FAMILY)) {\n+        if (!columnUpdate.isDeleted()) {\n+          // splits, which also write the time reference, are allowed to write this reference even when\n+          // the transaction is not running because the other half of the tablet is holding a reference\n+          // to the file.\n+          boolean isSplitMutation = false;\n+          // When a tablet is assigned, it re-writes the metadata.  It should probably only update the location information, \n+          // but it writes everything.  We allow it to re-write the bulk information if it is setting the location. \n+          // See ACCUMULO-1230. \n+          boolean isLocationMutation = false;\n+          for (ColumnUpdate update : mutation.getUpdates()) {\n+            if (new ColumnFQ(update).equals(Constants.METADATA_TIME_COLUMN)) {\n+              isSplitMutation = true;\n+            }\n+            if (update.getColumnFamily().equals(Constants.METADATA_CURRENT_LOCATION_COLUMN_FAMILY)) {\n+              isLocationMutation = true;\n+            }\n+          }\n+          \n+          if (!isSplitMutation && !isLocationMutation) {\n+            String tidString = new String(columnUpdate.getValue());\n+            long tid = Long.parseLong(tidString);\n+            try {\n+              if (!new ZooArbitrator().transactionAlive(Constants.BULK_ARBITRATOR_TYPE, tid)) {\n+                violations = addViolation(violations, 8);\n+              }\n+            } catch (Exception ex) {\n+              violations = addViolation(violations, 8);\n+            }\n+          }\n+        }\n       } else {\n         if (!isValidColumn(columnUpdate)) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 2);\n+          violations = addViolation(violations, 2);\n         } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0\n             && (violations == null || !violations.contains((short) 4))) {\n           KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);\n@@ -188,9 +210,7 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;\n           \n           if (!prevEndRowLessThanEndRow) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 3);\n+            violations = addViolation(violations, 3);\n           }\n         } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {\n           if (zooCache == null) {\n@@ -211,9 +231,7 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           }\n           \n           if (!lockHeld) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 7);\n+            violations = addViolation(violations, 7);\n           }\n         }\n         \n@@ -221,7 +239,10 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n     }\n     \n     if (violations != null) {\n-      log.debug(\" violating metadata mutation : \" + mutation);\n+      log.debug(\"violating metadata mutation : \" + new String(mutation.getRow()));\n+      for (ColumnUpdate update : mutation.getUpdates()) {\n+        log.debug(\" update: \" + new String(update.getColumnFamily()) + \":\" + new String(update.getColumnQualifier()) + \" value \" + (update.isDeleted() ? \"[delete]\" : new String(update.getValue())));\n+      }\n     }\n     \n     return violations;\n@@ -243,6 +264,8 @@ public String getViolationDescription(short violationCode) {\n         return \"Empty values are not allowed for any \" + Constants.METADATA_TABLE_NAME + \" column\";\n       case 7:\n         return \"Lock not held in zookeeper by writer\";\n+      case 8:\n+        return \"Bulk load transaction no longer running\";\n     }\n     return null;\n   }\n", "nb_test": 64, "linesAdd": 61, "jira_id": "1044", "singleLine": false, "nb_skipped": 0, "commit": "9396979b", "nb_failure": 1, "linesRem": 44}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCheck(org.apache.accumulo.server.constraints.MetadataConstraintsTest)"], "patch": "diff --git a/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java b/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\nindex bd19d1f..463b7b0 100644\n--- a/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\n+++ b/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\n@@ -34,6 +34,7 @@\n import org.apache.accumulo.server.client.HdfsZooInstance;\n import org.apache.accumulo.server.zookeeper.ZooCache;\n import org.apache.accumulo.server.zookeeper.ZooLock;\n+import org.apache.accumulo.server.zookeeper.TransactionWatcher.ZooArbitrator;\n import org.apache.hadoop.io.Text;\n import org.apache.log4j.Logger;\n \n@@ -72,6 +73,22 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n     return false;\n   }\n   \n+  static private ArrayList<Short> addViolation(ArrayList<Short> lst, int violation) {\n+    if (lst == null)\n+      lst = new ArrayList<Short>();\n+    lst.add((short)violation);\n+    return lst;\n+  }\n+  \n+  static private ArrayList<Short> addIfNotPresent(ArrayList<Short> lst, int intViolation) {\n+    if (lst == null)\n+      return addViolation(lst, intViolation);\n+    short violation = (short)intViolation;\n+    if (!lst.contains(violation))\n+      return addViolation(lst, intViolation);\n+    return lst;\n+  }\n+  \n   public List<Short> check(Environment env, Mutation mutation) {\n     \n     ArrayList<Short> violations = null;\n@@ -96,44 +113,30 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n         break;\n       \n       if (!validTableNameChars[0xff & b]) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     if (!containsSemiC) {\n       // see if last row char is <\n       if (row.length == 0 || row[row.length - 1] != '<') {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     } else {\n       if (row.length == 0) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     if (row.length > 0 && row[0] == '!') {\n       if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     // ensure row is not less than Constants.METADATA_TABLE_ID\n     if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {\n-      if (violations == null)\n-        violations = new ArrayList<Short>();\n-      violations.add((short) 5);\n+      violations = addViolation(violations, 5);\n     }\n     \n     for (ColumnUpdate columnUpdate : colUpdates) {\n@@ -141,17 +144,13 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n       \n       if (columnUpdate.isDeleted()) {\n         if (!isValidColumn(columnUpdate)) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 2);\n+          violations = addViolation(violations, 2);\n         }\n         continue;\n       }\n       \n       if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        violations.add((short) 6);\n+        violations = addViolation(violations, 6);\n       }\n       \n       if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {\n@@ -159,26 +158,49 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           DataFileValue dfv = new DataFileValue(columnUpdate.getValue());\n           \n           if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 1);\n+            violations = addViolation(violations, 1);\n           }\n         } catch (NumberFormatException nfe) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 1);\n+          violations = addViolation(violations, 1);\n         } catch (ArrayIndexOutOfBoundsException aiooe) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 1);\n+          violations = addViolation(violations, 1);\n         }\n       } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n         \n+      } else if (columnFamily.equals(Constants.METADATA_BULKFILE_COLUMN_FAMILY)) {\n+        if (!columnUpdate.isDeleted()) {\n+          // splits, which also write the time reference, are allowed to write this reference even when\n+          // the transaction is not running because the other half of the tablet is holding a reference\n+          // to the file.\n+          boolean isSplitMutation = false;\n+          // When a tablet is assigned, it re-writes the metadata.  It should probably only update the location information, \n+          // but it writes everything.  We allow it to re-write the bulk information if it is setting the location. \n+          // See ACCUMULO-1230. \n+          boolean isLocationMutation = false;\n+          for (ColumnUpdate update : mutation.getUpdates()) {\n+            if (new ColumnFQ(update).equals(Constants.METADATA_TIME_COLUMN)) {\n+              isSplitMutation = true;\n+            }\n+            if (update.getColumnFamily().equals(Constants.METADATA_CURRENT_LOCATION_COLUMN_FAMILY)) {\n+              isLocationMutation = true;\n+            }\n+          }\n+          \n+          if (!isSplitMutation && !isLocationMutation) {\n+            String tidString = new String(columnUpdate.getValue());\n+            long tid = Long.parseLong(tidString);\n+            try {\n+              if (!new ZooArbitrator().transactionAlive(Constants.BULK_ARBITRATOR_TYPE, tid)) {\n+                violations = addViolation(violations, 8);\n+              }\n+            } catch (Exception ex) {\n+              violations = addViolation(violations, 8);\n+            }\n+          }\n+        }\n       } else {\n         if (!isValidColumn(columnUpdate)) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 2);\n+          violations = addViolation(violations, 2);\n         } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0\n             && (violations == null || !violations.contains((short) 4))) {\n           KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);\n@@ -188,9 +210,7 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;\n           \n           if (!prevEndRowLessThanEndRow) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 3);\n+            violations = addViolation(violations, 3);\n           }\n         } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {\n           if (zooCache == null) {\n@@ -211,9 +231,7 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           }\n           \n           if (!lockHeld) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 7);\n+            violations = addViolation(violations, 7);\n           }\n         }\n         \n@@ -221,7 +239,10 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n     }\n     \n     if (violations != null) {\n-      log.debug(\" violating metadata mutation : \" + mutation);\n+      log.debug(\"violating metadata mutation : \" + new String(mutation.getRow()));\n+      for (ColumnUpdate update : mutation.getUpdates()) {\n+        log.debug(\" update: \" + new String(update.getColumnFamily()) + \":\" + new String(update.getColumnQualifier()) + \" value \" + (update.isDeleted() ? \"[delete]\" : new String(update.getValue())));\n+      }\n     }\n     \n     return violations;\n@@ -243,6 +264,8 @@ public String getViolationDescription(short violationCode) {\n         return \"Empty values are not allowed for any \" + Constants.METADATA_TABLE_NAME + \" column\";\n       case 7:\n         return \"Lock not held in zookeeper by writer\";\n+      case 8:\n+        return \"Bulk load transaction no longer running\";\n     }\n     return null;\n   }\n", "nb_test": 64, "linesAdd": 61, "jira_id": "1044", "singleLine": false, "nb_skipped": 0, "commit": "ea2f9856", "nb_failure": 1, "linesRem": 44}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ShellOptionsJCTest.testTraceHosts:59 expected:<localhost:[45454]> but was:<localhost:[2181]>"], "patch": "diff --git a/shell/src/main/java/org/apache/accumulo/shell/ShellOptionsJC.java b/shell/src/main/java/org/apache/accumulo/shell/ShellOptionsJC.java\nindex 92ea1a5..01b7ce3 100644\n--- a/shell/src/main/java/org/apache/accumulo/shell/ShellOptionsJC.java\n+++ b/shell/src/main/java/org/apache/accumulo/shell/ShellOptionsJC.java\n@@ -315,6 +315,11 @@ public ClientConfiguration getClientConfiguration() throws ConfigurationExceptio\n       clientConfig.withZkHosts(siteConf.get(Property.INSTANCE_ZK_HOST));\n     }\n \n+    // If the user provided the hosts, set the ZK for tracing too\n+    if (null != zooKeeperHosts) {\n+      clientConfig.setProperty(ClientProperty.INSTANCE_ZK_HOST, zooKeeperHosts);\n+    }\n+\n     return clientConfig;\n   }\n \n", "nb_test": 49, "linesAdd": 4, "jira_id": "3945", "singleLine": false, "nb_skipped": 0, "commit": "36225565", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["MutationTest.testEquals:584 null"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\nindex 5b052c3..e4e229c 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n@@ -598,7 +598,7 @@ public boolean equals(Object o) {\n \n   @Override\n   public int hashCode() {\n-    return toThrift(false).hashCode();\n+    return serializedSnapshot().hashCode();\n   }\n \n   /**\n", "nb_test": 709, "linesAdd": 1, "jira_id": "4029", "singleLine": false, "nb_skipped": 2, "commit": "5ca779a0", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test(org.apache.accumulo.core.iterators.user.GrepIteratorTest): expected:<dfh xyz:xyz [] 1 true> but was:<dfh xyz:xyz [] 0 false>"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/GrepIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/GrepIterator.java\nindex e768bff..ab8ca84 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/GrepIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/GrepIterator.java\n@@ -17,35 +17,27 @@\n package org.apache.accumulo.core.iterators.user;\n \n import java.io.IOException;\n+import java.util.Arrays;\n import java.util.Map;\n \n import org.apache.accumulo.core.client.IteratorSetting;\n import org.apache.accumulo.core.data.ByteSequence;\n import org.apache.accumulo.core.data.Key;\n import org.apache.accumulo.core.data.Value;\n+import org.apache.accumulo.core.iterators.Filter;\n import org.apache.accumulo.core.iterators.IteratorEnvironment;\n-import org.apache.accumulo.core.iterators.SkippingIterator;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n \n /**\n  * This iterator provides exact string matching. It searches both the Key and Value for the string. The string to match is specified by the \"term\" option.\n  */\n-public class GrepIterator extends SkippingIterator {\n+public class GrepIterator extends Filter {\n   \n   private byte term[];\n   \n   @Override\n-  protected void consume() throws IOException {\n-    while (getSource().hasTop()) {\n-      Key k = getSource().getTopKey();\n-      Value v = getSource().getTopValue();\n-      \n-      if (match(v.get()) || match(k.getRowData()) || match(k.getColumnFamilyData()) || match(k.getColumnQualifierData())) {\n-        break;\n-      }\n-      \n-      getSource().next();\n-    }\n+  public boolean accept(Key k, Value v) {\n+    return match(v.get()) || match(k.getRowData()) || match(k.getColumnFamilyData()) || match(k.getColumnQualifierData());\n   }\n   \n   private boolean match(ByteSequence bs) {\n@@ -88,7 +80,9 @@ private static int indexOf(byte[] source, int sourceOffset, int sourceCount, byt\n   \n   @Override\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n-    throw new UnsupportedOperationException();\n+    GrepIterator copy = (GrepIterator) super.deepCopy(env);\n+    copy.term = Arrays.copyOf(term, term.length);\n+    return copy;\n   }\n   \n   @Override\n", "nb_test": 276, "linesAdd": 8, "jira_id": "414", "singleLine": false, "nb_skipped": 0, "commit": "116d5928", "nb_failure": 1, "linesRem": 14}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["RFileTest.testCryptoDoesntLeakInstanceSecret:1767 expected:<-1> but was:<1000>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/security/crypto/CryptoModuleFactory.java b/core/src/main/java/org/apache/accumulo/core/security/crypto/CryptoModuleFactory.java\nindex 649bfc8..4d04125 100644\n--- a/core/src/main/java/org/apache/accumulo/core/security/crypto/CryptoModuleFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/security/crypto/CryptoModuleFactory.java\n@@ -258,6 +258,7 @@ public static CryptoModuleParameters fillParamsObjectFromConfiguration(CryptoMod\n     // Get all the options from the configuration\n     Map<String,String> cryptoOpts = conf.getAllPropertiesWithPrefix(Property.CRYPTO_PREFIX);\n     cryptoOpts.putAll(conf.getAllPropertiesWithPrefix(Property.INSTANCE_PREFIX));\n+    cryptoOpts.remove(Property.INSTANCE_SECRET.getKey());\n     cryptoOpts.put(Property.CRYPTO_BLOCK_STREAM_SIZE.getKey(), Integer.toString((int) conf.getMemoryInBytes(Property.CRYPTO_BLOCK_STREAM_SIZE)));\n \n     return fillParamsObjectFromStringMap(params, cryptoOpts);\n", "nb_test": 635, "linesAdd": 1, "jira_id": "2713", "singleLine": true, "nb_skipped": 1, "commit": "6138a80f", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["aboutTest(org.apache.accumulo.core.util.shell.ShellTest): expected:<1> but was:<0>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\nindex bb3c06e..fa0f5d4 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n@@ -493,7 +493,7 @@ public void printVerboseInfo() throws IOException {\n     if (disableAuthTimeout)\n       sb.append(\"- Authorization timeout: disabled\\n\");\n     else\n-      sb.append(\"- Authorization timeout: \").append(String.format(\"%.2fs%n\", TimeUnit.NANOSECONDS.toSeconds(authTimeout)));\n+      sb.append(\"- Authorization timeout: \").append(String.format(\"%ds%n\", TimeUnit.NANOSECONDS.toSeconds(authTimeout)));\n     sb.append(\"- Debug: \").append(isDebuggingEnabled() ? \"on\" : \"off\").append(\"\\n\");\n     if (!scanIteratorOptions.isEmpty()) {\n       for (Entry<String,List<IteratorSetting>> entry : scanIteratorOptions.entrySet()) {\n", "nb_test": 432, "linesAdd": 1, "jira_id": "3229", "singleLine": false, "nb_skipped": 0, "commit": "891584fb", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["UnsynchronizedBufferTest.testByteBufferConstructor:49 expected:<[34567]> but was:<[01234]>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java b/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\nindex 6947d64..f353613 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\n@@ -118,8 +118,8 @@ public Reader(byte b[]) {\n     }\n \n     public Reader(ByteBuffer buffer) {\n-      if (buffer.hasArray()) {\n-        offset = buffer.arrayOffset();\n+      if (buffer.hasArray() && buffer.array().length == buffer.arrayOffset() + buffer.limit()) {\n+        offset = buffer.arrayOffset() + buffer.position();\n         data = buffer.array();\n       } else {\n         data = new byte[buffer.remaining()];\n", "nb_test": 711, "linesAdd": 2, "jira_id": "4098", "singleLine": false, "nb_skipped": 2, "commit": "a2c2d38a", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAllFieldsWritable(org.apache.accumulo.core.client.mapred.RangeInputSplitTest): expected:<[name:SummingCombiner, priority:50, class:org.apache.accumulo.core.iterators.user.SummingCombiner, properties:{foo=bar}, name:WholeRowIterator, priority:100, class:org.apache.accumulo.core.iterators.user.WholeRowIterator, properties:{bar=foo}]> but was:<null>", "testAllFieldsWritable(org.apache.accumulo.core.client.mapreduce.RangeInputSplitTest): expected:<[name:SummingCombiner, priority:50, class:org.apache.accumulo.core.iterators.user.SummingCombiner, properties:{foo=bar}, name:WholeRowIterator, priority:100, class:org.apache.accumulo.core.iterators.user.WholeRowIterator, properties:{bar=foo}]> but was:<null>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\nindex 73c9b59..05316a1 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n@@ -205,6 +205,14 @@ public void readFields(DataInput in) throws IOException {\n     }\n \n     if (in.readBoolean()) {\n+      int numIterators = in.readInt();\n+      iterators = new ArrayList<IteratorSetting>(numIterators);\n+      for (int i = 0; i < numIterators; i++) {\n+        iterators.add(new IteratorSetting(in));\n+      }\n+    }\n+\n+    if (in.readBoolean()) {\n       level = Level.toLevel(in.readInt());\n     }\n   }\n@@ -275,6 +283,14 @@ public void write(DataOutput out) throws IOException {\n       out.writeUTF(zooKeepers);\n     }\n \n+    out.writeBoolean(null != iterators);\n+    if (null != iterators) {\n+      out.writeInt(iterators.size());\n+      for (IteratorSetting iterator : iterators) {\n+        iterator.write(out);\n+      }\n+    }\n+\n     out.writeBoolean(null != level);\n     if (null != level) {\n       out.writeInt(level.toInt());\n", "nb_test": 421, "linesAdd": 16, "jira_id": "2962", "singleLine": false, "nb_skipped": 0, "commit": "023be574", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["VolumeManagerImplTest.noViewFS \u00bb  Unexpected exception, expected<java.lang.Ill..."], "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\nindex 0cfb457..877b9a6 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n@@ -219,16 +219,6 @@ protected void ensureSyncIsEnabled() {\n       final String volumeName = entry.getKey();\n       FileSystem fs = entry.getValue().getFileSystem();\n \n-      if (ViewFSUtils.isViewFS(fs)) {\n-        try {\n-          FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path(\"/\")).getFileSystem(fs.getConf());\n-          log.debug(\"resolved \" + fs.getUri() + \" to \" + resolvedFs.getUri() + \" for sync check\");\n-          fs = resolvedFs;\n-        } catch (IOException e) {\n-          log.warn(\"Failed to resolve \" + fs.getUri(), e);\n-        }\n-      }\n-\n       if (fs instanceof DistributedFileSystem) {\n         final String DFS_DURABLE_SYNC = \"dfs.durable.sync\", DFS_SUPPORT_APPEND = \"dfs.support.append\";\n         final String ticketMessage = \"See ACCUMULO-623 and ACCUMULO-1637 for more details.\";\n@@ -410,6 +400,9 @@ public static VolumeManager get(AccumuloConfiguration conf) throws IOException {\n         // Cannot re-define the default volume\n         throw new IllegalArgumentException();\n \n+      if (volumeUriOrDir.startsWith(\"viewfs\"))\n+        throw new IllegalArgumentException();\n+\n       // We require a URI here, fail if it doesn't look like one\n       if (volumeUriOrDir.contains(\":\")) {\n         volumes.put(volumeUriOrDir, VolumeConfiguration.create(new Path(volumeUriOrDir), hadoopConf));\n@@ -426,16 +419,6 @@ public boolean isReady() throws IOException {\n     for (Volume volume : getFileSystems().values()) {\n       FileSystem fs = volume.getFileSystem();\n \n-      if (ViewFSUtils.isViewFS(fs)) {\n-        try {\n-          FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path(\"/\")).getFileSystem(fs.getConf());\n-          log.debug(\"resolved \" + fs.getUri() + \" to \" + resolvedFs.getUri() + \" for ready check\");\n-          fs = resolvedFs;\n-        } catch (IOException e) {\n-          log.warn(\"Failed to resolve \" + fs.getUri(), e);\n-        }\n-      }\n-\n       if (!(fs instanceof DistributedFileSystem))\n         continue;\n       DistributedFileSystem dfs = (DistributedFileSystem) fs;\n", "nb_test": 188, "linesAdd": 3, "jira_id": "3006", "singleLine": false, "nb_skipped": 2, "commit": "d6472040", "nb_failure": 0, "linesRem": 20}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["DeleteRowsCommandTest.testBeginRowHelp:26 -b should say it is exclusive", "MergeCommandTest.testBeginRowHelp:26 -b should say it is exclusive", "FlushCommandTest.testBeginRowHelp:26 -b should say it is exclusive", "CompactCommandTest.testBeginRowHelp:26 -b should say it is exclusive"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\nindex 432f17a..99e09e3 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n@@ -117,7 +117,7 @@ public static OptionGroup addListDeleteGroup(final String name) {\n   }\n \n   public static Option startRowOpt() {\n-    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (NOT) inclusive\");\n+    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\n     o.setArgName(\"begin-row\");\n     return o;\n   }\n", "nb_test": 722, "linesAdd": 1, "jira_id": "4138", "singleLine": false, "nb_skipped": 2, "commit": "4d23d784", "nb_failure": 4, "linesRem": 1}, {"files": 3, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ByteBufferUtilTest.testNonZeroArrayOffset:62->assertEquals:34 expected:<3456> but was:<0123>", "ByteBufferUtilTest.testDirectByteBuffer:92->assertEquals:34 \u00bb UnsupportedOperation"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/ArrayByteSequence.java b/core/src/main/java/org/apache/accumulo/core/data/ArrayByteSequence.java\nindex d9ddc67..d040139 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/ArrayByteSequence.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/ArrayByteSequence.java\n@@ -21,6 +21,8 @@\n import java.io.Serializable;\n import java.nio.ByteBuffer;\n \n+import org.apache.accumulo.core.util.ByteBufferUtil;\n+\n public class ArrayByteSequence extends ByteSequence implements Serializable {\n \n   private static final long serialVersionUID = 1L;\n@@ -52,15 +54,14 @@ public ArrayByteSequence(String s) {\n   }\n \n   public ArrayByteSequence(ByteBuffer buffer) {\n-    this.length = buffer.remaining();\n-\n     if (buffer.hasArray()) {\n       this.data = buffer.array();\n-      this.offset = buffer.position();\n+      this.offset = buffer.position() + buffer.arrayOffset();\n+      this.length = buffer.remaining();\n     } else {\n-      this.data = new byte[length];\n       this.offset = 0;\n-      buffer.get(data);\n+      this.data = ByteBufferUtil.toBytes(buffer);\n+      this.length = data.length;\n     }\n   }\n \n@@ -118,6 +119,7 @@ public ByteSequence subSequence(int start, int end) {\n     return copy;\n   }\n \n+  @Override\n   public String toString() {\n     return new String(data, offset, length, UTF_8);\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/ByteBufferUtil.java b/core/src/main/java/org/apache/accumulo/core/util/ByteBufferUtil.java\nindex be5cddf..cdde05c 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/ByteBufferUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/ByteBufferUtil.java\n@@ -31,7 +31,15 @@\n   public static byte[] toBytes(ByteBuffer buffer) {\n     if (buffer == null)\n       return null;\n-    return Arrays.copyOfRange(buffer.array(), buffer.position(), buffer.limit());\n+    if (buffer.hasArray()) {\n+      // did not use buffer.get() because it changes the position\n+      return Arrays.copyOfRange(buffer.array(), buffer.position() + buffer.arrayOffset(), buffer.limit() + buffer.arrayOffset());\n+    } else {\n+      byte[] data = new byte[buffer.remaining()];\n+      // duplicate inorder to avoid changing position\n+      buffer.duplicate().get(data);\n+      return data;\n+    }\n   }\n \n   public static List<ByteBuffer> toByteBuffers(Collection<byte[]> bytesList) {\n@@ -47,23 +55,32 @@\n   public static List<byte[]> toBytesList(Collection<ByteBuffer> bytesList) {\n     if (bytesList == null)\n       return null;\n-    ArrayList<byte[]> result = new ArrayList<byte[]>();\n+    ArrayList<byte[]> result = new ArrayList<byte[]>(bytesList.size());\n     for (ByteBuffer bytes : bytesList) {\n       result.add(toBytes(bytes));\n     }\n     return result;\n   }\n \n-  public static Text toText(ByteBuffer bytes) {\n-    if (bytes == null)\n+  public static Text toText(ByteBuffer byteBuffer) {\n+    if (byteBuffer == null)\n       return null;\n+\n+    if (byteBuffer.hasArray()) {\n       Text result = new Text();\n-    result.set(bytes.array(), bytes.position(), bytes.remaining());\n+      result.set(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());\n       return result;\n+    } else {\n+      return new Text(toBytes(byteBuffer));\n+    }\n   }\n \n   public static String toString(ByteBuffer bytes) {\n-    return new String(bytes.array(), bytes.position(), bytes.remaining(), UTF_8);\n+    if (bytes.hasArray()) {\n+      return new String(bytes.array(), bytes.arrayOffset() + bytes.position(), bytes.remaining(), UTF_8);\n+    } else {\n+      return new String(toBytes(bytes), UTF_8);\n+    }\n   }\n \n   public static ByteBuffer toByteBuffers(ByteSequence bs) {\n@@ -73,7 +90,6 @@ public static ByteBuffer toByteBuffers(ByteSequence bs) {\n     if (bs.isBackedByArray()) {\n       return ByteBuffer.wrap(bs.getBackingArray(), bs.offset(), bs.length());\n     } else {\n-      // TODO create more efficient impl\n       return ByteBuffer.wrap(bs.toArray());\n     }\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java b/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\nindex f353613..b776553 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\n@@ -122,8 +122,8 @@ public Reader(ByteBuffer buffer) {\n         offset = buffer.arrayOffset() + buffer.position();\n         data = buffer.array();\n       } else {\n-        data = new byte[buffer.remaining()];\n-        buffer.get(data);\n+        offset = 0;\n+        data = ByteBufferUtil.toBytes(buffer);\n       }\n     }\n \n", "nb_test": 715, "linesAdd": 30, "jira_id": "4113", "singleLine": false, "nb_skipped": 2, "commit": "27300d81", "nb_failure": 1, "linesRem": 13}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPutAfterEquals(org.apache.accumulo.core.data.MutationTest): Calling Mutation#equals then Mutation#put should not result in an IllegalStateException.", "testPutAfterHashCode(org.apache.accumulo.core.data.MutationTest): Calling Mutation#hashCode then Mutation#put should not result in an IllegalStateException."], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\nindex 0861cc4..81ad531 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n@@ -191,6 +191,20 @@ private void serialize() {\n     }\n   }\n \n+  /* This is so hashCode & equals can be called without changing this object.\n+   *\n+   * It will return a copy of the current data buffer if serialized has not been\n+   * called previously. Otherwise, this.data will be returned since the buffer is\n+   * null and will not change.\n+   */\n+  private byte[] serializedSnapshot() {\n+    if (buffer != null) {\n+      return buffer.toArray();\n+    } else {\n+      return this.data;\n+    }\n+  }\n+\n   /**\n    * @since 1.5.0\n    */\n@@ -691,13 +705,13 @@ public boolean equals(Object o) {\n \n   @Override\n   public int hashCode() {\n-    return toThrift().hashCode();\n+    return toThrift(false).hashCode();\n   }\n \n   public boolean equals(Mutation m) {\n-    serialize();\n-    m.serialize();\n-    if (Arrays.equals(row, m.row) && entries == m.entries && Arrays.equals(data, m.data)) {\n+    byte[] myData = serializedSnapshot();\n+    byte[] otherData = m.serializedSnapshot();\n+    if (Arrays.equals(row, m.row) && entries == m.entries && Arrays.equals(myData, otherData)) {\n       if (values == null && m.values == null)\n         return true;\n \n@@ -716,7 +730,17 @@ public boolean equals(Mutation m) {\n   }\n \n   public TMutation toThrift() {\n-    serialize();\n+    return toThrift(true);\n+  }\n+\n+  private TMutation toThrift(boolean serialize) {\n+    byte[] data;\n+    if (serialize) {\n+      this.serialize();\n+      data = this.data;\n+    } else {\n+      data = serializedSnapshot();\n+    }\n     return new TMutation(java.nio.ByteBuffer.wrap(row), java.nio.ByteBuffer.wrap(data), ByteBufferUtil.toByteBuffers(values), entries);\n   }\n \n", "nb_test": 434, "linesAdd": 23, "jira_id": "3718", "singleLine": false, "nb_skipped": 0, "commit": "73ce9cfb", "nb_failure": 2, "linesRem": 5}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testBadVisibility(org.apache.accumulo.core.iterators.system.VisibilityFilterTest): empty term near index 2(..)"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/iterators/system/VisibilityFilter.java b/core/src/main/java/org/apache/accumulo/core/iterators/system/VisibilityFilter.java\nindex a41f7be..4902e61 100644\n--- a/core/src/main/java/org/apache/accumulo/core/iterators/system/VisibilityFilter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/iterators/system/VisibilityFilter.java\n@@ -25,6 +25,7 @@\n import org.apache.accumulo.core.security.ColumnVisibility;\n import org.apache.accumulo.core.security.VisibilityEvaluator;\n import org.apache.accumulo.core.security.VisibilityParseException;\n+import org.apache.accumulo.core.util.BadArgumentException;\n import org.apache.accumulo.core.util.TextUtil;\n import org.apache.commons.collections.map.LRUMap;\n import org.apache.hadoop.io.Text;\n@@ -73,6 +74,9 @@ else if (testVis.getLength() == 0)\n     } catch (VisibilityParseException e) {\n       log.error(\"Parse Error\", e);\n       return false;\n+    } catch (BadArgumentException e) {\n+      log.error(\"Parse Error\", e);\n+      return false;\n     }\n   }\n }\n", "nb_test": 307, "linesAdd": 4, "jira_id": "844", "singleLine": false, "nb_skipped": 0, "commit": "692efde2", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ZooKeeperInstanceTest.testAllZooKeepersAreUsed:153", "Unexpected method call ZooCacheFactory.getZooCache(\"zk1\", 30000):"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java b/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\nindex b64fab4..17ad10b 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\n@@ -107,6 +107,8 @@ public static ClientProperty getPropertyByKey(String key) {\n \n   public ClientConfiguration(List<? extends Configuration> configs) {\n     super(configs);\n+    // Don't do list interpolation\n+    this.setListDelimiter('\\0');\n   }\n \n   /**\n", "nb_test": 702, "linesAdd": 1, "jira_id": "3218", "singleLine": true, "nb_skipped": 1, "commit": "1b35d263", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["setIterTest(org.apache.accumulo.core.util.shell.ShellTest): java.lang.IllegalArgumentException present in test@fake t> setiter -class VersioningIterator -p 1(..)", "duContextTest(org.apache.accumulo.core.util.shell.ShellTest): expected:<1> but was:<0>", "scanDateStringFormatterTest(org.apache.accumulo.core.util.shell.ShellTest): expected:<1> but was:<0>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\nindex 4c6d2d2..26e38e6 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\n@@ -175,14 +175,23 @@ private static String setUpOptions(ClassLoader classloader, final ConsoleReader\n       clazz = classloader.loadClass(className).asSubclass(OptionDescriber.class);\n       skvi = clazz.newInstance();\n     } catch (ClassNotFoundException e) {\n-      throw new IllegalArgumentException(e.getMessage());\n+      StringBuilder msg = new StringBuilder(\"Unable to load \").append(className);\n+      if (className.indexOf('.') < 0) {\n+        msg.append(\"; did you use a fully qualified package name?\");\n+      } else {\n+        msg.append(\"; class not found.\");\n+      }\n+      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, msg.toString());\n     } catch (InstantiationException e) {\n       throw new IllegalArgumentException(e.getMessage());\n     } catch (IllegalAccessException e) {\n       throw new IllegalArgumentException(e.getMessage());\n     } catch (ClassCastException e) {\n-      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, \"Unable to load \" + className + \" as type \" + OptionDescriber.class.getName()\n-          + \"; configure with 'config' instead\");\n+      StringBuilder msg = new StringBuilder(\"Loaded \");\n+      msg.append(className).append(\" but it does not implement \");\n+      msg.append(OptionDescriber.class.getSimpleName());\n+      msg.append(\"; use 'config -s' instead.\");\n+      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, msg.toString());\n     }\n     \n     final IteratorOptions itopts = skvi.describeOptions();\n", "nb_test": 383, "linesAdd": 12, "jira_id": "1358", "singleLine": false, "nb_skipped": 0, "commit": "6c565dfb", "nb_failure": 3, "linesRem": 3}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["InputTableConfigTest.testSerialization_allBooleans:64 expected:<org.apache.accumulo.core.client.mapreduce.InputTableConfig@3e1> but was:<org.apache.accumulo.core.client.mapreduce.InputTableConfig@3e0>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/InputTableConfig.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/InputTableConfig.java\nindex e59451e..fa3b7eb 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/InputTableConfig.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/InputTableConfig.java\n@@ -281,6 +281,7 @@ public void write(DataOutput dataOutput) throws IOException {\n     dataOutput.writeBoolean(autoAdjustRanges);\n     dataOutput.writeBoolean(useLocalIterators);\n     dataOutput.writeBoolean(useIsolatedScanners);\n+    dataOutput.writeBoolean(offlineScan);\n   }\n \n   /**\n@@ -325,6 +326,7 @@ public void readFields(DataInput dataInput) throws IOException {\n     autoAdjustRanges = dataInput.readBoolean();\n     useLocalIterators = dataInput.readBoolean();\n     useIsolatedScanners = dataInput.readBoolean();\n+    offlineScan = dataInput.readBoolean();\n   }\n \n   @Override\n", "nb_test": 700, "linesAdd": 2, "jira_id": "3143", "singleLine": false, "nb_skipped": 1, "commit": "ddd2c3bc", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\nindex 9ebdef4..2cdd3fe 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n@@ -37,6 +37,7 @@\n import org.apache.accumulo.core.conf.Property;\n import org.apache.accumulo.core.data.Key;\n import org.apache.accumulo.core.data.KeyExtent;\n+import org.apache.accumulo.core.file.rfile.RFile;\n import org.apache.accumulo.core.util.CachedConfiguration;\n import org.apache.accumulo.core.volume.NonConfiguredVolume;\n import org.apache.accumulo.core.volume.Volume;\n@@ -55,6 +56,7 @@\n import org.apache.hadoop.hdfs.DFSConfigKeys;\n import org.apache.hadoop.hdfs.DistributedFileSystem;\n import org.apache.hadoop.util.Progressable;\n+import org.apache.hadoop.util.StringUtils;\n import org.apache.log4j.Logger;\n \n import com.google.common.collect.HashMultimap;\n@@ -538,10 +540,30 @@ public Path getFullPath(FileType fileType, String path) {\n       }\n     }\n \n-    // normalize the path\n-    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\n     if (path.startsWith(\"/\"))\n       path = path.substring(1);\n+\n+    // ACCUMULO-2974 To ensure that a proper absolute path is created, the caller needs to include the table ID\n+    // in the relative path. Fail when this doesn't appear to happen.\n+    if (FileType.TABLE == fileType) {\n+      // Trailing slash doesn't create an additional element\n+      String[] pathComponents = StringUtils.split(path, Path.SEPARATOR_CHAR);\n+\n+      // Is an rfile\n+      if (path.endsWith(RFile.EXTENSION)) {\n+        if (pathComponents.length < 3) {\n+          throw new IllegalArgumentException(\"Fewer components in file path than expected\");\n+        }\n+      } else {\n+        // is a directory\n+        if (pathComponents.length < 2) {\n+          throw new IllegalArgumentException(\"Fewer components in directory path than expected\");\n+        }\n+      }\n+    }\n+\n+    // normalize the path\n+    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\n     fullPath = new Path(fullPath, path);\n \n     FileSystem fs = getVolumeByPath(fullPath).getFileSystem();\ndiff --git a/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java b/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java\nindex d72abd2..fbc9738 100644\n--- a/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java\n+++ b/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java\n@@ -80,6 +80,7 @@\n import org.apache.accumulo.server.tables.TableManager;\n import org.apache.accumulo.server.tablets.TabletTime;\n import org.apache.accumulo.server.util.MetadataTableUtil;\n+import org.apache.hadoop.fs.Path;\n import org.apache.hadoop.io.Text;\n import org.apache.thrift.TException;\n \n@@ -512,7 +513,10 @@ private void deleteTablets(MergeInfo info) throws AccumuloException {\n         } else if (key.compareColumnFamily(TabletsSection.CurrentLocationColumnFamily.NAME) == 0) {\n           throw new IllegalStateException(\"Tablet \" + key.getRow() + \" is assigned during a merge!\");\n         } else if (TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.hasColumns(key)) {\n-          datafiles.add(new FileRef(entry.getValue().toString(), this.master.fs.getFullPath(FileType.TABLE, entry.getValue().toString())));\n+          // ACCUMULO-2974 Need to include the TableID when converting a relative path to an absolute path.\n+          // The value has the leading path separator already included so it doesn't need it included.\n+          datafiles.add(new FileRef(entry.getValue().toString(), this.master.fs.getFullPath(FileType.TABLE, Path.SEPARATOR + extent.getTableId()\n+              + entry.getValue().toString())));\n           if (datafiles.size() > 1000) {\n             MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());\n             datafiles.clear();\n", "nb_test": 6, "linesAdd": 21, "jira_id": "2974", "singleLine": false, "nb_skipped": 0, "commit": "5eceb10e", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["setIterTest(org.apache.accumulo.core.util.shell.ShellTest): java.lang.IllegalArgumentException present in test@fake t> setiter -class VersioningIterator -p 1(..)", "duContextTest(org.apache.accumulo.core.util.shell.ShellTest): expected:<1> but was:<0>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\nindex 4c6d2d2..26e38e6 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\n@@ -175,14 +175,23 @@ private static String setUpOptions(ClassLoader classloader, final ConsoleReader\n       clazz = classloader.loadClass(className).asSubclass(OptionDescriber.class);\n       skvi = clazz.newInstance();\n     } catch (ClassNotFoundException e) {\n-      throw new IllegalArgumentException(e.getMessage());\n+      StringBuilder msg = new StringBuilder(\"Unable to load \").append(className);\n+      if (className.indexOf('.') < 0) {\n+        msg.append(\"; did you use a fully qualified package name?\");\n+      } else {\n+        msg.append(\"; class not found.\");\n+      }\n+      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, msg.toString());\n     } catch (InstantiationException e) {\n       throw new IllegalArgumentException(e.getMessage());\n     } catch (IllegalAccessException e) {\n       throw new IllegalArgumentException(e.getMessage());\n     } catch (ClassCastException e) {\n-      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, \"Unable to load \" + className + \" as type \" + OptionDescriber.class.getName()\n-          + \"; configure with 'config' instead\");\n+      StringBuilder msg = new StringBuilder(\"Loaded \");\n+      msg.append(className).append(\" but it does not implement \");\n+      msg.append(OptionDescriber.class.getSimpleName());\n+      msg.append(\"; use 'config -s' instead.\");\n+      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, msg.toString());\n     }\n     \n     final IteratorOptions itopts = skvi.describeOptions();\n", "nb_test": 363, "linesAdd": 12, "jira_id": "1358", "singleLine": false, "nb_skipped": 0, "commit": "4d10c92f", "nb_failure": 2, "linesRem": 3}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ReverseLexicoderTest.testReverseSortDates:55->LexicoderTest.assertSortOrder:57 expected:<[Tue Jul 26 05:06:42 PDT 2016, Tue Jul 26 05:06:33 PDT 2016, Tue Jul 26 05:06:32 PDT 2016, Mon Feb 02 03:04:05 PST 1920]> but was:<[Mon Feb 02 03:04:05 PST 1920, Tue Jul 26 05:06:42 PDT 2016, Tue Jul 26 05:06:33 PDT 2016, Tue Jul 26 05:06:32 PDT 2016]>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/lexicoder/DateLexicoder.java b/core/src/main/java/org/apache/accumulo/core/client/lexicoder/DateLexicoder.java\nindex c93ba70..8533bfe 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/lexicoder/DateLexicoder.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/lexicoder/DateLexicoder.java\n@@ -20,11 +20,12 @@\n \n /**\n  * A lexicoder for date objects. It preserves the native Java sort order for Date.\n+ *\n  * @since 1.6.0\n  */\n public class DateLexicoder implements Lexicoder<Date> {\n \n-  private ULongLexicoder longEncoder = new ULongLexicoder();\n+  private LongLexicoder longEncoder = new LongLexicoder();\n \n   @Override\n   public byte[] encode(Date data) {\n", "nb_test": 697, "linesAdd": 1, "jira_id": "3385", "singleLine": false, "nb_skipped": 2, "commit": "a3267d3e", "nb_failure": 1, "linesRem": 1}, {"files": 4, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/init/Initialize.java b/server/base/src/main/java/org/apache/accumulo/server/init/Initialize.java\nindex 0a681c4..9b952ba 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/init/Initialize.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/init/Initialize.java\n@@ -20,6 +20,7 @@\n import java.io.IOException;\n import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Locale;\n@@ -31,6 +32,8 @@\n import org.apache.accumulo.core.Constants;\n import org.apache.accumulo.core.cli.Help;\n import org.apache.accumulo.core.client.AccumuloSecurityException;\n+import org.apache.accumulo.core.client.IteratorSetting;\n+import org.apache.accumulo.core.client.IteratorSetting.Column;\n import org.apache.accumulo.core.client.impl.Namespaces;\n import org.apache.accumulo.core.client.impl.thrift.ThriftSecurityException;\n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n@@ -41,6 +44,8 @@\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.file.FileOperations;\n import org.apache.accumulo.core.file.FileSKVWriter;\n+import org.apache.accumulo.core.iterators.Combiner;\n+import org.apache.accumulo.core.iterators.IteratorUtil.IteratorScope;\n import org.apache.accumulo.core.iterators.user.VersioningIterator;\n import org.apache.accumulo.core.master.state.tables.TableState;\n import org.apache.accumulo.core.master.thrift.MasterGoalState;\n@@ -65,10 +70,12 @@\n import org.apache.accumulo.server.fs.VolumeManager;\n import org.apache.accumulo.server.fs.VolumeManagerImpl;\n import org.apache.accumulo.server.iterators.MetadataBulkLoadFilter;\n+import org.apache.accumulo.server.replication.StatusCombiner;\n import org.apache.accumulo.server.security.AuditedSecurityOperation;\n import org.apache.accumulo.server.security.SystemCredentials;\n import org.apache.accumulo.server.tables.TableManager;\n import org.apache.accumulo.server.tablets.TabletTime;\n+import org.apache.accumulo.server.util.ReplicationTableUtil;\n import org.apache.accumulo.server.util.TablePropUtil;\n import org.apache.accumulo.server.zookeeper.ZooReaderWriter;\n import org.apache.hadoop.conf.Configuration;\n@@ -566,6 +573,23 @@ public static void initMetadataConfig(String tableId) throws IOException {\n   protected static void initMetadataConfig() throws IOException {\n     initMetadataConfig(RootTable.ID);\n     initMetadataConfig(MetadataTable.ID);\n+\n+    // ACCUMULO-3077 Set the combiner on accumulo.metadata during init to reduce the likelihood of a race\n+    // condition where a tserver compacts away Status updates because it didn't see the Combiner configured\n+    IteratorSetting setting = new IteratorSetting(9, ReplicationTableUtil.COMBINER_NAME, StatusCombiner.class);\n+    Combiner.setColumns(setting, Collections.singletonList(new Column(MetadataSchema.ReplicationSection.COLF)));\n+    try {\n+      for (IteratorScope scope : IteratorScope.values()) {\n+        String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), setting.getName());\n+        for (Entry<String,String> prop : setting.getOptions().entrySet()) {\n+          TablePropUtil.setTableProperty(MetadataTable.ID, root + \".opt.\" + prop.getKey(), prop.getValue());\n+        }\n+        TablePropUtil.setTableProperty(MetadataTable.ID, root, setting.getPriority() + \",\" + setting.getIteratorClass());\n+      }\n+    } catch (Exception e) {\n+      log.fatal(\"Error talking to ZooKeeper\", e);\n+      throw new IOException(e);\n+    }\n   }\n \n   private static void setMetadataReplication(int replication, String reason) throws IOException {\ndiff --git a/server/base/src/main/java/org/apache/accumulo/server/util/ReplicationTableUtil.java b/server/base/src/main/java/org/apache/accumulo/server/util/ReplicationTableUtil.java\nindex 2a9774d..ab5ee86 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/util/ReplicationTableUtil.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/util/ReplicationTableUtil.java\n@@ -187,7 +187,7 @@ public static void updateLogs(Credentials creds, KeyExtent extent, Collection<Lo\n    */\n   public static void updateFiles(Credentials creds, KeyExtent extent, Collection<String> files, Status stat) {\n     if (log.isDebugEnabled()) {\n-      log.debug(\"Updating replication for \" + extent + \" with \" + files + \" using \" + ProtobufUtil.toString(stat));\n+      log.debug(\"Updating replication status for \" + extent + \" with \" + files + \" using \" + ProtobufUtil.toString(stat));\n     }\n     // TODO could use batch writer, would need to handle failure and retry like update does - ACCUMULO-1294\n     if (files.isEmpty()) {\ndiff --git a/server/tserver/src/main/java/org/apache/accumulo/tserver/log/TabletServerLogger.java b/server/tserver/src/main/java/org/apache/accumulo/tserver/log/TabletServerLogger.java\nindex b4f14ec..26e6891 100644\n--- a/server/tserver/src/main/java/org/apache/accumulo/tserver/log/TabletServerLogger.java\n+++ b/server/tserver/src/main/java/org/apache/accumulo/tserver/log/TabletServerLogger.java\n@@ -276,8 +276,8 @@ private int write(final Collection<CommitSession> sessions, boolean mincFinish,\n                   logs.add(logger.getFileName());\n                 }\n                 Status status = StatusUtil.fileCreated(System.currentTimeMillis());\n-                log.debug(\"Writing \" + ProtobufUtil.toString(status) + \" to replication table for \" + logs);\n-                // Got some new WALs, note this in the replication table\n+                log.debug(\"Writing \" + ProtobufUtil.toString(status) + \" to metadata table for \" + logs);\n+                // Got some new WALs, note this in the metadata table\n                 ReplicationTableUtil.updateFiles(SystemCredentials.get(), commitSession.getExtent(), logs, status);\n               }\n             }\ndiff --git a/server/tserver/src/main/java/org/apache/accumulo/tserver/tablet/DatafileManager.java b/server/tserver/src/main/java/org/apache/accumulo/tserver/tablet/DatafileManager.java\nindex 5b46b7b..78a2ed6 100644\n--- a/server/tserver/src/main/java/org/apache/accumulo/tserver/tablet/DatafileManager.java\n+++ b/server/tserver/src/main/java/org/apache/accumulo/tserver/tablet/DatafileManager.java\n@@ -424,6 +424,9 @@ void bringMinorCompactionOnline(FileRef tmpDatafile, FileRef newDatafile, FileRe\n       // This WAL could still be in use by other Tablets *from the same table*, so we can only mark that there is data to replicate,\n       // but it is *not* closed\n       if (replicate) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"Recording that data has been ingested into \" + tablet.getExtent() + \" using \" + logFileOnly);\n+        }\n         ReplicationTableUtil.updateFiles(SystemCredentials.get(), tablet.getExtent(), logFileOnly, StatusUtil.openWithUnknownLength());\n       }\n     } finally {\n", "nb_test": 6, "linesAdd": 27, "jira_id": "3077", "singleLine": false, "nb_skipped": 0, "commit": "17654199", "nb_failure": 0, "linesRem": 2}, {"files": 4, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCreateUseVersions(org.apache.accumulo.core.client.mock.MockTableOperationsTest): expected:<3> but was:<1>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsImpl.java b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsImpl.java\nindex c35d7fa..ea4f311 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsImpl.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsImpl.java\n@@ -190,11 +190,7 @@ public void create(String tableName, boolean limitVersion, TimeType timeType) th\n     \n     List<ByteBuffer> args = Arrays.asList(ByteBuffer.wrap(tableName.getBytes()), ByteBuffer.wrap(timeType.name().getBytes()));\n     \n-    Map<String,String> opts;\n-    if (limitVersion) {\n-      opts = IteratorUtil.generateInitialTableProperties();\n-    } else\n-      opts = Collections.emptyMap();\n+    Map<String,String> opts = IteratorUtil.generateInitialTableProperties(limitVersion);\n     \n     try {\n       doTableOperation(TableOperation.CREATE, args, opts);\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex f558822..9289608 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -88,9 +88,9 @@ public int compareTo(Key o) {\n   private TimeType timeType;\n   SortedSet<Text> splits = new TreeSet<Text>();\n   \n-  MockTable(boolean useVersions, TimeType timeType) {\n+  MockTable(boolean limitVersion, TimeType timeType) {\n     this.timeType = timeType;\n-    settings = IteratorUtil.generateInitialTableProperties();\n+    settings = IteratorUtil.generateInitialTableProperties(limitVersion);\n     for (Entry<String,String> entry : AccumuloConfiguration.getDefaultConfiguration()) {\n       String key = entry.getKey();\n       if (key.startsWith(Property.TABLE_PREFIX.getKey()))\ndiff --git a/core/src/main/java/org/apache/accumulo/core/iterators/IteratorUtil.java b/core/src/main/java/org/apache/accumulo/core/iterators/IteratorUtil.java\nindex 172fa63..9b1ca69 100644\n--- a/core/src/main/java/org/apache/accumulo/core/iterators/IteratorUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/iterators/IteratorUtil.java\n@@ -63,13 +63,22 @@ public int compare(IterInfo o1, IterInfo o2) {\n     \n   }\n   \n-  public static Map<String,String> generateInitialTableProperties() {\n+  /**\n+   * Generate the initial (default) properties for a table\n+   * @param limitVersion\n+   *   include a VersioningIterator at priority 20 that retains a single version of a given K/V pair.\n+   * @return A map of Table properties\n+   */\n+  public static Map<String,String> generateInitialTableProperties(boolean limitVersion) {\n     TreeMap<String,String> props = new TreeMap<String,String>();\n     \n+    if (limitVersion) {\n         for (IteratorScope iterScope : IteratorScope.values()) {\n           props.put(Property.TABLE_ITERATOR_PREFIX + iterScope.name() + \".vers\", \"20,\" + VersioningIterator.class.getName());\n           props.put(Property.TABLE_ITERATOR_PREFIX + iterScope.name() + \".vers.opt.maxVersions\", \"1\");\n         }\n+    }\n+    \n     return props;\n   }\n   \ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/CreateTableCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/CreateTableCommand.java\nindex 83829a9..f2495cc 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/CreateTableCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/CreateTableCommand.java\n@@ -110,7 +110,7 @@ public int execute(final String fullCommand, final CommandLine cl, final Shell s\n     // context\n     \n     if (cl.hasOption(createTableNoDefaultIters.getOpt())) {\n-      for (String key : IteratorUtil.generateInitialTableProperties().keySet()) {\n+      for (String key : IteratorUtil.generateInitialTableProperties(true).keySet()) {\n         shellState.getConnector().tableOperations().removeProperty(tableName, key);\n       }\n     }\n", "nb_test": 294, "linesAdd": 8, "jira_id": "795", "singleLine": false, "nb_skipped": 0, "commit": "9453bcfa", "nb_failure": 1, "linesRem": 9}, {"files": 1, "project": "accumulo", "nb_error": 8, "classification": {"singleLine": false}, "failing_tests": ["AccumuloRowInputFormatTest.test:202 \u00bb IO Job failed!", "AccumuloInputFormatTest.testMap:281 \u00bb IO Job failed!", "AccumuloMultiTableInputFormatTest.testMap:159 \u00bb IO Job failed!", "AccumuloOutputFormatTest.testMR:193 \u00bb IO Job failed!", "AccumuloFileOutputFormatTest.testEmptyWrite:91->handleWriteTests:174 \u00bb IO Job ...", "AccumuloFileOutputFormatTest.testRealWrite:96->handleWriteTests:174 \u00bb IO Job f...", "AccumuloFileOutputFormatTest.writeBadVisibility:195 \u00bb IO Job failed!", "TokenFileTest.testMR:167 \u00bb IO Job failed!"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapred/InputFormatBase.java b/core/src/main/java/org/apache/accumulo/core/client/mapred/InputFormatBase.java\nindex 54b983f..0cee355 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapred/InputFormatBase.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapred/InputFormatBase.java\n@@ -322,6 +322,9 @@ protected void setupIterators(JobConf job, Scanner scanner, String tableName, or\n         iterators = getIterators(job);\n       } else {\n         iterators = split.getIterators();\n+        if (null == iterators) {\n+          iterators = getIterators(job);\n+        }\n       }\n \n       setupIterators(iterators, scanner);\n", "nb_test": 629, "linesAdd": 3, "jira_id": "2659", "singleLine": false, "nb_skipped": 1, "commit": "019edb16", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDelete(org.apache.accumulo.proxy.SimpleTest): expected:<1> but was:<0>"], "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex 0fedb1d..f873010 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -1124,13 +1124,13 @@ private void addCellsToWriter(Map<ByteBuffer,List<ColumnUpdate>> cells, BatchWri\n         if (update.isSetValue())\n           value = update.getValue();\n         if (update.isSetTimestamp()) {\n-          if (update.isSetDeleteCell()) {\n+          if (update.isSetDeleteCell() && update.isDeleteCell()) {\n             m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n           } else {\n             m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, update.getTimestamp(), new Value(value));\n           }\n         } else {\n-          if (update.isSetDeleteCell()) {\n+          if (update.isSetDeleteCell() && update.isDeleteCell()) {\n             m.putDelete(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz);\n           } else {\n             m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, new Value(value));\n", "nb_test": 34, "linesAdd": 2, "jira_id": "3474", "singleLine": false, "nb_skipped": 0, "commit": "cfb832a1", "nb_failure": 1, "linesRem": 2}, {"files": 5, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testToThrift(org.apache.accumulo.core.security.CredentialsTest)", "testMockConnector(org.apache.accumulo.core.security.CredentialsTest): Error BAD_CREDENTIALS for user root - Username or Password is Invalid"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/impl/ConnectorImpl.java b/core/src/main/java/org/apache/accumulo/core/client/impl/ConnectorImpl.java\nindex 14df55f..bd11569 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/impl/ConnectorImpl.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/impl/ConnectorImpl.java\n@@ -55,6 +55,9 @@\n   \n   public ConnectorImpl(final Instance instance, Credentials cred) throws AccumuloException, AccumuloSecurityException {\n     ArgumentChecker.notNull(instance, cred);\n+    if (cred.getToken().isDestroyed())\n+      throw new AccumuloSecurityException(cred.getPrincipal(), SecurityErrorCode.TOKEN_EXPIRED);\n+    \n     this.instance = instance;\n     \n     this.credentials = cred;\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockConnector.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockConnector.java\nindex 4af2ea5..80ec513 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockConnector.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockConnector.java\n@@ -18,6 +18,7 @@\n \n import java.util.concurrent.TimeUnit;\n \n+import org.apache.accumulo.core.client.AccumuloSecurityException;\n import org.apache.accumulo.core.client.BatchDeleter;\n import org.apache.accumulo.core.client.BatchScanner;\n import org.apache.accumulo.core.client.BatchWriter;\n@@ -32,7 +33,10 @@\n import org.apache.accumulo.core.client.admin.InstanceOperations;\n import org.apache.accumulo.core.client.admin.SecurityOperations;\n import org.apache.accumulo.core.client.admin.TableOperations;\n+import org.apache.accumulo.core.client.impl.thrift.SecurityErrorCode;\n+import org.apache.accumulo.core.client.security.tokens.NullToken;\n import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.accumulo.core.security.Credentials;\n \n public class MockConnector extends Connector {\n   \n@@ -40,12 +44,14 @@\n   private final MockAccumulo acu;\n   private final Instance instance;\n   \n-  MockConnector(String username, MockInstance instance) {\n-    this(username, new MockAccumulo(MockInstance.getDefaultFileSystem()), instance);\n+  MockConnector(String username, MockInstance instance) throws AccumuloSecurityException {\n+    this(new Credentials(username, new NullToken()), new MockAccumulo(MockInstance.getDefaultFileSystem()), instance);\n   }\n   \n-  MockConnector(String username, MockAccumulo acu, MockInstance instance) {\n-    this.username = username;\n+  MockConnector(Credentials credentials, MockAccumulo acu, MockInstance instance) throws AccumuloSecurityException {\n+    if (credentials.getToken().isDestroyed())\n+      throw new AccumuloSecurityException(credentials.getPrincipal(), SecurityErrorCode.TOKEN_EXPIRED);\n+    this.username = credentials.getPrincipal();\n     this.acu = acu;\n     this.instance = instance;\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockInstance.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockInstance.java\nindex f37994d..2ba8c67 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockInstance.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockInstance.java\n@@ -31,6 +31,7 @@\n import org.apache.accumulo.core.client.security.tokens.AuthenticationToken;\n import org.apache.accumulo.core.client.security.tokens.PasswordToken;\n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.security.Credentials;\n import org.apache.accumulo.core.util.ByteBufferUtil;\n import org.apache.accumulo.core.util.CachedConfiguration;\n import org.apache.accumulo.core.util.TextUtil;\n@@ -150,7 +151,7 @@ public void setConfiguration(AccumuloConfiguration conf) {\n   \n   @Override\n   public Connector getConnector(String principal, AuthenticationToken token) throws AccumuloException, AccumuloSecurityException {\n-    Connector conn = new MockConnector(principal, acu, this);\n+    Connector conn = new MockConnector(new Credentials(principal, token), acu, this);\n     if (!acu.users.containsKey(principal))\n       conn.securityOperations().createLocalUser(principal, (PasswordToken) token);\n     else if (!acu.users.get(principal).token.equals(token))\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/security/tokens/PasswordToken.java b/core/src/main/java/org/apache/accumulo/core/client/security/tokens/PasswordToken.java\nindex c39fb8d..11bbf49 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/security/tokens/PasswordToken.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/security/tokens/PasswordToken.java\n@@ -46,7 +46,9 @@\n   /**\n    * Constructor for use with {@link Writable}. Call {@link #readFields(DataInput)}.\n    */\n-  public PasswordToken() {}\n+  public PasswordToken() {\n+    password = new byte[0];\n+  }\n   \n   /**\n    * Constructs a token from a copy of the password. Destroying the argument after construction will not destroy the copy in this token, and destroying this\ndiff --git a/core/src/main/java/org/apache/accumulo/core/security/Credentials.java b/core/src/main/java/org/apache/accumulo/core/security/Credentials.java\nindex 71a09f6..0552e7e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/security/Credentials.java\n+++ b/core/src/main/java/org/apache/accumulo/core/security/Credentials.java\n@@ -22,6 +22,7 @@\n import org.apache.accumulo.core.client.AccumuloSecurityException;\n import org.apache.accumulo.core.client.Connector;\n import org.apache.accumulo.core.client.Instance;\n+import org.apache.accumulo.core.client.impl.thrift.SecurityErrorCode;\n import org.apache.accumulo.core.client.security.tokens.AuthenticationToken;\n import org.apache.accumulo.core.client.security.tokens.AuthenticationToken.AuthenticationTokenSerializer;\n import org.apache.accumulo.core.security.thrift.TCredentials;\n@@ -58,7 +59,11 @@ public AuthenticationToken getToken() {\n    * {@link AuthenticationToken}, so this should be used just before placing on the wire, and references to it should be tightly controlled.\n    */\n   public TCredentials toThrift(Instance instance) {\n-    return new TCredentials(principal, token.getClass().getName(), ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(token)), instance.getInstanceID());\n+    TCredentials tCreds = new TCredentials(getPrincipal(), getToken().getClass().getName(),\n+        ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(getToken())), instance.getInstanceID());\n+    if (getToken().isDestroyed())\n+      throw new RuntimeException(\"Token has been destroyed\", new AccumuloSecurityException(getPrincipal(), SecurityErrorCode.TOKEN_EXPIRED));\n+    return tCreds;\n   }\n   \n   /**\n", "nb_test": 434, "linesAdd": 24, "jira_id": "1312", "singleLine": false, "nb_skipped": 0, "commit": "d9ab8449", "nb_failure": 1, "linesRem": 7}, {"files": 1, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["test1(org.apache.accumulo.core.iterators.user.RegExFilterTest)"], "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\nindex fcf77c4..0b3b73f 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n@@ -39,10 +39,10 @@\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n     RegExFilter result = new RegExFilter();\n     result.setSource(getSource().deepCopy(env));\n-    result.rowMatcher = rowMatcher.pattern().matcher(\"\");\n-    result.colfMatcher = colfMatcher.pattern().matcher(\"\");\n-    result.colqMatcher = colqMatcher.pattern().matcher(\"\");\n-    result.valueMatcher = valueMatcher.pattern().matcher(\"\");\n+    result.rowMatcher = copyMatcher(rowMatcher);\n+    result.colfMatcher = copyMatcher(colfMatcher);\n+    result.colqMatcher = copyMatcher(colqMatcher);\n+    result.valueMatcher = copyMatcher(valueMatcher);\n     result.orFields = orFields;\n     return result;\n   }\n@@ -61,6 +61,14 @@\n   \n   private ByteArrayBackedCharSequence babcs = new ByteArrayBackedCharSequence();\n   \n+  private Matcher copyMatcher(Matcher m)\n+  {\n+\t  if(m == null)\n+\t\t  return m;\n+\t  else\n+\t\t  return m.pattern().matcher(\"\");\n+  }\n+  \n   private boolean matches(Matcher matcher, ByteSequence bs) {\n     if (matcher != null) {\n       babcs.set(bs);\n", "nb_test": 266, "linesAdd": 12, "jira_id": "189", "singleLine": false, "nb_skipped": 0, "commit": "6dbbdc21", "nb_failure": 0, "linesRem": 4}, {"files": 2, "project": "accumulo", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testDeleteRows(org.apache.accumulo.core.client.mock.MockTableOperationsTest): Code is not implemented"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex 8fb9f0e..c4262c0 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -20,9 +20,11 @@\n import java.util.EnumSet;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Set;\n import java.util.Map.Entry;\n import java.util.SortedMap;\n import java.util.SortedSet;\n+import java.util.TreeMap;\n import java.util.TreeSet;\n import java.util.concurrent.ConcurrentSkipListMap;\n \n@@ -86,6 +88,7 @@ public int compareTo(Key o) {\n   Map<String,EnumSet<TablePermission>> userPermissions = new HashMap<String,EnumSet<TablePermission>>();\n   private TimeType timeType;\n   SortedSet<Text> splits = new TreeSet<Text>();\n+  Map<String,Set<Text>> localityGroups = new TreeMap<String, Set<Text>>();\n   \n   MockTable(boolean limitVersion, TimeType timeType) {\n     this.timeType = timeType;\n@@ -122,4 +125,11 @@ public void addSplits(SortedSet<Text> partitionKeys) {\n   public Collection<Text> getSplits() {\n     return splits;\n   }\n+  \n+  public void setLocalityGroups(Map<String,Set<Text>> groups) {\n+    localityGroups = groups;\n+  }\n+  public Map<String,Set<Text>> getLocalityGroups() {\n+    return localityGroups;\n+  }\n }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex b5ffc73..5da7d64 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -40,6 +40,7 @@\n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.data.Key;\n import org.apache.accumulo.core.data.Mutation;\n+import org.apache.accumulo.core.data.PartialKey;\n import org.apache.accumulo.core.data.Range;\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.file.FileOperations;\n@@ -155,17 +156,23 @@ public void removeProperty(String tableName, String property) throws AccumuloExc\n   \n   @Override\n   public void setLocalityGroups(String tableName, Map<String,Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n+    acu.tables.get(tableName).setLocalityGroups(groups);\n   }\n   \n   @Override\n   public Map<String,Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n+    return acu.tables.get(tableName).getLocalityGroups();\n   }\n   \n   @Override\n   public Set<Range> splitRangeByTablets(String tableName, Range range, int maxSplits) throws AccumuloException, AccumuloSecurityException,\n       TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     return Collections.singleton(range);\n   }\n   \n@@ -262,15 +269,20 @@ public void importDirectory(String tableName, String dir, String failureDir, boo\n   \n   @Override\n   public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new AccumuloException(tableName + \" does not exists\");\n   }\n   \n   @Override\n-  public void online(String tableName) throws AccumuloSecurityException, AccumuloException {}\n+  public void online(String tableName) throws AccumuloSecurityException, AccumuloException {\n+    if (!exists(tableName))\n+      throw new AccumuloException(tableName + \" does not exists\");\n+  }\n   \n   @Override\n   public void clearLocatorCache(String tableName) throws TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n   }\n   \n   @Override\n@@ -284,24 +296,31 @@ public void clearLocatorCache(String tableName) throws TableNotFoundException {\n   \n   @Override\n   public void merge(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n }\n   \n   @Override\n   public void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n+    MockTable t = acu.tables.get(tableName);\n+    Set<Key> keep = new TreeSet<Key>(t.table.tailMap(new Key(start)).headMap(new Key(end)).keySet());\n+    t.table.keySet().removeAll(keep);\n   }\n   \n   @Override\n   public void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException,\n       AccumuloException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n   }\n   \n   @Override\n   public void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException,\n       TableNotFoundException, AccumuloException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n   }\n   \n   @Override\n@@ -312,7 +331,8 @@ public void clone(String srcTableName, String newTableName, boolean flush, Map<S\n   \n   @Override\n   public void flush(String tableName, Text start, Text end, boolean wait) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n  }\n   \n   @Override\n", "nb_test": 311, "linesAdd": 40, "jira_id": "843", "singleLine": false, "nb_skipped": 0, "commit": "65390f8c", "nb_failure": 0, "linesRem": 10}, {"files": 1, "project": "accumulo", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEmptyColumnFamily(org.apache.accumulo.core.client.mapreduce.AccumuloInputFormatTest): expected:<[(foo,bar), (,null), (,), (foo,), (,bar)]> but was:<[(foo,bar), (,), (foo,), (,bar)]>"], "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/lib/util/InputConfigurator.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/lib/util/InputConfigurator.java\nindex ff14107..b0e649b 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/lib/util/InputConfigurator.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/lib/util/InputConfigurator.java\n@@ -238,8 +238,15 @@ public static void fetchColumns(Class<?> implementingClass, Configuration conf,\n    */\n   public static Set<Pair<Text,Text>> getFetchedColumns(Class<?> implementingClass, Configuration conf) {\n     ArgumentChecker.notNull(conf);\n-\n-    return deserializeFetchedColumns(conf.getStringCollection(enumToConfKey(implementingClass, ScanOpts.COLUMNS)));\n+    String confValue = conf.get(enumToConfKey(implementingClass, ScanOpts.COLUMNS));\n+    List<String> serialized = new ArrayList<String>();\n+    if (confValue != null) {\n+      // Split and include any trailing empty strings to allow empty column families\n+      for (String val : confValue.split(\",\", -1)) {\n+        serialized.add(val);\n+      }\n+    }\n+    return deserializeFetchedColumns(serialized);\n   }\n \n   public static Set<Pair<Text,Text>> deserializeFetchedColumns(Collection<String> serialized) {\n", "nb_test": 403, "linesAdd": 8, "jira_id": "1661", "singleLine": false, "nb_skipped": 0, "commit": "13eb19c2", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["CheckpointCoordinatorTest.testCheckpointAbortsIfTriggerTasksAreFinished:116 null"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java\nindex 9694132..de83ad9 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java\n@@ -23,6 +23,7 @@\n import akka.actor.Props;\n \n import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.execution.ExecutionState;\n import org.apache.flink.runtime.executiongraph.Execution;\n import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;\n@@ -224,7 +225,7 @@ public boolean triggerCheckpoint(final long timestamp) {\n \t\t\tExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length];\n \t\t\tfor (int i = 0; i < tasksToTrigger.length; i++) {\n \t\t\t\tExecution ee = tasksToTrigger[i].getCurrentExecutionAttempt();\n-\t\t\t\tif (ee != null) {\n+\t\t\t\tif (ee != null && ee.getState() == ExecutionState.RUNNING) {\n \t\t\t\t\ttriggerIDs[i] = ee.getAttemptId();\n \t\t\t\t} else {\n \t\t\t\t\tLOG.info(\"Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.\",\n", "nb_test": 716, "linesAdd": 2, "jira_id": "2515", "singleLine": false, "nb_skipped": 0, "commit": "06e2da35", "nb_failure": 1, "linesRem": 1}, {"files": 3, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/datastream/KeyedDataStream.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/datastream/KeyedDataStream.java\nindex 7628815..100e5de 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/datastream/KeyedDataStream.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/datastream/KeyedDataStream.java\n@@ -35,7 +35,8 @@\n  * @param <T> The type of the elements in the Keyed Stream\n  */\n public class KeyedDataStream<T> extends DataStream<T> {\n-\tKeySelector<T, ?> keySelector;\n+\t\n+\tprotected final KeySelector<T, ?> keySelector;\n \n \t/**\n \t * Creates a new {@link KeyedDataStream} using the given {@link KeySelector}\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java\nindex c50f23e..d91afc9 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java\n@@ -1228,8 +1228,7 @@ public static LocalStreamEnvironment createLocalEnvironment(int parallelism, Con\n \t */\n \tpublic static StreamExecutionEnvironment createRemoteEnvironment(String host, int port,\n \t\t\tString... jarFiles) {\n-\t\tRemoteStreamEnvironment env = new RemoteStreamEnvironment(host, port, jarFiles);\n-\t\treturn env;\n+\t\treturn new RemoteStreamEnvironment(host, port, jarFiles);\n \t}\n \n \t/**\n@@ -1298,8 +1297,7 @@ public StreamGraph getStreamGraph() {\n \t\tif (transformations.size() <= 0) {\n \t\t\tthrow new IllegalStateException(\"No operators defined in streaming topology. Cannot execute.\");\n \t\t}\n-\t\tStreamGraph result = StreamGraphGenerator.generate(this, transformations);\n-\t\treturn result;\n+\t\treturn StreamGraphGenerator.generate(this, transformations);\n \t}\n \n \t/**\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\nindex 89c6142..cd32548 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\n@@ -27,41 +27,9 @@\n import org.apache.flink.api.java.functions.KeySelector;\n import org.apache.flink.api.java.operators.Keys;\n import org.apache.flink.api.java.tuple.Tuple;\n-import org.apache.flink.api.java.tuple.Tuple1;\n-import org.apache.flink.api.java.tuple.Tuple10;\n-import org.apache.flink.api.java.tuple.Tuple11;\n-import org.apache.flink.api.java.tuple.Tuple12;\n-import org.apache.flink.api.java.tuple.Tuple13;\n-import org.apache.flink.api.java.tuple.Tuple14;\n-import org.apache.flink.api.java.tuple.Tuple15;\n-import org.apache.flink.api.java.tuple.Tuple16;\n-import org.apache.flink.api.java.tuple.Tuple17;\n-import org.apache.flink.api.java.tuple.Tuple18;\n-import org.apache.flink.api.java.tuple.Tuple19;\n-import org.apache.flink.api.java.tuple.Tuple2;\n-import org.apache.flink.api.java.tuple.Tuple20;\n-import org.apache.flink.api.java.tuple.Tuple21;\n-import org.apache.flink.api.java.tuple.Tuple22;\n-import org.apache.flink.api.java.tuple.Tuple23;\n-import org.apache.flink.api.java.tuple.Tuple24;\n-import org.apache.flink.api.java.tuple.Tuple25;\n-import org.apache.flink.api.java.tuple.Tuple3;\n-import org.apache.flink.api.java.tuple.Tuple4;\n-import org.apache.flink.api.java.tuple.Tuple5;\n-import org.apache.flink.api.java.tuple.Tuple6;\n-import org.apache.flink.api.java.tuple.Tuple7;\n-import org.apache.flink.api.java.tuple.Tuple8;\n-import org.apache.flink.api.java.tuple.Tuple9;\n \n public class KeySelectorUtil {\n \n-\tpublic static Class<?>[] tupleClasses = new Class[] { Tuple1.class, Tuple2.class, Tuple3.class,\n-\t\t\tTuple4.class, Tuple5.class, Tuple6.class, Tuple7.class, Tuple8.class, Tuple9.class,\n-\t\t\tTuple10.class, Tuple11.class, Tuple12.class, Tuple13.class, Tuple14.class,\n-\t\t\tTuple15.class, Tuple16.class, Tuple17.class, Tuple18.class, Tuple19.class,\n-\t\t\tTuple20.class, Tuple21.class, Tuple22.class, Tuple23.class, Tuple24.class,\n-\t\t\tTuple25.class };\n-\n \tpublic static <X> KeySelector<X, ?> getSelectorForKeys(Keys<X> keys, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {\n \t\tint[] logicalKeyPositions = keys.computeLogicalKeyPositions();\n \t\tint keyLength = logicalKeyPositions.length;\n@@ -129,7 +97,7 @@ public ComparableKeySelector(TypeComparator<IN> comparator, int keyLength) {\n \n \t\t@Override\n \t\tpublic Tuple getKey(IN value) throws Exception {\n-\t\t\tkey = (Tuple) tupleClasses[keyLength - 1].newInstance();\n+\t\t\tkey = Tuple.getTupleClass(keyLength).newInstance();\n \t\t\tcomparator.extractKeys(value, keyArray, 0);\n \t\t\tfor (int i = 0; i < keyLength; i++) {\n \t\t\t\tkey.setField(keyArray[i], i);\n@@ -139,12 +107,11 @@ public Tuple getKey(IN value) throws Exception {\n \n \t}\n \n-\tpublic static class ArrayKeySelector<IN> implements KeySelector<IN, Tuple> {\n+\tpublic static final class ArrayKeySelector<IN> implements KeySelector<IN, Tuple> {\n \n \t\tprivate static final long serialVersionUID = 1L;\n \t\t\n-\t\tTuple key;\n-\t\tint[] fields;\n+\t\tprivate final int[] fields;\n \n \t\tpublic ArrayKeySelector(int... fields) {\n \t\t\tthis.fields = fields;\n@@ -152,10 +119,9 @@ public ArrayKeySelector(int... fields) {\n \n \t\t@Override\n \t\tpublic Tuple getKey(IN value) throws Exception {\n-\t\t\tkey = (Tuple) tupleClasses[fields.length - 1].newInstance();\n+\t\t\tTuple key = Tuple.getTupleClass(fields.length).newInstance();\n \t\t\tfor (int i = 0; i < fields.length; i++) {\n-\t\t\t\tint pos = fields[i];\n-\t\t\t\tkey.setField(Array.get(value, fields[pos]), i);\n+\t\t\t\tkey.setField(Array.get(value, fields[i]), i);\n \t\t\t}\n \t\t\treturn key;\n \t\t}\n", "nb_test": 25, "linesAdd": 9, "jira_id": "2734", "singleLine": false, "nb_skipped": 0, "commit": "8b40bb7a", "nb_failure": 0, "linesRem": 44}, {"files": 13, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["DoubleParserTest>ParserTestBase.testInValidStringInIsolation:249 Parser accepted the invalid value  1.", "DoubleParserTest>ParserTestBase.testInValidStringsMixedIn:294 Parser accepted the invalid value  1.", "DoubleParserTest>ParserTestBase.testStaticParseMethodWithInvalidValues:362 Static parse method accepted invalid value", "IntParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "DoubleValueParserTest>ParserTestBase.testInValidStringInIsolation:249 Parser accepted the invalid value  1.", "DoubleValueParserTest>ParserTestBase.testInValidStringsMixedIn:294 Parser accepted the invalid value  1.", "ByteParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "IntValueParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "ShortParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "ByteValueParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "FloatParserTest>ParserTestBase.testInValidStringInIsolation:249 Parser accepted the invalid value  1.", "FloatParserTest>ParserTestBase.testInValidStringsMixedIn:294 Parser accepted the invalid value  1.", "LongValueParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "FloatParserTest>ParserTestBase.testStaticParseMethodWithInvalidValues:362 Static parse method accepted invalid value", "ShortValueParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string.", "FloatValueParserTest>ParserTestBase.testInValidStringInIsolation:249 Parser accepted the invalid value  1.", "FloatValueParserTest>ParserTestBase.testInValidStringsMixedIn:294 Parser accepted the invalid value  1.", "LongParserTest>ParserTestBase.testEmptyFieldInIsolation:430 Parser accepted the empty string."], "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\nindex 5858da2..09e517a 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\n@@ -36,7 +36,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B\n \t\t\tstartPos++;\n \n \t\t\t// check for empty field with only the sign\n-\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n+\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, \n+\t\t\t\tdelimiter))) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n \t\t\t\treturn -1;\n \t\t\t}\n@@ -44,6 +45,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (byte) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -75,38 +80,35 @@ public Byte getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type byte from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type byte from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final byte parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type byte from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type byte from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final byte parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -121,7 +123,7 @@ public static final byte parseField(byte[] bytes, int startPos, int length, char\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (byte) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\nindex f9b36e4..612a1cb 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\n@@ -52,6 +52,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B\n \t\tfor (int i = startPos; i < limit; i++) {\n \n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((byte) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\nindex 947fdfe..086c1f5 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\n@@ -42,11 +42,15 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, D\n \t\t}\n \n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tthis.result = Double.parseDouble(str);\n \t\t\treturn (i == limit) ? limit : i + delimiter.length;\n-\t\t}\n-\t\tcatch (NumberFormatException e) {\n+\t\t} catch (NumberFormatException e) {\n \t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\n \t\t\treturn -1;\n \t\t}\n@@ -63,33 +67,33 @@ public Double getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type double from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type double from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final double parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type double from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type double from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final double parseField(byte[] bytes, int startPos, int length, char delimiter) {\n \t\tif (length <= 0) {\n@@ -102,7 +106,12 @@ public static final double parseField(byte[] bytes, int startPos, int length, ch\n \t\t\ti++;\n \t\t}\n \n-\t\tString str = new String(bytes, startPos, i);\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tthrow new NumberFormatException(\"There is leading or trailing whitespace in the \" +\n+\t\t\t\t\"numeric field: \" + str);\n+\t\t}\n \t\treturn Double.parseDouble(str);\n \t}\n }\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\nindex e225c1f..7751831 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\n@@ -43,6 +43,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, D\n \t\t}\n \t\t\n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tdouble value = Double.parseDouble(str);\n \t\t\treusable.setValue(value);\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\nindex 33697fd..55e9915 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\n@@ -64,7 +64,13 @@\n \t\tUNTERMINATED_QUOTED_STRING,\n \n \t\t/** The parser found characters between the end of the quoted string and the delimiter. */\n-\t\tUNQUOTED_CHARS_AFTER_QUOTED_STRING\n+\t\tUNQUOTED_CHARS_AFTER_QUOTED_STRING,\n+\t\t\n+\t\t/** The string is empty. */\n+\t\tEMPTY_STRING,\n+\n+\t\t/** There is whitespace in a numeric field. */\n+\t\tWHITESPACE_IN_NUMERIC_FIELD\n \t}\n \t\n \tprivate ParseErrorState errorState = ParseErrorState.NONE;\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\nindex 7d166c7..be98aa1 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\n@@ -27,7 +27,8 @@\n \tprivate float result;\n \t\n \t@Override\n-\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float reusable) {\n+\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float \n+\t\treusable) {\n \n \t\tint i = startPos;\n \n@@ -40,12 +41,17 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, F\n \t\t\ti++;\n \t\t}\n \n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n+\n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n \t\ttry {\n \t\t\tthis.result = Float.parseFloat(str);\n \t\t\treturn (i == limit) ? limit : i + delimiter.length;\n-\t\t}\n-\t\tcatch (NumberFormatException e) {\n+\t\t} catch (NumberFormatException e) {\n \t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\n \t\t\treturn -1;\n \t\t}\n@@ -62,33 +68,33 @@ public Float getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type float from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type float from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final float parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type float from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type float from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final float parseField(byte[] bytes, int startPos, int length, char delimiter) {\n \t\tif (length <= 0) {\n@@ -101,7 +107,12 @@ public static final float parseField(byte[] bytes, int startPos, int length, cha\n \t\t\ti++;\n \t\t}\n \t\t\n-\t\tString str = new String(bytes, startPos, i);\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tthrow new NumberFormatException(\"There is leading or trailing whitespace in the \" +\n+\t\t\t\t\"numeric field: \" + str);\n+\t\t}\n+\t\tint len = str.length();\n \t\treturn Float.parseFloat(str);\n \t}\n }\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\nindex af16d4c..e8caac2 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\n@@ -43,6 +43,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, F\n \t\t}\n \t\t\n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tfloat value = Float.parseFloat(str);\n \t\t\treusable.setValue(value);\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\nindex c871f4a..dcd2ec2 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\n@@ -32,7 +32,8 @@\n \tprivate int result;\n \n \t@Override\n-\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer reusable) {\n+\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer \n+\t\treusable) {\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -43,7 +44,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I\n \t\t\tstartPos++;\n \n \t\t\t// check for empty field with only the sign\n-\t\t\tif (startPos == limit || ( startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n+\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, \n+\t\t\t\tdelimiter))) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n \t\t\t\treturn -1;\n \t\t\t}\n@@ -51,6 +53,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (int) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -82,38 +88,35 @@ public Integer getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type int from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type int from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final int parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type int from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type int from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final int parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -128,7 +131,7 @@ public static final int parseField(byte[] bytes, int startPos, int length, char\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (int) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\nindex 8cb8176..abd8615 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\n@@ -54,6 +54,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((int) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\nindex af17f15..bb6c7c9 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\n@@ -47,6 +47,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, L\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = neg ? -val : val;\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -123,9 +127,6 @@ public static final long parseField(byte[] bytes, int startPos, int length) {\n \t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n \t */\n \tpublic static final long parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -140,7 +141,7 @@ public static final long parseField(byte[] bytes, int startPos, int length, char\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn neg ? -val : val;\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\nindex 8b697cc..a99a86e 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\n@@ -51,6 +51,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, L\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue(neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\nindex a6f9898..6e04d60 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\n@@ -51,6 +51,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (short) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -111,9 +115,6 @@ public static final short parseField(byte[] bytes, int startPos, int length) {\n \t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n \t */\n \tpublic static final short parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -128,7 +129,7 @@ public static final short parseField(byte[] bytes, int startPos, int length, cha\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (short) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\nindex f5168cc..4289d1a 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\n@@ -54,6 +54,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((short) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n", "nb_test": 835, "linesAdd": 82, "jira_id": "1820", "singleLine": false, "nb_skipped": 0, "commit": "39d526e6", "nb_failure": 18, "linesRem": 27}, {"files": 2, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PathTest.testIsAbsolute:130 null"], "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/core/fs/Path.java b/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\nindex 75155eb..c47bc0d 100644\n--- a/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\n+++ b/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\n@@ -260,7 +260,11 @@ private String normalizePath(String path) {\n \t\tpath = path.replaceAll(\"/+\", \"/\");\n \n \t\t// remove tailing separator\n-\t\tif(!path.equals(SEPARATOR) && path.endsWith(SEPARATOR)) {\n+\t\tif(!path.equals(SEPARATOR) &&         \t\t// UNIX root path\n+\t\t\t\t!path.matches(\"/\\\\p{Alpha}+:/\") &&  // Windows root path\n+\t\t\t\tpath.endsWith(SEPARATOR))\n+\t\t{\n+\t\t\t// remove tailing slash\n \t\t\tpath = path.substring(0, path.length() - SEPARATOR.length());\n \t\t}\n \ndiff --git a/flink-core/src/main/java/org/apache/flink/core/fs/local/LocalFileSystem.java b/flink-core/src/main/java/org/apache/flink/core/fs/local/LocalFileSystem.java\nindex 2313a41..9dd9e30 100644\n--- a/flink-core/src/main/java/org/apache/flink/core/fs/local/LocalFileSystem.java\n+++ b/flink-core/src/main/java/org/apache/flink/core/fs/local/LocalFileSystem.java\n@@ -228,8 +228,13 @@ private boolean delete(final File f) throws IOException {\n \t */\n \tpublic boolean mkdirs(final Path f) throws IOException {\n \n-\t\tfinal Path parent = f.getParent();\n \t\tfinal File p2f = pathToFile(f);\n+\n+\t\tif(p2f.isDirectory()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tfinal Path parent = f.getParent();\n \t\treturn (parent == null || mkdirs(parent)) && (p2f.mkdir() || p2f.isDirectory());\n \t}\n \n", "nb_test": 859, "linesAdd": 10, "jira_id": "1848", "singleLine": false, "nb_skipped": 0, "commit": "7164b2b6", "nb_failure": 1, "linesRem": 2}, {"files": 2, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["CoGroupCustomPartitioningTest.testIncompatibleHashAndCustomPartitioning:268 No plan meeting the requirements could be created @ CoGroup (CoGroup at testIncompatibleHashAndCustomPartitioning(CoGroupCustomPartitioningTest.java:251)) (1:null)(2:null). Most likely reason: Too restrictive plan hints.", "JoinCustomPartitioningTest.testIncompatibleHashAndCustomPartitioning:265 No plan meeting the requirements could be created @ Join (Join at testIncompatibleHashAndCustomPartitioning(JoinCustomPartitioningTest.java:248)) (1:null)(2:null). Most likely reason: Too restrictive plan hints."], "patch": "diff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/operators/AbstractJoinDescriptor.java b/flink-compiler/src/main/java/org/apache/flink/compiler/operators/AbstractJoinDescriptor.java\nindex cb0e61c..d8f7746 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/operators/AbstractJoinDescriptor.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/operators/AbstractJoinDescriptor.java\n@@ -19,6 +19,7 @@\n package org.apache.flink.compiler.operators;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n \n import org.apache.flink.api.common.functions.Partitioner;\n@@ -62,6 +63,33 @@ public void setCustomPartitioner(Partitioner<?> partitioner) {\n \t\t\n \t\tif (repartitionAllowed) {\n \t\t\t// partition both (hash or custom)\n+\t\t\tif (this.customPartitioner == null) {\n+\t\t\t\t\n+\t\t\t\t// we accept compatible partitionings of any type\n+\t\t\t\tRequestedGlobalProperties partitioned_left_any = new RequestedGlobalProperties();\n+\t\t\t\tRequestedGlobalProperties partitioned_right_any = new RequestedGlobalProperties();\n+\t\t\t\tpartitioned_left_any.setAnyPartitioning(this.keys1);\n+\t\t\t\tpartitioned_right_any.setAnyPartitioning(this.keys2);\n+\t\t\t\tpairs.add(new GlobalPropertiesPair(partitioned_left_any, partitioned_right_any));\n+\t\t\t\t\n+\t\t\t\t// we also explicitly add hash partitioning, as a fallback, if the any-pairs do not match\n+\t\t\t\tRequestedGlobalProperties partitioned_left_hash = new RequestedGlobalProperties();\n+\t\t\t\tRequestedGlobalProperties partitioned_right_hash = new RequestedGlobalProperties();\n+\t\t\t\tpartitioned_left_hash.setHashPartitioned(this.keys1);\n+\t\t\t\tpartitioned_right_hash.setHashPartitioned(this.keys2);\n+\t\t\t\tpairs.add(new GlobalPropertiesPair(partitioned_left_hash, partitioned_right_hash));\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tRequestedGlobalProperties partitioned_left = new RequestedGlobalProperties();\n+\t\t\t\tpartitioned_left.setCustomPartitioned(this.keys1, this.customPartitioner);\n+\t\t\t\t\n+\t\t\t\tRequestedGlobalProperties partitioned_right = new RequestedGlobalProperties();\n+\t\t\t\tpartitioned_right.setCustomPartitioned(this.keys2, this.customPartitioner);\n+\t\t\t\t\n+\t\t\t\treturn Collections.singletonList(new GlobalPropertiesPair(partitioned_left, partitioned_right));\n+\t\t\t}\n+\t\t\t\n+\t\t\t\n \t\t\tRequestedGlobalProperties partitioned1 = new RequestedGlobalProperties();\n \t\t\tif (customPartitioner == null) {\n \t\t\t\tpartitioned1.setAnyPartitioning(this.keys1);\ndiff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/operators/CoGroupDescriptor.java b/flink-compiler/src/main/java/org/apache/flink/compiler/operators/CoGroupDescriptor.java\nindex 14f40f3..bc83c51 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/operators/CoGroupDescriptor.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/operators/CoGroupDescriptor.java\n@@ -18,6 +18,7 @@\n \n package org.apache.flink.compiler.operators;\n \n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n \n@@ -98,21 +99,29 @@ public DriverStrategy getStrategy() {\n \n \t@Override\n \tprotected List<GlobalPropertiesPair> createPossibleGlobalProperties() {\n-\t\tRequestedGlobalProperties partitioned1 = new RequestedGlobalProperties();\n \t\tif (this.customPartitioner == null) {\n-\t\t\tpartitioned1.setAnyPartitioning(this.keys1);\n-\t\t} else {\n-\t\t\tpartitioned1.setCustomPartitioned(this.keys1, this.customPartitioner);\n-\t\t}\n+\t\t\tRequestedGlobalProperties partitioned_left_any = new RequestedGlobalProperties();\n+\t\t\tRequestedGlobalProperties partitioned_left_hash = new RequestedGlobalProperties();\n+\t\t\tpartitioned_left_any.setAnyPartitioning(this.keys1);\n+\t\t\tpartitioned_left_hash.setHashPartitioned(this.keys1);\n \t\t\t\n-\t\tRequestedGlobalProperties partitioned2 = new RequestedGlobalProperties();\n-\t\tif (this.customPartitioner == null) {\n-\t\t\tpartitioned2.setAnyPartitioning(this.keys2);\n-\t\t} else {\n-\t\t\tpartitioned2.setCustomPartitioned(this.keys2, this.customPartitioner);\n+\t\t\tRequestedGlobalProperties partitioned_right_any = new RequestedGlobalProperties();\n+\t\t\tRequestedGlobalProperties partitioned_right_hash = new RequestedGlobalProperties();\n+\t\t\tpartitioned_right_any.setAnyPartitioning(this.keys2);\n+\t\t\tpartitioned_right_hash.setHashPartitioned(this.keys2);\n+\t\t\t\n+\t\t\treturn Arrays.asList(new GlobalPropertiesPair(partitioned_left_any, partitioned_right_any),\n+\t\t\t\t\tnew GlobalPropertiesPair(partitioned_left_hash, partitioned_right_hash));\n \t\t}\n+\t\telse {\n+\t\t\tRequestedGlobalProperties partitioned_left = new RequestedGlobalProperties();\n+\t\t\tpartitioned_left.setCustomPartitioned(this.keys1, this.customPartitioner);\n+\t\t\t\n+\t\t\tRequestedGlobalProperties partitioned_right = new RequestedGlobalProperties();\n+\t\t\tpartitioned_right.setCustomPartitioned(this.keys2, this.customPartitioner);\n \t\t\t\n-\t\treturn Collections.singletonList(new GlobalPropertiesPair(partitioned1, partitioned2));\n+\t\t\treturn Collections.singletonList(new GlobalPropertiesPair(partitioned_left, partitioned_right));\n+\t\t}\n \t}\n \t\n \t@Override\n", "nb_test": 170, "linesAdd": 46, "jira_id": "1290", "singleLine": false, "nb_skipped": 0, "commit": "45fb6d82", "nb_failure": 2, "linesRem": 11}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["KryoGenericTypeSerializerTest.validateReferenceMappingDisabled:177 null"], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\nindex f1287fa..276ffc4 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n@@ -323,6 +323,10 @@ private void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = getKryoInstance();\n \n+\t\t\t// disable reference tracking. reference tracking is costly, usually unnecessary, and\n+\t\t\t// inconsistent with Flink's own serialization (which does not do reference tracking)\n+\t\t\tkryo.setReferences(false);\n+\t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n", "nb_test": 1100, "linesAdd": 2, "jira_id": "3267", "singleLine": false, "nb_skipped": 0, "commit": "ed3810b1", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PojoTypeExtractionTest.testDualUseOfPojo:874 null"], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 41644f9..1ae8d3d 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -26,9 +26,7 @@\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n-import java.util.HashSet;\n import java.util.List;\n-import java.util.Set;\n \n import org.apache.avro.specific.SpecificRecordBase;\n import org.apache.flink.api.common.functions.CoGroupFunction;\n@@ -67,14 +65,32 @@\n  */\n public class TypeExtractor {\n \n-\tprivate static final Logger LOG = LoggerFactory.getLogger(TypeExtractor.class);\n+\t/*\n+\t * NOTE: Most methods of the TypeExtractor work with a so-called \"typeHierarchy\".\n+\t * The type hierarchy describes all types (Classes, ParameterizedTypes, TypeVariables etc. ) and intermediate\n+\t * types from a given type of a function or type (e.g. MyMapper, Tuple2) until a current type\n+\t * (depends on the method, e.g. MyPojoFieldType).\n+\t *\n+\t * Thus, it fully qualifies types until tuple/POJO field level.\n+\t *\n+\t * A typical typeHierarchy could look like:\n+\t *\n+\t * UDF: MyMapFunction.class\n+\t * top-level UDF: MyMapFunctionBase.class\n+\t * RichMapFunction: RichMapFunction.class\n+\t * MapFunction: MapFunction.class\n+\t * Function's OUT: Tuple1<MyPojo>\n+\t * user-defined POJO: MyPojo.class\n+\t * user-defined top-level POJO: MyPojoBase.class\n+\t * POJO field: Tuple1<String>\n+\t * Field type: String.class\n+\t *\n+\t */\n \t\n-\t// We need this to detect recursive types and not get caught\n-\t// in an endless recursion\n-\tprivate Set<Class<?>> alreadySeen;\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(TypeExtractor.class);\n \n \tprotected TypeExtractor() {\n-\t\talreadySeen = new HashSet<Class<?>>();\n+\t\t// only create instances for special use cases\n \t}\n \n \t// --------------------------------------------------------------------------------------------\n@@ -416,10 +432,12 @@ protected TypeExtractor() {\n \t\t\t\n \t\t\tTypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];\n \t\t\tfor (int i = 0; i < subtypes.length; i++) {\n+\t\t\t\tArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy);\n+\t\t\t\tsubTypeHierarchy.add(subtypes[i]);\n \t\t\t\t// sub type could not be determined with materializing\n \t\t\t\t// try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n \t\t\t\tif (subtypes[i] instanceof TypeVariable<?>) {\n-\t\t\t\t\ttupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n+\t\t\t\t\ttupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type);\n \t\t\t\t\t\n \t\t\t\t\t// variable could not be determined\n \t\t\t\t\tif (tupleSubTypes[i] == null) {\n@@ -430,7 +448,7 @@ protected TypeExtractor() {\n \t\t\t\t\t\t\t\t+ \"all variables in the return type can be deduced from the input type(s).\");\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\ttupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n+\t\t\t\t\ttupleSubTypes[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type);\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n@@ -914,6 +932,19 @@ else if (typeInfo instanceof GenericTypeInfo<?>) {\n \t// --------------------------------------------------------------------------------------------\n \n \t/**\n+\t * @return number of items with equal type or same raw type\n+\t */\n+\tprivate static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {\n+\t\tint count = 0;\n+\t\tfor (Type t : typeHierarchy) {\n+\t\t\tif (t == type || (isClassType(type) && t == typeToClass(type))) {\n+\t\t\t\tcount++;\n+\t\t\t}\n+\t\t}\n+\t\treturn count;\n+\t}\n+\t\n+\t/**\n \t * @param curT : start type\n \t * @return Type The immediate child of the top class\n \t */\n@@ -1183,12 +1214,10 @@ private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeV\n \t\t\treturn (TypeInformation<OUT>) new AvroTypeInfo(clazz);\n \t\t}\n \n-\t\tif (alreadySeen.contains(clazz)) {\n+\t\tif (countTypeInHierarchy(typeHierarchy, clazz) > 1) {\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n \t\t}\n \n-\t\talreadySeen.add(clazz);\n-\n \t\tif (Modifier.isInterface(clazz.getModifiers())) {\n \t\t\t// Interface has no members and is therefore not handled as POJO\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n", "nb_test": 966, "linesAdd": 16, "jira_id": "2447", "singleLine": false, "nb_skipped": 0, "commit": "5546a1ef", "nb_failure": 1, "linesRem": 10}, {"files": 4, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["IterationsCompilerTest.testIterationPushingWorkOut:247 expected:<FORWARD> but was:<PARTITION_HASH>", "IterationsCompilerTest.testTwoIterationsDirectlyChained:160 expected:<FORWARD> but was:<PARTITION_HASH>", "IterationsCompilerTest.testBulkIterationWithPartialSolutionProperties:432->CompilerTestBase.compileNoStats:94 \u00bb Compiler"], "patch": "diff --git a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/BulkIterationNode.java b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/BulkIterationNode.java\nindex 3d95c22..556e2e3 100644\n--- a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/BulkIterationNode.java\n+++ b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/BulkIterationNode.java\n@@ -28,7 +28,6 @@\n import org.apache.flink.api.common.operators.SemanticProperties;\n import org.apache.flink.api.common.operators.SemanticProperties.EmptySemanticProperties;\n import org.apache.flink.api.common.operators.base.BulkIterationBase;\n-import org.apache.flink.api.common.operators.util.FieldList;\n import org.apache.flink.optimizer.CompilerException;\n import org.apache.flink.optimizer.DataStatistics;\n import org.apache.flink.optimizer.traversals.InterestingPropertyVisitor;\n@@ -48,6 +47,7 @@\n import org.apache.flink.optimizer.plan.PlanNode;\n import org.apache.flink.optimizer.plan.SingleInputPlanNode;\n import org.apache.flink.optimizer.plan.PlanNode.FeedbackPropertiesMeetRequirementsReport;\n+import org.apache.flink.optimizer.util.NoOpUnaryUdfOp;\n import org.apache.flink.runtime.operators.DriverStrategy;\n import org.apache.flink.util.Visitor;\n \n@@ -273,7 +273,7 @@ public void computeUnclosedBranchStack() {\n \t\tthis.openBranches = (result == null || result.isEmpty()) ? Collections.<UnclosedBranchDescriptor>emptyList() : result;\n \t}\n \n-\n+\t@SuppressWarnings(\"unchecked\")\n \t@Override\n \tprotected void instantiateCandidate(OperatorDescriptorSingle dps, Channel in, List<Set<? extends NamedChannel>> broadcastPlanChannels, \n \t\t\tList<PlanNode> target, CostEstimator estimator, RequestedGlobalProperties globPropsReq, RequestedLocalProperties locPropsReq)\n@@ -322,7 +322,9 @@ else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\n \t\t\t\t\tglobPropsReq.parameterizeChannel(toNoOp, false, rootConnection.getDataExchangeMode(), false);\n \t\t\t\t\tlocPropsReq.parameterizeChannel(toNoOp);\n \n-\t\t\t\t\tUnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode(\"Rebuild Partial Solution Properties\", FieldList.EMPTY_LIST);\n+\t\t\t\t\tNoOpUnaryUdfOp noOpUnaryUdfOp = new NoOpUnaryUdfOp<>();\n+\t\t\t\t\tnoOpUnaryUdfOp.setInput(candidate.getProgramOperator());\n+\t\t\t\t\tUnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode(\"Rebuild Partial Solution Properties\", noOpUnaryUdfOp, true);\n \t\t\t\t\trebuildPropertiesNode.setParallelism(candidate.getParallelism());\n \t\t\t\t\t\n \t\t\t\t\tSingleInputPlanNode rebuildPropertiesPlanNode = new SingleInputPlanNode(rebuildPropertiesNode, \"Rebuild Partial Solution Properties\", toNoOp, DriverStrategy.UNARY_NO_OP);\n@@ -343,6 +345,8 @@ else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\n \t\t\t\t\tplanDeleter.remove();\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tcandidates.addAll(newCandidates);\n \t\t}\n \n \t\tif (candidates.isEmpty()) {\ndiff --git a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/UnaryOperatorNode.java b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/UnaryOperatorNode.java\nindex 0c48033..0ec0264 100644\n--- a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/UnaryOperatorNode.java\n+++ b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/UnaryOperatorNode.java\n@@ -18,10 +18,12 @@\n \n package org.apache.flink.optimizer.dag;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n \n import org.apache.flink.api.common.operators.SemanticProperties;\n+import org.apache.flink.api.common.operators.SingleInputOperator;\n import org.apache.flink.api.common.operators.SingleInputSemanticProperties;\n import org.apache.flink.api.common.operators.util.FieldSet;\n import org.apache.flink.optimizer.DataStatistics;\n@@ -30,11 +32,17 @@\n \n public class UnaryOperatorNode extends SingleInputNode {\n \t\n-\tprivate final List<OperatorDescriptorSingle> operator;\n+\tprivate final List<OperatorDescriptorSingle> operators;\n \t\n \tprivate final String name;\n \n+\tpublic UnaryOperatorNode(String name, SingleInputOperator<?, ?, ?> operator, boolean onDynamicPath) {\n+\t\tsuper(operator);\n \n+\t\tthis.name = name;\n+\t\tthis.operators = new ArrayList<>();\n+\t\tthis.onDynamicPath = onDynamicPath;\n+\t}\n \t\n \tpublic UnaryOperatorNode(String name, FieldSet keys, OperatorDescriptorSingle ... operators) {\n \t\tthis(name, keys, Arrays.asList(operators));\n@@ -43,13 +51,13 @@ public UnaryOperatorNode(String name, FieldSet keys, OperatorDescriptorSingle ..\n \tpublic UnaryOperatorNode(String name, FieldSet keys, List<OperatorDescriptorSingle> operators) {\n \t\tsuper(keys);\n \t\t\n-\t\tthis.operator = operators;\n+\t\tthis.operators = operators;\n \t\tthis.name = name;\n \t}\n \n \t@Override\n \tprotected List<OperatorDescriptorSingle> getPossibleProperties() {\n-\t\treturn this.operator;\n+\t\treturn this.operators;\n \t}\n \n \t@Override\ndiff --git a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/WorksetIterationNode.java b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/WorksetIterationNode.java\nindex 15b9a50..7969a94 100644\n--- a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/WorksetIterationNode.java\n+++ b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/WorksetIterationNode.java\n@@ -52,6 +52,7 @@\n import org.apache.flink.optimizer.plan.WorksetPlanNode;\n import org.apache.flink.optimizer.plan.PlanNode.FeedbackPropertiesMeetRequirementsReport;\n import org.apache.flink.optimizer.util.NoOpBinaryUdfOp;\n+import org.apache.flink.optimizer.util.NoOpUnaryUdfOp;\n import org.apache.flink.runtime.operators.DriverStrategy;\n import org.apache.flink.runtime.operators.shipping.ShipStrategyType;\n import org.apache.flink.runtime.operators.util.LocalStrategy;\n@@ -308,6 +309,7 @@ public void clearInterestingProperties() {\n \t\tthis.solutionSetDelta.accept(InterestingPropertiesClearer.INSTANCE);\n \t}\n \n+\t@SuppressWarnings(\"unchecked\")\n \t@Override\n \tprotected void instantiate(OperatorDescriptorDual operator, Channel solutionSetIn, Channel worksetIn,\n \t\t\tList<Set<? extends NamedChannel>> broadcastPlanChannels, List<PlanNode> target, CostEstimator estimator,\n@@ -368,8 +370,13 @@ else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnextWorksetRootConnection.getDataExchangeMode(), false);\n \t\t\t\t\tlocPropsReqWorkset.parameterizeChannel(toNoOp);\n \n-\t\t\t\t\tUnaryOperatorNode rebuildWorksetPropertiesNode = new UnaryOperatorNode(\"Rebuild Workset Properties\",\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFieldList.EMPTY_LIST);\n+\t\t\t\t\tNoOpUnaryUdfOp noOpUnaryUdfOp = new NoOpUnaryUdfOp<>();\n+\t\t\t\t\tnoOpUnaryUdfOp.setInput(candidate.getProgramOperator());\n+\n+\t\t\t\t\tUnaryOperatorNode rebuildWorksetPropertiesNode = new UnaryOperatorNode(\n+\t\t\t\t\t\t\"Rebuild Workset Properties\",\n+\t\t\t\t\t\tnoOpUnaryUdfOp,\n+\t\t\t\t\t\ttrue);\n \t\t\t\t\t\n \t\t\t\t\trebuildWorksetPropertiesNode.setParallelism(candidate.getParallelism());\n \t\t\t\t\t\ndiff --git a/flink-optimizer/src/main/java/org/apache/flink/optimizer/util/NoOpUnaryUdfOp.java b/flink-optimizer/src/main/java/org/apache/flink/optimizer/util/NoOpUnaryUdfOp.java\nindex cc4a4d6..8537b9c 100644\n--- a/flink-optimizer/src/main/java/org/apache/flink/optimizer/util/NoOpUnaryUdfOp.java\n+++ b/flink-optimizer/src/main/java/org/apache/flink/optimizer/util/NoOpUnaryUdfOp.java\n@@ -36,7 +36,7 @@\n \t@SuppressWarnings(\"rawtypes\")\n \tpublic static final NoOpUnaryUdfOp INSTANCE = new NoOpUnaryUdfOp();\n \t\n-\tprivate NoOpUnaryUdfOp() {\n+\tpublic NoOpUnaryUdfOp() {\n \t\t// pass null here because we override getOutputType to return type\n \t\t// of input operator\n \t\tsuper(new UserCodeClassWrapper<NoOpFunction>(NoOpFunction.class), null, \"\");\n", "nb_test": 335, "linesAdd": 28, "jira_id": "3052", "singleLine": false, "nb_skipped": 0, "commit": "8dc70f2e", "nb_failure": 2, "linesRem": 9}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["TypeExtractorTest.testDuplicateValue:1466 \u00bb InvalidTypes Type of TypeVariable ..."], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex d8e1aed..d5f3619 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -201,7 +201,7 @@ private TypeExtractor() {\n \t\t\n \t\t// return type is a variable -> try to get the type info from the input directly\n \t\tif (returnType instanceof TypeVariable<?>) {\n-\t\t\ttypeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) returnType, typeHierarchy, in1Type, in2Type);\n+\t\t\ttypeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) returnType, typeHierarchy, in1Type, in2Type);\n \t\t\t\n \t\t\tif (typeInfo != null) {\n \t\t\t\treturn typeInfo;\n@@ -280,7 +280,7 @@ private TypeExtractor() {\n \t\t\t\t// sub type could not be determined with materializing\n \t\t\t\t// try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n \t\t\t\tif (subtypes[i] instanceof TypeVariable<?>) {\n-\t\t\t\t\ttupleSubTypes[i] = createTypeInfoFromInput((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n+\t\t\t\t\ttupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n \t\t\t\t\t\n \t\t\t\t\t// variable could not be determined\n \t\t\t\t\tif (tupleSubTypes[i] == null) {\n@@ -315,7 +315,7 @@ else if (t instanceof TypeVariable) {\n \t\t\t}\n \t\t\t// try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n \t\t\telse {\n-\t\t\t\tTypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\n+\t\t\t\tTypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\n \t\t\t\tif (typeInfo != null) {\n \t\t\t\t\treturn typeInfo;\n \t\t\t\t} else {\n@@ -371,7 +371,7 @@ else if (t instanceof Class) {\n \t\tthrow new InvalidTypesException(\"Type Information could not be created.\");\n \t}\n \t\n-\tprivate <IN1, IN2> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, \n+\tprivate <IN1, IN2> TypeInformation<?> createTypeInfoFromInputs(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, \n \t\t\tTypeInformation<IN1> in1TypeInfo, TypeInformation<IN2> in2TypeInfo) {\n \n \t\tType matReturnTypeVar = materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n@@ -389,20 +389,16 @@ else if (t instanceof Class) {\n \t\t\t// find the deepest type variable that describes the type of input 1\n \t\t\tParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\n \t\t\tType in1Type = baseClass.getActualTypeArguments()[0];\n-\t\t\tif (in1Type instanceof TypeVariable) {\n-\t\t\t\tin1Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in1Type);\n-\t\t\t\tinfo = findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\n-\t\t\t}\n+\n+\t\t\tinfo = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in1Type, in1TypeInfo);\n \t\t}\n \n \t\tif (info == null && in2TypeInfo != null) {\n \t\t\t// find the deepest type variable that describes the type of input 2\n \t\t\tParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\n \t\t\tType in2Type = baseClass.getActualTypeArguments()[1];\n-\t\t\tif (in2Type instanceof TypeVariable) {\n-\t\t\t\tin2Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in2Type);\n-\t\t\t\tinfo = findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\n-\t\t\t}\n+\n+\t\t\tinfo = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in2Type, in2TypeInfo);\n \t\t}\n \n \t\tif (info != null) {\n@@ -412,6 +408,31 @@ else if (t instanceof Class) {\n \t\treturn null;\n \t}\n \t\n+\tprivate <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, \n+\t\t\tType inType, TypeInformation<IN1> inTypeInfo) {\n+\t\tTypeInformation<?> info = null;\n+\t\t// the input is a type variable\n+\t\tif (inType instanceof TypeVariable) {\n+\t\t\tinType = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) inType);\n+\t\t\tinfo = findCorrespondingInfo(returnTypeVar, inType, inTypeInfo);\n+\t\t}\n+\t\t// the input is a tuple that may contains type variables\n+\t\telse if (inType instanceof ParameterizedType && Tuple.class.isAssignableFrom(((Class<?>)((ParameterizedType) inType).getRawType()))) {\n+\t\t\tType[] tupleElements = ((ParameterizedType) inType).getActualTypeArguments();\n+\t\t\t// go thru all tuple elements and search for type variables\n+\t\t\tfor(int i = 0; i < tupleElements.length; i++) {\n+\t\t\t\tif(tupleElements[i] instanceof TypeVariable) {\n+\t\t\t\t\tinType = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) tupleElements[i]);\n+\t\t\t\t\tinfo = findCorrespondingInfo(returnTypeVar, inType, ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i));\n+\t\t\t\t\tif(info != null) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\t\n \t// --------------------------------------------------------------------------------------------\n \t//  Extract type parameters\n \t// --------------------------------------------------------------------------------------------\n", "nb_test": 455, "linesAdd": 30, "jira_id": "1133", "singleLine": false, "nb_skipped": 1, "commit": "27e40205", "nb_failure": 0, "linesRem": 12}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": [], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\nindex 2d2f29b..73f0a89 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\n@@ -274,6 +274,7 @@ public CopyingOperatorCollector(OneInputStreamOperator operator, TypeSerializer<\n \t\t@Override\n \t\tpublic void collect(T record) {\n \t\t\ttry {\n+\t\t\t\toperator.getRuntimeContext().setNextInput(record);\n \t\t\t\toperator.processElement(serializer.copy(record));\n \t\t\t} catch (Exception e) {\n \t\t\t\tif (LOG.isErrorEnabled()) {\n", "nb_test": 25, "linesAdd": 1, "jira_id": "2294", "singleLine": true, "nb_skipped": 0, "commit": "fef9f115", "nb_failure": 0, "linesRem": 0}, {"files": 2, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ExecutionGraphRestartTest.testConstraintsAfterRestart:143->restartAfterFailure:405 expected:<RUNNING> but was:<FAILING>"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\nindex 9085483..a03f0bf 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n@@ -51,6 +51,7 @@\n import org.apache.flink.runtime.jobgraph.JobVertexID;\n import org.apache.flink.runtime.jobgraph.ScheduleMode;\n import org.apache.flink.runtime.jobmanager.RecoveryMode;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroup;\n import org.apache.flink.runtime.jobmanager.scheduler.Scheduler;\n import org.apache.flink.runtime.messages.ExecutionGraphMessages;\n import org.apache.flink.runtime.taskmanager.TaskExecutionState;\n@@ -76,6 +77,8 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Collection;\n+import java.util.HashSet;\n import java.util.NoSuchElementException;\n import java.util.UUID;\n import java.util.concurrent.Callable;\n@@ -849,7 +852,16 @@ else if (current != JobStatus.RESTARTING) {\n \n \t\t\t\tthis.currentExecutions.clear();\n \n+\t\t\t\tCollection<CoLocationGroup> colGroups = new HashSet<>();\n+\t\t\t\t\n \t\t\t\tfor (ExecutionJobVertex jv : this.verticesInCreationOrder) {\n+\t\t\t\t\t\n+\t\t\t\t\tCoLocationGroup cgroup = jv.getCoLocationGroup();\n+\t\t\t\t\tif(cgroup != null && !colGroups.contains(cgroup)){\n+\t\t\t\t\t\tcgroup.resetConstraints();\n+\t\t\t\t\t\tcolGroups.add(cgroup);\n+\t\t\t\t\t}\n+\t\t\t\t\t\n \t\t\t\t\tjv.resetForNewExecution();\n \t\t\t\t}\n \ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java\nindex 93ae7c1..bc368ab 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java\n@@ -362,9 +362,6 @@ public void resetForNewExecution() {\n \t\t\tif (slotSharingGroup != null) {\n \t\t\t\tslotSharingGroup.clearTaskAssignment();\n \t\t\t}\n-\t\t\tif (coLocationGroup != null) {\n-\t\t\t\tcoLocationGroup.resetConstraints();\n-\t\t\t}\n \t\t\t\n \t\t\t// reset vertices one by one. if one reset fails, the \"vertices in final state\"\n \t\t\t// fields will be consistent to handle triggered cancel calls\n", "nb_test": 943, "linesAdd": 12, "jira_id": "3256", "singleLine": false, "nb_skipped": 1, "commit": "44061882", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["KryoGenericTypeSerializerTest.validateReferenceMappingEnabled:166 null"], "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\nindex d5c2f67..e74e251 100644\n--- a/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n+++ b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n@@ -327,9 +327,8 @@ private void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = getKryoInstance();\n \n-\t\t\t// disable reference tracking. reference tracking is costly, usually unnecessary, and\n-\t\t\t// inconsistent with Flink's own serialization (which does not do reference tracking)\n-\t\t\tkryo.setReferences(false);\n+\t\t\t// Enable reference tracking. \n+\t\t\tkryo.setReferences(true);\n \t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n", "nb_test": 1807, "linesAdd": 1, "jira_id": "3762", "singleLine": false, "nb_skipped": 0, "commit": "dc78a747", "nb_failure": 1, "linesRem": 1}, {"files": 3, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["GenericCsvInputFormatTest.readWithParseQuotedStrings:620 Test failed due to a ParseException: Line could not be parsed: '\"ab\\\"c\"|\"def\"'", "ParserError UNQUOTED_CHARS_AFTER_QUOTED_STRING", "Expect field types: class org.apache.flink.types.StringValue, class org.apache.flink.types.StringValue", "in file: file:/some/file/that/will/not/be/read", "QuotedStringParserTest>ParserTestBase.testValidStringInIsolationWithEndDelimiter:141 Parser declared the valid value \"\\\"Hello World\\\"\" as invalid.", "QuotedStringParserTest>ParserTestBase.testInValidStringsMixedIn:287 Parser declared the valid value \"\\\"Hello World\\\"\" as invalid.", "QuotedStringParserTest>ParserTestBase.testConcatenatedMultiCharDelimiter:219 Parser declared the valid value \"\\\"Hello World\\\"\" as invalid.", "QuotedStringParserTest>ParserTestBase.testConcatenated:183 Parser declared the valid value \"\\\"Hello World\\\"\" as invalid.", "QuotedStringParserTest>ParserTestBase.testValidStringInIsolation:96 Parser declared the valid value \"\\\"Hello World\\\"\" as invalid."], "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/api/common/io/GenericCsvInputFormat.java b/flink-core/src/main/java/org/apache/flink/api/common/io/GenericCsvInputFormat.java\nindex b132ca2..8d979bb 100644\n--- a/flink-core/src/main/java/org/apache/flink/api/common/io/GenericCsvInputFormat.java\n+++ b/flink-core/src/main/java/org/apache/flink/api/common/io/GenericCsvInputFormat.java\n@@ -53,6 +53,8 @@\n \t\n \tprivate static final byte[] DEFAULT_FIELD_DELIMITER = new byte[] {','};\n \n+\tprivate static final byte BACKSLASH = 92;\n+\n \t// --------------------------------------------------------------------------------------------\n \t//  Variables for internal operation.\n \t//  They are all transient, because we do not want them so be serialized \n@@ -443,9 +445,10 @@ protected int skipFields(byte[] bytes, int startPos, int limit, byte[] delim) {\n \t\tif(quotedStringParsing == true && bytes[i] == quoteCharacter) {\n \n \t\t\t// quoted string parsing enabled and field is quoted\n-\t\t\t// search for ending quote character\n+\t\t\t// search for ending quote character, continue when it is escaped\n \t\t\ti++;\n-\t\t\twhile(i < limit && bytes[i] != quoteCharacter) {\n+\n+\t\t\twhile (i < limit && (bytes[i] != quoteCharacter || bytes[i-1] == BACKSLASH)){\n \t\t\t\ti++;\n \t\t\t}\n \t\t\ti++;\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/StringParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/StringParser.java\nindex 27e49f5..47e4494 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/StringParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/StringParser.java\n@@ -27,6 +27,7 @@\n \n \tprivate boolean quotedStringParsing = false;\n \tprivate byte quoteCharacter;\n+\tprivate static final byte BACKSLASH = 92;\n \n \tprivate String result;\n \n@@ -46,8 +47,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S\n \t\t\t// quoted string parsing enabled and first character Vis a quote\n \t\t\ti++;\n \n-\t\t\t// search for ending quote character\n-\t\t\twhile(i < limit && bytes[i] != quoteCharacter) {\n+\t\t\t// search for ending quote character, continue when it is escaped\n+\t\t\twhile (i < limit && (bytes[i] != quoteCharacter || bytes[i-1] == BACKSLASH)){\n \t\t\t\ti++;\n \t\t\t}\n \ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/StringValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/StringValueParser.java\nindex 086e3e4..bcb1042 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/StringValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/StringValueParser.java\n@@ -31,6 +31,7 @@\n \n \tprivate boolean quotedStringParsing = false;\n \tprivate byte quoteCharacter;\n+\tprivate static final byte BACKSLASH = 92;\n \n \tprivate StringValue result;\n \n@@ -51,8 +52,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S\n \t\t\t// quoted string parsing enabled and first character is a quote\n \t\t\ti++;\n \n-\t\t\t// search for ending quote character\n-\t\t\twhile(i < limit && bytes[i] != quoteCharacter) {\n+\t\t\t// search for ending quote character, continue when it is escaped\n+\t\t\twhile (i < limit && (bytes[i] != quoteCharacter || bytes[i-1] == BACKSLASH)){\n \t\t\t\ti++;\n \t\t\t}\n \n", "nb_test": 956, "linesAdd": 8, "jira_id": "2567", "singleLine": false, "nb_skipped": 0, "commit": "948b6e05", "nb_failure": 6, "linesRem": 3}, {"files": 2, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["KeysTest.testTupleWithNestedPojo:274 \u00bb IllegalArgument Wrong field type"], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java b/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java\nindex 69d306f..09874e5 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java\n@@ -223,41 +223,41 @@ public ExpressionKeys(int[] groupingFields, TypeInformation<T> type, boolean all\n \t\t\t} else {\n \t\t\t\tgroupingFields = rangeCheckFields(groupingFields, type.getArity() -1);\n \t\t\t}\n-\t\t\tCompositeType<?> compositeType = (CompositeType<?>) type;\n \t\t\tPreconditions.checkArgument(groupingFields.length > 0, \"Grouping fields can not be empty at this point\");\n \t\t\t\n \t\t\tkeyFields = new ArrayList<FlatFieldDescriptor>(type.getTotalFields());\n \t\t\t// for each key, find the field:\n \t\t\tfor(int j = 0; j < groupingFields.length; j++) {\n+\t\t\t\tint keyPos = groupingFields[j];\n+\n+\t\t\t\tint offset = 0;\n \t\t\t\tfor(int i = 0; i < type.getArity(); i++) {\n-\t\t\t\t\tTypeInformation<?> fieldType = compositeType.getTypeAt(i);\n \n-\t\t\t\t\tif(groupingFields[j] == i) { // check if user set the key\n-\t\t\t\t\t\tint keyId = countNestedElementsBefore(compositeType, i) + i;\n-\t\t\t\t\t\tif(fieldType instanceof TupleTypeInfoBase) {\n-\t\t\t\t\t\t\tTupleTypeInfoBase<?> tupleFieldType = (TupleTypeInfoBase<?>) fieldType;\n-\t\t\t\t\t\t\ttupleFieldType.addAllFields(keyId, keyFields);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tPreconditions.checkArgument(fieldType instanceof AtomicType, \"Wrong field type\");\n-\t\t\t\t\t\t\tkeyFields.add(new FlatFieldDescriptor(keyId, fieldType));\n+\t\t\t\t\tTypeInformation fieldType = ((CompositeType<?>) type).getTypeAt(i);\n+\t\t\t\t\tif(i < keyPos) {\n+\t\t\t\t\t\t// not yet there, increment key offset\n+\t\t\t\t\t\toffset += fieldType.getTotalFields();\n \t\t\t\t\t}\n-\t\t\t\t\t\t\n+\t\t\t\t\telse {\n+\t\t\t\t\t\t// arrived at key position\n+\t\t\t\t\t\tif(fieldType instanceof CompositeType) {\n+\t\t\t\t\t\t\t// add all nested fields of composite type\n+\t\t\t\t\t\t\t((CompositeType) fieldType).getFlatFields(\"*\", offset, keyFields);\n \t\t\t\t\t\t}\n+\t\t\t\t\t\telse if(fieldType instanceof AtomicType) {\n+\t\t\t\t\t\t\t// add atomic type field\n+\t\t\t\t\t\t\tkeyFields.add(new FlatFieldDescriptor(offset, fieldType));\n \t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t// type should either be composite or atomic\n+\t\t\t\t\t\t\tthrow new InvalidProgramException(\"Field type is neither CompositeType nor AtomicType: \"+fieldType);\n \t\t\t\t\t\t}\n-\t\t\tkeyFields = removeNullElementsFromList(keyFields);\n+\t\t\t\t\t\t// go to next key\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n-\t\t\n-\t\tprivate static int countNestedElementsBefore(CompositeType<?> compositeType, int pos) {\n-\t\t\tif( pos == 0) {\n-\t\t\t\treturn 0;\n \t\t\t\t}\n-\t\t\tint ret = 0;\n-\t\t\tfor (int i = 0; i < pos; i++) {\n-\t\t\t\tTypeInformation<?> fieldType = compositeType.getTypeAt(i);\n-\t\t\t\tret += fieldType.getTotalFields() -1;\n \t\t\t}\n-\t\t\treturn ret;\n+\t\t\tkeyFields = removeNullElementsFromList(keyFields);\n \t\t}\n \n \t\tpublic static <R> List<R> removeNullElementsFromList(List<R> in) {\ndiff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java\nindex 3314ca9..881e690 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java\n@@ -23,7 +23,6 @@\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-import org.apache.flink.api.common.typeinfo.AtomicType;\n import org.apache.flink.api.common.typeinfo.TypeInformation;\n import org.apache.flink.api.common.typeutils.CompositeType;\n import org.apache.flink.api.java.operators.Keys.ExpressionKeys;\n@@ -88,25 +87,6 @@ public int getTotalFields() {\n \t\treturn tupleType;\n \t}\n \n-\t/**\n-\t * Recursively add all fields in this tuple type. We need this in particular to get all\n-\t * the types.\n-\t * @param startKeyId\n-\t * @param keyFields\n-\t */\n-\tpublic void addAllFields(int startKeyId, List<FlatFieldDescriptor> keyFields) {\n-\t\tfor(int i = 0; i < this.getArity(); i++) {\n-\t\t\tTypeInformation<?> type = this.types[i];\n-\t\t\tif(type instanceof AtomicType) {\n-\t\t\t\tkeyFields.add(new FlatFieldDescriptor(startKeyId, type));\n-\t\t\t} else if(type instanceof TupleTypeInfoBase<?>) {\n-\t\t\t\tTupleTypeInfoBase<?> ttb = (TupleTypeInfoBase<?>) type;\n-\t\t\t\tttb.addAllFields(startKeyId, keyFields);\n-\t\t\t}\n-\t\t\tstartKeyId += type.getTotalFields();\n-\t\t}\n-\t}\n-\n \t@Override\n \tpublic void getFlatFields(String fieldExpression, int offset, List<FlatFieldDescriptor> result) {\n \n", "nb_test": 962, "linesAdd": 15, "jira_id": "2442", "singleLine": false, "nb_skipped": 0, "commit": "30761572", "nb_failure": 0, "linesRem": 35}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["NetworkBufferPoolTest.testDestroyAll:125 Should fail with an IllegalStateException", "LocalBufferPoolTest.destroyAndVerifyAllBuffersReturned:77 Did not return all buffers to memory segment pool after test. expected:<1024> but was:<1023>", "LocalBufferPoolTest.testRequestAfterDestroy:118 Call should have failed with an IllegalStateException", "LocalBufferPoolTest.testDestroyDuringBlockingRequest:323 \u00bb Execution java.lang..."], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java\nindex 1da2b8b..4cb1521 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java\n@@ -141,7 +141,7 @@ private Buffer requestBuffer(boolean isBlocking) throws InterruptedException, IO\n \n \t\t\twhile (availableMemorySegments.isEmpty()) {\n \t\t\t\tif (isDestroyed) {\n-\t\t\t\t\treturn null;\n+\t\t\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n \t\t\t\t}\n \n \t\t\t\tif (numberOfRequestedMemorySegments < currentPoolSize) {\n", "nb_test": 608, "linesAdd": 1, "jira_id": "1930", "singleLine": false, "nb_skipped": 0, "commit": "4dbf030a", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ExecutionGraphRestartTest.testCancelWhileFailing:293 expected:<CANCELLING> but was:<FAILING>", "ExecutionGraphRestartTest.testCancelWhileRestarting:217 expected:<CANCELED> but was:<RESTARTING>", "LeaderChangeStateCleanupTest.testReelectionOfSameJobManager:237 TaskManager should not be able to register at JobManager."], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\nindex aae0b7c..1e5d02c 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n@@ -711,6 +711,26 @@ public void cancel() {\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n+\t\t\t// Executions are being canceled. Go into cancelling and wait for\n+\t\t\t// all vertices to be in their final state.\n+\t\t\telse if (current == JobStatus.FAILING) {\n+\t\t\t\tif (transitionState(current, JobStatus.CANCELLING)) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// All vertices have been cancelled and it's safe to directly go\n+\t\t\t// into the canceled state.\n+\t\t\telse if (current == JobStatus.RESTARTING) {\n+\t\t\t\tsynchronized (progressLock) {\n+\t\t\t\t\tif (transitionState(current, JobStatus.CANCELED)) {\n+\t\t\t\t\t\tpostRunCleanup();\n+\t\t\t\t\t\tprogressLock.notifyAll();\n+\n+\t\t\t\t\t\tLOG.info(\"Canceled during restart.\");\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \t\t\telse {\n \t\t\t\t// no need to treat other states\n \t\t\t\treturn;\n@@ -747,9 +767,16 @@ else if (transitionState(current, JobStatus.FAILING, t)) {\n \tpublic void restart() {\n \t\ttry {\n \t\t\tsynchronized (progressLock) {\n-\t\t\t\tif (state != JobStatus.RESTARTING) {\n+\t\t\t\tJobStatus current = state;\n+\n+\t\t\t\tif (current == JobStatus.CANCELED) {\n+\t\t\t\t\tLOG.info(\"Canceled job during restart. Aborting restart.\");\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\telse if (current != JobStatus.RESTARTING) {\n \t\t\t\t\tthrow new IllegalStateException(\"Can only restart job from state restarting.\");\n \t\t\t\t}\n+\n \t\t\t\tif (scheduler == null) {\n \t\t\t\t\tthrow new IllegalStateException(\"The execution graph has not been scheduled before - scheduler is null.\");\n \t\t\t\t}\n", "nb_test": 894, "linesAdd": 24, "jira_id": "3011", "singleLine": false, "nb_skipped": 1, "commit": "5a86a0a1", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["InstanceConnectionInfoTest.testGetHostname2:192 null"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/instance/InstanceConnectionInfo.java b/flink-runtime/src/main/java/org/apache/flink/runtime/instance/InstanceConnectionInfo.java\nindex a1eec4d..ee79c23 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/instance/InstanceConnectionInfo.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/instance/InstanceConnectionInfo.java\n@@ -31,7 +31,10 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * This class encapsulates all connection information necessary to connect to the instance's task manager.\n+ * This class encapsulates the connection information of a TaskManager.\n+ * It describes the host where the TaskManager operates and its server port\n+ * for data exchange. This class also contains utilities to work with the\n+ * TaskManager's host name, which is used to localize work assignments.\n  */\n public class InstanceConnectionInfo implements IOReadableWritable, Comparable<InstanceConnectionInfo>, java.io.Serializable {\n \n@@ -56,16 +59,10 @@\n \tprivate String fqdnHostName;\n \t\n \t/**\n-\t * The hostname\n+\t * The hostname, derived from the fully qualified host name.\n \t */\n \tprivate String hostName;\n \n-\t/**\n-\t * This flag indicates if the FQDN hostname cound not be resolved and is represented\n-\t * as an IP address (string).\n-\t */\n-\tprivate boolean fqdnHostNameIsIP = false;\n-\n \n \t/**\n \t * Constructs a new instance connection info object. The constructor will attempt to retrieve the instance's\n@@ -90,14 +87,24 @@ public InstanceConnectionInfo(InetAddress inetAddress, int dataPort) {\n \t\t// get FQDN hostname on this TaskManager.\n \t\ttry {\n \t\t\tthis.fqdnHostName = this.inetAddress.getCanonicalHostName();\n-\t\t} catch (Throwable t) {\n-\t\t\tLOG.warn(\"Unable to determine hostname for TaskManager. The performance might be degraded since HDFS input split assignment is not possible\");\n-\t\t\tif(LOG.isDebugEnabled()) {\n-\t\t\t\tLOG.debug(\"getCanonicalHostName() Exception\", t);\n \t\t}\n-\t\t\t// could not determine host name, so take IP textual representation\n-\t\t\tthis.fqdnHostName = inetAddress.getHostAddress();\n-\t\t\tthis.fqdnHostNameIsIP = true;\n+\t\tcatch (Throwable t) {\n+\t\t\tLOG.warn(\"Unable to determine the canonical hostname. Input split assignment (such as \" +\n+\t\t\t\t\t\"for HDFS files) may be non-local when the canonical hostname is missing.\");\n+\t\t\tLOG.debug(\"getCanonicalHostName() Exception:\", t);\n+\t\t\tthis.fqdnHostName = this.inetAddress.getHostAddress();\n+\t\t}\n+\n+\t\tif (this.fqdnHostName.equals(this.inetAddress.getHostAddress())) {\n+\t\t\t// this happens when the name lookup fails, either due to an exception,\n+\t\t\t// or because no hostname can be found for the address\n+\t\t\t// take IP textual representation\n+\t\t\tthis.hostName = this.fqdnHostName;\n+\t\t\tLOG.warn(\"No hostname could be resolved for the IP address {}, using IP address as host name. \"\n+\t\t\t\t\t+ \"Local input split assignment (such as for HDFS files) may be impacted.\");\n+\t\t}\n+\t\telse {\n+\t\t\tthis.hostName = NetUtils.getHostnameFromFQDN(this.fqdnHostName);\n \t\t}\n \t}\n \n@@ -126,27 +133,37 @@ public InetAddress address() {\n \t}\n \n \t/**\n-\t * Returns the host name of the instance. If the host name could not be determined, the return value will be a\n-\t * textual representation of the instance's IP address.\n+\t * Returns the fully-qualified domain name the TaskManager. If the name could not be\n+\t * determined, the return value will be a textual representation of the TaskManager's IP address.\n \t * \n-\t * @return the host name of the instance\n+\t * @return The fully-qualified domain name of the TaskManager.\n \t */\n \tpublic String getFQDNHostname() {\n \t\treturn this.fqdnHostName;\n \t}\n \n+\t/**\n+\t * Gets the hostname of the TaskManager. The hostname derives from the fully qualified\n+\t * domain name (FQDN, see {@link #getFQDNHostname()}):\n+\t * <ul>\n+\t *     <li>If the FQDN is the textual IP address, then the hostname is also the IP address</li>\n+\t *     <li>If the FQDN has only one segment (such as \"localhost\", or \"host17\"), then this is\n+\t *         used as the hostname.</li>\n+\t *     <li>If the FQDN has multiple segments (such as \"worker3.subgroup.company.net\"), then the first\n+\t *         segment (here \"worker3\") will be used as the hostname.</li>\n+\t * </ul>\n+\t *\n+\t * @return The hostname of the TaskManager.\n+\t */\n \tpublic String getHostname() {\n-\t\tif(hostName == null) {\n-\t\t\tString fqdn = getFQDNHostname();\n-\t\t\tif(this.fqdnHostNameIsIP) { // fqdn to hostname translation is pointless if FQDN is an ip address.\n-\t\t\t\thostName = fqdn;\n-\t\t\t} else {\n-\t\t\t\thostName = NetUtils.getHostnameFromFQDN(fqdn);\n-\t\t\t}\n-\t\t}\n \t\treturn hostName;\n \t}\n \n+\t/**\n+\t * Gets the IP address where the TaskManager operates.\n+\t *\n+\t * @return The IP address.\n+\t */\n \tpublic String getInetAdress() {\n \t\treturn this.inetAddress.toString();\n \t}\n@@ -166,7 +183,6 @@ public void read(DataInputView in) throws IOException {\n \t\t\n \t\tthis.fqdnHostName = StringUtils.readNullableString(in);\n \t\tthis.hostName = StringUtils.readNullableString(in);\n-\t\tthis.fqdnHostNameIsIP = in.readBoolean();\n \n \t\ttry {\n \t\t\tthis.inetAddress = InetAddress.getByAddress(address);\n@@ -185,7 +201,6 @@ public void write(final DataOutputView out) throws IOException {\n \t\t\n \t\tStringUtils.writeNullableString(fqdnHostName, out);\n \t\tStringUtils.writeNullableString(hostName, out);\n-\t\tout.writeBoolean(fqdnHostNameIsIP);\n \t}\n \n \t// --------------------------------------------------------------------------------------------\n", "nb_test": 562, "linesAdd": 14, "jira_id": "1705", "singleLine": false, "nb_skipped": 0, "commit": "5308ac83", "nb_failure": 1, "linesRem": 18}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ExecutionGraphRestartTest.run:41->org$scalatest$WordSpecLike$$super$run:41->runTests:41->runTest:41->withFixture:41->fail:41->newAssertionFailedException:41 \u00bb TestFailed"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\nindex 9430d80..aae0b7c 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n@@ -746,12 +746,6 @@ else if (transitionState(current, JobStatus.FAILING, t)) {\n \n \tpublic void restart() {\n \t\ttry {\n-\t\t\tif (state == JobStatus.FAILED) {\n-\t\t\t\tif (!transitionState(JobStatus.FAILED, JobStatus.RESTARTING)) {\n-\t\t\t\t\tthrow new IllegalStateException(\"Execution Graph left the state FAILED while trying to restart.\");\n-\t\t\t\t}\n-\t\t\t}\n-\n \t\t\tsynchronized (progressLock) {\n \t\t\t\tif (state != JobStatus.RESTARTING) {\n \t\t\t\t\tthrow new IllegalStateException(\"Can only restart job from state restarting.\");\n", "nb_test": 892, "linesAdd": 0, "jira_id": "3011", "singleLine": false, "nb_skipped": 1, "commit": "a402002d", "nb_failure": 0, "linesRem": 6}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["SimpleCheckpointStatsTrackerTest.testIllegalOperatorId:88 \u00bb IllegalArgument Un..."], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\nindex 5881f4f..fba3f22 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\n@@ -299,9 +299,9 @@ else if (latestCompletedCheckpoint != null && subTaskStats != null) {\n \t\t\t\tlong[][] subTaskStats = this.subTaskStats.get(operatorId);\n \n \t\t\t\tif (subTaskStats == null) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\"Unknown operator ID.\");\n+\t\t\t\t\treturn Option.empty();\n \t\t\t\t}\n-\n+\t\t\t\telse {\n \t\t\t\t\tlong maxDuration = Long.MIN_VALUE;\n \t\t\t\t\tlong stateSize = 0;\n \n@@ -325,6 +325,7 @@ else if (latestCompletedCheckpoint != null && subTaskStats != null) {\n \n \t\t\t\t\treturn Option.apply(stats);\n \t\t\t\t}\n+\t\t\t}\n \t\t\telse {\n \t\t\t\treturn Option.empty();\n \t\t\t}\n", "nb_test": 940, "linesAdd": 3, "jira_id": "3251", "singleLine": false, "nb_skipped": 1, "commit": "117ba95f", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["UnionReplacementTest.testUnionReplacement:46 The Pact compiler is unable to compile this plan correctly."], "patch": "diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java\nindex bf3d6af..5a0a3e1 100644\n--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java\n+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java\n@@ -1218,42 +1218,19 @@ public void postVisit(PlanNode visitable) {\n \t\t\t\n \t\t\t\tPlanNode newUnionNode;\n \n-\t\t\t\t// if any input is cached, we keep this as a binary union and do not collapse it into a\n-\t\t\t\t// n-ary union\n-//\t\t\t\tif (in1.getTempMode().isCached() || in2.getTempMode().isCached()) {\n-//\t\t\t\t\t// replace this node by an explicit operator\n-//\t\t\t\t\tChannel cached, pipelined;\n-//\t\t\t\t\tif (in1.getTempMode().isCached()) {\n-//\t\t\t\t\t\tcached = in1;\n-//\t\t\t\t\t\tpipelined = in2;\n-//\t\t\t\t\t} else {\n-//\t\t\t\t\t\tcached = in2;\n-//\t\t\t\t\t\tpipelined = in1;\n-//\t\t\t\t\t}\n-//\t\t\t\t\t\n-//\t\t\t\t\tnewUnionNode = new DualInputPlanNode(unionNode.getOriginalOptimizerNode(), cached, pipelined,\n-//\t\t\t\t\t\tDriverStrategy.UNION_WITH_CACHED);\n-//\t\t\t\t\tnewUnionNode.initProperties(unionNode.getGlobalProperties(), new LocalProperties());\n-//\t\t\t\t\t\n-//\t\t\t\t\tin1.setTarget(newUnionNode);\n-//\t\t\t\t\tin2.setTarget(newUnionNode);\n-//\t\t\t\t} else {\n-\t\t\t\t\t// collect the union inputs to collapse this operator with \n-\t\t\t\t\t// its collapsed predecessors. check whether an input is materialized to prevent\n-\t\t\t\t\t// collapsing\n \t\t\t\tList<Channel> inputs = new ArrayList<Channel>();\n \t\t\t\tcollect(in1, inputs);\n \t\t\t\tcollect(in2, inputs);\n \n \t\t\t\tnewUnionNode = new NAryUnionPlanNode(unionNode.getOptimizerNode(), inputs, unionNode.getGlobalProperties());\n \n-\t\t\t\t\t// adjust the input channels to have their target point to the new union node\n \t\t\t\tfor (Channel c : inputs) {\n \t\t\t\t\tc.setTarget(newUnionNode);\n \t\t\t\t}\n-//\t\t\t\t}\n \n-\t\t\t\tunionNode.getOutgoingChannels().get(0).swapUnionNodes(newUnionNode);\n+\t\t\t\tfor(Channel channel : unionNode.getOutgoingChannels()){\n+\t\t\t\t\tchannel.swapUnionNodes(newUnionNode);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n", "nb_test": 64, "linesAdd": 3, "jira_id": "996", "singleLine": false, "nb_skipped": 0, "commit": "32a003d5", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["IterationCompilerTest.testIterationWithUnionRoot:116 null", "IterationCompilerTest.testWorksetIterationWithUnionRoot:170 null"], "patch": "diff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/PactCompiler.java b/flink-compiler/src/main/java/org/apache/flink/compiler/PactCompiler.java\nindex bec264d..a63cfd1 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/PactCompiler.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/PactCompiler.java\n@@ -837,10 +837,7 @@ public void postVisit(Operator<?> c) {\n \t\t\t\t\n \t\t\t\t// go over the contained data flow and mark the dynamic path nodes\n \t\t\t\tStaticDynamicPathIdentifier identifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\n-\t\t\t\trootOfStepFunction.accept(identifier);\n-\t\t\t\tif(terminationCriterion != null){\n-\t\t\t\t\tterminationCriterion.accept(identifier);\n-\t\t\t\t}\n+\t\t\t\titerNode.acceptForStepFunction(identifier);\n \t\t\t}\n \t\t\telse if (n instanceof WorksetIterationNode) {\n \t\t\t\tfinal WorksetIterationNode iterNode = (WorksetIterationNode) n;\n@@ -919,8 +916,7 @@ else if (successor.getClass() == CoGroupNode.class) {\n \t\t\t\t\n \t\t\t\t// go over the contained data flow and mark the dynamic path nodes\n \t\t\t\tStaticDynamicPathIdentifier pathIdentifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\n-\t\t\t\tnextWorksetNode.accept(pathIdentifier);\n-\t\t\t\titerNode.getSolutionSetDelta().accept(pathIdentifier);\n+\t\t\t\titerNode.acceptForStepFunction(pathIdentifier);\n \t\t\t}\n \t\t}\n \t};\n", "nb_test": 173, "linesAdd": 2, "jira_id": "1311", "singleLine": false, "nb_skipped": 0, "commit": "94c8e3fa", "nb_failure": 2, "linesRem": 6}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["StreamingJobGraphGeneratorTest.testExecutionConfigSerialization:81 NullPointer"], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\nindex 6bad4c8..d16ee58 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n@@ -17,6 +17,7 @@\n \n package org.apache.flink.streaming.api.graph;\n \n+import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n@@ -26,6 +27,7 @@\n import java.util.Map.Entry;\n \n import org.apache.commons.lang.StringUtils;\n+import org.apache.flink.api.common.ExecutionConfig;\n import org.apache.flink.configuration.Configuration;\n import org.apache.flink.runtime.jobgraph.AbstractJobVertex;\n import org.apache.flink.runtime.jobgraph.DistributionPattern;\n@@ -43,6 +45,7 @@\n import org.apache.flink.streaming.runtime.partitioner.StreamPartitioner.PartitioningStrategy;\n import org.apache.flink.streaming.runtime.tasks.StreamIterationHead;\n import org.apache.flink.streaming.runtime.tasks.StreamIterationTail;\n+import org.apache.flink.util.InstantiationUtil;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -93,6 +96,12 @@ public JobGraph createJobGraph(String jobName) {\n \t\t\n \t\tconfigureCheckpointing();\n \n+\t\ttry {\n+\t\t\tInstantiationUtil.writeObjectToConfig(this.streamGraph.getExecutionConfig(), this.jobGraph.getJobConfiguration(), ExecutionConfig.CONFIG_KEY);\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(\"Config object could not be written to Job Configuration: \", e);\n+\t\t}\n+\t\t\n \t\treturn jobGraph;\n \t}\n \n", "nb_test": 149, "linesAdd": 9, "jira_id": "1985", "singleLine": false, "nb_skipped": 1, "commit": "495a5c3c", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["TypeInfoParserTest.testBasicTypes:65 \u00bb IllegalArgument String could not be par..."], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java\nindex e9d5dac..98373da 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java\n@@ -40,8 +40,9 @@\n \tprivate static final Pattern writablePattern = Pattern.compile(\"^((\" + WRITABLE_PACKAGE.replaceAll(\"\\\\.\", \"\\\\\\\\.\") + \"\\\\.)?Writable)<([^\\\\s,>]*)(,|>|$)\");\n \tprivate static final Pattern enumPattern = Pattern.compile(\"^((java\\\\.lang\\\\.)?Enum)<([^\\\\s,>]*)(,|>|$)\");\n \tprivate static final Pattern basicTypePattern = Pattern\n-\t\t\t.compile(\"^((java\\\\.lang\\\\.)?(String|Integer|Byte|Short|Character|Double|Float|Long|Boolean))(,|>|$)\");\n-\tprivate static final Pattern basicType2Pattern = Pattern.compile(\"^(int|byte|short|char|double|float|long|boolean)(,|>|$)\");\n+\t\t\t.compile(\"^((java\\\\.lang\\\\.)?(String|Integer|Byte|Short|Character|Double|Float|Long|Boolean|Void))(,|>|$)\");\n+\tprivate static final Pattern basicTypeDatePattern = Pattern.compile(\"^((java\\\\.util\\\\.)?Date)(,|>|$)\");\n+\tprivate static final Pattern basicType2Pattern = Pattern.compile(\"^(int|byte|short|char|double|float|long|boolean|void)(,|>|$)\");\n \tprivate static final Pattern valueTypePattern = Pattern.compile(\"^((\" + VALUE_PACKAGE.replaceAll(\"\\\\.\", \"\\\\\\\\.\")\n \t\t\t+ \"\\\\.)?(String|Int|Byte|Short|Char|Double|Float|Long|Boolean|List|Map|Null))Value(,|>|$)\");\n \tprivate static final Pattern basicArrayTypePattern = Pattern\n@@ -105,6 +106,7 @@\n \t\tfinal Matcher enumMatcher = enumPattern.matcher(infoString);\n \n \t\tfinal Matcher basicTypeMatcher = basicTypePattern.matcher(infoString);\n+\t\tfinal Matcher basicTypeDateMatcher = basicTypeDatePattern.matcher(infoString);\n \t\tfinal Matcher basicType2Matcher = basicType2Pattern.matcher(infoString);\n \n \t\tfinal Matcher valueTypeMatcher = valueTypePattern.matcher(infoString);\n@@ -194,6 +196,19 @@ else if (basicTypeMatcher.find()) {\n \t\t\t}\n \t\t\treturnType = BasicTypeInfo.getInfoFor(clazz);\n \t\t}\n+\t\t// special basic type \"Date\"\n+\t\telse if (basicTypeDateMatcher.find()) {\n+\t\t\tString className = basicTypeDateMatcher.group(1);\n+\t\t\tsb.delete(0, className.length());\n+\t\t\tClass<?> clazz;\n+\t\t\t// check if fully qualified\n+\t\t\tif (className.startsWith(\"java.util\")) {\n+\t\t\t\tclazz = Class.forName(className);\n+\t\t\t} else {\n+\t\t\t\tclazz = Class.forName(\"java.util.\" + className);\n+\t\t\t}\n+\t\t\treturnType = BasicTypeInfo.getInfoFor(clazz);\n+\t\t}\n \t\t// basic type of primitives\n \t\telse if (basicType2Matcher.find()) {\n \t\t\tString className = basicType2Matcher.group(1);\n@@ -216,6 +231,8 @@ else if (basicType2Matcher.find()) {\n \t\t\t\tclazz = Long.class;\n \t\t\t} else if (className.equals(\"boolean\")) {\n \t\t\t\tclazz = Boolean.class;\n+\t\t\t} else if (className.equals(\"void\")) {\n+\t\t\t\tclazz = Void.class;\n \t\t\t}\n \t\t\treturnType = BasicTypeInfo.getInfoFor(clazz);\n \t\t}\n", "nb_test": 638, "linesAdd": 17, "jira_id": "1382", "singleLine": false, "nb_skipped": 0, "commit": "9cd96df7", "nb_failure": 0, "linesRem": 2}, {"files": 2, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["KryoGenericTypeSerializerTest.testForwardEOFExceptionWhileDeserializing:147 throws wrong exception: should throw a java.io.EOFException, has thrown a com.esotericsoftware.kryo.KryoException"], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java\nindex 133dd57..d8411a0 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java\n@@ -195,7 +195,18 @@ public T deserialize(DataInputView source) throws IOException {\n \t\t\tinput = new NoFetchingInput(inputStream);\n \t\t\tpreviousIn = source;\n \t\t}\n+\n+\t\ttry {\n \t\t\treturn (T) kryo.readClassAndObject(input);\n+\t\t} catch (KryoException ke) {\n+\t\t\tThrowable cause = ke.getCause();\n+\n+\t\t\tif(cause instanceof EOFException) {\n+\t\t\t\tthrow (EOFException) cause;\n+\t\t\t} else {\n+\t\t\t\tthrow ke;\n+\t\t\t}\n+\t\t}\n \t}\n \t\n \t@Override\ndiff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/NoFetchingInput.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/NoFetchingInput.java\nindex 524347c..0f4fe94 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/NoFetchingInput.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/NoFetchingInput.java\n@@ -21,6 +21,7 @@\n import com.esotericsoftware.kryo.KryoException;\n import com.esotericsoftware.kryo.io.Input;\n \n+import java.io.EOFException;\n import java.io.IOException;\n import java.io.InputStream;\n \n@@ -73,7 +74,7 @@ protected int require(int required) throws KryoException {\n \t\t\tcount = fill(buffer, bytesRead, required - bytesRead);\n \n \t\t\tif(count == -1){\n-\t\t\t\tthrow new KryoException(\"Buffer underflow\");\n+\t\t\t\tthrow new KryoException(new EOFException(\"No more bytes left.\"));\n \t\t\t}\n \n \t\t\tbytesRead += count;\n@@ -121,7 +122,7 @@ public void readBytes(byte[] bytes, int offset, int count) throws KryoException\n \t\t\t\tc = inputStream.read(bytes, offset+bytesRead, count-bytesRead);\n \n \t\t\t\tif(c == -1){\n-\t\t\t\t\tthrow new KryoException(\"Buffer underflow\");\n+\t\t\t\t\tthrow new KryoException(new EOFException(\"No more bytes left.\"));\n \t\t\t\t}\n \n \t\t\t\tbytesRead += c;\n", "nb_test": 782, "linesAdd": 14, "jira_id": "1531", "singleLine": false, "nb_skipped": 0, "commit": "21f47d9c", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PojoTypeInfoTest.testPrimitivePojo:82 null", "PojoTypeInfoTest.testUnderscorePojo:89 null"], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 1dec90b..0281da6 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -30,6 +30,7 @@\n import java.util.List;\n \n import org.apache.avro.specific.SpecificRecordBase;\n+import org.apache.commons.lang3.ClassUtils;\n import org.apache.flink.api.common.functions.CoGroupFunction;\n import org.apache.flink.api.common.functions.CrossFunction;\n import org.apache.flink.api.common.functions.FlatJoinFunction;\n@@ -1299,22 +1300,26 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\treturn true;\n \t\t} else {\n \t\t\tboolean hasGetter = false, hasSetter = false;\n-\t\t\tfinal String fieldNameLow = f.getName().toLowerCase();\n+\t\t\tfinal String fieldNameLow = f.getName().toLowerCase().replaceAll(\"_\", \"\");\n \n \t\t\tType fieldType = f.getGenericType();\n+\t\t\tClass<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType());\n+\n \t\t\tTypeVariable<?> fieldTypeGeneric = null;\n \t\t\tif(fieldType instanceof TypeVariable) {\n \t\t\t\tfieldTypeGeneric = (TypeVariable<?>) fieldType;\n \t\t\t\tfieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType);\n \t\t\t}\n \t\t\tfor(Method m : clazz.getMethods()) {\n+\t\t\t\tfinal String methodNameLow = m.getName().toLowerCase().replaceAll(\"_\", \"\");\n+\n \t\t\t\t// check for getter\n \t\t\t\tif(\t// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala) or \"is<fieldName>\" for boolean fields.\n-\t\t\t\t\t(m.getName().toLowerCase().equals(\"get\"+fieldNameLow) || m.getName().toLowerCase().equals(\"is\"+fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&\n+\t\t\t\t\t(methodNameLow.equals(\"get\"+fieldNameLow) || methodNameLow.equals(\"is\"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&\n \t\t\t\t\t// no arguments for the getter\n \t\t\t\t\tm.getParameterTypes().length == 0 &&\n \t\t\t\t\t// return type is same as field type (or the generic variant of it)\n-\t\t\t\t\t(m.getGenericReturnType().equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )\n+\t\t\t\t\t(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )\n \t\t\t\t) {\n \t\t\t\t\tif(hasGetter) {\n \t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one getter\");\n@@ -1322,9 +1327,9 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\t\thasGetter = true;\n \t\t\t\t}\n \t\t\t\t// check for setters (<FieldName>_$eq for scala)\n-\t\t\t\tif((m.getName().toLowerCase().equals(\"set\"+fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow+\"_$eq\")) &&\n+\t\t\t\tif((methodNameLow.equals(\"set\"+fieldNameLow) || methodNameLow.equals(fieldNameLow+\"_$eq\")) &&\n \t\t\t\t\tm.getParameterTypes().length == 1 && // one parameter of the field's type\n-\t\t\t\t\t( m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&\n+\t\t\t\t\t(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&\n \t\t\t\t\t// return type is void.\n \t\t\t\t\tm.getReturnType().equals(Void.TYPE)\n \t\t\t\t) {\n", "nb_test": 1062, "linesAdd": 10, "jira_id": "2874", "singleLine": false, "nb_skipped": 0, "commit": "17e7b423", "nb_failure": 2, "linesRem": 5}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["PojoTypeExtractionTest.testGetterSetterWithVertex:561 \u00bb IllegalState Detected ..."], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 7836e74..6a56e46 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -975,10 +974,10 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\t\t// no arguments for the getter\n \t\t\t\t\tm.getParameterTypes().length == 0 &&\n \t\t\t\t\t// return type is same as field type (or the generic variant of it)\n-\t\t\t\t\tm.getReturnType().equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric) )\n+\t\t\t\t\t(m.getReturnType().equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )\n \t\t\t\t) {\n \t\t\t\t\tif(hasGetter) {\n-\t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one getters\");\n+\t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one getter\");\n \t\t\t\t\t}\n \t\t\t\t\thasGetter = true;\n \t\t\t\t}\n@@ -990,7 +989,7 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\t\tm.getReturnType().equals(Void.TYPE)\n \t\t\t\t) {\n \t\t\t\t\tif(hasSetter) {\n-\t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one getters\");\n+\t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one setter\");\n \t\t\t\t\t}\n \t\t\t\t\thasSetter = true;\n \t\t\t\t}\n", "nb_test": 535, "linesAdd": 3, "jira_id": "1145", "singleLine": false, "nb_skipped": 2, "commit": "22c370d9", "nb_failure": 0, "linesRem": 3}, {"files": 2, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java\nindex f50ddcd..80563b8 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java\n@@ -79,7 +79,7 @@\n \n \tprivate final DeserializationDelegate<StreamElement> deserializationDelegate;\n \n-\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+\t@SuppressWarnings(\"unchecked\")\n \tpublic StreamInputProcessor(InputGate[] inputGates, TypeSerializer<IN> inputSerializer,\n \t\t\t\t\t\t\t\tEventListener<CheckpointBarrier> checkpointListener,\n \t\t\t\t\t\t\t\tCheckpointingMode checkpointMode,\n@@ -125,7 +125,6 @@ else if (checkpointMode == CheckpointingMode.AT_LEAST_ONCE) {\n \t\tlastEmittedWatermark = Long.MIN_VALUE;\n \t}\n \n-\t@SuppressWarnings(\"unchecked\")\n \tpublic boolean processInput(OneInputStreamOperator<IN, ?> streamOperator, Object lock) throws Exception {\n \t\tif (isFinished) {\n \t\t\treturn false;\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java\nindex 2ad2d2d..c937e51 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java\n@@ -23,6 +23,7 @@\n import java.util.concurrent.TimeUnit;\n \n import org.apache.flink.api.common.JobID;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.runtime.io.RecordWriterOutput;\n import org.apache.flink.streaming.runtime.io.BlockingQueueBroker;\n import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n@@ -64,6 +64,13 @@ protected void run() throws Exception {\n \t\t\tCollection<RecordWriterOutput<OUT>> outputs = \n \t\t\t\t\t(Collection<RecordWriterOutput<OUT>>) (Collection<?>) outputHandler.getOutputs();\n \n+\t\t\t// If timestamps are enabled we make sure to remove cyclic watermark dependencies\n+\t\t\tif (getExecutionConfig().areTimestampsEnabled()) {\n+\t\t\t\tfor (RecordWriterOutput<OUT> output : outputs) {\n+\t\t\t\t\toutput.emitWatermark(new Watermark(Long.MAX_VALUE));\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\twhile (running) {\n \t\t\t\tStreamRecord<OUT> nextRecord = shouldWait ?\n \t\t\t\t\tdataChannel.poll(iterationWaitTime, TimeUnit.MILLISECONDS) :\n", "nb_test": 25, "linesAdd": 8, "jira_id": "2802", "singleLine": false, "nb_skipped": 0, "commit": "88a97768", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PojoSerializerTest>SerializerTestBase.testSerializeAsSequenceReusingValues:278 Exception in test: null", "PojoSerializerTest>SerializerTestBase.testSerializeIndividuallyReusingValues:214 Exception in test: null", "PojoSerializerTest>SerializerTestBase.testCopyIntoReusedElements:154 Exception in test: null"], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\nindex b81ab67..c61ad8d 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\n@@ -293,7 +293,14 @@ public T copy(T from, T reuse) {\n \t\t\t\tfor (int i = 0; i < numFields; i++) {\n \t\t\t\t\tObject value = fields[i].get(from);\n \t\t\t\t\tif (value != null) {\n-\t\t\t\t\t\tObject copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));\n+\t\t\t\t\t\tObject reuseValue = fields[i].get(reuse);\n+\t\t\t\t\t\tObject copy;\n+\t\t\t\t\t\tif(reuseValue != null) {\n+\t\t\t\t\t\t\tcopy = fieldSerializers[i].copy(value, reuseValue);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\tcopy = fieldSerializers[i].copy(value);\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tfields[i].set(reuse, copy);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n@@ -484,7 +491,15 @@ public T deserialize(T reuse, DataInputView source) throws IOException {\n \t\t\t\t\tif (isNull) {\n \t\t\t\t\t\tfields[i].set(reuse, null);\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tObject field = fieldSerializers[i].deserialize(fields[i].get(reuse), source);\n+\t\t\t\t\t\tObject field;\n+\n+\t\t\t\t\t\tObject reuseField = fields[i].get(reuse);\n+\t\t\t\t\t\tif(reuseField != null) {\n+\t\t\t\t\t\t\tfield = fieldSerializers[i].deserialize(reuseField, source);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\tfield = fieldSerializers[i].deserialize(source);\n+\t\t\t\t\t\t}\n \n \t\t\t\t\t\tfields[i].set(reuse, field);\n \t\t\t\t\t}\n", "nb_test": 856, "linesAdd": 17, "jira_id": "1978", "singleLine": false, "nb_skipped": 0, "commit": "0078c44e", "nb_failure": 3, "linesRem": 2}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["IterateTest.test \u00bb JobExecution Job execution failed."], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/streamvertex/StreamIterationTail.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/streamvertex/StreamIterationTail.java\nindex 7b654be..ab09aff 100755\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/streamvertex/StreamIterationTail.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/streamvertex/StreamIterationTail.java\n@@ -49,7 +49,7 @@ public void setInputsOutputs() {\n \t\t\titerationId = configuration.getIterationId();\n \t\t\titerationWaitTime = configuration.getIterationWaitTime();\n \t\t\tshouldWait = iterationWaitTime > 0;\n-\t\t\tBlockingQueueBroker.instance().get(iterationId.toString()+\"-\"\n+\t\t\tdataChannel = BlockingQueueBroker.instance().get(iterationId.toString()+\"-\"\n \t\t\t\t\t+getEnvironment().getIndexInSubtaskGroup());\n \t\t} catch (Exception e) {\n \t\t\tthrow new StreamVertexException(String.format(\n", "nb_test": 136, "linesAdd": 1, "jira_id": "1686", "singleLine": false, "nb_skipped": 0, "commit": "1f726e48", "nb_failure": 0, "linesRem": 1}, {"files": 2, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["HashTableTest.testSpillingFreesOnlyOverflowSegments:188 Bug in Hybrid Hash Join: Request to spill a partition with less than two buffers."], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\nindex 7baaee7..32fd74a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\n@@ -199,6 +199,19 @@ public final boolean isInMemory() {\n \t\treturn this.buildSideChannel == null;\n \t}\n \n+\t/**\n+\t * Gets the number of memory segments used by this partition, which includes build side\n+\t * memory buffers and overflow memory segments.\n+\t * \n+\t * @return The number of occupied memory segments.\n+\t */\n+\tpublic int getNumOccupiedMemorySegments() {\n+\t\t// either the number of memory segments, or one for spilling\n+\t\tfinal int numPartitionBuffers = this.partitionBuffers != null ? this.partitionBuffers.length : 1;\n+\t\treturn numPartitionBuffers + numOverflowSegments;\n+\t}\n+\t\n+\t\n \tpublic int getBuildSideBlockCount() {\n \t\treturn this.partitionBuffers == null ? this.buildSideWriteBuffer.getBlockCount() : this.partitionBuffers.length;\n \t}\n@@ -284,7 +297,7 @@ public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIO\n \t\t\tthrow new RuntimeException(\"Bug in Hybrid Hash Join: \" +\n \t\t\t\t\t\"Request to spill a partition that has already been spilled.\");\n \t\t}\n-\t\tif (getBuildSideBlockCount() + this.numOverflowSegments < 2) {\n+\t\tif (getNumOccupiedMemorySegments() < 2) {\n \t\t\tthrow new RuntimeException(\"Bug in Hybrid Hash Join: \" +\n \t\t\t\t\"Request to spill a partition with less than two buffers.\");\n \t\t}\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/MutableHashTable.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/MutableHashTable.java\nindex 2ad01aa..efaceea 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/MutableHashTable.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/MutableHashTable.java\n@@ -1093,8 +1093,8 @@ protected int spillPartition() throws IOException {\n \t\t\n \t\tfor (int i = 0; i < partitions.size(); i++) {\n \t\t\tHashPartition<BT, PT> p = partitions.get(i);\n-\t\t\tif (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {\n-\t\t\t\tlargestNumBlocks = p.getBuildSideBlockCount();\n+\t\t\tif (p.isInMemory() && p.getNumOccupiedMemorySegments() > largestNumBlocks) {\n+\t\t\t\tlargestNumBlocks = p.getNumOccupiedMemorySegments();\n \t\t\t\tlargestPartNum = i;\n \t\t\t}\n \t\t}\n", "nb_test": 832, "linesAdd": 9, "jira_id": "2763", "singleLine": false, "nb_skipped": 0, "commit": "af477563", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\nindex d8839a0..9c76d95 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\n@@ -28,6 +28,8 @@\n import org.apache.flink.api.java.functions.KeySelector;\n import org.apache.flink.api.java.operators.Keys;\n import org.apache.flink.api.java.tuple.Tuple;\n+import org.apache.flink.api.java.typeutils.ResultTypeQueryable;\n+import org.apache.flink.api.java.typeutils.TupleTypeInfo;\n \n /**\n  * Utility class that contains helper methods to manipulating {@link KeySelector} for streaming.\n@@ -47,12 +49,14 @@\n \t\t\n \t\t// use ascending order here, the code paths for that are usually a slight bit faster\n \t\tboolean[] orders = new boolean[numKeyFields];\n+\t\tTypeInformation[] typeInfos = new TypeInformation[numKeyFields];\n \t\tfor (int i = 0; i < numKeyFields; i++) {\n \t\t\torders[i] = true;\n+\t\t\ttypeInfos[i] = compositeType.getTypeAt(logicalKeyPositions[i]);\n \t\t}\n \n \t\tTypeComparator<X> comparator = compositeType.createComparator(logicalKeyPositions, orders, 0, executionConfig);\n-\t\treturn new ComparableKeySelector<X>(comparator, numKeyFields);\n+\t\treturn new ComparableKeySelector<>(comparator, numKeyFields, new TupleTypeInfo<>(typeInfos));\n \t}\n \n \t\n@@ -70,7 +74,7 @@\n \n \t\tTypeComparator<X> comparator = ((CompositeType<X>) typeInfo).createComparator(\n \t\t\t\tlogicalKeyPositions, new boolean[1], 0, executionConfig);\n-\t\treturn new OneKeySelector<X, K>(comparator);\n+\t\treturn new OneKeySelector<>(comparator);\n \t}\n \n \t/**\n@@ -111,21 +115,23 @@ public K getKey(IN value) throws Exception {\n \t *\n \t * @param <IN> The type from which the key is extracted.\n \t */\n-\tpublic static final class ComparableKeySelector<IN> implements KeySelector<IN, Tuple> {\n+\tpublic static final class ComparableKeySelector<IN> implements KeySelector<IN, Tuple>, ResultTypeQueryable<Tuple> {\n \n \t\tprivate static final long serialVersionUID = 1L;\n \n \t\tprivate final TypeComparator<IN> comparator;\n \t\tprivate final int keyLength;\n+\t\tprivate final TupleTypeInfo tupleTypeInfo;\n \n \t\t/** Reusable array to hold the key objects. Since this is initially empty (all positions\n \t\t * are null), it does not have any serialization problems */\n \t\t@SuppressWarnings(\"NonSerializableFieldInSerializableClass\")\n \t\tprivate final Object[] keyArray;\n \n-\t\tpublic ComparableKeySelector(TypeComparator<IN> comparator, int keyLength) {\n+\t\tpublic ComparableKeySelector(TypeComparator<IN> comparator, int keyLength, TupleTypeInfo tupleTypeInfo) {\n \t\t\tthis.comparator = comparator;\n \t\t\tthis.keyLength = keyLength;\n+\t\t\tthis.tupleTypeInfo = tupleTypeInfo;\n \t\t\tkeyArray = new Object[keyLength];\n \t\t}\n \n@@ -139,6 +145,10 @@ public Tuple getKey(IN value) throws Exception {\n \t\t\treturn key;\n \t\t}\n \n+\t\t@Override\n+\t\tpublic TypeInformation<Tuple> getProducedType() {\n+\t\t\treturn tupleTypeInfo;\n+\t\t}\n \t}\n \n \t// ------------------------------------------------------------------------\n", "nb_test": 25, "linesAdd": 14, "jira_id": "2812", "singleLine": false, "nb_skipped": 0, "commit": "e494c279", "nb_failure": 0, "linesRem": 4}, {"files": 2, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SlidingTimeGroupedPreReducerTest.testPreReduce1:173 expected:<[[(2,2), (1,1)], [(2,6), (3,3)], [(4,10), (5,5)], [(6,14), (7,7)], [(8,18), (9,9)], [(10,22), (11,11)], [(27,2), (26,1)], [(27,6), (28,3)], [(29,10), (30,5)], [(31,14), (32,7)], [(33,18), (34,9)], [(35,22), (36,11)]]> but was:<[[(2,2), (1,1)], [(2,6), (3,3)], [(4,10), (5,5)], [(6,14), (7,7)], [(8,18), (9,9)], [(10,22), (11,11)], [(27,2), (26,1)], [(27,6), (26,4)], [(29,10), (28,8)], [(31,14), (30,12)], [(33,18), (32,16)], [(35,22), (34,20)]]>", "SlidingTimePreReducerTest.testPreReduce1:142 expected:<[[(1,3)], [(2,9)], [(4,15)], [(6,21)], [(8,27)], [(10,33)], [(26,3)], [(27,9)], [(29,15)], [(31,21)], [(33,27)], [(35,33)]]> but was:<[[(1,3)], [(2,9)], [(4,15)], [(6,21)], [(8,27)], [(10,33)], [(26,3)], [(26,10)], [(28,18)], [(30,26)], [(32,34)], [(34,42)]]>"], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingGroupedPreReducer.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingGroupedPreReducer.java\nindex 0872c6e..09fadf9 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingGroupedPreReducer.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingGroupedPreReducer.java\n@@ -143,6 +143,7 @@ protected void addCurrentToBuffer(T element) throws Exception {\n \t@Override\n \tprotected void resetCurrent() {\n \t\tcurrentReducedMap = null;\n+\t\telementsSinceLastPreAggregate = 0;\n \t}\n \n \t@Override\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingTimePreReducer.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingTimePreReducer.java\nindex 7652d81..d84505c 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingTimePreReducer.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingTimePreReducer.java\n@@ -89,6 +89,7 @@ public void evict(int n) {\n \n \t\tif (toRemove > 0 && lastPreAggregateSize == null) {\n \t\t\tcurrentReduced = null;\n+\t\t\telementsSinceLastPreAggregate = 0;\n \t\t\ttoRemove = 0;\n \t\t}\n \t}\n", "nb_test": 150, "linesAdd": 2, "jira_id": "2074", "singleLine": false, "nb_skipped": 1, "commit": "6bc6dbec", "nb_failure": 2, "linesRem": 0}, {"files": 3, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["FoldWindowFunctionTest.testFoldWindowFunctionOutputTypeConfigurable:120 \u00bb NullPointer"], "patch": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperator.java\nindex 17bd08d..32be2ba 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperator.java\n@@ -20,8 +20,10 @@\n \n import java.io.Serializable;\n \n+import org.apache.flink.api.common.ExecutionConfig;\n import org.apache.flink.api.common.functions.Function;\n import org.apache.flink.api.common.functions.util.FunctionUtils;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n import org.apache.flink.configuration.Configuration;\n import org.apache.flink.runtime.state.StateHandle;\n import org.apache.flink.streaming.api.checkpoint.CheckpointNotifier;\n@@ -44,7 +46,7 @@\n  * @param <F>\n  *            The type of the user function\n  */\n-public abstract class AbstractUdfStreamOperator<OUT, F extends Function> extends AbstractStreamOperator<OUT> {\n+public abstract class AbstractUdfStreamOperator<OUT, F extends Function> extends AbstractStreamOperator<OUT> implements OutputTypeConfigurable<OUT> {\n \n \tprivate static final long serialVersionUID = 1L;\n \t\n@@ -176,6 +178,20 @@ public void notifyOfCompletedCheckpoint(long checkpointId) throws Exception {\n \t}\n \n \t// ------------------------------------------------------------------------\n+\t//  Output type configuration\n+\t// ------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void setOutputType(TypeInformation<OUT> outTypeInfo, ExecutionConfig executionConfig) {\n+\t\tif (userFunction instanceof OutputTypeConfigurable) {\n+\t\t\tOutputTypeConfigurable<OUT> outputTypeConfigurable = (OutputTypeConfigurable<OUT>) userFunction;\n+\n+\t\t\toutputTypeConfigurable.setOutputType(outTypeInfo, executionConfig);\n+\t\t}\n+\t}\n+\n+\n+\t// ------------------------------------------------------------------------\n \t//  Utilities\n \t// ------------------------------------------------------------------------\n \ndiff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/NonKeyedWindowOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/NonKeyedWindowOperator.java\nindex d12a930..cf90cf2 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/NonKeyedWindowOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/NonKeyedWindowOperator.java\n@@ -31,7 +31,6 @@\n import org.apache.flink.streaming.api.operators.AbstractUdfStreamOperator;\n import org.apache.flink.streaming.api.operators.ChainingStrategy;\n import org.apache.flink.streaming.api.operators.OneInputStreamOperator;\n-import org.apache.flink.streaming.api.operators.OutputTypeConfigurable;\n import org.apache.flink.streaming.api.operators.TimestampedCollector;\n import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;\n@@ -70,7 +69,7 @@\n  */\n public class NonKeyedWindowOperator<IN, OUT, W extends Window>\n \t\textends AbstractUdfStreamOperator<OUT, AllWindowFunction<IN, OUT, W>>\n-\t\timplements OneInputStreamOperator<IN, OUT>, Triggerable, InputTypeConfigurable, OutputTypeConfigurable<OUT> {\n+\t\timplements OneInputStreamOperator<IN, OUT>, Triggerable, InputTypeConfigurable {\n \n \tprivate static final long serialVersionUID = 1L;\n \n@@ -510,15 +509,6 @@ public void registerEventTimeTimer(long time) {\n \t\treturn this;\n \t}\n \n-\t@Override\n-\tpublic final void setOutputType(TypeInformation<OUT> outTypeInfo, ExecutionConfig executionConfig) {\n-\t\tif (userFunction instanceof OutputTypeConfigurable) {\n-\t\t\t@SuppressWarnings(\"unchecked\")\n-\t\t\tOutputTypeConfigurable<OUT> typeConfigurable = (OutputTypeConfigurable<OUT>) userFunction;\n-\t\t\ttypeConfigurable.setOutputType(outTypeInfo, executionConfig);\n-\t\t}\n-\t}\n-\n \t// ------------------------------------------------------------------------\n \t//  Checkpointing\n \t// ------------------------------------------------------------------------\ndiff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\nindex c39679f..6764186 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\n@@ -32,7 +32,6 @@\n import org.apache.flink.streaming.api.operators.AbstractUdfStreamOperator;\n import org.apache.flink.streaming.api.operators.ChainingStrategy;\n import org.apache.flink.streaming.api.operators.OneInputStreamOperator;\n-import org.apache.flink.streaming.api.operators.OutputTypeConfigurable;\n import org.apache.flink.streaming.api.operators.TimestampedCollector;\n import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;\n@@ -88,7 +87,7 @@\n  */\n public class WindowOperator<K, IN, OUT, W extends Window>\n \t\textends AbstractUdfStreamOperator<OUT, WindowFunction<IN, OUT, K, W>>\n-\t\timplements OneInputStreamOperator<IN, OUT>, Triggerable, InputTypeConfigurable, OutputTypeConfigurable<OUT> {\n+\t\timplements OneInputStreamOperator<IN, OUT>, Triggerable, InputTypeConfigurable {\n \n \tprivate static final long serialVersionUID = 1L;\n \n@@ -579,15 +578,6 @@ public void registerEventTimeTimer(long time) {\n \t\treturn this;\n \t}\n \n-\t@Override\n-\tpublic final void setOutputType(TypeInformation<OUT> outTypeInfo, ExecutionConfig executionConfig) {\n-\t\tif (userFunction instanceof OutputTypeConfigurable) {\n-\t\t\t@SuppressWarnings(\"unchecked\")\n-\t\t\tOutputTypeConfigurable<OUT> typeConfigurable = (OutputTypeConfigurable<OUT>) userFunction;\n-\t\t\ttypeConfigurable.setOutputType(outTypeInfo, executionConfig);\n-\t\t}\n-\t}\n-\n \t// ------------------------------------------------------------------------\n \t//  Checkpointing\n \t// ------------------------------------------------------------------------\n", "nb_test": 232, "linesAdd": 16, "jira_id": "2968", "singleLine": false, "nb_skipped": 4, "commit": "59685903", "nb_failure": 0, "linesRem": 23}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["TaskTest.testCancelTaskException:617 expected:<CANCELED> but was:<FAILED>"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java\nindex 40198dc..6250837 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java\n@@ -537,7 +537,7 @@ else if (current == ExecutionState.CANCELING) {\n \t\t\t//  actual task core work\n \t\t\t// ----------------------------------------------------------------\n \n-\t\t\t// we must make strictly sure that the invokable is accessible to teh cancel() call\n+\t\t\t// we must make strictly sure that the invokable is accessible to the cancel() call\n \t\t\t// by the time we switched to running.\n \t\t\tthis.invokable = invokable;\n \n@@ -597,24 +597,27 @@ else if (current == ExecutionState.CANCELING) {\n \t\t\t\t// to failExternally()\n \t\t\t\twhile (true) {\n \t\t\t\t\tExecutionState current = this.executionState;\n+\n \t\t\t\t\tif (current == ExecutionState.RUNNING || current == ExecutionState.DEPLOYING) {\n+\t\t\t\t\t\tif (t instanceof CancelTaskException) {\n+\t\t\t\t\t\t\tif (STATE_UPDATER.compareAndSet(this, current, ExecutionState.CANCELED)) {\n+\t\t\t\t\t\t\t\tcancelInvokable();\n+\n+\t\t\t\t\t\t\t\tnotifyObservers(ExecutionState.CANCELED, null);\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n \t\t\t\t\t\t\tif (STATE_UPDATER.compareAndSet(this, current, ExecutionState.FAILED)) {\n \t\t\t\t\t\t\t\t// proper failure of the task. record the exception as the root cause\n \t\t\t\t\t\t\t\tfailureCause = t;\n-\t\t\t\t\t\t\tnotifyObservers(ExecutionState.FAILED, t);\n+\t\t\t\t\t\t\t\tcancelInvokable();\n \n-\t\t\t\t\t\t\t// in case of an exception during execution, we still call \"cancel()\" on the task\n-\t\t\t\t\t\t\tif (invokable != null && this.invokable != null && invokableHasBeenCanceled.compareAndSet(false, true)) {\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tinvokable.cancel();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tcatch (Throwable t2) {\n-\t\t\t\t\t\t\t\t\tLOG.error(\"Error while canceling task \" + taskNameWithSubtask, t2);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tnotifyObservers(ExecutionState.FAILED, t);\n \t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t\telse if (current == ExecutionState.CANCELING) {\n \t\t\t\t\t\tif (STATE_UPDATER.compareAndSet(this, current, ExecutionState.CANCELED)) {\n \t\t\t\t\t\t\tnotifyObservers(ExecutionState.CANCELED, null);\n@@ -746,7 +749,7 @@ public void cancelExecution() {\n \t}\n \n \t/**\n-\t * Marks task execution failed for an external reason (a reason other than th task code itself\n+\t * Marks task execution failed for an external reason (a reason other than the task code itself\n \t * throwing an exception). If the task is already in a terminal state\n \t * (such as FINISHED, CANCELED, FAILED), or if the task is already canceling this does nothing.\n \t * Otherwise it sets the state to FAILED, and, if the invokable code is running,\n@@ -962,6 +965,18 @@ private void executeAsyncCallRunnable(Runnable runnable, String callName) {\n \t//  Utilities\n \t// ------------------------------------------------------------------------\n \n+\tprivate void cancelInvokable() {\n+\t\t// in case of an exception during execution, we still call \"cancel()\" on the task\n+\t\tif (invokable != null && this.invokable != null && invokableHasBeenCanceled.compareAndSet(false, true)) {\n+\t\t\ttry {\n+\t\t\t\tinvokable.cancel();\n+\t\t\t}\n+\t\t\tcatch (Throwable t) {\n+\t\t\t\tLOG.error(\"Error while canceling task \" + taskNameWithSubtask, t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn getTaskNameWithSubtasks() + \" [\" + executionState + ']';\n", "nb_test": 680, "linesAdd": 24, "jira_id": "2109", "singleLine": false, "nb_skipped": 0, "commit": "d594d024", "nb_failure": 1, "linesRem": 9}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/FileMonitoringFunction.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/FileMonitoringFunction.java\nindex 2c85650..a217923 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/FileMonitoringFunction.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/FileMonitoringFunction.java\n@@ -17,13 +17,6 @@\n \n package org.apache.flink.streaming.api.functions.source;\n \n-import java.io.IOException;\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n import org.apache.flink.api.java.tuple.Tuple3;\n import org.apache.flink.core.fs.FileStatus;\n import org.apache.flink.core.fs.FileSystem;\n@@ -31,6 +24,13 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n public class FileMonitoringFunction implements SourceFunction<Tuple3<String, Long, Long>> {\n \tprivate static final long serialVersionUID = 1L;\n \n@@ -95,6 +95,9 @@ public void run(SourceContext<Tuple3<String, Long, Long>> ctx) throws Exception\n \n \t\tFileStatus[] statuses = fileSystem.listStatus(new Path(path));\n \n+\t\tif (statuses == null) {\n+\t\t\tLOG.warn(\"Path does not exist: {}\", path);\n+\t\t} else {\n \t\t\tfor (FileStatus status : statuses) {\n \t\t\t\tPath filePath = status.getPath();\n \t\t\t\tString fileName = filePath.getName();\n@@ -105,6 +108,8 @@ public void run(SourceContext<Tuple3<String, Long, Long>> ctx) throws Exception\n \t\t\t\t\tmodificationTimes.put(fileName, modificationTime);\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n+\n \t\treturn files;\n \t}\n \n", "nb_test": 25, "linesAdd": 12, "jira_id": "2817", "singleLine": false, "nb_skipped": 0, "commit": "5dfc897b", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ExecutionGraphRestartTest.testFailingExecutionAfterRestart:475 expected:<FINISHED> but was:<FAILED>"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\nindex eb2e68c..db037bb 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n@@ -435,7 +435,7 @@ else if (current == FINISHED || current == FAILED) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\telse if (current == CREATED || current == SCHEDULED) {\n-\t\t\t\t// from here, we can directly switch to cancelled, because the no task has been deployed\n+\t\t\t\t// from here, we can directly switch to cancelled, because no task has been deployed\n \t\t\t\tif (transitionState(current, CANCELED)) {\n \t\t\t\t\t\n \t\t\t\t\t// we skip the canceling state. set the timestamp, for a consistent appearance\n@@ -754,11 +754,10 @@ private boolean processFail(Throwable t, boolean isCallback) {\n \t\t\t\treturn false;\n \t\t\t}\n \n-\t\t\tif (current == CANCELED) {\n-\t\t\t\t// we are already aborting or are already aborted\n+\t\t\tif (current == CANCELED || current == FINISHED) {\n+\t\t\t\t// we are already aborting or are already aborted or we are already finished\n \t\t\t\tif (LOG.isDebugEnabled()) {\n-\t\t\t\t\tLOG.debug(String.format(\"Ignoring transition of vertex %s to %s while being %s\", \n-\t\t\t\t\t\t\tgetVertexWithAttempt(), FAILED, CANCELED));\n+\t\t\t\t\tLOG.debug(\"Ignoring transition of vertex {} to {} while being {}.\", getVertexWithAttempt(), FAILED, current);\n \t\t\t\t}\n \t\t\t\treturn false;\n \t\t\t}\n@@ -928,6 +927,11 @@ private boolean transitionState(ExecutionState currentState, ExecutionState targ\n \t}\n \n \tprivate boolean transitionState(ExecutionState currentState, ExecutionState targetState, Throwable error) {\n+\t\t// sanity check\n+\t\tif (currentState.isTerminal()) {\n+\t\t\tthrow new IllegalStateException(\"Cannot leave terminal state \" + currentState + \" to transition to \" + targetState + \".\");\n+\t\t}\n+\n \t\tif (STATE_UPDATER.compareAndSet(this, currentState, targetState)) {\n \t\t\tmarkTimestamp(targetState);\n \n", "nb_test": 962, "linesAdd": 6, "jira_id": "3260", "singleLine": false, "nb_skipped": 1, "commit": "6968a57a", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamingRuntimeContext.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamingRuntimeContext.java\nindex 2ca2862..b82888e 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamingRuntimeContext.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamingRuntimeContext.java\n@@ -104,8 +104,8 @@ public Configuration getTaskStubParameters() {\n \t\t\tthrow new RuntimeException(\"Cannot set default state to null.\");\n \t\t}\n \t\tStreamOperatorState<S, C> state = (StreamOperatorState<S, C>) getState(name, partitioned);\n-\t\tstate.setDefaultState(defaultState);\n \t\tstate.setCheckpointer(checkpointer);\n+\t\tstate.setDefaultState(defaultState);\n \n \t\treturn (OperatorState<S>) state;\n \t}\n", "nb_test": 25, "linesAdd": 1, "jira_id": "2707", "singleLine": false, "nb_skipped": 0, "commit": "3e233a38", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PojoSerializerTest>SerializerTestBase.testCopy:113 Exception in test: null", "PojoSerializerTest>SerializerTestBase.testSerializedCopyIndividually:311 Exception in test: null", "PojoSerializerTest>SerializerTestBase.testCopyIntoNewElements:132 Exception in test: null", "PojoSerializerTest>SerializerTestBase.testCopyIntoReusedElements:154 Exception in test: null", "PojoSerializerTest>SerializerTestBase.testSerializedCopyAsSequence:349 Exception in test: null"], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\nindex 99b9f65..1e58b9d 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\n@@ -142,9 +142,15 @@ public T copy(T from) {\n \t\t\n \t\ttry {\n \t\t\tfor (int i = 0; i < numFields; i++) {\n-\t\t\t\tObject copy = fieldSerializers[i].copy(fields[i].get(from));\n+\t\t\t\tObject value = fields[i].get(from);\n+\t\t\t\tif (value != null) {\n+\t\t\t\t\tObject copy = fieldSerializers[i].copy(value);\n \t\t\t\t\tfields[i].set(target, copy);\n \t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tfields[i].set(target, null);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tcatch (IllegalAccessException e) {\n \t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\");\n@@ -156,9 +162,15 @@ public T copy(T from) {\n \tpublic T copy(T from, T reuse) {\n \t\ttry {\n \t\t\tfor (int i = 0; i < numFields; i++) {\n+\t\t\t\tObject value = fields[i].get(from);\n+\t\t\t\tif (value != null) {\n \t\t\t\t\tObject copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));\n \t\t\t\t\tfields[i].set(reuse, copy);\n \t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tfields[i].set(reuse, null);\n+\t\t\t\t}\n+\t\t\t}\n \t\t} catch (IllegalAccessException e) {\n \t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" +\n \t\t\t\t\t\"before.\");\n@@ -257,10 +269,13 @@ public void copy(DataInputView source, DataOutputView target) throws IOException\n \t\t// copy the Non-Null/Null tag\n \t\ttarget.writeBoolean(source.readBoolean());\n \t\tfor (int i = 0; i < numFields; i++) {\n-\t\t\ttarget.writeBoolean(source.readBoolean());\n+\t\t\tboolean isNull = source.readBoolean();\n+\t\t\ttarget.writeBoolean(isNull);\n+\t\t\tif (!isNull) {\n \t\t\t\tfieldSerializers[i].copy(source, target);\n \t\t\t}\n \t\t}\n+\t}\n \t\n \t@Override\n \tpublic int hashCode() {\n", "nb_test": 738, "linesAdd": 17, "jira_id": "1437", "singleLine": false, "nb_skipped": 0, "commit": "fb7ce0e3", "nb_failure": 5, "linesRem": 2}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["SavepointCoordinatorTest.testSimpleRollbackSavepoint:218 null"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java\nindex 6ce6502..ea4b8ae 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java\n@@ -230,6 +230,7 @@ public ApplicationID restoreSavepoint(\n \n \t\t\t// Reset the checkpoint ID counter\n \t\t\tlong nextCheckpointId = checkpoint.getCheckpointID();\n+\t\t\tcheckpointIdCounter.start();\n \t\t\tcheckpointIdCounter.setCount(nextCheckpointId + 1);\n \t\t\tLOG.info(\"Reset the checkpoint ID to {}\", nextCheckpointId);\n \n", "nb_test": 964, "linesAdd": 1, "jira_id": "3107", "singleLine": true, "nb_skipped": 1, "commit": "937963e3", "nb_failure": 1, "rtElixir": true, "linesRem": 0}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["PartitionRequestClientHandlerTest.testReceiveEmptyBuffer:103 \u00bb NullPointer"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientHandler.java\nindex fef21ce..12ed140 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientHandler.java\n@@ -133,9 +133,12 @@ private void notifyAllChannelsOfErrorAndClose(Throwable cause) {\n \t\t\t}\n \n \t\t\tinputChannels.clear();\n+\n+\t\t\tif (ctx != null) {\n \t\t\t\tctx.close();\n \t\t\t}\n \t\t}\n+\t}\n \n \t// ------------------------------------------------------------------------\n \n@@ -187,6 +190,13 @@ private boolean decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessag\n \t\ttry {\n \t\t\tif (bufferOrEvent.isBuffer()) {\n \t\t\t\t// ---- Buffer ------------------------------------------------\n+\n+\t\t\t\t// Early return for empty buffers. Otherwise Netty's readBytes() throws an\n+\t\t\t\t// IndexOutOfBoundsException.\n+\t\t\t\tif (bufferOrEvent.getSize() == 0) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\n \t\t\t\tBufferProvider bufferProvider = inputChannel.getBufferProvider();\n \n \t\t\t\tif (bufferProvider == null) {\n", "nb_test": 586, "linesAdd": 8, "jira_id": "1761", "singleLine": false, "nb_skipped": 0, "commit": "380ef878", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PartitionPushdownTest.testPartitioningNotPushedDown:59 expected:<PARTITION_HASH> but was:<FORWARD>"], "patch": "diff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/SingleInputNode.java b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/SingleInputNode.java\nindex b3d639b..730c1bb 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/SingleInputNode.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/SingleInputNode.java\n@@ -220,8 +220,21 @@ public void computeInterestingPropertiesForInputs(CostEstimator estimator) {\n \t\t// add all properties relevant to this node\n \t\tfor (OperatorDescriptorSingle dps : getPossibleProperties()) {\n \t\t\tfor (RequestedGlobalProperties gp : dps.getPossibleGlobalProperties()) {\n+\t\t\t\t\n+\t\t\t\tif (gp.getPartitioning().isPartitionedOnKey()) {\n+\t\t\t\t\t// make sure that among the same partitioning types, we do not push anything down that has fewer key fields\n+\t\t\t\t\t\n+\t\t\t\t\tfor (RequestedGlobalProperties contained : props.getGlobalProperties()) {\n+\t\t\t\t\t\tif (contained.getPartitioning() == gp.getPartitioning() && gp.getPartitionedFields().isValidSubset(contained.getPartitionedFields())) {\n+\t\t\t\t\t\t\tprops.getGlobalProperties().remove(contained);\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t\n \t\t\t\tprops.addGlobalProperties(gp);\n \t\t\t}\n+\t\t\t\n \t\t\tfor (RequestedLocalProperties lp : dps.getPossibleLocalProperties()) {\n \t\t\t\tprops.addLocalProperties(lp);\n \t\t\t}\n", "nb_test": 96, "linesAdd": 12, "jira_id": "1214", "singleLine": false, "nb_skipped": 0, "commit": "6ecd0f82", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SimpleCheckpointStatsTrackerTest.testCompletedCheckpointReordering:98->verifyJobStats:176 expected:<CheckpointStats{checkpointId=1, triggerTimestamp=1468530066917, duration=66, stateSize=-4982714695508294559}> but was:<CheckpointStats{checkpointId=1, triggerTimestamp=1468530066917, duration=66, stateSize=1293681761}>", "SimpleCheckpointStatsTrackerTest.testRandomStats:70->verifyJobStats:176 expected:<CheckpointStats{checkpointId=0, triggerTimestamp=1468530063180, duration=21, stateSize=-7081107918679045612}> but was:<CheckpointStats{checkpointId=0, triggerTimestamp=1468530063180, duration=21, stateSize=-2098329068}>"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\nindex fba3f22..5ee4fc3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\n@@ -136,7 +136,7 @@ public void onCompletedCheckpoint(CompletedCheckpoint checkpoint) {\n \t\t}\n \n \t\tsynchronized (statsLock) {\n-\t\t\tint overallStateSize = 0;\n+\t\t\tlong overallStateSize = 0;\n \n \t\t\t// Operator stats\n \t\t\tMap<JobVertexID, long[][]> statsForSubTasks = new HashMap<>();\n", "nb_test": 954, "linesAdd": 1, "jira_id": "3342", "singleLine": false, "nb_skipped": 1, "commit": "8e3e2f8f", "nb_failure": 2, "linesRem": 1}, {"files": 2, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CEPPatternOperator.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CEPPatternOperator.java\nindex 153c9c9..7760817 100644\n--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CEPPatternOperator.java\n+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CEPPatternOperator.java\n@@ -87,6 +87,8 @@ public void processWatermark(Watermark mark) throws Exception {\n \n \t\t\tprocessEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\n \t\t}\n+\n+\t\toutput.emitWatermark(mark);\n \t}\n \n \t@Override\ndiff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/KeyedCEPPatternOperator.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/KeyedCEPPatternOperator.java\nindex 5d754ce..5db8ef2 100644\n--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/KeyedCEPPatternOperator.java\n+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/KeyedCEPPatternOperator.java\n@@ -163,6 +163,8 @@ public void processWatermark(Watermark mark) throws Exception {\n \t\t\t\tprocessEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\n \t\t\t}\n \t\t}\n+\n+\t\toutput.emitWatermark(mark);\n \t}\n \n \t@Override\n", "nb_test": 10, "linesAdd": 4, "jira_id": "3684", "singleLine": false, "nb_skipped": 0, "commit": "e3759a5e", "nb_failure": 0, "linesRem": 0}, {"files": 3, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["IterationCompilerTest.testIterationWithUnionRoot:106 An error occurred while translating the optimized plan to a nephele JobGraph: Error translating node 'Union \"Union\" : UNION [[ GlobalProperties [partitioning=RANDOM] ]] [[ LocalProperties [ordering=null, grouped=null, unique=null] ]]': null", "IterationCompilerTest.testWorksetIterationWithUnionRoot:141 An error occurred while translating the optimized plan to a nephele JobGraph: Error translating node 'Union \"Union\" : UNION [[ GlobalProperties [partitioning=RANDOM] ]] [[ LocalProperties [ordering=null, grouped=null, unique=null] ]]': null"], "patch": "diff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java\nindex a5f8026..d3f0fbb 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java\n@@ -132,7 +132,7 @@ public void setNextPartialSolution(OptimizerNode nextPartialSolution, OptimizerN\n \t\t// check if the root of the step function has the same DOP as the iteration\n \t\t// or if the steo function has any operator at all\n \t\tif (nextPartialSolution.getDegreeOfParallelism() != getDegreeOfParallelism() ||\n-\t\t\tnextPartialSolution == partialSolution)\n+\t\t\tnextPartialSolution == partialSolution || nextPartialSolution instanceof BinaryUnionNode)\n \t\t{\n \t\t\t// add a no-op to the root to express the re-partitioning\n \t\t\tNoOpNode noop = new NoOpNode();\ndiff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java\nindex 7638cca..b6ae34e 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java\n@@ -160,7 +160,7 @@ public void setNextPartialSolution(OptimizerNode solutionSetDelta, OptimizerNode\n \t\t\n \t\t// there needs to be at least one node in the workset path, so\n \t\t// if the next workset is equal to the workset, we need to inject a no-op node\n-\t\tif (nextWorkset == worksetNode) {\n+\t\tif (nextWorkset == worksetNode || nextWorkset instanceof BinaryUnionNode) {\n \t\t\tNoOpNode noop = new NoOpNode();\n \t\t\tnoop.setDegreeOfParallelism(getDegreeOfParallelism());\n \ndiff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java b/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java\nindex 00e2bc2..60500b8 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java\n@@ -26,7 +25,6 @@\n import java.io.StringWriter;\n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n@@ -47,7 +45,6 @@\n import org.apache.flink.compiler.dataproperties.LocalProperties;\n import org.apache.flink.compiler.plan.BulkIterationPlanNode;\n import org.apache.flink.compiler.plan.Channel;\n-import org.apache.flink.compiler.plan.NAryUnionPlanNode;\n import org.apache.flink.compiler.plan.OptimizedPlan;\n import org.apache.flink.compiler.plan.PlanNode;\n import org.apache.flink.compiler.plan.SingleInputPlanNode;\n@@ -265,31 +262,16 @@ private boolean visit(DumpableNode<?> node, PrintWriter writer, boolean first) {\n \t\tif (inConns != null && inConns.hasNext()) {\n \t\t\t// start predecessor list\n \t\t\twriter.print(\",\\n\\t\\t\\\"predecessors\\\": [\");\n-\t\t\tint connNum = 0;\n \t\t\tint inputNum = 0;\n \t\t\t\n \t\t\twhile (inConns.hasNext()) {\n-\t\t\t\tfinal DumpableConnection<?> conn = inConns.next();\n-\t\t\t\t\n-\t\t\t\tfinal Collection<DumpableConnection<?>> inConnsForInput;\n-\t\t\t\tif (conn.getSource() instanceof NAryUnionPlanNode) {\n-\t\t\t\t\tinConnsForInput = new ArrayList<DumpableConnection<?>>();\n-\t\t\t\t\t\n-\t\t\t\t\tfor (DumpableConnection<?> inputOfUnion : conn.getSource().getDumpableInputs()) {\n-\t\t\t\t\t\tinConnsForInput.add(inputOfUnion);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tinConnsForInput = Collections.<DumpableConnection<?>>singleton(conn);\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tfor (DumpableConnection<?> inConn : inConnsForInput) {\n+\t\t\t\tfinal DumpableConnection<?> inConn = inConns.next();\n \t\t\t\tfinal DumpableNode<?> source = inConn.getSource();\n-\t\t\t\t\twriter.print(connNum == 0 ? \"\\n\" : \",\\n\");\n-\t\t\t\t\tif (connNum == 0) {\n+\t\t\t\twriter.print(inputNum == 0 ? \"\\n\" : \",\\n\");\n+\t\t\t\tif (inputNum == 0) {\n \t\t\t\t\tchild1name += child1name.length() > 0 ? \", \" : \"\"; \n \t\t\t\t\tchild1name += source.getOptimizerNode().getPactContract().getName();\n-\t\t\t\t\t} else if (connNum == 1) {\n+\t\t\t\t} else if (inputNum == 1) {\n \t\t\t\t\tchild2name += child2name.length() > 0 ? \", \" : \"\"; \n \t\t\t\t\tchild2name = source.getOptimizerNode().getPactContract().getName();\n \t\t\t\t}\n@@ -331,7 +313,7 @@ private boolean visit(DumpableNode<?> node, PrintWriter writer, boolean first) {\n \t\t\t\t\t\tshipStrategy = \"Rebalance\";\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tthrow new CompilerException(\"Unknown ship strategy '\" + conn.getShipStrategy().name()\n+\t\t\t\t\t\tthrow new CompilerException(\"Unknown ship strategy '\" + inConn.getShipStrategy().name()\n \t\t\t\t\t\t\t+ \"' in JSON generator.\");\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -378,8 +360,6 @@ private boolean visit(DumpableNode<?> node, PrintWriter writer, boolean first) {\n \t\t\t\t}\n \t\t\t\t\n \t\t\t\twriter.print('}');\n-\t\t\t\t\tconnNum++;\n-\t\t\t\t}\n \t\t\t\tinputNum++;\n \t\t\t}\n \t\t\t// finish predecessors\n", "nb_test": 93, "linesAdd": 7, "jira_id": "1167", "singleLine": false, "nb_skipped": 0, "commit": "259f10c0", "nb_failure": 2, "linesRem": 26}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["BufferReaderTest.testBackwardsEventWithUninitializedChannel:189", "taskEventDispatcher.publish(", "<any>,", "<any>,", "<any>", ");", "Wanted 2 times:", "-> at org.apache.flink.runtime.io.network.api.reader.BufferReaderTest.testBackwardsEventWithUninitializedChannel(BufferReaderTest.java:189)", "But was 1 time:", "-> at org.apache.flink.runtime.io.network.partition.consumer.LocalInputChannel.sendTaskEvent(LocalInputChannel.java:96)"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/BufferReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/BufferReader.java\nindex 91784f6..fca27fa 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/BufferReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/BufferReader.java\n@@ -49,6 +49,8 @@\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingQueue;\n@@ -91,6 +93,10 @@\n \n \tprivate final AtomicReference<EventListener<BufferReaderBase>> readerListener = new AtomicReference<EventListener<BufferReaderBase>>(null);\n \n+\tprivate final List<TaskEvent> pendingEvents = new ArrayList<TaskEvent>();\n+\n+\tprivate int numberOfUninitializedChannels;\n+\n \t// ------------------------------------------------------------------------\n \n \tprivate boolean isIterativeReader;\n@@ -149,17 +155,13 @@ public ConnectionManager getConnectionManager() {\n \t\treturn networkEnvironment.getConnectionManager();\n \t}\n \n-\t// TODO This is a work-around for the union reader\n-\tboolean hasInputChannelWithData() {\n-\t\treturn !inputChannelsWithData.isEmpty();\n-\t}\n-\n \t/**\n \t * Returns the total number of input channels for this reader.\n \t * <p>\n \t * Note: This number might be smaller the current number of input channels\n \t * of the reader as channels are possibly updated during runtime.\n \t */\n+\t@Override\n \tpublic int getNumberOfInputChannels() {\n \t\treturn totalNumberOfInputChannels;\n \t}\n@@ -170,7 +172,11 @@ public BufferProvider getBufferProvider() {\n \n \tpublic void setInputChannel(IntermediateResultPartitionID partitionId, InputChannel inputChannel) {\n \t\tsynchronized (requestLock) {\n-\t\t\tinputChannels.put(checkNotNull(partitionId), checkNotNull(inputChannel));\n+\t\t\tif (inputChannels.put(checkNotNull(partitionId), checkNotNull(inputChannel)) == null &&\n+\t\t\t\t\tinputChannel.getClass() == UnknownInputChannel.class) {\n+\n+\t\t\t\tnumberOfUninitializedChannels++;\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -202,7 +208,16 @@ else if (partitionInfo.getProducerLocation() == PartitionLocation.LOCAL) {\n \n \t\t\t\tinputChannels.put(partitionId, newChannel);\n \n+\n \t\t\t\tnewChannel.requestIntermediateResultPartition(queueToRequest);\n+\n+\t\t\t\tfor (TaskEvent event : pendingEvents) {\n+\t\t\t\t\tnewChannel.sendTaskEvent(event);\n+\t\t\t\t}\n+\n+\t\t\t\tif (--numberOfUninitializedChannels == 0) {\n+\t\t\t\t\tpendingEvents.clear();\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -387,6 +402,10 @@ public void sendTaskEvent(TaskEvent event) throws IOException, InterruptedExcept\n \t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n \t\t\t\tinputChannel.sendTaskEvent(event);\n \t\t\t}\n+\n+\t\t\tif (numberOfUninitializedChannels > 0) {\n+\t\t\t\tpendingEvents.add(event);\n+\t\t\t}\n \t\t}\n \t}\n \n", "nb_test": 535, "linesAdd": 25, "jira_id": "1496", "singleLine": false, "nb_skipped": 0, "commit": "0a4c7694", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["HashTableTest.testSpillingWhenBuildingTableWithoutOverflow:234 \u00bb Runtime Bug i..."], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\nindex 32fd74a..97bef4a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\n@@ -207,7 +207,8 @@ public final boolean isInMemory() {\n \t */\n \tpublic int getNumOccupiedMemorySegments() {\n \t\t// either the number of memory segments, or one for spilling\n-\t\tfinal int numPartitionBuffers = this.partitionBuffers != null ? this.partitionBuffers.length : 1;\n+\t\tfinal int numPartitionBuffers = this.partitionBuffers != null ?\n+\t\t\tthis.partitionBuffers.length : this.buildSideWriteBuffer.getNumOccupiedMemorySegments();\n \t\treturn numPartitionBuffers + numOverflowSegments;\n \t}\n \t\n@@ -542,6 +543,11 @@ int getBlockCount() {\n \t\t\treturn this.currentBlockNumber + 1;\n \t\t}\n \n+\t\tint getNumOccupiedMemorySegments() {\n+\t\t\t// return the current segment + all filled segments\n+\t\t\treturn this.targetList.size() + 1;\n+\t\t}\n+\t\t\n \t\tint spill(BlockChannelWriter<MemorySegment> writer) throws IOException {\n \t\t\tthis.writer = writer;\n \t\t\tfinal int numSegments = this.targetList.size();\n", "nb_test": 892, "linesAdd": 6, "jira_id": "2964", "singleLine": false, "nb_skipped": 1, "commit": "76bebd42", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["EnumerateNestedFilesTest.testGetStatisticsMultipleNestedFiles:366 The file size from the statistics is wrong. expected:<34067> but was:<40369>"], "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/api/common/io/FileInputFormat.java b/flink-core/src/main/java/org/apache/flink/api/common/io/FileInputFormat.java\nindex 37739f5..a8f334b 100644\n--- a/flink-core/src/main/java/org/apache/flink/api/common/io/FileInputFormat.java\n+++ b/flink-core/src/main/java/org/apache/flink/api/common/io/FileInputFormat.java\n@@ -330,7 +330,7 @@ protected FileBaseStatistics getFileStats(FileBaseStatistics cachedStats, Path f\n \n \t\t// enumerate all files\n \t\tif (file.isDir()) {\n-\t\t\ttotalLength += addFilesInDir(file.getPath(), files, totalLength, false);\n+\t\t\ttotalLength += addFilesInDir(file.getPath(), files, false);\n \t\t} else {\n \t\t\tfiles.add(file);\n \t\t\ttestForUnsplittable(file);\n@@ -390,7 +390,7 @@ public LocatableInputSplitAssigner getInputSplitAssigner(FileInputSplit[] splits\n \t\tfinal FileStatus pathFile = fs.getFileStatus(path);\n \n \t\tif (pathFile.isDir()) {\n-\t\t\ttotalLength += addFilesInDir(path, files, totalLength, true);\n+\t\t\ttotalLength += addFilesInDir(path, files, true);\n \t\t} else {\n \t\t\ttestForUnsplittable(pathFile);\n \n@@ -497,14 +497,16 @@ public LocatableInputSplitAssigner getInputSplitAssigner(FileInputSplit[] splits\n \t * Enumerate all files in the directory and recursive if enumerateNestedFiles is true.\n \t * @return the total length of accepted files.\n \t */\n-\tprivate long addFilesInDir(Path path, List<FileStatus> files, long length, boolean logExcludedFiles)\n+\tprivate long addFilesInDir(Path path, List<FileStatus> files, boolean logExcludedFiles)\n \t\t\tthrows IOException {\n \t\tfinal FileSystem fs = path.getFileSystem();\n \n+\t\tlong length = 0;\n+\n \t\tfor(FileStatus dir: fs.listStatus(path)) {\n \t\t\tif (dir.isDir()) {\n \t\t\t\tif (acceptFile(dir) && enumerateNestedFiles) {\n-\t\t\t\t\tlength += addFilesInDir(dir.getPath(), files, length, logExcludedFiles);\n+\t\t\t\t\tlength += addFilesInDir(dir.getPath(), files, logExcludedFiles);\n \t\t\t\t} else {\n \t\t\t\t\tif (logExcludedFiles && LOG.isDebugEnabled()) {\n \t\t\t\t\t\tLOG.debug(\"Directory \"+dir.getPath().toString()+\" did not pass the file-filter and is excluded.\");\n", "nb_test": 860, "linesAdd": 6, "jira_id": "2121", "singleLine": false, "nb_skipped": 0, "commit": "03340919", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["TypeExtractorTest.testPojo:354 null"], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 1ae8d3d..2e45107 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -18,6 +18,7 @@\n \n package org.apache.flink.api.java.typeutils;\n \n+import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.Method;\n@@ -1298,10 +1299,10 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\treturn true;\n \t\t\t} else {\n \t\t\t\tif(!hasGetter) {\n-\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a getter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(clazz+\" does not contain a getter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\tif(!hasSetter) {\n-\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a setter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(clazz+\" does not contain a setter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\treturn false;\n \t\t\t}\n@@ -1323,7 +1324,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\t\n \t\tList<Field> fields = getAllDeclaredFields(clazz);\n \t\tif(fields.size() == 0) {\n-\t\t\tLOG.info(\"No fields detected for class \" + clazz + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n+\t\t\tLOG.info(\"No fields detected for \" + clazz + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n \t\t}\n \n@@ -1331,7 +1332,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\tfor (Field field : fields) {\n \t\t\tType fieldType = field.getGenericType();\n \t\t\tif(!isValidPojoField(field, clazz, typeHierarchy)) {\n-\t\t\t\tLOG.info(\"Class \" + clazz + \" is not a valid POJO type\");\n+\t\t\t\tLOG.info(clazz + \" is not a valid POJO type\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\ttry {\n@@ -1357,24 +1358,29 @@ else if(typeHierarchy.size() <= 1) {\n \t\tList<Method> methods = getAllDeclaredMethods(clazz);\n \t\tfor (Method method : methods) {\n \t\t\tif (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n-\t\t\t\tLOG.info(\"Class \"+clazz+\" contains custom serialization methods we do not call.\");\n+\t\t\t\tLOG.info(clazz+\" contains custom serialization methods we do not call.\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t}\n \n \t\t// Try retrieving the default constructor, if it does not have one\n \t\t// we cannot use this because the serializer uses it.\n+\t\tConstructor defaultConstructor = null;\n \t\ttry {\n-\t\t\tclazz.getDeclaredConstructor();\n+\t\t\tdefaultConstructor = clazz.getDeclaredConstructor();\n \t\t} catch (NoSuchMethodException e) {\n \t\t\tif (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {\n-\t\t\t\tLOG.info(\"Class \" + clazz + \" is abstract or an interface, having a concrete \" +\n+\t\t\t\tLOG.info(clazz + \" is abstract or an interface, having a concrete \" +\n \t\t\t\t\t\t\"type can increase performance.\");\n \t\t\t} else {\n-\t\t\t\tLOG.info(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\n+\t\t\t\tLOG.info(clazz + \" must have a default constructor to be used as a POJO.\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t}\n+\t\tif(defaultConstructor != null && !Modifier.isPublic(defaultConstructor.getModifiers())) {\n+\t\t\tLOG.info(\"The default constructor of \" + clazz + \" should be Public to be used as a POJO.\");\n+\t\t\treturn null;\n+\t\t}\n \t\t\n \t\t// everything is checked, we return the pojo\n \t\treturn pojoType;\n@@ -1394,7 +1400,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\t\t\t\tcontinue; // we have no use for transient or static fields\n \t\t\t\t}\n \t\t\t\tif(hasFieldWithSameName(field.getName(), result)) {\n-\t\t\t\t\tthrow new RuntimeException(\"The field \"+field+\" is already contained in the hierarchy of the class \"+clazz+\".\"\n+\t\t\t\t\tthrow new RuntimeException(\"The field \"+field+\" is already contained in the hierarchy of the \"+clazz+\".\"\n \t\t\t\t\t\t\t+ \"Please use unique field names through your classes hierarchy\");\n \t\t\t\t}\n \t\t\t\tresult.add(field);\n", "nb_test": 966, "linesAdd": 15, "jira_id": "2437", "singleLine": false, "nb_skipped": 0, "commit": "a41bc8cc", "nb_failure": 1, "linesRem": 9}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PathTest.testDepth:159 expected:<3> but was:<4>", "PathTest.testPathFromString:35 expected:</my/path[]> but was:</my/path[/]>", "PathTest.testGetParent:127 expected:</my/other/fancy[]> but was:</my/other/fancy[/path]>", "PathTest.testSuffix:148 expected:</my/path/[]abc> but was:</my/path/[path/]abc>", "FileOutputFormatTest.testCreateNonParallelLocalFS:114 null", "FileOutputFormatTest.testCreateParallelLocalFS:346 null", "FileOutputFormatTest.testOverwriteParallelLocalFS:646 null", "FileOutputFormatTest.testOverwriteNonParallelLocalFS:428 null"], "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/core/fs/Path.java b/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\nindex a104d86..30a2a65 100644\n--- a/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\n+++ b/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\n@@ -37,6 +37,8 @@\n /**\n  * Names a file or directory in a {@link FileSystem}. Path strings use slash as\n  * the directory separator. A path string is absolute if it begins with a slash.\n+ *\n+ * Tailing slashes are removed from the path.\n  */\n public class Path implements IOReadableWritable, Serializable {\n \t\n@@ -71,7 +73,7 @@ public Path() {}\n \t * Constructs a path object from a given URI.\n \t * \n \t * @param uri\n-\t *        the URI to contruct the path object from\n+\t *        the URI to construct the path object from\n \t */\n \tpublic Path(URI uri) {\n \t\tthis.uri = uri;\n@@ -145,18 +147,22 @@ public Path(Path parent, Path child) {\n \t/**\n  \t * Checks if the provided path string is either null or has zero length and throws\n \t * a {@link IllegalArgumentException} if any of the two conditions apply.\n+\t * In addition, leading and tailing whitespaces are removed.\n \t *\n \t * @param path\n \t *        the path string to be checked\n+\t * @return The checked and trimmed path.\n \t */\n-\tprivate void checkPathArg(String path) {\n+\tprivate String checkAndTrimPathArg(String path) {\n \t\t// disallow construction of a Path from an empty string\n \t\tif (path == null) {\n \t\t\tthrow new IllegalArgumentException(\"Can not create a Path from a null string\");\n \t\t}\n+\t\tpath = path.trim();\n \t\tif (path.length() == 0) {\n \t\t\tthrow new IllegalArgumentException(\"Can not create a Path from an empty string\");\n \t\t}\n+\t\treturn path;\n \t}\n \n \t/**\n@@ -167,7 +173,7 @@ private void checkPathArg(String path) {\n \t *        the string to construct a path from\n \t */\n \tpublic Path(String pathString) {\n-\t\tcheckPathArg(pathString);\n+\t\tpathString = checkAndTrimPathArg(pathString);\n \n \t\t// We can't use 'new URI(String)' directly, since it assumes things are\n \t\t// escaped, which we don't require of Paths.\n@@ -217,7 +223,7 @@ public Path(String pathString) {\n \t *        the path string\n \t */\n \tpublic Path(String scheme, String authority, String path) {\n-\t\tcheckPathArg(path);\n+\t\tpath = checkAndTrimPathArg(path);\n \t\tinitialize(scheme, authority, path);\n \t}\n \n@@ -247,9 +253,18 @@ private void initialize(String scheme, String authority, String path) {\n \t * @return the normalized path string\n \t */\n \tprivate String normalizePath(String path) {\n-\t\t// remove double slashes & backslashes\n-\t\tpath = path.replace(\"//\", \"/\");\n+\n+\t\t// remove leading and tailing whitespaces\n+\t\tpath = path.trim();\n+\n+\t\t// remove consecutive slashes & backslashes\n \t\tpath = path.replace(\"\\\\\", \"/\");\n+\t\tpath = path.replaceAll(\"/+\", \"/\");\n+\n+\t\t// remove tailing separator\n+\t\tif(!path.equals(SEPARATOR) && path.endsWith(SEPARATOR)) {\n+\t\t\tpath = path.substring(0, path.length() - SEPARATOR.length());\n+\t\t}\n \n \t\treturn path;\n \t}\n@@ -306,23 +321,19 @@ public boolean isAbsolute() {\n \t}\n \n \t/**\n-\t * Returns the final component of this path.\n+\t * Returns the final component of this path, i.e., everything that follows the last separator.\n \t * \n \t * @return the final component of the path\n \t */\n \tpublic String getName() {\n \t\tfinal String path = uri.getPath();\n-\t\tif (path.endsWith(SEPARATOR)) {\n-\t\t\tfinal int slash = path.lastIndexOf(SEPARATOR, path.length() - SEPARATOR.length() - 1);\n-\t\t\treturn path.substring(slash + 1, path.length() - SEPARATOR.length());\n-\t\t} else {\n \t\tfinal int slash = path.lastIndexOf(SEPARATOR);\n \t\treturn path.substring(slash + 1);\n \t}\n-\t}\n \n \t/**\n-\t * Returns the parent of a path or <code>null</code> if at root.\n+\t * Returns the parent of a path, i.e., everything that precedes the last separator\n+\t * or <code>null</code> if at root.\n \t * \n \t * @return the parent of a path or <code>null</code> if at root.\n \t */\n", "nb_test": 819, "linesAdd": 13, "jira_id": "1640", "singleLine": false, "nb_skipped": 0, "commit": "8f321c72", "nb_failure": 8, "linesRem": 9}, {"files": 1, "project": "flink", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["TypeExtractorTest.testGenericTypeWithSubclassInput:1927 \u00bb InvalidTypes Input m...", "TypeExtractorTest.testInputWithCustomTypeInfo:2016 \u00bb InvalidTypes Input mismat..."], "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 01afe14..dd4b132 100644\n--- a/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -890,8 +890,8 @@ private static void validateInfo(ArrayList<Type> typeHierarchy, Type type, TypeI\n \t\t}\n \t\t\n \t\tif (!(type instanceof TypeVariable<?>)) {\n-\t\t\t// check for basic type\n-\t\t\tif (typeInfo.isBasicType()) {\n+\t\t\t// check for Java Basic Types\n+\t\t\tif (typeInfo instanceof BasicTypeInfo) {\n \t\t\t\t\n \t\t\t\tTypeInformation<?> actual;\n \t\t\t\t// check if basic type at all\n@@ -904,8 +904,8 @@ private static void validateInfo(ArrayList<Type> typeHierarchy, Type type, TypeI\n \t\t\t\t}\n \t\t\t\t\n \t\t\t}\n-\t\t\t// check for tuple\n-\t\t\telse if (typeInfo.isTupleType()) {\n+\t\t\t// check for Java Tuples\n+\t\t\telse if (typeInfo instanceof TupleTypeInfo) {\n \t\t\t\t// check if tuple at all\n \t\t\t\tif (!(isClassType(type) && Tuple.class.isAssignableFrom(typeToClass(type)))) {\n \t\t\t\t\tthrow new InvalidTypesException(\"Tuple type expected.\");\n@@ -1079,9 +1079,9 @@ else if (typeInfo instanceof EnumTypeInfo) {\n \t\t\t// check for generic object\n \t\t\telse if (typeInfo instanceof GenericTypeInfo<?>) {\n \t\t\t\tClass<?> clazz = null;\n-\t\t\t\tif (!(isClassType(type) && ((GenericTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {\n-\t\t\t\t\tthrow new InvalidTypesException(\"Generic object type '\"\n-\t\t\t\t\t\t\t+ ((GenericTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\"\n+\t\t\t\tif (!(isClassType(type) && (clazz = typeToClass(type)).isAssignableFrom(((GenericTypeInfo<?>) typeInfo).getTypeClass()))) {\n+\t\t\t\t\tthrow new InvalidTypesException(\"Generic type '\"\n+\t\t\t\t\t\t\t+ ((GenericTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' or a subclass of it expected but was '\"\n \t\t\t\t\t\t\t+ clazz.getCanonicalName() + \"'.\");\n \t\t\t\t}\n \t\t\t}\n", "nb_test": 1774, "linesAdd": 5, "jira_id": "3566", "singleLine": false, "nb_skipped": 0, "commit": "434e88fd", "nb_failure": 0, "linesRem": 5}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["TypeExtractorTest.testAbstractAndInterfaceTypesException:1094 null"], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 99292a6..124055c 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -893,6 +893,10 @@ private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, C\n \t\twhile (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {\n \t\t\ttypeHierarchy.add(curT);\n \t\t\tcurT = typeToClass(curT).getGenericSuperclass();\n+\n+\t\t\tif (curT == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\treturn curT;\n \t}\n@@ -1090,11 +1094,6 @@ private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeV\n \t\t\tParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n \t\tValidate.notNull(clazz);\n \t\t\n-\t\t// check for abstract classes or interfaces\n-\t\tif (!clazz.isPrimitive() && (Modifier.isInterface(clazz.getModifiers()) || (Modifier.isAbstract(clazz.getModifiers()) && !clazz.isArray()))) {\n-\t\t\tthrow new InvalidTypesException(\"Interfaces and abstract classes are not valid types: \" + clazz);\n-\t\t}\n-\n \t\tif (clazz.equals(Object.class)) {\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n \t\t}\n@@ -1153,6 +1152,11 @@ private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeV\n \n \t\talreadySeen.add(clazz);\n \n+\t\tif (Modifier.isInterface(clazz.getModifiers())) {\n+\t\t\t// Interface has no members and is therefore not handled as POJO\n+\t\t\treturn new GenericTypeInfo<OUT>(clazz);\n+\t\t}\n+\n \t\tif (clazz.equals(Class.class)) {\n \t\t\t// special case handling for Class, this should not be handled by the POJO logic\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n@@ -1228,10 +1232,10 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\treturn true;\n \t\t\t} else {\n \t\t\t\tif(!hasGetter) {\n-\t\t\t\t\tLOG.warn(\"Class \"+clazz+\" does not contain a getter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a getter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\tif(!hasSetter) {\n-\t\t\t\t\tLOG.warn(\"Class \"+clazz+\" does not contain a setter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a setter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\treturn false;\n \t\t\t}\n@@ -1251,11 +1255,16 @@ else if(typeHierarchy.size() <= 1) {\n \t\t}\n \t\t\n \t\tList<Field> fields = getAllDeclaredFields(clazz);\n+\t\tif(fields.size() == 0) {\n+\t\t\tLOG.info(\"No fields detected for class \" + clazz + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n+\t\t\treturn new GenericTypeInfo<OUT>(clazz);\n+\t\t}\n+\n \t\tList<PojoField> pojoFields = new ArrayList<PojoField>();\n \t\tfor (Field field : fields) {\n \t\t\tType fieldType = field.getGenericType();\n \t\t\tif(!isValidPojoField(field, clazz, typeHierarchy)) {\n-\t\t\t\tLOG.warn(\"Class \"+clazz+\" is not a valid POJO type\");\n+\t\t\t\tLOG.info(\"Class \" + clazz + \" is not a valid POJO type\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\ttry {\n@@ -1281,7 +1290,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\tList<Method> methods = getAllDeclaredMethods(clazz);\n \t\tfor (Method method : methods) {\n \t\t\tif (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n-\t\t\t\tLOG.warn(\"Class \"+clazz+\" contains custom serialization methods we do not call.\");\n+\t\t\t\tLOG.info(\"Class \"+clazz+\" contains custom serialization methods we do not call.\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t}\n@@ -1291,9 +1300,14 @@ else if(typeHierarchy.size() <= 1) {\n \t\ttry {\n \t\t\tclazz.getDeclaredConstructor();\n \t\t} catch (NoSuchMethodException e) {\n-\t\t\tLOG.warn(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\n+\t\t\tif (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {\n+\t\t\t\tLOG.info(\"Class \" + clazz + \" is abstract or an interface, having a concrete \" +\n+\t\t\t\t\t\t\"type can increase performance.\");\n+\t\t\t} else {\n+\t\t\t\tLOG.info(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\n \t\t\t\treturn null;\n \t\t\t}\n+\t\t}\n \t\t\n \t\t// everything is checked, we return the pojo\n \t\treturn pojoType;\n", "nb_test": 744, "linesAdd": 23, "jira_id": "1458", "singleLine": false, "nb_skipped": 0, "commit": "91f9bfc7", "nb_failure": 1, "linesRem": 9}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["TypeExtractorTest.testInputMismatchWithRawFuntion:1758 \u00bb IllegalArgument The t..."], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 124055c..c99a80f 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -680,10 +680,20 @@ private static void validateInputType(Type t, TypeInformation<?> inType) {\n \t\t}\n \t}\n \t\n-\tprivate static void validateInputType(Class<?> baseClass, Class<?> clazz, int inputParamPos, TypeInformation<?> inType) {\n+\tprivate static void validateInputType(Class<?> baseClass, Class<?> clazz, int inputParamPos, TypeInformation<?> inTypeInfo) {\n \t\tArrayList<Type> typeHierarchy = new ArrayList<Type>();\n+\n+\t\t// try to get generic parameter\n+\t\tType inType;\n+\t\ttry {\n+\t\t\tinType = getParameterType(baseClass, typeHierarchy, clazz, inputParamPos);\n+\t\t}\n+\t\tcatch (IllegalArgumentException e) {\n+\t\t\treturn; // skip input validation e.g. for raw types\n+\t\t}\n+\n \t\ttry {\n-\t\t\tvalidateInfo(typeHierarchy, getParameterType(baseClass, typeHierarchy, clazz, inputParamPos), inType);\n+\t\t\tvalidateInfo(typeHierarchy, inType, inTypeInfo);\n \t\t}\n \t\tcatch(InvalidTypesException e) {\n \t\t\tthrow new InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n", "nb_test": 745, "linesAdd": 11, "jira_id": "1471", "singleLine": false, "nb_skipped": 0, "commit": "d033fa8f", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["org.apache.flink.runtime.operators.sort.FixedLengthRecordSorterTest.testFlushPartialMemoryPage(org.apache.flink.runtime.operators.sort.FixedLengthRecordSorterTest)", "Run 1: FixedLengthRecordSorterTest.testFlushPartialMemoryPage:455 \u00bb EOF", "Run 2: FixedLengthRecordSorterTest.afterTest:78 Memory Leak: Some memory has not been returned to the memory manager."], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/sort/FixedLengthRecordSorter.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/sort/FixedLengthRecordSorter.java\nindex da96b17..3a44ab5 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/sort/FixedLengthRecordSorter.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/sort/FixedLengthRecordSorter.java\n@@ -447,11 +447,13 @@ public void writeToOutput(final ChannelWriterOutputView output, final int start,\n \t\t\t\tnum -= recordsPerSegment;\n \t\t\t} else {\n \t\t\t\t// partially filled segment\n-\t\t\t\tfor (; num > 0; num--) {\n+\t\t\t\tfor (; num > 0 && offset <= this.lastEntryOffset; num--, offset += this.recordSize) {\n \t\t\t\t\trecord = comparator.readWithKeyDenormalization(record, inView);\n \t\t\t\t\tserializer.serialize(record, output);\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\toffset = 0;\n \t\t}\n \t}\n \t\n", "nb_test": 831, "linesAdd": 3, "jira_id": "2754", "singleLine": false, "nb_skipped": 0, "commit": "68912126", "nb_failure": 0, "linesRem": 1}, {"files": 3, "project": "flink", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["WindowOperatorTest.testSessionWindowsWithCountTrigger:578 Output was not correct.: arrays first differed at element [1]; expected:<Record @ 9999 : (key1-22,10,10000)> but was:<Record @ 9999 : (key1-19,2500,10000)>", "WindowOperatorTest.testPointSessions:668 \u00bb IllegalState Window TimeWindow{star...", "WindowOperatorTest.testReduceSessionWindows:489 \u00bb IllegalState Window TimeWind...", "WindowOperatorTest.testSessionWindows:414 \u00bb IllegalState Window TimeWindow{sta..."], "patch": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java\nindex 1e4e453..84ee0b9 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java\n@@ -82,15 +82,11 @@ public void processElement(StreamRecord<IN> element) throws Exception {\n \t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(),\n \t\t\t\telement.getTimestamp());\n \n-\t\tK key = (K) getStateBackend().getCurrentKey();\n+\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n-\t\t\tif (mergingWindows == null) {\n-\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n-\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n-\t\t\t}\n \n+\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n \n \t\t\tfor (W window : elementWindows) {\n \t\t\t\t// If there is a merge, it can only result in a window that contains our new\n@@ -107,6 +103,7 @@ public void processElement(StreamRecord<IN> element) throws Exception {\n \t\t\t\t\t\t\tpublic void merge(W mergeResult,\n \t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n \t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n+\t\t\t\t\t\t\t\tcontext.key = key;\n \t\t\t\t\t\t\t\tcontext.window = mergeResult;\n \n \t\t\t\t\t\t\t\t// store for later use\n@@ -141,7 +138,7 @@ public void merge(W mergeResult,\n \t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult,\n \t\t\t\t\t\tmergeTriggerResult.f0);\n \n-\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n+\t\t\t\tprocessTriggerResult(combinedTriggerResult, actualWindow);\n \t\t\t}\n \n \t\t} else {\n@@ -157,14 +154,14 @@ public void merge(W mergeResult,\n \t\t\t\tcontext.window = window;\n \t\t\t\tTriggerResult triggerResult = context.onElement(element);\n \n-\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n+\t\t\t\tprocessTriggerResult(triggerResult, window);\n \t\t\t}\n \t\t}\n \t}\n \n \t@Override\n \t@SuppressWarnings(\"unchecked,rawtypes\")\n-\tprotected void processTriggerResult(TriggerResult triggerResult, K key, W window) throws Exception {\n+\tprotected void processTriggerResult(TriggerResult triggerResult, W window) throws Exception {\n \t\tif (!triggerResult.isFire() && !triggerResult.isPurge()) {\n \t\t\t// do nothing\n \t\t\treturn;\n@@ -175,7 +172,7 @@ protected void processTriggerResult(TriggerResult triggerResult, K key, W window\n \t\tMergingWindowSet<W> mergingWindows = null;\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tmergingWindows = mergingWindowsByKey.get(key);\n+\t\t\tmergingWindows = getMergingWindowSet();\n \t\t\tW stateWindow = mergingWindows.getStateWindow(window);\n \t\t\twindowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n \ndiff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java\nindex 7ef1af4..49a2017 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java\n@@ -17,6 +17,8 @@\n  */\n package org.apache.flink.streaming.runtime.operators.windowing;\n \n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.java.tuple.Tuple2;\n import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;\n import org.apache.flink.streaming.api.windowing.windows.Window;\n import org.slf4j.Logger;\n@@ -73,6 +75,24 @@ public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner) {\n \t}\n \n \t/**\n+\t * Restores a {@link MergingWindowSet} from the given state.\n+\t */\n+\tpublic MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {\n+\t\tthis.windowAssigner = windowAssigner;\n+\t\twindows = new HashMap<>();\n+\n+\t\tfor (Tuple2<W, W> window: state.get()) {\n+\t\t\twindows.put(window.f0, window.f1);\n+\t\t}\n+\t}\n+\n+\tpublic void persist(ListState<Tuple2<W, W>> state) throws Exception {\n+\t\tfor (Map.Entry<W, W> window: windows.entrySet()) {\n+\t\t\tstate.add(new Tuple2<>(window.getKey(), window.getValue()));\n+\t\t}\n+\t}\n+\n+\t/**\n \t * Returns the state window for the given in-flight {@code Window}. The state window is the\n \t * {@code Window} in which we keep the actual state of a given in-flight window. Windows\n \t * might expand but we keep to original state window for keeping the elements of the window\ndiff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\nindex c106e70..919cee7 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\n@@ -22,6 +22,8 @@\n import org.apache.flink.annotation.Internal;\n import org.apache.flink.api.common.ExecutionConfig;\n import org.apache.flink.api.common.state.AppendingState;\n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n import org.apache.flink.api.common.state.MergingState;\n import org.apache.flink.api.common.state.State;\n import org.apache.flink.api.common.state.StateDescriptor;\n@@ -29,10 +31,13 @@\n import org.apache.flink.api.common.state.ValueStateDescriptor;\n import org.apache.flink.api.common.typeinfo.TypeInformation;\n import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.api.common.typeutils.base.VoidSerializer;\n import org.apache.flink.api.java.functions.KeySelector;\n import org.apache.flink.api.java.tuple.Tuple1;\n+import org.apache.flink.api.java.tuple.Tuple2;\n import org.apache.flink.api.java.typeutils.InputTypeConfigurable;\n import org.apache.flink.api.java.typeutils.TypeExtractor;\n+import org.apache.flink.api.java.typeutils.runtime.TupleSerializer;\n import org.apache.flink.core.memory.DataInputView;\n import org.apache.flink.runtime.state.AbstractStateBackend;\n import org.apache.flink.runtime.state.StateHandle;\n@@ -224,6 +229,25 @@ public final void open() throws Exception {\n \t@Override\n \tpublic final void close() throws Exception {\n \t\tsuper.close();\n+\t\ttimestampedCollector = null;\n+\t\twatermarkTimers = null;\n+\t\twatermarkTimersQueue = null;\n+\t\tprocessingTimeTimers = null;\n+\t\tprocessingTimeTimersQueue = null;\n+\t\tcontext = null;\n+\t\tmergingWindowsByKey = null;\n+\t}\n+\n+\t@Override\n+\tpublic void dispose() {\n+\t\tsuper.dispose();\n+\t\ttimestampedCollector = null;\n+\t\twatermarkTimers = null;\n+\t\twatermarkTimersQueue = null;\n+\t\tprocessingTimeTimers = null;\n+\t\tprocessingTimeTimersQueue = null;\n+\t\tcontext = null;\n+\t\tmergingWindowsByKey = null;\n \t}\n \n \t@Override\n@@ -231,15 +255,10 @@ public final void close() throws Exception {\n \tpublic void processElement(StreamRecord<IN> element) throws Exception {\n \t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n \n-\t\tK key = (K) getStateBackend().getCurrentKey();\n+\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n-\t\t\tif (mergingWindows == null) {\n-\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n-\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n-\t\t\t}\n-\n+\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n \n \t\t\tfor (W window: elementWindows) {\n \t\t\t\t// If there is a merge, it can only result in a window that contains our new\n@@ -255,6 +274,7 @@ public void processElement(StreamRecord<IN> element) throws Exception {\n \t\t\t\t\tpublic void merge(W mergeResult,\n \t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n \t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n+\t\t\t\t\t\tcontext.key = key;\n \t\t\t\t\t\tcontext.window = mergeResult;\n \n \t\t\t\t\t\t// store for later use\n@@ -286,7 +306,7 @@ public void merge(W mergeResult,\n \n \t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n \n-\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n+\t\t\t\tprocessTriggerResult(combinedTriggerResult, actualWindow);\n \t\t\t}\n \n \t\t} else {\n@@ -301,13 +321,40 @@ public void merge(W mergeResult,\n \t\t\t\tcontext.window = window;\n \t\t\t\tTriggerResult triggerResult = context.onElement(element);\n \n-\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n+\t\t\t\tprocessTriggerResult(triggerResult, window);\n \t\t\t}\n \t\t}\n \t}\n \n+\t/**\n+\t * Retrieves the {@link MergingWindowSet} for the currently active key. The caller must\n+\t * ensure that the correct key is set in the state backend.\n+\t */\n \t@SuppressWarnings(\"unchecked\")\n-\tprotected void processTriggerResult(TriggerResult triggerResult, K key, W window) throws Exception {\n+\tprotected MergingWindowSet<W> getMergingWindowSet() throws Exception {\n+\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get((K) getStateBackend().getCurrentKey());\n+\t\tif (mergingWindows == null) {\n+\t\t\t// try to retrieve from state\n+\n+\t\t\tTupleSerializer<Tuple2<W, W>> tupleSerializer = new TupleSerializer<>((Class) Tuple2.class, new TypeSerializer[] {windowSerializer, windowSerializer} );\n+\t\t\tListStateDescriptor<Tuple2<W, W>> mergeStateDescriptor = new ListStateDescriptor<>(\"merging-window-set\", tupleSerializer);\n+\t\t\tListState<Tuple2<W, W>> mergeState = getStateBackend().getPartitionedState(null, VoidSerializer.INSTANCE, mergeStateDescriptor);\n+\n+\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner, mergeState);\n+\t\t\tmergeState.clear();\n+\n+\t\t\tmergingWindowsByKey.put((K) getStateBackend().getCurrentKey(), mergingWindows);\n+\t\t}\n+\t\treturn mergingWindows;\n+\t}\n+\n+\n+\t/**\n+\t * Process {@link TriggerResult} for the currently active key and the given window. The caller\n+\t * must ensure that the correct key is set in the state backend and the context object.\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void processTriggerResult(TriggerResult triggerResult, W window) throws Exception {\n \t\tif (!triggerResult.isFire() && !triggerResult.isPurge()) {\n \t\t\t// do nothing\n \t\t\treturn;\n@@ -318,7 +365,7 @@ protected void processTriggerResult(TriggerResult triggerResult, K key, W window\n \t\tMergingWindowSet<W> mergingWindows = null;\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tmergingWindows = mergingWindowsByKey.get(key);\n+\t\t\tmergingWindows = getMergingWindowSet();\n \t\t\tW stateWindow = mergingWindows.getStateWindow(window);\n \t\t\twindowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n \n@@ -366,7 +413,7 @@ private void processTriggersFor(Watermark mark) throws Exception {\n \t\t\t\tcontext.window = timer.window;\n \t\t\t\tsetKeyContext(timer.key);\n \t\t\t\tTriggerResult triggerResult = context.onEventTime(timer.timestamp);\n-\t\t\t\tprocessTriggerResult(triggerResult, context.key, context.window);\n+\t\t\t\tprocessTriggerResult(triggerResult, context.window);\n \t\t\t} else {\n \t\t\t\tfire = false;\n \t\t\t}\n@@ -389,7 +436,7 @@ public final void trigger(long time) throws Exception {\n \t\t\t\tcontext.window = timer.window;\n \t\t\t\tsetKeyContext(timer.key);\n \t\t\t\tTriggerResult triggerResult = context.onProcessingTime(timer.timestamp);\n-\t\t\t\tprocessTriggerResult(triggerResult, context.key, context.window);\n+\t\t\t\tprocessTriggerResult(triggerResult, context.window);\n \t\t\t} else {\n \t\t\t\tfire = false;\n \t\t\t}\n@@ -604,7 +651,20 @@ public String toString() {\n \t// ------------------------------------------------------------------------\n \n \t@Override\n+\t@SuppressWarnings(\"unchecked\")\n \tpublic StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {\n+\n+\t\tif (mergingWindowsByKey != null) {\n+\t\t\tTupleSerializer<Tuple2<W, W>> tupleSerializer = new TupleSerializer<>((Class) Tuple2.class, new TypeSerializer[] {windowSerializer, windowSerializer} );\n+\t\t\tListStateDescriptor<Tuple2<W, W>> mergeStateDescriptor = new ListStateDescriptor<>(\"merging-window-set\", tupleSerializer);\n+\t\t\tfor (Map.Entry<K, MergingWindowSet<W>> key: mergingWindowsByKey.entrySet()) {\n+\t\t\t\tsetKeyContext(key.getKey());\n+\t\t\t\tListState<Tuple2<W, W>> mergeState = getStateBackend().getPartitionedState(null, VoidSerializer.INSTANCE, mergeStateDescriptor);\n+\t\t\t\tmergeState.clear();\n+\t\t\t\tkey.getValue().persist(mergeState);\n+\t\t\t}\n+\t\t}\n+\n \t\tStreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);\n \n \t\tAbstractStateBackend.CheckpointStateOutputView out =\n", "nb_test": 284, "linesAdd": 88, "jira_id": "3740", "singleLine": false, "nb_skipped": 1, "commit": "f2f5bd5b", "nb_failure": 1, "linesRem": 23}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ValueStateDescriptorTest.testVeryLargeDefaultValue:126 \u00bb Runtime Read size doe..."], "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java b/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java\nindex 10ac5ba..243ebcd 100644\n--- a/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java\n+++ b/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java\n@@ -284,12 +284,10 @@ private void readObject(final ObjectInputStream in) throws IOException, ClassNot\n \t\tboolean hasDefaultValue = in.readBoolean();\n \t\tif (hasDefaultValue) {\n \t\t\tint size = in.readInt();\n+\n \t\t\tbyte[] buffer = new byte[size];\n-\t\t\tint bytesRead = in.read(buffer);\n \n-\t\t\tif (bytesRead != size) {\n-\t\t\t\tthrow new RuntimeException(\"Read size does not match expected size.\");\n-\t\t\t}\n+\t\t\tin.readFully(buffer);\n \n \t\t\ttry (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);\n \t\t\t\t\tDataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(bais))\n", "nb_test": 1802, "linesAdd": 2, "jira_id": "3760", "singleLine": false, "nb_skipped": 0, "commit": "494212b3", "nb_failure": 0, "linesRem": 4}, {"files": 2, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java\nindex 115a97c..408a0f0 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java\n@@ -55,6 +55,8 @@\n \tprivate IN currentInput;\n \n \tprivate ClassLoader cl;\n+\tprivate boolean restored = true;\n+\tprivate StateHandle<Serializable> checkpoint = null;\n \n \tpublic PartitionedStreamOperatorState(StateCheckpointer<S, C> checkpointer,\n \t\t\tStateHandleProvider<C> provider, KeySelector<IN, Serializable> keySelector, ClassLoader cl) {\n@@ -76,6 +78,10 @@ public S value() throws IOException {\n \t\tif (currentInput == null) {\n \t\t\tthrow new IllegalStateException(\"Need a valid input for accessing the state.\");\n \t\t} else {\n+\t\t\tif (!restored) {\n+\t\t\t\t// If the state is not restored yet, restore now\n+\t\t\t\trestoreWithCheckpointer();\n+\t\t\t}\n \t\t\tSerializable key;\n \t\t\ttry {\n \t\t\t\tkey = keySelector.getKey(currentInput);\n@@ -100,6 +106,10 @@ public void update(S state) throws IOException {\n \t\tif (currentInput == null) {\n \t\t\tthrow new IllegalStateException(\"Need a valid input for updating a state.\");\n \t\t} else {\n+\t\t\tif (!restored) {\n+\t\t\t\t// If the state is not restored yet, restore now\n+\t\t\t\trestoreWithCheckpointer();\n+\t\t\t}\n \t\t\tSerializable key;\n \t\t\ttry {\n \t\t\t\tkey = keySelector.getKey(currentInput);\n@@ -131,12 +141,26 @@ public void setCurrentInput(IN input) {\n \n \t@Override\n \tpublic StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {\n-\t\treturn stateStore.snapshotStates(checkpointId, checkpointTimestamp);\n+\t\t// If the state is restored we take a snapshot, otherwise return the last checkpoint\n+\t\treturn restored ? stateStore.snapshotStates(checkpointId, checkpointTimestamp) : provider\n+\t\t\t\t.createStateHandle(checkpoint.getState(cl));\n \t}\n \t\n \t@Override\n-\tpublic void restoreState(StateHandle<Serializable> snapshots, ClassLoader userCodeClassLoader) throws Exception {\n-\t\tstateStore.restoreStates(snapshots, userCodeClassLoader);\n+\tpublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\n+\t\t// We store the snapshot for lazy restore\n+\t\tcheckpoint = snapshot;\n+\t\trestored = false;\n+\t}\n+\t\n+\tprivate void restoreWithCheckpointer() throws IOException {\n+\t\ttry {\n+\t\t\tstateStore.restoreStates(checkpoint, cl);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t\trestored = true;\n+\t\tcheckpoint = null;\n \t}\n \n \t@Override\n@@ -145,6 +169,12 @@ public void restoreState(StateHandle<Serializable> snapshots, ClassLoader userCo\n \t}\n \t\n \t@Override\n+\tpublic void setCheckpointer(StateCheckpointer<S, C> checkpointer) {\n+\t\tsuper.setCheckpointer(checkpointer);\n+\t\tstateStore.setCheckPointer(checkpointer);\n+\t}\n+\n+\t@Override\n \tpublic String toString() {\n \t\treturn stateStore.toString();\n \t}\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java\nindex 29a19b5..c33b94e 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java\n@@ -44,7 +44,10 @@\n \n \tprivate S state;\n \tprotected StateCheckpointer<S, C> checkpointer;\n-\tprivate final StateHandleProvider<Serializable> provider;\n+\tprotected final StateHandleProvider<Serializable> provider;\n+\t\n+\tprivate boolean restored = true;\n+\tprivate Serializable checkpoint = null;\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic StreamOperatorState(StateCheckpointer<S, C> checkpointer, StateHandleProvider<C> provider) {\n@@ -59,6 +62,10 @@ public StreamOperatorState(StateHandleProvider<C> provider) {\n \n \t@Override\n \tpublic S value() throws IOException {\n+\t\tif (!restored) {\n+\t\t\t// If the state is not restore it yet, restore at this point\n+\t\t\trestoreWithCheckpointer();\n+\t\t}\n \t\treturn state;\n \t}\n \n@@ -67,6 +74,11 @@ public void update(S state) throws IOException {\n \t\tif (state == null) {\n \t\t\tthrow new RuntimeException(\"Cannot set state to null.\");\n \t\t}\n+\t\tif (!restored) {\n+\t\t\t// If the value is updated before the restore it is overwritten\n+\t\t\trestored = true;\n+\t\t\tcheckpoint = false;\n+\t\t}\n \t\tthis.state = state;\n \t}\n \t\n@@ -90,14 +102,22 @@ public void setCheckpointer(StateCheckpointer<S, C> checkpointer) {\n \n \tpublic StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp)\n \t\t\tthrows Exception {\n-\t\treturn provider.createStateHandle(checkpointer.snapshotState(value(), checkpointId,\n-\t\t\t\tcheckpointTimestamp));\n+\t\t// If the state is restored we take a snapshot, otherwise return the last checkpoint\n+\t\treturn provider.createStateHandle(restored ? checkpointer.snapshotState(value(), checkpointId,\n+\t\t\t\tcheckpointTimestamp) : checkpoint);\n+\t}\n \n+\tpublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\n+\t\t// We set the checkpoint for lazy restore\n+\t\tcheckpoint = snapshot.getState(userCodeClassLoader);\n+\t\trestored = false;\n \t}\n \t\n \t@SuppressWarnings(\"unchecked\")\n-\tpublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\n-\t\tupdate(checkpointer.restoreState((C) snapshot.getState(userCodeClassLoader)));\n+\tprivate void restoreWithCheckpointer() throws IOException {\n+\t\tupdate(checkpointer.restoreState((C) checkpoint));\n+\t\trestored = true;\n+\t\tcheckpoint = null;\n \t}\n \n \tpublic Map<Serializable, S> getPartitionedState() throws Exception {\n", "nb_test": 25, "linesAdd": 50, "jira_id": "2713", "singleLine": false, "nb_skipped": 0, "commit": "63d9800e", "nb_failure": 0, "linesRem": 8}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["KryoClearedBufferTest.testOutputBufferedBeingClearedInCaseOfException:80 \u00bb EOF"], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\nindex f825fc6..8549e26 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n@@ -182,11 +182,22 @@ public void serialize(T record, DataOutputView target) throws IOException {\n \t\t\tpreviousOut = target;\n \t\t}\n \n+\t\t// Sanity check: Make sure that the output is cleared/has been flushed by the last call\n+\t\t// otherwise data might be written multiple times in case of a previous EOFException\n+\t\tif (output.position() != 0) {\n+\t\t\tthrow new IllegalStateException(\"The Kryo Output still contains data from a previous \" +\n+\t\t\t\t\"serialize call. It has to be flushed or cleared at the end of the serialize call.\");\n+\t\t}\n+\n \t\ttry {\n \t\t\tkryo.writeClassAndObject(output, record);\n \t\t\toutput.flush();\n \t\t}\n \t\tcatch (KryoException ke) {\n+\t\t\t// make sure that the Kryo output buffer is cleared in case that we can recover from\n+\t\t\t// the exception (e.g. EOFException which denotes buffer full)\n+\t\t\toutput.clear();\n+\n \t\t\tThrowable cause = ke.getCause();\n \t\t\tif (cause instanceof EOFException) {\n \t\t\t\tthrow (EOFException) cause;\n", "nb_test": 1063, "linesAdd": 7, "jira_id": "2800", "singleLine": false, "nb_skipped": 0, "commit": "b654e989", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["StreamingJobGraphGeneratorNodeHashTest.testChangedOperatorName:343 expected:<b5a07107ff294c7c73af04fe19fe861e> but was:<794fffc5554098c3a3a108acf8061d34>"], "patch": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\nindex da46424..e3e1ac6 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n@@ -736,8 +736,6 @@ private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id) {\n \n \t\thasher.putInt(node.getParallelism());\n \n-\t\thasher.putString(node.getOperatorName(), Charset.forName(\"UTF-8\"));\n-\n \t\tif (node.getOperator() instanceof AbstractUdfStreamOperator) {\n \t\t\tString udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator())\n \t\t\t\t\t.getUserFunction().getClass().getName();\n", "nb_test": 274, "linesAdd": 0, "jira_id": "3513", "singleLine": false, "nb_skipped": 1, "commit": "d90672fd", "nb_failure": 1, "linesRem": 2}, {"files": 2, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["TaskManagerRegistrationTest.testTaskManagerResumesConnectAfterJobManagerFailure:270 assertion failed: timeout (1995329515 nanoseconds) during expectMsgClass waiting for class org.apache.flink.runtime.messages.RegistrationMessages$RegisterTaskManager", "TaskInputSplitProviderTest.testRequestNextInputSplitWithInvalidExecutionID:77 \u00bb Runtime"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\nindex 3ba378c..baed947 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n@@ -328,7 +328,7 @@ public void deployToSlot(final SimpleSlot slot) throws JobException {\n \t\t\t// register this execution at the execution graph, to receive call backs\n \t\t\tvertex.getExecutionGraph().registerExecution(this);\n \n-\t\t\tInstance instance = slot.getInstance();\n+\t\t\tfinal Instance instance = slot.getInstance();\n \t\t\tFuture<Object> deployAction = Patterns.ask(instance.getTaskManager(),\n \t\t\t\t\tnew SubmitTask(deployment), new Timeout(timeout));\n \n@@ -338,7 +338,9 @@ public void deployToSlot(final SimpleSlot slot) throws JobException {\n \t\t\t\tpublic void onComplete(Throwable failure, Object success) throws Throwable {\n \t\t\t\t\tif (failure != null) {\n \t\t\t\t\t\tif (failure instanceof TimeoutException) {\n-\t\t\t\t\t\t\tmarkFailed(new Exception(\"Cannot deploy task - TaskManager not responding.\", failure));\n+\t\t\t\t\t\t\tmarkFailed(new Exception(\n+\t\t\t\t\t\t\t\t\t\"Cannot deploy task - TaskManager \" + instance + \" not responding.\",\n+\t\t\t\t\t\t\t\t\tfailure));\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\tmarkFailed(failure);\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/TaskInputSplitProvider.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/TaskInputSplitProvider.java\nindex 1bdc346..5a69850 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/TaskInputSplitProvider.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/TaskInputSplitProvider.java\n@@ -68,10 +68,6 @@ public InputSplit getNextInputSplit() {\n \n \t\t\tfinal Object result = Await.result(response, timeout.duration());\n \n-\t\t\tif (result == null) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n \t\t\tif(!(result instanceof JobManagerMessages.NextInputSplit)){\n \t\t\t\tthrow new RuntimeException(\"RequestNextInputSplit requires a response of type \" +\n \t\t\t\t\t\t\"NextInputSplit. Instead response is of type \" + result.getClass() + \".\");\n@@ -80,10 +76,15 @@ public InputSplit getNextInputSplit() {\n \t\t\t\t\t\t(JobManagerMessages.NextInputSplit) result;\n \n \t\t\t\tbyte[] serializedData = nextInputSplit.splitData();\n+\n+\t\t\t\tif(serializedData == null) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t} else {\n \t\t\t\t\tObject deserialized = InstantiationUtil.deserializeObject(serializedData,\n \t\t\t\t\t\t\tusercodeClassLoader);\n \t\t\t\t\treturn (InputSplit) deserialized;\n \t\t\t\t}\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tthrow new RuntimeException(\"Requesting the next InputSplit failed.\", e);\n \t\t}\n", "nb_test": 617, "linesAdd": 9, "jira_id": "1922", "singleLine": false, "nb_skipped": 0, "commit": "ccd574a4", "nb_failure": 1, "linesRem": 6}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["TempInIterationsTest.testTempInIterationTest:73 null"], "patch": "diff --git a/flink-optimizer/src/main/java/org/apache/flink/optimizer/plantranslate/JobGraphGenerator.java b/flink-optimizer/src/main/java/org/apache/flink/optimizer/plantranslate/JobGraphGenerator.java\nindex dc21c13..2630019 100644\n--- a/flink-optimizer/src/main/java/org/apache/flink/optimizer/plantranslate/JobGraphGenerator.java\n+++ b/flink-optimizer/src/main/java/org/apache/flink/optimizer/plantranslate/JobGraphGenerator.java\n@@ -1163,8 +1163,9 @@ private void addLocalInfoFromChannelToConfig(Channel channel, TaskConfig config,\n \t\t\tfinal TempMode tm = channel.getTempMode();\n \n \t\t\tboolean needsMemory = false;\n-\t\t\t// Don't add a pipeline breaker if the data exchange is already blocking.\n-\t\t\tif (tm.breaksPipeline() && channel.getDataExchangeMode() != DataExchangeMode.BATCH) {\n+\t\t\t// Don't add a pipeline breaker if the data exchange is already blocking, EXCEPT the channel is within an iteration.\n+\t\t\tif (tm.breaksPipeline() &&\n+\t\t\t\t\t(channel.isOnDynamicPath() || channel.getDataExchangeMode() != DataExchangeMode.BATCH) ) {\n \t\t\t\tconfig.setInputAsynchronouslyMaterialized(inputNum, true);\n \t\t\t\tneedsMemory = true;\n \t\t\t}\n", "nb_test": 327, "linesAdd": 2, "jira_id": "1951", "singleLine": false, "nb_skipped": 0, "commit": "adb321d6", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["CliFrontendInfoTest.testShowExecutionPlan:67 null"], "patch": "diff --git a/flink-clients/src/main/java/org/apache/flink/client/cli/CliFrontendParser.java b/flink-clients/src/main/java/org/apache/flink/client/cli/CliFrontendParser.java\nindex 4e081fd..07d409e 100644\n--- a/flink-clients/src/main/java/org/apache/flink/client/cli/CliFrontendParser.java\n+++ b/flink-clients/src/main/java/org/apache/flink/client/cli/CliFrontendParser.java\n@@ -339,7 +339,7 @@ public static SavepointOptions parseSavepointCommand(String[] args) throws CliAr\n \tpublic static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {\n \t\ttry {\n \t\t\tPosixParser parser = new PosixParser();\n-\t\t\tCommandLine line = parser.parse(INFO_OPTIONS, args, false);\n+\t\t\tCommandLine line = parser.parse(INFO_OPTIONS, args, true);\n \t\t\treturn new InfoOptions(line);\n \t\t}\n \t\tcatch (ParseException e) {\n", "nb_test": 45, "linesAdd": 1, "jira_id": "3189", "singleLine": false, "nb_skipped": 0, "commit": "a5b05566", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 6, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SpillableSubpartitionTest>SubpartitionTestBase.testReleaseParentAfterSpilled:88->SubpartitionTestBase.verifyViewReleasedAfterParentRelease:111 null", "SpillableSubpartitionTest>SubpartitionTestBase.testReleaseParent:80->SubpartitionTestBase.verifyViewReleasedAfterParentRelease:111 null"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 931790a..3b7a2a6 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n@@ -41,7 +41,7 @@\n \tprivate boolean isFinished;\n \n \t/** Flag indicating whether the subpartition has been released. */\n-\tprivate boolean isReleased;\n+\tprivate volatile boolean isReleased;\n \n \t/**\n \t * A data availability listener. Registered, when the consuming task is faster than the\n@@ -167,6 +167,11 @@ public int releaseMemory() {\n \t}\n \n \t@Override\n+\tpublic boolean isReleased() {\n+\t\treturn isReleased;\n+\t}\n+\n+\t@Override\n \tpublic PipelinedSubpartitionView createReadView(BufferProvider bufferProvider) {\n \t\tsynchronized (buffers) {\n \t\t\tif (readView != null) {\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\nindex e9dfe32..b7ca9c4 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n@@ -81,4 +81,6 @@ protected Throwable getFailureCause() {\n \n \tabstract int releaseMemory() throws IOException;\n \n+\tabstract public boolean isReleased();\n+\n }\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\nindex 4a18691..21e9cc6 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\n@@ -59,7 +59,7 @@\n \tprivate boolean isFinished;\n \n \t/** Flag indicating whether the subpartition has been released. */\n-\tboolean isReleased;\n+\tprivate volatile boolean isReleased;\n \n \t/** The read view to consume this subpartition. */\n \tprivate ResultSubpartitionView readView;\n@@ -168,6 +168,11 @@ public int releaseMemory() throws IOException {\n \t}\n \n \t@Override\n+\tpublic boolean isReleased() {\n+\t\treturn isReleased;\n+\t}\n+\n+\t@Override\n \tpublic ResultSubpartitionView createReadView(BufferProvider bufferProvider) throws IOException {\n \t\tsynchronized (buffers) {\n \t\t\tif (!isFinished) {\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\nindex 972e34b..c9da40a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\n@@ -73,7 +73,7 @@ public Buffer getNextBuffer() throws IOException, InterruptedException {\n \n \t\t// 1) In-memory\n \t\tsynchronized (parent.buffers) {\n-\t\t\tif (parent.isReleased) {\n+\t\t\tif (parent.isReleased()) {\n \t\t\t\treturn null;\n \t\t\t}\n \n@@ -162,7 +162,7 @@ public void releaseAllResources() throws IOException {\n \n \t@Override\n \tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n+\t\treturn parent.isReleased() || isReleased.get();\n \t}\n \n \t@Override\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewAsyncIO.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewAsyncIO.java\nindex ea5c20b..052a7cd 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewAsyncIO.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewAsyncIO.java\n@@ -187,7 +187,7 @@ public void releaseAllResources() throws IOException {\n \n \t@Override\n \tpublic boolean isReleased() {\n-\t\treturn isReleased;\n+\t\treturn parent.isReleased() || isReleased;\n \t}\n \n \t@Override\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewSyncIO.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewSyncIO.java\nindex 24099a7..5b91668 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewSyncIO.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewSyncIO.java\n@@ -108,7 +108,7 @@ public void releaseAllResources() throws IOException {\n \n \t@Override\n \tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n+\t\treturn parent.isReleased() || isReleased.get();\n \t}\n \n \t@Override\n", "nb_test": 719, "linesAdd": 18, "jira_id": "2460", "singleLine": false, "nb_skipped": 0, "commit": "a17d4e82", "nb_failure": 2, "linesRem": 6}, {"files": 2, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ExecutionGraphRestartTest.testFailExecutionAfterCancel:539 expected:<CANCELED> but was:<RESTARTING>", "ExecutionVertexCancelTest.testActionsWhileCancelling:552 expected:<CANCELED> but was:<FAILED>", "ExecutionVertexCancelTest.testCancelCallFails:403 expected:<CANCELED> but was:<FAILED>"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\nindex bc75664..6d5832b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n@@ -797,6 +797,11 @@ private boolean processFail(Throwable t, boolean isCallback) {\n \t\t\t\treturn false;\n \t\t\t}\n \n+\t\t\tif (current == CANCELING) {\n+\t\t\t\tcancelingComplete();\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n \t\t\tif (transitionState(current, FAILED, t)) {\n \t\t\t\t// success (in a manner of speaking)\n \t\t\t\tthis.failureCause = t;\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\nindex 0d6de98..ed50bea 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n@@ -809,7 +809,7 @@ public void stop() throws StoppingException {\n \tpublic void fail(Throwable t) {\n \t\twhile (true) {\n \t\t\tJobStatus current = state;\n-\t\t\tif (current == JobStatus.FAILED || current == JobStatus.FAILING) {\n+\t\t\tif (current == JobStatus.FAILING || current.isTerminalState()) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\telse if (transitionState(current, JobStatus.FAILING, t)) {\n", "nb_test": 977, "linesAdd": 6, "jira_id": "3534", "singleLine": false, "nb_skipped": 1, "commit": "734ba01d", "nb_failure": 3, "linesRem": 1}, {"files": 2, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\nindex c953a94..38f1231 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\n@@ -150,7 +150,11 @@ public void broadcastBarrier(long id, long timestamp) throws IOException, Interr\n \t\t\t// operator which will be returned and set it up using the wrapper\n \t\t\tOneInputStreamOperator chainableOperator =\n \t\t\t\t\tchainedTaskConfig.getStreamOperator(vertex.getUserCodeClassLoader());\n-\t\t\tchainableOperator.setup(wrapper, vertex.context);\n+\t\t\t\n+\t\t\tStreamingRuntimeContext chainedContext = vertex.createRuntimeContext(chainedTaskConfig);\n+\t\t\tvertex.contexts.add(chainedContext);\n+\t\t\t\n+\t\t\tchainableOperator.setup(wrapper, chainedContext);\n \n \t\t\tchainedOperators.add(chainableOperator);\n \t\t\treturn new OperatorCollector<X>(chainableOperator);\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\nindex d678922..1a3d44f 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n@@ -62,7 +62,7 @@\n \n \tprotected volatile boolean isRunning = false;\n \n-\tprotected StreamingRuntimeContext context;\n+\tprotected List<StreamingRuntimeContext> contexts;\n \n \tprotected ClassLoader userClassLoader;\n \t\n@@ -73,21 +73,26 @@\n \tpublic StreamTask() {\n \t\tstreamOperator = null;\n \t\tsuperstepListener = new SuperstepEventListener();\n+\t\tcontexts = new ArrayList<StreamingRuntimeContext>();\n \t}\n \n \t@Override\n \tpublic void registerInputOutput() {\n \t\tthis.userClassLoader = getUserCodeClassLoader();\n \t\tthis.configuration = new StreamConfig(getTaskConfiguration());\n-\t\tthis.context = createRuntimeContext(getEnvironment().getTaskName());\n \t\tthis.stateHandleProvider = getStateHandleProvider();\n \n \t\toutputHandler = new OutputHandler<OUT>(this);\n \n \t\tstreamOperator = configuration.getStreamOperator(userClassLoader);\n+\t\t\n \t\tif (streamOperator != null) {\n+\t\t\t//Create context of the head operator\n+\t\t\tStreamingRuntimeContext headContext = createRuntimeContext(configuration);\n+\t\t\tthis.contexts.add(headContext);\n+\n \t\t\t// IterationHead and IterationTail don't have an Operator...\n-\t\t\tstreamOperator.setup(outputHandler.getOutput(), this.context);\n+\t\t\tstreamOperator.setup(outputHandler.getOutput(), headContext);\n \t\t}\n \n \t\thasChainedOperators = !outputHandler.getChainedOperators().isEmpty();\n@@ -97,10 +102,10 @@ public String getName() {\n \t\treturn getEnvironment().getTaskName();\n \t}\n \n-\tpublic StreamingRuntimeContext createRuntimeContext(String taskName) {\n+\tpublic StreamingRuntimeContext createRuntimeContext(StreamConfig conf) {\n \t\tEnvironment env = getEnvironment();\n-\t\treturn new StreamingRuntimeContext(taskName, env, getUserCodeClassLoader(),\n-\t\t\t\tgetExecutionConfig());\n+\t\treturn new StreamingRuntimeContext(conf.getStreamOperator(userClassLoader).getClass()\n+\t\t\t\t.getSimpleName(), env, getUserCodeClassLoader(), getExecutionConfig());\n \t}\n \t\n \tprivate StateHandleProvider<Serializable> getStateHandleProvider() {\n", "nb_test": 28, "linesAdd": 15, "jira_id": "2082", "singleLine": false, "nb_skipped": 0, "commit": "0cfa43d7", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java\nindex b7766ee..fd896c9 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java\n@@ -76,7 +76,7 @@\n \n \t/**\n \t * \n-\t * @param inputGate Teh input gate to draw the buffers and events from.\n+\t * @param inputGate The input gate to draw the buffers and events from.\n \t * @param ioManager The I/O manager that gives access to the temp directories.\n \t * \n \t * @throws IOException Thrown, when the spilling to temp files cannot be initialized.\n@@ -102,6 +102,7 @@ public BufferOrEvent getNextNonBlocked() throws IOException, InterruptedExceptio\n \t\t\tif (currentBuffered != null) {\n \t\t\t\tnext = currentBuffered.getNext();\n \t\t\t\tif (next == null) {\n+\t\t\t\t\tcurrentBuffered.cleanup();\n \t\t\t\t\tcurrentBuffered = queuedBuffered.pollFirst();\n \t\t\t\t\tif (currentBuffered != null) {\n \t\t\t\t\t\tcurrentBuffered.open();\n", "nb_test": 25, "linesAdd": 1, "jira_id": "2484", "singleLine": true, "nb_skipped": 0, "commit": "d738430c", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PojoTypeExtractionTest.testPojoWithGenericFields:166 null"], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex e52e2af..b528d00 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -989,12 +989,12 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t}\n \t\t\tfor(Method m : clazz.getMethods()) {\n \t\t\t\t// check for getter\n-\t\t\t\tif(\t// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala).\n-\t\t\t\t\t(m.getName().toLowerCase().equals(\"get\"+fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&\n+\t\t\t\tif(\t// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala) or \"is<fieldName>\" for boolean fields.\n+\t\t\t\t\t(m.getName().toLowerCase().equals(\"get\"+fieldNameLow) || m.getName().toLowerCase().equals(\"is\"+fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&\n \t\t\t\t\t// no arguments for the getter\n \t\t\t\t\tm.getParameterTypes().length == 0 &&\n \t\t\t\t\t// return type is same as field type (or the generic variant of it)\n-\t\t\t\t\t(m.getReturnType().equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )\n+\t\t\t\t\t(m.getGenericReturnType().equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )\n \t\t\t\t) {\n \t\t\t\t\tif(hasGetter) {\n \t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one getter\");\n@@ -1004,7 +1004,7 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\t// check for setters (<FieldName>_$eq for scala)\n \t\t\t\tif((m.getName().toLowerCase().equals(\"set\"+fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow+\"_$eq\")) &&\n \t\t\t\t\tm.getParameterTypes().length == 1 && // one parameter of the field's type\n-\t\t\t\t\t( m.getParameterTypes()[0].equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&\n+\t\t\t\t\t( m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&\n \t\t\t\t\t// return type is void.\n \t\t\t\t\tm.getReturnType().equals(Void.TYPE)\n \t\t\t\t) {\n", "nb_test": 634, "linesAdd": 4, "jira_id": "1333", "singleLine": false, "nb_skipped": 0, "commit": "63ef8e86", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["TypeExtractorTest.testDuplicateValueNested:1486 \u00bb InvalidTypes Type of TypeVar..."], "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex d5f3619..55f6b1f 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -421,15 +421,12 @@ else if (inType instanceof ParameterizedType && Tuple.class.isAssignableFrom(((C\n \t\t\tType[] tupleElements = ((ParameterizedType) inType).getActualTypeArguments();\n \t\t\t// go thru all tuple elements and search for type variables\n \t\t\tfor(int i = 0; i < tupleElements.length; i++) {\n-\t\t\t\tif(tupleElements[i] instanceof TypeVariable) {\n-\t\t\t\t\tinType = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) tupleElements[i]);\n-\t\t\t\t\tinfo = findCorrespondingInfo(returnTypeVar, inType, ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i));\n+\t\t\t\tinfo = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i));\n \t\t\t\tif(info != null) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t}\n \t\treturn info;\n \t}\n \t\n", "nb_test": 456, "linesAdd": 1, "jira_id": "1133", "singleLine": false, "nb_skipped": 1, "commit": "02c08456", "nb_failure": 0, "linesRem": 4}, {"files": 2, "project": "flink", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["SpillableSubpartitionTest.testReleasePartitionAndGetNext:148 \u00bb IndexOutOfBounds"], "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\nindex 91f2042..4a18691 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\n@@ -59,7 +59,7 @@\n \tprivate boolean isFinished;\n \n \t/** Flag indicating whether the subpartition has been released. */\n-\tprivate boolean isReleased;\n+\tboolean isReleased;\n \n \t/** The read view to consume this subpartition. */\n \tprivate ResultSubpartitionView readView;\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\nindex d37f042..972e34b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\n@@ -73,6 +73,10 @@ public Buffer getNextBuffer() throws IOException, InterruptedException {\n \n \t\t// 1) In-memory\n \t\tsynchronized (parent.buffers) {\n+\t\t\tif (parent.isReleased) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n \t\t\tif (parent.spillWriter == null) {\n \t\t\t\tif (currentQueuePosition < numberOfBuffers) {\n \t\t\t\t\tBuffer buffer = parent.buffers.get(currentQueuePosition);\n", "nb_test": 700, "linesAdd": 5, "jira_id": "2412", "singleLine": false, "nb_skipped": 0, "commit": "a56aad74", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "flink", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["StreamTaskTest.testEarlyCanceling:112 Task did not cancel"], "patch": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\nindex 9ab6c10..c9624fc 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n@@ -147,6 +147,9 @@\n \t * needs to be initialized to true, so that early cancel() before invoke() behaves correctly */\n \tprivate volatile boolean isRunning;\n \t\n+\t/** Flag to mark this task as canceled */\n+\tprivate volatile boolean canceled;\n+\n \tprivate long recoveryTimestamp;\n \n \t// ------------------------------------------------------------------------\n@@ -191,6 +194,11 @@ public final void invoke() throws Exception {\n \t\t\t// task specific initialization\n \t\t\tinit();\n \t\t\t\n+\t\t\t// save the work of reloadig state, etc, if the task is already canceled\n+\t\t\tif (canceled) {\n+\t\t\t\tthrow new CancelTaskException();\n+\t\t\t}\n+\t\t\t\n \t\t\t// -------- Invoke --------\n \t\t\tLOG.debug(\"Invoking {}\", getName());\n \t\t\t\n@@ -205,6 +213,11 @@ public final void invoke() throws Exception {\n \t\t\t\topenAllOperators();\n \t\t\t}\n \n+\t\t\t// final check to exit early before starting to run\n+\t\t\tif (canceled) {\n+\t\t\t\tthrow new CancelTaskException();\n+\t\t\t}\n+\n \t\t\t\t// let the task do its work\n \t\t\tisRunning = true;\n \t\t\trun();\n@@ -290,6 +303,7 @@ public final void invoke() throws Exception {\n \t@Override\n \tpublic final void cancel() throws Exception {\n \t\tisRunning = false;\n+\t\tcanceled = true;\n \t\tcancelTask();\n \t}\n \n@@ -297,6 +311,10 @@ public final boolean isRunning() {\n \t\treturn isRunning;\n \t}\n \t\n+\tpublic final boolean isCanceled() {\n+\t\treturn canceled;\n+\t}\n+\t\n \tprivate void openAllOperators() throws Exception {\n \t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n \t\t\tif (operator != null) {\n", "nb_test": 243, "linesAdd": 15, "jira_id": "3314", "singleLine": false, "nb_skipped": 5, "commit": "8fc7e7af", "nb_failure": 1, "linesRem": 0}, {"files": 0, "project": "flink", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["FlinkTopologyBuilderTest.testFieldsGroupingOnMultipleBoltOutputStreams:73 \u00bb InvalidProgram", "FlinkTopologyBuilderTest.testFieldsGroupingOnMultipleSpoutOutputStreams:61 \u00bb InvalidProgram"], "patch": "", "nb_test": 125, "linesAdd": 0, "jira_id": "2658", "singleLine": false, "nb_skipped": 0, "commit": "ce68cbd9", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/appender/SyslogAppender.java b/core/src/main/java/org/apache/logging/log4j/core/appender/SyslogAppender.java\nindex d2392e9..39fbd38 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/appender/SyslogAppender.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/appender/SyslogAppender.java\n@@ -111,7 +111,7 @@ public static SyslogAppender createAppender(@PluginAttr(\"host\") String host,\n                 LOGGER.error(\"Charset \" + charset + \" is not supported for layout, using \" + c.displayName());\n             }\n         }\n-        Layout layout = (format.equalsIgnoreCase(RFC5424)) ?\n+        Layout layout = (RFC5424.equalsIgnoreCase(format)) ?\n             RFC5424Layout.createLayout(facility, id, ein, includeMDC, mdcId, includeNL, appName,  msgId,\n                 excludes, includes, required, charset, config) :\n             SyslogLayout.createLayout(facility, includeNL, charset);\n", "nb_test": 88, "linesAdd": 1, "jira_id": "101", "singleLine": false, "nb_skipped": 0, "commit": "c79a743b", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFilter(org.apache.logging.log4j.core.filter.ThreadContextMapFilterTest)"], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/filter/ThreadContextMapFilter.java b/core/src/main/java/org/apache/logging/log4j/core/filter/ThreadContextMapFilter.java\nindex 9ad6cab..b3f3838 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/filter/ThreadContextMapFilter.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/filter/ThreadContextMapFilter.java\n@@ -96,7 +96,7 @@ private Result filter() {\n                 }\n             }\n         } else {\n-            match = key.equals(ThreadContext.get(key));\n+            match = value.equals(ThreadContext.get(key));\n         }\n         return match ? onMatch : onMismatch;\n     }\n", "nb_test": 112, "linesAdd": 1, "jira_id": "147", "singleLine": false, "nb_skipped": 0, "commit": "17296089", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["HTMLLayoutTest.testLayout:100 Incorrect header: <title>Log4J Log Messages</title>"], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java b/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\nindex 7adce60..76dfdfe 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\n@@ -258,6 +258,7 @@ private void appendThrowableAsHTML(final Throwable throwable, final StringBuilde\n         sbuf.append(Constants.LINE_SEP);\n         sbuf.append(\"<html>\").append(Constants.LINE_SEP);\n         sbuf.append(\"<head>\").append(Constants.LINE_SEP);\n+        sbuf.append(\"<meta charset=\\\"\").append(getCharset()).append(\"\\\"/>\").append(Constants.LINE_SEP);\n         sbuf.append(\"<title>\").append(title).append(\"</title>\").append(Constants.LINE_SEP);\n         sbuf.append(\"<style type=\\\"text/css\\\">\").append(Constants.LINE_SEP);\n         sbuf.append(\"<!--\").append(Constants.LINE_SEP);\n@@ -317,7 +318,7 @@ public static HTMLLayout createLayout(@PluginAttr(\"locationInfo\") final String l\n                                           @PluginAttr(\"charset\") final String charsetName,\n                                           @PluginAttr(\"fontSize\") String fontSize,\n                                           @PluginAttr(\"fontName\") String font) {\n-        final Charset charset = Charsets.getSupportedCharset(charsetName);\n+        final Charset charset = Charsets.getSupportedCharset(charsetName, Charsets.UTF_8);\n         if (font == null) {\n             font = \"arial,sans-serif\";\n         }\n", "nb_test": 331, "linesAdd": 2, "jira_id": "258", "singleLine": false, "nb_skipped": 3, "commit": "7b38965d", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["DefaultLevelConverterCustomJulLevelsTest.testCustomJulLevelNearAll:72 expected:<ALL> but was:<null>", "DefaultLevelConverterCustomJulLevelsTest.testCustomJulLevelNearConfig:107 expected:<CONFIG> but was:<null>", "DefaultLevelConverterCustomJulLevelsTest.testCustomJulLevelNearFine:98 expected:<DEBUG> but was:<null>", "DefaultLevelConverterCustomJulLevelsTest.testCustomJulLevelNearFiner:89 expected:<TRACE> but was:<null>", "DefaultLevelConverterCustomJulLevelsTest.testCustomJulLevelNearFinest:80 expected:<FINEST> but was:<null>", "DefaultLevelConverterCustomJulLevelsTest.testCustomJulLevelNearInfo:116 expected:<INFO> but was:<null>", "DefaultLevelConverterCustomJulLevelsTest.testCustomJulLevelNearOff:143 expected:<OFF> but was:<null>", "DefaultLevelConverterCustomJulLevelsTest.testCustomJulLevelNearSevere:134 expected:<ERROR> but was:<null>", "DefaultLevelConverterCustomJulLevelsTest.testCustomJulLevelNearWarning:125 expected:<WARN> but was:<null>"], "patch": "diff --git a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\nindex 5d84de4..c2d8eb3 100644\n--- a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\n+++ b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\n@@ -17,24 +17,38 @@\n \n package org.apache.logging.log4j.jul;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n import java.util.IdentityHashMap;\n+import java.util.List;\n import java.util.Map;\n \n import org.apache.logging.log4j.Level;\n \n /**\n  * Default implementation of LevelConverter strategy.\n- *\n+ * <p>\n+ * Supports custom JUL levels by mapping them to their closest mapped neighbour. \n+ * </p>\n  * @since 2.1\n  */\n public class DefaultLevelConverter implements LevelConverter {\n \n+    static final class JulLevelComparator implements Comparator<java.util.logging.Level> {\n+        @Override\n+        public int compare(java.util.logging.Level level1, java.util.logging.Level level2) {\n+            return Integer.compare(level1.intValue(), level2.intValue());\n+        }\n+    }\n+\n     private final Map<java.util.logging.Level, Level> julToLog4j = new IdentityHashMap<>(9);\n     private final Map<Level, java.util.logging.Level> log4jToJul = new IdentityHashMap<>(10);\n+    private final List<java.util.logging.Level> sortedJulLevels = new ArrayList<>(9);\n \n     public DefaultLevelConverter() {\n         // Map JUL to Log4j\n-        mapJulToLog4j(java.util.logging.Level.OFF, Level.OFF);\n+        mapJulToLog4j(java.util.logging.Level.ALL, Level.ALL);\n         mapJulToLog4j(java.util.logging.Level.FINEST, LevelTranslator.FINEST);\n         mapJulToLog4j(java.util.logging.Level.FINER, Level.TRACE);\n         mapJulToLog4j(java.util.logging.Level.FINE, Level.DEBUG);\n@@ -42,9 +56,9 @@ public DefaultLevelConverter() {\n         mapJulToLog4j(java.util.logging.Level.INFO, Level.INFO);\n         mapJulToLog4j(java.util.logging.Level.WARNING, Level.WARN);\n         mapJulToLog4j(java.util.logging.Level.SEVERE, Level.ERROR);\n-        mapJulToLog4j(java.util.logging.Level.ALL, Level.ALL);\n+        mapJulToLog4j(java.util.logging.Level.OFF, Level.OFF);\n         // Map Log4j to JUL\n-        mapLog4jToJul(Level.OFF, java.util.logging.Level.OFF);\n+        mapLog4jToJul(Level.ALL, java.util.logging.Level.ALL);\n         mapLog4jToJul(LevelTranslator.FINEST, java.util.logging.Level.FINEST);\n         mapLog4jToJul(Level.TRACE, java.util.logging.Level.FINER);\n         mapLog4jToJul(Level.DEBUG, java.util.logging.Level.FINE);\n@@ -53,18 +67,46 @@ public DefaultLevelConverter() {\n         mapLog4jToJul(Level.WARN, java.util.logging.Level.WARNING);\n         mapLog4jToJul(Level.ERROR, java.util.logging.Level.SEVERE);\n         mapLog4jToJul(Level.FATAL, java.util.logging.Level.SEVERE);\n-        mapLog4jToJul(Level.ALL, java.util.logging.Level.ALL);\n+        mapLog4jToJul(Level.OFF, java.util.logging.Level.OFF);\n+        // Sorted Java levels\n+        sortedJulLevels.addAll(julToLog4j.keySet());\n+        Collections.sort(sortedJulLevels, new JulLevelComparator());\n+\n+    }\n+\n+    private Level addCustomJulLevel(java.util.logging.Level customJavaLevel) {\n+        long prevDist = Long.MAX_VALUE;\n+        java.util.logging.Level prevLevel = null;\n+        for (java.util.logging.Level mappedJavaLevel : sortedJulLevels) {\n+            long distance = distance(customJavaLevel, mappedJavaLevel);\n+            if (distance > prevDist) {\n+                return mapCustomJulLevel(customJavaLevel, prevLevel);\n+            }\n+            prevDist = distance;\n+            prevLevel = mappedJavaLevel;\n+        }\n+        return mapCustomJulLevel(customJavaLevel, prevLevel);\n+    }\n+\n+    private long distance(java.util.logging.Level javaLevel, java.util.logging.Level customJavaLevel) {\n+        return Math.abs((long) customJavaLevel.intValue() - (long) javaLevel.intValue());\n+    }\n+\n+    private Level mapCustomJulLevel(java.util.logging.Level customJavaLevel, java.util.logging.Level stdJavaLevel) {\n+        final Level level = julToLog4j.get(stdJavaLevel);\n+        julToLog4j.put(customJavaLevel, level);\n+        return level;\n     }\n \n     /*\n-     * TODO consider making public.\n+     * TODO consider making public for advanced configuration.\n      */\n     private void mapJulToLog4j(java.util.logging.Level julLevel, Level level) {\n         julToLog4j.put(julLevel, level);\n     }\n \n     /*\n-     * TODO consider making public.\n+     * TODO consider making public for advanced configuration.\n      */\n     private void mapLog4jToJul(Level level, java.util.logging.Level julLevel) {\n         log4jToJul.put(level, julLevel);\n@@ -77,6 +119,7 @@ private void mapLog4jToJul(Level level, java.util.logging.Level julLevel) {\n \n     @Override\n     public Level toLevel(final java.util.logging.Level javaLevel) {\n-        return julToLog4j.get(javaLevel);\n+        final Level level = julToLog4j.get(javaLevel);\n+        return level != null ? level : addCustomJulLevel(javaLevel);\n     }\n }\n", "nb_test": 55, "linesAdd": 45, "jira_id": "1025", "singleLine": false, "nb_skipped": 0, "commit": "a96b455c", "nb_failure": 9, "linesRem": 5}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ServerTest.testEscapeQuotesAndEscapesQuote:89 expected:<[\"a\\\"c\"]> but was:<[a\"c]>", "ServerTest.testEscapeQuotesButDoesNotEscapeEquals:35 expected:<\"WebAppClassLoader[]=1320771902@4eb9613e...> but was:<\"WebAppClassLoader[\\]=1320771902@4eb9613e...>", "ServerTest.testEscapeQuotesButDoesNotEscapeColon:53 expected:<\"a[:b]:c\"> but was:<\"a[\\:b\\]:c\">", "ServerTest.testEscapeQuotesButDoesNotEscapeComma:44 expected:<\"a[,b],c\"> but was:<\"a[\\,b\\],c\">"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\nindex 9c66b63..e7af983 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n@@ -74,14 +74,18 @@ public static String escape(final String name) {\n         for (int i = 0; i < name.length(); i++) {\n             final char c = name.charAt(i);\n             switch (c) {\n-            case ',':\n-            case '=':\n-            case ':':\n             case '\\\\':\n             case '*':\n             case '?':\n-                sb.append('\\\\');\n-                needsQuotes = true;\n+            case '\\\"':\n+                sb.append('\\\\'); // quote, star, question & backslash must be escaped\n+                needsQuotes = true; // ... and can only appear in quoted value\n+                break;\n+            case ',':\n+            case '=':\n+            case ':':\n+                needsQuotes = true; // no need to escape these, but value must be quoted\n+                break;\n             }\n             sb.append(c);\n         }\n", "nb_test": 515, "linesAdd": 9, "jira_id": "492", "singleLine": false, "nb_skipped": 1, "commit": "a759d8ae", "nb_failure": 4, "linesRem": 5}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/appender/rolling/helper/FileRenameAction.java b/core/src/main/java/org/apache/logging/log4j/core/appender/rolling/helper/FileRenameAction.java\nindex 0f6c367..5d1cff9 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/appender/rolling/helper/FileRenameAction.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/appender/rolling/helper/FileRenameAction.java\n@@ -16,6 +16,9 @@\n  */\n package org.apache.logging.log4j.core.appender.rolling.helper;\n \n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.status.StatusLogger;\n+\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n@@ -27,6 +30,9 @@\n  * File rename action.\n  */\n public final class FileRenameAction extends ActionBase {\n+\n+    private static final Logger LOGGER = StatusLogger.getLogger();\n+\n     /**\n      * Source.\n      */\n@@ -74,17 +80,31 @@ public boolean execute() {\n      */\n     public static boolean execute(final File source, final File destination, boolean renameEmptyFiles) {\n         if (renameEmptyFiles || (source.length() > 0)) {\n+            File parent = destination.getParentFile();\n+            if (!parent.exists()) {\n+                if (!parent.mkdirs()) {\n+                    LOGGER.error(\"Unable to create directory {}\", parent.getAbsolutePath());\n+                    return false;\n+                }\n+            }\n             try {\n-\n-                boolean result = source.renameTo(destination);\n-                //System.out.println(\"Rename of \" + source.getName() + \" to \" + destination.getName() + \": \" + result);\n-                return result;\n+                if (!source.renameTo(destination)) {\n+                    try {\n+                        copyFile(source, destination);\n+                        return source.delete();\n+                    } catch (IOException iex) {\n+                        LOGGER.error(\"Unable to rename file {} to {} - {}\", source.getAbsolutePath(),\n+                            destination.getAbsolutePath(), iex.getMessage());\n+                    }\n+                }\n+                return true;\n             } catch (Exception ex) {\n                 try {\n                     copyFile(source, destination);\n                     return source.delete();\n                 } catch (IOException iex) {\n-                    iex.printStackTrace();\n+                    LOGGER.error(\"Unable to rename file {} to {} - {}\", source.getAbsolutePath(),\n+                        destination.getAbsolutePath(), iex.getMessage());\n                 }\n             }\n         }\n", "nb_test": 72, "linesAdd": 25, "jira_id": "71", "singleLine": false, "nb_skipped": 0, "commit": "2afe3dff", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FileConfigTest.testReconfiguration:62 Reconfiguration failed expected not same", "TestConfigurator.testReconfiguration:236 Configuration not reset", "LoggerTest.testReconfiguration:210 Reconfiguration failed expected not same"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\nindex fb7efa7..747f809 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\n@@ -242,9 +242,7 @@ public Configuration reconfigure() {\n                 final ConfigurationFactory.ConfigurationSource source =\n                     new ConfigurationFactory.ConfigurationSource(new FileInputStream(configFile), configFile);\n                 final XmlConfiguration config = new XmlConfiguration(source);\n-                if (config.rootElement == null) {\n-                    return null;\n-                }\n+                return (config.rootElement == null) ? null : config;\n             } catch (final FileNotFoundException ex) {\n                 LOGGER.error(\"Cannot locate file \" + configFile, ex);\n             }\n", "nb_test": 659, "linesAdd": 1, "jira_id": "619", "singleLine": false, "nb_skipped": 2, "commit": "3b4b370e", "nb_failure": 3, "linesRem": 3}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testConfig(org.apache.logging.log4j.core.filter.StructuredDataFilterTest): No StructuredDataFilter"], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/filter/StructuredDataFilter.java b/core/src/main/java/org/apache/logging/log4j/core/filter/StructuredDataFilter.java\nindex 26e12a6..6c9a862 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/filter/StructuredDataFilter.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/filter/StructuredDataFilter.java\n@@ -22,6 +22,7 @@\n import org.apache.logging.log4j.core.Logger;\n import org.apache.logging.log4j.core.config.plugins.Plugin;\n import org.apache.logging.log4j.core.config.plugins.PluginAttr;\n+import org.apache.logging.log4j.core.config.plugins.PluginElement;\n import org.apache.logging.log4j.core.config.plugins.PluginFactory;\n import org.apache.logging.log4j.core.helpers.KeyValuePair;\n import org.apache.logging.log4j.message.Message;\n@@ -98,7 +99,7 @@ private String getValue(StructuredDataMessage data, String key) {\n      * @return The StructuredDataFilter.\n      */\n     @PluginFactory\n-    public static StructuredDataFilter createFilter(@PluginAttr(\"pairs\") KeyValuePair[] pairs,\n+    public static StructuredDataFilter createFilter(@PluginElement(\"pairs\") KeyValuePair[] pairs,\n                                                     @PluginAttr(\"operator\") String oper,\n                                                     @PluginAttr(\"onmatch\") String match,\n                                                     @PluginAttr(\"onmismatch\") String mismatch) {\n", "nb_test": 104, "linesAdd": 2, "jira_id": "113", "singleLine": false, "nb_skipped": 0, "commit": "fc3e9d2d", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["PropertiesConfigurationRootLoggerOnlyTest.testPropertiesConfiguration:45 \u00bb NullPointer"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\nindex 50f9285..27644d8 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\n@@ -130,7 +130,7 @@ public PropertiesConfiguration getConfiguration(ConfigurationSource source) {\n             }\n         }\n         String loggerProp = properties.getProperty(\"loggers\");\n-        if (appenderProp != null) {\n+        if (loggerProp != null) {\n             String[] loggerNames = loggerProp.split(\",\");\n             for (String loggerName : loggerNames) {\n                 String name = loggerName.trim();\n@@ -343,7 +343,6 @@ private LayoutComponentBuilder createLayout(ConfigurationBuilder<PropertiesConfi\n         return componentBuilder;\n     }\n \n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n     private void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {\n         while (properties.size() > 0) {\n             String propertyName = properties.stringPropertyNames().iterator().next();\n", "nb_test": 919, "linesAdd": 1, "jira_id": "1153", "singleLine": false, "nb_skipped": 3, "commit": "9f924f10", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["MarkerTest.testContainsMarker:53 \u00bb NullPointer"], "patch": "diff --git a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\nindex 50d126c..c2273f5 100644\n--- a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n+++ b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n@@ -85,6 +85,9 @@ public boolean hasChildren() {\n \r\n     @Override\r\n \tpublic boolean contains(final org.slf4j.Marker marker) {\r\n+\t\tif (marker == null) {\r\n+\t\t\tthrow new IllegalArgumentException();\r\n+\t\t}\r\n \t\treturn this.marker.isInstanceOf(marker.getName());\r\n \t}\r\n \r\n", "nb_test": 18, "linesAdd": 3, "jira_id": "1058", "singleLine": false, "nb_skipped": 0, "commit": "c8fd3c53", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["TestNoMsg(org.apache.logging.log4j.core.filter.RegexFilterTest)"], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/filter/RegexFilter.java b/core/src/main/java/org/apache/logging/log4j/core/filter/RegexFilter.java\nindex ae41b86..56d8ec6 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/filter/RegexFilter.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/filter/RegexFilter.java\n@@ -57,12 +57,18 @@ public Result filter(final Logger logger, final Level level, final Marker marker\n     @Override\n     public Result filter(final Logger logger, final Level level, final Marker marker, final Object msg,\n                          final Throwable t) {\n+        if (msg == null) {\n+            return onMismatch;\n+        }\n         return filter(msg.toString());\n     }\n \n     @Override\n     public Result filter(final Logger logger, final Level level, final Marker marker, final Message msg,\n                          final Throwable t) {\n+        if (msg == null) {\n+            return onMismatch;\n+        }\n         final String text = useRawMessage ? msg.getFormat() : msg.getFormattedMessage();\n         return filter(text);\n     }\n", "nb_test": 183, "linesAdd": 6, "jira_id": "234", "singleLine": false, "nb_skipped": 0, "commit": "2d7d6311", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ServerTest.testEscapeEscapesLineFeed:107 expected:<a[]c> but was:<a[\\r]c>", "ServerTest.testEscapeEscapesCarriageReturn:116 expected:<[\"a\\nc\"]> but was:<[a\\nc]>"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\nindex 898e5e1..e2c03f9 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n@@ -88,12 +88,12 @@ public static String escape(final String name) {\n                 needsQuotes = true;\n                 break;\n             case '\\r':\n-                // replace by \\\\r, no need to quote\n-                sb.append(\"\\\\r\");\n+                // drop \\r characters: \\\\r gives \"invalid escape sequence\"\n                 continue;\n             case '\\n':\n-                // replace by \\\\n, no need to quote\n+                // replace \\n characters with \\\\n sequence\n                 sb.append(\"\\\\n\");\n+                needsQuotes = true;\n                 continue;\n             }\n             sb.append(c);\n@@ -260,13 +260,14 @@ public static void unregisterContext(String loggerContextName) {\n      */\n     public static void unregisterContext(String contextName, MBeanServer mbs) {\n         final String pattern = LoggerContextAdminMBean.PATTERN;\n-        final String search = String.format(pattern, contextName, \"*\");\n+        final String safeContextName = escape(contextName);\n+        final String search = String.format(pattern, safeContextName, \"*\");\n         unregisterAllMatching(search, mbs); // unregister context mbean\n-        unregisterLoggerConfigs(contextName, mbs);\n-        unregisterAppenders(contextName, mbs);\n-        unregisterAsyncAppenders(contextName, mbs);\n-        unregisterAsyncLoggerRingBufferAdmins(contextName, mbs);\n-        unregisterAsyncLoggerConfigRingBufferAdmins(contextName, mbs);\n+        unregisterLoggerConfigs(safeContextName, mbs);\n+        unregisterAppenders(safeContextName, mbs);\n+        unregisterAsyncAppenders(safeContextName, mbs);\n+        unregisterAsyncLoggerRingBufferAdmins(safeContextName, mbs);\n+        unregisterAsyncLoggerConfigRingBufferAdmins(safeContextName, mbs);\n     }\n \n     private static void registerStatusLogger(final MBeanServer mbs, final Executor executor)\n", "nb_test": 527, "linesAdd": 8, "jira_id": "492", "singleLine": false, "nb_skipped": 1, "commit": "61ccbb95", "nb_failure": 2, "linesRem": 7}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["VelocityTest.testVelocity:33 \u00bb NoSuchMethod org.apache.log4j.PatternLayout.<in..."], "patch": "diff --git a/log4j-1.2-api/src/main/java/org/apache/log4j/PatternLayout.java b/log4j-1.2-api/src/main/java/org/apache/log4j/PatternLayout.java\nindex 7595f75..a1d77c7 100644\n--- a/log4j-1.2-api/src/main/java/org/apache/log4j/PatternLayout.java\n+++ b/log4j-1.2-api/src/main/java/org/apache/log4j/PatternLayout.java\n@@ -23,6 +23,10 @@\n  */\n public class PatternLayout extends Layout {\n \n+    public PatternLayout(String pattern) {\n+\n+    }\n+\n     @Override\n     public String format(final LoggingEvent event) {\n         return \"\";\n", "nb_test": 64, "linesAdd": 4, "jira_id": "368", "singleLine": false, "nb_skipped": 0, "commit": "a8a24357", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ObjectMessageTest.testDeserializeNonSerializableParamEqualIfToStringSame:90 expected: org.apache.logging.log4j.message.ObjectMessage<ObjectMessage[obj=org.apache.logging.log4j.message.ObjectMessageTest$1NonSerializable@1d508393]> but was: org.apache.logging.log4j.message.ObjectMessage<ObjectMessage[obj=org.apache.logging.log4j.message.ObjectMessageTest$1NonSerializable@1d508393]>"], "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\nindex 021adcc..3441edb 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\n@@ -83,7 +83,11 @@ public boolean equals(final Object o) {\n         }\n \n         final ObjectMessage that = (ObjectMessage) o;\n-        return obj == null ? that.obj == null : obj.equals(that.obj);\n+        return obj == null ? that.obj == null : equalObjectsOrStrings(obj, that.obj);\n+    }\n+    \n+    private boolean equalObjectsOrStrings(Object left, Object right) {\n+        return left.equals(right) || String.valueOf(left).equals(String.valueOf(right));\n     }\n \n     @Override\n", "nb_test": 204, "linesAdd": 5, "jira_id": "763", "singleLine": false, "nb_skipped": 2, "commit": "b2ec5106", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ExtendedThrowablePatternConverterTest.testDeserializedLogEventWithThrowableProxyButNoThrowable:49"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java\nindex 3897721..2357093 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java\n@@ -64,7 +64,7 @@ public void format(final LogEvent event, final StringBuilder toAppendTo) {\n             proxy = ((Log4jLogEvent) event).getThrownProxy();\n         }\n         final Throwable throwable = event.getThrown();\n-        if (throwable != null && options.anyLines()) {\n+        if ((throwable != null || proxy != null) && options.anyLines()) {\n             if (proxy == null) {\n                 super.format(event, toAppendTo);\n                 return;\n", "nb_test": 767, "linesAdd": 1, "jira_id": "1068", "singleLine": false, "nb_skipped": 2, "commit": "e7bbeceb", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "logging-log4j2", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["AsyncLoggerUseAfterShutdownTest.testNoErrorIfLogAfterShutdown:59 \u00bb NullPointer", "AsyncLoggerConfigUseAfterShutdownTest.testNoErrorIfLogAfterShutdown:44 \u00bb NullPointer"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java\nindex b99608c..c832973 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java\n@@ -231,9 +231,15 @@ public void logMessage(final String fqcn, final Level level, final Marker marker\n             threadlocalInfo.set(info);\n         }\n         \n+        Disruptor<RingBufferLogEvent> temp = disruptor;\n+        if (temp == null) { // LOG4J2-639\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down\");\n+            return;\n+        }\n+\n         // LOG4J2-471: prevent deadlock when RingBuffer is full and object\n         // being logged calls Logger.log() from its toString() method\n-        if (info.isAppenderThread && disruptor.getRingBuffer().remainingCapacity() == 0) {\n+        if (info.isAppenderThread && temp.getRingBuffer().remainingCapacity() == 0) {\n             // bypass RingBuffer and invoke Appender directly\n             config.loggerConfig.log(getName(), fqcn, marker, level, message, thrown);\n             return;\n@@ -266,7 +272,15 @@ public void logMessage(final String fqcn, final Level level, final Marker marker\n                 // CachedClock: 10% faster than system clock, smaller gaps\n                 clock.currentTimeMillis());\n \n+        // LOG4J2-639: catch NPE if disruptor field was set to null after our check above\n+        try {\n+            // Note: do NOT use the temp variable above!\n+            // That could result in adding a log event to the disruptor after it was shut down,\n+            // which could cause the publishEvent method to hang and never return.\n             disruptor.publishEvent(info.translator);\n+        } catch (NullPointerException npe) {\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down.\");\n+        }\n     }\n \n     private static StackTraceElement location(final String fqcnOfLogger) {\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java\nindex 9d2f4f0..2e8814c 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java\n@@ -316,16 +316,29 @@ public void run() {\n      *          calling thread needs to process the event itself\n      */\n     public boolean callAppendersFromAnotherThread(final LogEvent event) {\n+        Disruptor<Log4jEventWrapper> temp = disruptor;\n+        if (temp == null) { // LOG4J2-639\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down\");\n+            return true;\n+        }\n \n         // LOG4J2-471: prevent deadlock when RingBuffer is full and object\n         // being logged calls Logger.log() from its toString() method\n         if (isAppenderThread.get() == Boolean.TRUE //\n-                && disruptor.getRingBuffer().remainingCapacity() == 0) {\n+                && temp.getRingBuffer().remainingCapacity() == 0) {\n \n             // bypass RingBuffer and invoke Appender directly\n             return false;\n         }\n+        // LOG4J2-639: catch NPE if disruptor field was set to null after our check above\n+        try {\n+            // Note: do NOT use the temp variable above!\n+            // That could result in adding a log event to the disruptor after it was shut down,\n+            // which could cause the publishEvent method to hang and never return.\n             disruptor.getRingBuffer().publishEvent(translator, event, asyncLoggerConfig);\n+        } catch (NullPointerException npe) {\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down.\");\n+        }\n         return true;\n     }\n \n", "nb_test": 565, "linesAdd": 21, "jira_id": "639", "singleLine": false, "nb_skipped": 2, "commit": "a5a1f1a2", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testPatternWithConfiguration(org.apache.logging.log4j.core.pattern.MessagePatternConverterTest)"], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/pattern/MessagePatternConverter.java b/core/src/main/java/org/apache/logging/log4j/core/pattern/MessagePatternConverter.java\nindex 8db9313..c3850b3 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/pattern/MessagePatternConverter.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/pattern/MessagePatternConverter.java\n@@ -67,8 +67,12 @@ public void format(final LogEvent event, final StringBuilder toAppendTo) {\n             } else {\n                 result = msg.getFormattedMessage();\n             }\n+            if (result != null) {\n                 toAppendTo.append(config != null && result.contains(\"${\") ?\n                     config.getSubst().replace(event, result) : result);\n+            } else {\n+                toAppendTo.append(\"null\");\n+            }\n         }\n     }\n }\n", "nb_test": 112, "linesAdd": 4, "jira_id": "143", "singleLine": false, "nb_skipped": 0, "commit": "1461f1f6", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java b/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\nindex 0819211..13cf5bb 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n@@ -107,7 +107,7 @@ public String lookup(LogEvent event, String var) {\n             if (value != null) {\n                 return value;\n             }\n-            var = var.substring(prefixPos);\n+            var = var.substring(prefixPos + 1);\n         }\n         if (defaultLookup != null) {\n             return event == null ? defaultLookup.lookup(var) : defaultLookup.lookup(event, var);\n", "nb_test": 87, "linesAdd": 1, "jira_id": "94", "singleLine": false, "nb_skipped": 0, "commit": "d8af1c93", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ThrowableProxyTest.testSerialization_getExtendedStackTraceAsString:146 \u00bb NullPointer"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\nindex 2d0941f..1d3af2a 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n@@ -342,7 +342,8 @@ public String getExtendedStackTraceAsString(final List<String> ignorePackages) {\n             sb.append(\": \").append(msg);\n         }\n         sb.append(EOL);\n-        this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, ignorePackages);\n+        StackTraceElement[] causedTrace = this.throwable != null ? this.throwable.getStackTrace() : null;\n+        this.formatElements(sb, 0, causedTrace, this.extendedStackTrace, ignorePackages);\n         this.formatCause(sb, this.causeProxy, ignorePackages);\n         return sb.toString();\n     }\n", "nb_test": 745, "linesAdd": 2, "jira_id": "914", "singleLine": false, "nb_skipped": 2, "commit": "f8a42197", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["Log4jLevelTranslatorTest.testToJavaLevel:64 expected:<SEVERE> but was:<null>"], "patch": "diff --git a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\nindex 01d5aa3..b79478b 100644\n--- a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\n+++ b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\n@@ -32,7 +32,7 @@\n     private final Map<java.util.logging.Level, Level> JDK_TO_LOG4J =\n         new IdentityHashMap<java.util.logging.Level, Level>(9);\n     private final Map<Level, java.util.logging.Level> LOG4J_TO_JDK =\n-        new IdentityHashMap<Level, java.util.logging.Level>(9);\n+        new IdentityHashMap<Level, java.util.logging.Level>(10);\n \n     public DefaultLevelConverter() {\n         JDK_TO_LOG4J.put(java.util.logging.Level.OFF, Level.OFF);\n@@ -52,6 +52,7 @@ public DefaultLevelConverter() {\n         LOG4J_TO_JDK.put(Level.INFO, java.util.logging.Level.INFO);\n         LOG4J_TO_JDK.put(Level.WARN, java.util.logging.Level.WARNING);\n         LOG4J_TO_JDK.put(Level.ERROR, java.util.logging.Level.SEVERE);\n+        LOG4J_TO_JDK.put(Level.FATAL, java.util.logging.Level.SEVERE);\n         LOG4J_TO_JDK.put(Level.ALL, java.util.logging.Level.ALL);\n     }\n \n", "nb_test": 46, "linesAdd": 2, "jira_id": "892", "singleLine": false, "nb_skipped": 0, "commit": "f9b0bbee", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/net/Priority.java b/core/src/main/java/org/apache/logging/log4j/core/net/Priority.java\nindex 0e83dfa..00144e2 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/net/Priority.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/net/Priority.java\n@@ -43,7 +43,7 @@ public Priority(Facility facility, Severity severity) {\n      * @return The integer value of the priority.\n      */\n     public static int getPriority(Facility facility, Level level) {\n-        return facility.getCode() << 3 + Severity.getSeverity(level).getCode();\n+        return (facility.getCode() << 3) + Severity.getSeverity(level).getCode();\n     }\n \n     /**\n", "nb_test": 89, "linesAdd": 1, "jira_id": "102", "singleLine": false, "nb_skipped": 0, "commit": "7f391872", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["MarkerTest.testRemoveNullMarker:105 \u00bb NullPointer"], "patch": "diff --git a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\nindex c2273f5..d57cf19 100644\n--- a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n+++ b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n@@ -56,7 +56,7 @@ public void add(final Marker marker) {\n \r\n     @Override\r\n \tpublic boolean remove(final Marker marker) {\r\n-        return this.marker.remove(MarkerManager.getMarker(marker.getName()));\r\n+\t\treturn marker != null ? this.marker.remove(MarkerManager.getMarker(marker.getName())) : false;\r\n \t}\r\n \r\n     @Override\r\n", "nb_test": 19, "linesAdd": 1, "jira_id": "1061", "singleLine": false, "nb_skipped": 0, "commit": "86d8944f", "nb_failure": 0, "linesRem": 1}, {"files": 3, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["RollingRandomAccessFileManagerHeaderFooterTest.testAppender:68->assertHeader:82 rolled1.log expected:<[<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">", "<html>", "<head>", "<meta charset=\"UTF-8\"/>", "<title>Log4j Log Messages</title>", "<style type=\"text/css\">", "<!--", "body, table {font-family:arial,sans-serif; font-size: medium;}", "th {background: #336699; color: #FFFFFF; text-align: left;}", "-->", "</style>", "</head>", "<body bgcolor=\"#FFFFFF\" topmargin=\"6\" leftmargin=\"6\">", "<hr size=\"1\" noshade>", "Log session]> but was:<[", "<tr>", "<td>616</td>", "<td title=\"main thread\">main</td>", "<td title=\"Level\"><font color=\"#339933\">DEBUG</font></td>", "<td title=\"org.apache.logging.log4j.core.appender.rolling.RollingRandomAccessFileManagerHeaderFooterTest logger\">org.apache.logging.log4j.core.appender.rolling.RollingRandomAccessFileManagerHeaderFooterTest</td>", "<td title=\"Message\">This is test message number 0</td>", "</tr>", "<tr>", "<td>617</td>", "<td title=\"main thread\">main</td]>"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\nindex 246abba..0065585 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\n@@ -28,8 +28,7 @@\n public class OutputStreamManager extends AbstractManager {\n \n     private volatile OutputStream os;\n-\n-    private final Layout<?> layout;\n+    protected final Layout<?> layout;\n \n     protected OutputStreamManager(final OutputStream os, final String streamName, final Layout<?> layout) {\n         super(streamName);\n@@ -66,11 +65,21 @@ protected OutputStreamManager(final OutputStream os, final String streamName, fi\n      */\n     @Override\n     public void releaseSub() {\n+        writeFooter();\n+        close();\n+    }\n+\n+    /**\n+     * Writes the footer.\n+     */\n+    protected void writeFooter() {\n+        if (layout == null) {\n+            return;\n+        }\n         byte[] footer = layout.getFooter();\n         if (footer != null) {\n             write(footer);\n         }\n-        close();\n     }\n \n     /**\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java\nindex c58b18c..3184702 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java\n@@ -167,6 +167,7 @@ private boolean rollover(final RolloverStrategy strategy) {\n         try {\n             final RolloverDescription descriptor = strategy.rollover(this);\n             if (descriptor != null) {\n+                writeFooter();\n                 close();\n                 if (descriptor.getSynchronous() != null) {\n                     LOGGER.debug(\"RollingFileManager executing synchronous {}\", descriptor.getSynchronous());\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingRandomAccessFileManager.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingRandomAccessFileManager.java\nindex cc63bfe..992ab09 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingRandomAccessFileManager.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingRandomAccessFileManager.java\n@@ -55,6 +55,26 @@ public RollingRandomAccessFileManager(final RandomAccessFile raf, final String f\n         this.randomAccessFile = raf;\n         isEndOfBatch.set(Boolean.FALSE);\n         this.buffer = ByteBuffer.allocate(bufferSize);\n+        writeHeader();\n+    }\n+\n+    /**\n+     * Writes the layout's header to the file if it exists.\n+     */\n+    private void writeHeader() {\n+        if (layout == null) {\n+            return;\n+        }\n+        byte[] header = layout.getHeader();\n+        if (header == null) {\n+            return;\n+        }\n+        try {\n+            // write to the file, not to the buffer: the buffer may not be empty\n+            randomAccessFile.write(header, 0, header.length);\n+        } catch (final IOException ioe) {\n+            LOGGER.error(\"Unable to write header\", ioe);\n+        }\n     }\n \n     public static RollingRandomAccessFileManager getRollingRandomAccessFileManager(final String fileName,\n@@ -99,6 +119,7 @@ protected void createFileAfterRollover() throws IOException {\n         if (isAppend()) {\n             randomAccessFile.seek(randomAccessFile.length());\n         }\n+        writeHeader();\n     }\n \n     @Override\n", "nb_test": 660, "linesAdd": 27, "jira_id": "581", "singleLine": false, "nb_skipped": 2, "commit": "bb02fa15", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["NoSQLDatabaseManagerTest.testConnection:74", "Unexpected method call NoSQLConnection.isClosed():"], "patch": "diff --git a/log4j-nosql/src/main/java/org/apache/logging/log4j/nosql/appender/NoSQLDatabaseManager.java b/log4j-nosql/src/main/java/org/apache/logging/log4j/nosql/appender/NoSQLDatabaseManager.java\nindex 6f2ea26..d3c5b37 100644\n--- a/log4j-nosql/src/main/java/org/apache/logging/log4j/nosql/appender/NoSQLDatabaseManager.java\n+++ b/log4j-nosql/src/main/java/org/apache/logging/log4j/nosql/appender/NoSQLDatabaseManager.java\n@@ -51,6 +51,7 @@ protected void startupInternal() {\n \n     @Override\n     protected void shutdownInternal() {\n+        // NoSQL doesn't use transactions, so all we need to do here is simply close the client\n         Closer.closeSilent(this.connection);\n     }\n \n@@ -155,13 +156,10 @@ protected void writeInternal(final LogEvent event) {\n \n     @Override\n     protected void commitAndClose() {\n-        try {\n-            if (this.connection != null && !this.connection.isClosed()) {\n-                this.connection.close();\n-            }\n-        } catch (Exception e) {\n-            throw new AppenderLoggingException(\"Failed to commit and close NoSQL connection in manager.\", e);\n-        }\n+        // all NoSQL drivers auto-commit (since NoSQL doesn't generally use the concept of transactions).\n+        // also, all our NoSQL drivers use internal connection pooling and provide clients, not connections.\n+        // thus, we should not be closing the client until shutdown as NoSQL is very different from SQL.\n+        // see LOG4J2-591 and LOG4J2-676\n     }\n \n     private NoSQLObject<W>[] convertStackTrace(final StackTraceElement[] stackTrace) {\n", "nb_test": 9, "linesAdd": 0, "jira_id": "676", "singleLine": false, "nb_skipped": 0, "commit": "3b2e880e", "nb_failure": 1, "linesRem": 7}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ServerTest.testEscapeEscapesCarriageReturn:117 \u00bb MalformedObjectName Invalid c..."], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\nindex 537b029..898e5e1 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n@@ -87,6 +87,14 @@ public static String escape(final String name) {\n                 // no need to escape these, but value must be quoted\n                 needsQuotes = true;\n                 break;\n+            case '\\r':\n+                // replace by \\\\r, no need to quote\n+                sb.append(\"\\\\r\");\n+                continue;\n+            case '\\n':\n+                // replace by \\\\n, no need to quote\n+                sb.append(\"\\\\n\");\n+                continue;\n             }\n             sb.append(c);\n         }\n", "nb_test": 516, "linesAdd": 6, "jira_id": "492", "singleLine": false, "nb_skipped": 1, "commit": "24a3bed4", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["InterpolatorTest.testLookupWithDefaultInterpolator:96 No Date"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\nindex a768f4e..f50293f 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n@@ -71,6 +71,8 @@ public Interpolator(Map<String, String> properties) {\n         lookups.put(\"sys\", new SystemPropertiesLookup());\n         lookups.put(\"env\", new EnvironmentLookup());\n         lookups.put(\"jndi\", new JndiLookup());\n+        lookups.put(\"date\", new DateLookup());\n+        lookups.put(\"ctx\", new ContextMapLookup());\n         try {\n             if (Class.forName(\"javax.servlet.ServletContext\") != null) {\n                 lookups.put(\"web\", new WebLookup());\n", "nb_test": 531, "linesAdd": 2, "jira_id": "378", "singleLine": false, "nb_skipped": 1, "commit": "ef8517e4", "nb_failure": 1, "linesRem": 0}, {"files": 7, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ObjectMessageTest.testSafeWithMutableParams:51 Should use initial param value expected:<[abc]> but was:<[XYZ]>", "StringFormattedMessageTest.testSafeWithMutableParams:73 Should use initial param value expected:<Test message [abc]> but was:<Test message [XYZ]>", "MessageFormatMessageTest.testSafeWithMutableParams:74 Should use initial param value expected:<Test message [abc]> but was:<Test message [XYZ]>", "FormattedMessageTest.testSafeWithMutableParams:96 Should use initial param value expected:<Test message [abc]> but was:<Test message [XYZ]>", "LocalizedMessageTest.testSafeWithMutableParams:76 Should use initial param value expected:<Test message [abc]> but was:<Test message [XYZ]>"], "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/FormattedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/FormattedMessage.java\nindex 1c540dd..3ca4b82 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/FormattedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/FormattedMessage.java\n@@ -46,12 +46,11 @@ public FormattedMessage(final String messagePattern, final Object[] arguments, f\n         this.messagePattern = messagePattern;\n         this.argArray = arguments;\n         this.throwable = throwable;\n+        getFormattedMessage(); // LOG4J2-763 take snapshot of parameters at message construction time\n     }\n \n     public FormattedMessage(final String messagePattern, final Object[] arguments) {\n-        this.messagePattern = messagePattern;\n-        this.argArray = arguments;\n-        this.throwable = null;\n+        this(messagePattern, arguments, null);\n     }\n \n     /**\n@@ -60,9 +59,7 @@ public FormattedMessage(final String messagePattern, final Object[] arguments) {\n      * @param arg The parameter.\n      */\n     public FormattedMessage(final String messagePattern, final Object arg) {\n-        this.messagePattern = messagePattern;\n-        this.argArray = new Object[] {arg};\n-        this.throwable = null;\n+        this(messagePattern, new Object[] {arg}, null);\n     }\n \n     /**\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\nindex c6839b8..2a2246b 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\n@@ -78,6 +78,7 @@ public LocalizedMessage(final String baseName, final Locale locale, final String\n         this.baseName = baseName;\n         this.resourceBundle = null;\n         this.locale = locale;\n+        getFormattedMessage(); // LOG4J2-763 take snapshot of parameters at message construction time\n     }\n \n     public LocalizedMessage(final ResourceBundle bundle, final Locale locale, final String key,\n@@ -88,6 +89,7 @@ public LocalizedMessage(final ResourceBundle bundle, final Locale locale, final\n         this.baseName = null;\n         this.resourceBundle = bundle;\n         this.locale = locale;\n+        getFormattedMessage(); // LOG4J2-763 take snapshot of parameters at message construction time\n     }\n \n     public LocalizedMessage(final Locale locale, final String key, final Object[] arguments) {\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\nindex db6826a..4cbef35 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\n@@ -26,6 +26,11 @@\n \n /**\n  * Represents a Message that consists of a Map.\n+ * <p>\n+ * Thread-safety note: the contents of this message can be modified after construction.\n+ * When using asynchronous loggers and appenders it is not recommended to modify this message after the message is\n+ * logged, because it is undefined whether the logged message string will contain the old values or the modified\n+ * values.\n  */\n public class MapMessage implements MultiformatMessage {\n     /**\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/MessageFormatMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/MessageFormatMessage.java\nindex 0493b0f..f728324 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/MessageFormatMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/MessageFormatMessage.java\n@@ -49,6 +49,7 @@ public MessageFormatMessage(final String messagePattern, final Object... argumen\n         if (arguments != null && arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable) {\n             this.throwable = (Throwable) arguments[arguments.length - 1];\n         }\n+        getFormattedMessage(); // LOG4J2-763 take snapshot of parameters at message construction time\n     }\n \n     /**\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\nindex 27f288e..dcccf46 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\n@@ -29,6 +29,7 @@\n     private static final long serialVersionUID = -5903272448334166185L;\n \n     private transient Object obj;\n+    private final String objectString;\n \n     /**\n      * Create the ObjectMessage.\n@@ -39,6 +40,9 @@ public ObjectMessage(Object obj) {\n             obj = \"null\";\n         }\n         this.obj = obj;\n+        \n+        // LOG4J2-763: take snapshot of parameters at message construction time\n+        objectString = String.valueOf(obj);\n     }\n \n     /**\n@@ -47,7 +51,7 @@ public ObjectMessage(Object obj) {\n      */\n     @Override\n     public String getFormattedMessage() {\n-        return obj.toString();\n+        return objectString;\n     }\n \n     /**\n@@ -56,7 +60,7 @@ public String getFormattedMessage() {\n      */\n     @Override\n     public String getFormat() {\n-        return obj.toString();\n+        return objectString;\n     }\n \n     /**\n@@ -89,7 +93,7 @@ public int hashCode() {\n \n     @Override\n     public String toString() {\n-        return \"ObjectMessage[obj=\" + obj.toString() + ']';\n+        return \"ObjectMessage[obj=\" + objectString + ']';\n     }\n \n     private void writeObject(final ObjectOutputStream out) throws IOException {\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\nindex f6007e4..91df370 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\n@@ -48,6 +48,7 @@ public StringFormattedMessage(final String messagePattern, final Object... argum\n         if (arguments != null && arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable) {\n             this.throwable = (Throwable) arguments[arguments.length - 1];\n         }\n+        getFormattedMessage(); // LOG4J2-763 take snapshot of parameters at message construction time\n     }\n \n     /**\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\nindex 246e11b..f6300ee 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\n@@ -22,6 +22,11 @@\n \n /**\n  * Represents a Message that conforms to an RFC 5424 StructuredData element along with the syslog message.\n+ * <p>\n+ * Thread-safety note: the contents of this message can be modified after construction.\n+ * When using asynchronous loggers and appenders it is not recommended to modify this message after the message is\n+ * logged, because it is undefined whether the logged message string will contain the old values or the modified\n+ * values.\n  *\n  * @see <a href=\"https://tools.ietf.org/html/rfc5424\">RFC 5424</a>\n  */\n", "nb_test": 197, "linesAdd": 13, "jira_id": "763", "singleLine": false, "nb_skipped": 2, "commit": "97203de8", "nb_failure": 5, "linesRem": 9}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SMTPAppenderTest.testDelivery:156 null"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/SMTPManager.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/SMTPManager.java\nindex dd0b7fb..ebd45e1 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/SMTPManager.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/SMTPManager.java\n@@ -136,9 +136,8 @@ public void sendEvents(final Layout<?> layout, final LogEvent appendEvent) {\n         }\n         try {\n             final LogEvent[] priorEvents = buffer.removeAll();\n-            if (priorEvents == null || priorEvents.length == 0) {\n-                return; // nothing to do, another thread already took all events\n-            }\n+            // LOG4J-310: log appendEvent even if priorEvents is empty\n+            \n             final byte[] rawBytes = formatContentToBytes(priorEvents, appendEvent, layout);\n \n             final String contentType = layout.getContentType();\n", "nb_test": 413, "linesAdd": 1, "jira_id": "310", "singleLine": false, "nb_skipped": 5, "commit": "3f1e0fdc", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["AsyncLoggerConfigTest.testIncludeLocationDefaultsToFalse:71 Include location should default to false for async logggers"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfig.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfig.java\nindex 9e1cd9a..f87d4e3 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfig.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfig.java\n@@ -236,7 +236,7 @@ public static LoggerConfig createLogger(\n \n             return new AsyncLoggerConfig(LogManager.ROOT_LOGGER_NAME,\n                     appenderRefs, filter, level, additive, properties, config,\n-                    includeLocation(includeLocation));\n+                    AsyncLoggerConfig.includeLocation(includeLocation));\n         }\n     }\n }\n", "nb_test": 755, "linesAdd": 1, "jira_id": "991", "singleLine": false, "nb_skipped": 2, "commit": "3cee912e", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FileUtilsTest.testFileFromUriWithPlusCharactersInName:37 expected:<log4j[+config+with+plus+]characters.xml> but was:<log4j[ config with plus ]characters.xml>"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/FileUtils.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/FileUtils.java\nindex 5752f77..2e38b52 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/FileUtils.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/FileUtils.java\n@@ -63,7 +63,11 @@ public static File fileFromURI(URI uri) {\n             }\n         }\n         try {\n-            return new File(URLDecoder.decode(uri.toURL().getFile(), \"UTF8\"));\n+            String fileName = uri.toURL().getFile();\n+            if (new File(fileName).exists()) {\n+                return new File(fileName);\n+            }\n+            return new File(URLDecoder.decode(fileName, \"UTF8\"));\n         } catch (final MalformedURLException ex) {\n             LOGGER.warn(\"Invalid URL \" + uri, ex);\n         } catch (final UnsupportedEncodingException uee) {\n", "nb_test": 491, "linesAdd": 5, "jira_id": "466", "singleLine": false, "nb_skipped": 8, "commit": "7b9e48e8", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["JndiLookupTest.testNonStringLookup:82 \u00bb ClassCast java.lang.Integer cannot be ..."], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/JndiLookup.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/JndiLookup.java\nindex d7d50cb..1cd4290 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/JndiLookup.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/JndiLookup.java\n@@ -52,7 +52,7 @@ public String lookup(final LogEvent event, final String key) {\n         final String jndiName = convertJndiName(key);\n         final JndiManager jndiManager = JndiManager.getDefaultManager();\n         try {\n-            return jndiManager.lookup(jndiName);\n+            return String.valueOf(jndiManager.lookup(jndiName));\n         } catch (final NamingException e) {\n             LOGGER.warn(LOOKUP, \"Error looking up JNDI resource [{}].\", jndiName, e);\n             return null;\n", "nb_test": 1114, "linesAdd": 1, "jira_id": "1310", "singleLine": false, "nb_skipped": 3, "commit": "c6318b63", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["TestConfigurator.testFromClassPathWithClassLoaderPrefix:154 NullPointer", "TestConfigurator.testFromClassPathWithClassPathPrefix:138 NullPointer"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\nindex 7873c79..8490196 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\n@@ -88,6 +88,18 @@\n      */\n     protected static final String DEFAULT_PREFIX = \"log4j2\";\n \n+    /**\n+     * The name of the classloader URI scheme.\n+     */\n+    private static final String CLASS_LOADER_SCHEME = \"classloader\";\n+    private static final int CLASS_LOADER_SCHEME_LENGTH = CLASS_LOADER_SCHEME.length() + 1;\n+\n+    /**\n+     * The name of the classpath URI scheme, synonymous with the classloader URI scheme.\n+     */\n+    private static final String CLASS_PATH_SCHEME = \"classpath\";\n+    private static final int CLASS_PATH_SCHEME_LENGTH = CLASS_PATH_SCHEME.length() + 1;\n+\n     private static volatile List<ConfigurationFactory> factories = null;\n \n     private static ConfigurationFactory configFactory = new Factory();\n@@ -221,9 +233,19 @@ protected ConfigurationSource getInputFromURI(final URI configLocation) {\n             }\n         }\n         final String scheme = configLocation.getScheme();\n-        if (scheme == null || scheme.equals(\"classloader\")) {\n+        final boolean isClassLoaderScheme = scheme != null && scheme.equals(CLASS_LOADER_SCHEME);\n+        final boolean isClassPathScheme = scheme != null && !isClassLoaderScheme && scheme.equals(CLASS_PATH_SCHEME);\n+        if (scheme == null || isClassLoaderScheme || isClassPathScheme) {\n             final ClassLoader loader = this.getClass().getClassLoader();\n-            final ConfigurationSource source = getInputFromResource(configLocation.getPath(), loader);\n+            String path;\n+            if (isClassLoaderScheme) {\n+                path = configLocation.toString().substring(CLASS_LOADER_SCHEME_LENGTH);\n+            } else if (isClassPathScheme) {\n+                path = configLocation.toString().substring(CLASS_PATH_SCHEME_LENGTH);\n+            } else {\n+                path = configLocation.getPath();\n+            }\n+            final ConfigurationSource source = getInputFromResource(path, loader);\n             if (source != null) {\n                 return source;\n             }\n@@ -365,7 +387,7 @@ public Configuration getConfiguration(final String name, final URI configLocatio\n                     final String[] types = factory.getSupportedTypes();\n                     if (types != null) {\n                         for (final String type : types) {\n-                            if (type.equals(\"*\") || configLocation.getPath().endsWith(type)) {\n+                            if (type.equals(\"*\") || configLocation.toString().endsWith(type)) {\n                                 final Configuration config = factory.getConfiguration(name, configLocation);\n                                 if (config != null) {\n                                     return config;\n", "nb_test": 417, "linesAdd": 19, "jira_id": "293", "singleLine": false, "nb_skipped": 5, "commit": "25cb587a", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["XmlFileAppenderTest.testFlushAtEndOfBatch:65 line1", "XmlCompactFileAppenderTest.testFlushAtEndOfBatch:60 line1", "XmlCompleteFileAppenderTest.testFlushAtEndOfBatch:67 line1"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java\nindex 7e577bb..509f6c7 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java\n@@ -151,13 +151,17 @@ public void start() {\n         setup();\n         setupAdvertisement();\n         doConfigure();\n+        final Set<LoggerConfig> alreadyStarted = new HashSet<LoggerConfig>();\n         for (final LoggerConfig logger : loggers.values()) {\n             logger.start();\n+            alreadyStarted.add(logger);\n         }\n         for (final Appender appender : appenders.values()) {\n             appender.start();\n         }\n+        if (!alreadyStarted.contains(root)) { // LOG4J2-392\n             root.start(); // LOG4J2-336\n+        }\n         super.start();\n         LOGGER.debug(\"Started configuration {} OK.\", this);\n     }\n@@ -185,7 +189,7 @@ public void stop() {\n             }\n         }\n         // similarly, first stop AsyncLoggerConfig Disruptor thread(s)\n-        Set<LoggerConfig> alreadyStopped = new HashSet<LoggerConfig>();\n+        final Set<LoggerConfig> alreadyStopped = new HashSet<LoggerConfig>();\n         int asyncLoggerConfigCount = 0;\n         for (final LoggerConfig logger : loggers.values()) {\n             if (logger instanceof AsyncLoggerConfig) {\n", "nb_test": 659, "linesAdd": 5, "jira_id": "392", "singleLine": false, "nb_skipped": 2, "commit": "731c84b5", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": true}, "failing_tests": ["XIncludeTest.testConfiguredAppenders:96", "Expected: is <3>", "but: was <1>", "XIncludeTest.testLogger:104", "Expected: is <DEBUG>", "but: was <ERROR>", "XIncludeTest.testLogToFile:125 \u00bb FileNotFound target/test-xinclude.log (No suc..."], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\nindex eadcbbc..ca72c09 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\n@@ -131,6 +131,7 @@ public XmlConfiguration(final ConfigurationSource configSource) {\n                 configStream.close();\n             }\n             final InputSource source = new InputSource(new ByteArrayInputStream(buffer));\n+            source.setSystemId(configSource.getLocation());\n             final Document document = newDocumentBuilder().parse(source);\n             rootElement = document.getDocumentElement();\n             final Map<String, String> attrs = processAttributes(rootNode, rootElement);\n", "nb_test": 673, "linesAdd": 1, "jira_id": "742", "singleLine": true, "nb_skipped": 2, "commit": "4b77622b", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["SerializeTest.testLogger:70 \u00bb NotSerializable org.slf4j.impl.SLF4JLogger"], "patch": "diff --git a/log4j-slf4j-impl/src/main/java/org/slf4j/impl/SLF4JLogger.java b/log4j-slf4j-impl/src/main/java/org/slf4j/impl/SLF4JLogger.java\nindex eaac80e..767941e 100644\n--- a/log4j-slf4j-impl/src/main/java/org/slf4j/impl/SLF4JLogger.java\n+++ b/log4j-slf4j-impl/src/main/java/org/slf4j/impl/SLF4JLogger.java\n@@ -17,6 +17,7 @@\n package org.slf4j.impl;\n \n import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.message.Message;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.apache.logging.log4j.message.SimpleMessage;\n@@ -27,17 +28,23 @@\n import org.slf4j.helpers.EventDataConverter;\n import org.slf4j.spi.LocationAwareLogger;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n /**\n  *\n  */\n-public class SLF4JLogger implements LocationAwareLogger {\n+public class SLF4JLogger implements LocationAwareLogger, Serializable {\n \n+    private static final long serialVersionUID = 7869000638091304316L;\n     private static final String FQCN = SLF4JLogger.class.getName();\n     private static final Marker EVENT_MARKER = MarkerFactory.getMarker(\"EVENT\");\n     private final boolean eventLogger;\n-    private final AbstractLoggerWrapper logger;\n+    private transient AbstractLoggerWrapper logger;\n     private final String name;\n-    private final EventDataConverter converter;\n+    private transient EventDataConverter converter;\n \n     public SLF4JLogger(final AbstractLogger logger, final String name) {\n         this.logger = new AbstractLoggerWrapper(logger, name, null);\n@@ -502,6 +509,27 @@ public String getName() {\n         return name;\n     }\n \n+    /**\n+     * Always treat de-serialization as a full-blown constructor, by\n+     * validating the final state of the de-serialized object.\n+     */\n+    private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {\n+        //always perform the default de-serialization first\n+        aInputStream.defaultReadObject();\n+        logger = new AbstractLoggerWrapper((AbstractLogger) LogManager.getLogger(name), name, null);\n+        converter = createConverter();\n+    }\n+\n+    /**\n+     * This is the default implementation of writeObject.\n+     * Customise if necessary.\n+     */\n+    private void writeObject(ObjectOutputStream aOutputStream\n+    ) throws IOException {\n+        //perform the default serialization for all non-transient, non-static fields\n+        aOutputStream.defaultWriteObject();\n+    }\n+\n     private EventDataConverter createConverter() {\n         try {\n             Class.forName(\"org.slf4j.ext.EventData\");\n", "nb_test": 13, "linesAdd": 21, "jira_id": "410", "singleLine": false, "nb_skipped": 0, "commit": "8f0c4871", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ResolverUtilTest.testFileFromUriWithSpacesAndPlusCharactersInName:64->testExtractPathFromJarUrlNotDecodedIfFileExists:58 should not be decoded: /home/ylyu/parallel/log4j2/log4j29/dataset/logging-log4j2/LOG4J2-1008_0c20bfd8adb32cb47621e4796e92335627024562/log4j-core/target/test-classes/s p a c e s/log4j config with plus characters.xml"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java\nindex 475ef9c..65da5bc 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java\n@@ -22,6 +22,7 @@\n import java.io.IOException;\n import java.io.UnsupportedEncodingException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n import java.net.URL;\n import java.net.URLDecoder;\n import java.util.Arrays;\n@@ -41,26 +42,29 @@\n import org.osgi.framework.wiring.BundleWiring;\n \n /**\n- * <p>ResolverUtil is used to locate classes that are available in the/a class path and meet\n- * arbitrary conditions. The two most common conditions are that a class implements/extends\n- * another class, or that is it annotated with a specific annotation. However, through the use\n- * of the {@link Test} class it is possible to search using arbitrary conditions.</p>\n+ * <p>\n+ * ResolverUtil is used to locate classes that are available in the/a class path and meet arbitrary conditions. The two\n+ * most common conditions are that a class implements/extends another class, or that is it annotated with a specific\n+ * annotation. However, through the use of the {@link Test} class it is possible to search using arbitrary conditions.\n+ * </p>\n  *\n- * <p>A ClassLoader is used to locate all locations (directories and jar files) in the class\n- * path that contain classes within certain packages, and then to load those classes and\n- * check them. By default the ClassLoader returned by\n- *  {@code Thread.currentThread().getContextClassLoader()} is used, but this can be overridden\n- * by calling {@link #setClassLoader(ClassLoader)} prior to invoking any of the {@code find()}\n- * methods.</p>\n+ * <p>\n+ * A ClassLoader is used to locate all locations (directories and jar files) in the class path that contain classes\n+ * within certain packages, and then to load those classes and check them. By default the ClassLoader returned by\n+ * {@code Thread.currentThread().getContextClassLoader()} is used, but this can be overridden by calling\n+ * {@link #setClassLoader(ClassLoader)} prior to invoking any of the {@code find()} methods.\n+ * </p>\n  *\n- * <p>General searches are initiated by calling the\n- * {@link #find(ResolverUtil.Test, String...)} method and supplying\n- * a package name and a Test instance. This will cause the named package <b>and all sub-packages</b>\n- * to be scanned for classes that meet the test. There are also utility methods for the common\n- * use cases of scanning multiple packages for extensions of particular classes, or classes\n- * annotated with a specific annotation.</p>\n+ * <p>\n+ * General searches are initiated by calling the {@link #find(ResolverUtil.Test, String...)} method and supplying a\n+ * package name and a Test instance. This will cause the named package <b>and all sub-packages</b> to be scanned for\n+ * classes that meet the test. There are also utility methods for the common use cases of scanning multiple packages for\n+ * extensions of particular classes, or classes annotated with a specific annotation.\n+ * </p>\n  *\n- * <p>The standard usage pattern for the ResolverUtil class is as follows:</p>\n+ * <p>\n+ * The standard usage pattern for the ResolverUtil class is as follows:\n+ * </p>\n  *\n  * <pre>\n  * ResolverUtil&lt;ActionBean&gt; resolver = new ResolverUtil&lt;ActionBean&gt;();\n@@ -70,7 +74,8 @@\n  * Collection&lt;ActionBean&gt; beans = resolver.getClasses();\n  * </pre>\n  *\n- * <p>This class was copied and modified from Stripes - http://stripes.mc4j.org/confluence/display/stripes/Home\n+ * <p>\n+ * This class was copied and modified from Stripes - http://stripes.mc4j.org/confluence/display/stripes/Home\n  * </p>\n  */\n public class ResolverUtil {\n@@ -88,14 +93,14 @@\n     private final Set<URI> resourceMatches = new HashSet<URI>();\n \n     /**\n-     * The ClassLoader to use when looking for classes. If null then the ClassLoader returned\n-     * by Thread.currentThread().getContextClassLoader() will be used.\n+     * The ClassLoader to use when looking for classes. If null then the ClassLoader returned by\n+     * Thread.currentThread().getContextClassLoader() will be used.\n      */\n     private ClassLoader classloader;\n \n     /**\n-     * Provides access to the classes discovered so far. If no calls have been made to\n-     * any of the {@code find()} methods, this set will be empty.\n+     * Provides access to the classes discovered so far. If no calls have been made to any of the {@code find()}\n+     * methods, this set will be empty.\n      *\n      * @return the set of classes that have been discovered.\n      */\n@@ -105,16 +110,16 @@\n \n     /**\n      * Returns the matching resources.\n+     * \n      * @return A Set of URIs that match the criteria.\n      */\n     public Set<URI> getResources() {\n         return resourceMatches;\n     }\n \n-\n     /**\n-     * Returns the classloader that will be used for scanning for classes. If no explicit\n-     * ClassLoader has been set by the calling, the context class loader will be used.\n+     * Returns the classloader that will be used for scanning for classes. If no explicit ClassLoader has been set by\n+     * the calling, the context class loader will be used.\n      *\n      * @return the ClassLoader that will be used to scan for classes\n      */\n@@ -123,19 +128,24 @@ public ClassLoader getClassLoader() {\n     }\n \n     /**\n-     * Sets an explicit ClassLoader that should be used when scanning for classes. If none\n-     * is set then the context classloader will be used.\n+     * Sets an explicit ClassLoader that should be used when scanning for classes. If none is set then the context\n+     * classloader will be used.\n      *\n-     * @param classloader a ClassLoader to use when scanning for classes\n+     * @param classloader\n+     *        a ClassLoader to use when scanning for classes\n      */\n-    public void setClassLoader(final ClassLoader classloader) { this.classloader = classloader; }\n+    public void setClassLoader(final ClassLoader classloader) {\n+        this.classloader = classloader;\n+    }\n \n     /**\n-     * Attempts to discover classes that pass the test. Accumulated\n-     * classes can be accessed by calling {@link #getClasses()}.\n+     * Attempts to discover classes that pass the test. Accumulated classes can be accessed by calling\n+     * {@link #getClasses()}.\n      *\n-     * @param test the test to determine matching classes\n-     * @param packageNames one or more package names to scan (including subpackages) for classes\n+     * @param test\n+     *        the test to determine matching classes\n+     * @param packageNames\n+     *        one or more package names to scan (including subpackages) for classes\n      */\n     public void find(final Test test, final String... packageNames) {\n         if (packageNames == null) {\n@@ -148,14 +158,14 @@ public void find(final Test test, final String... packageNames) {\n     }\n \n     /**\n-     * Scans for classes starting at the package provided and descending into subpackages.\n-     * Each class is offered up to the Test as it is discovered, and if the Test returns\n-     * true the class is retained.  Accumulated classes can be fetched by calling\n-     * {@link #getClasses()}.\n+     * Scans for classes starting at the package provided and descending into subpackages. Each class is offered up to\n+     * the Test as it is discovered, and if the Test returns true the class is retained. Accumulated classes can be\n+     * fetched by calling {@link #getClasses()}.\n      *\n-     * @param test an instance of {@link Test} that will be used to filter classes\n-     * @param packageName the name of the package from which to start scanning for\n-     *        classes, e.g. {@code net.sourceforge.stripes}\n+     * @param test\n+     *        an instance of {@link Test} that will be used to filter classes\n+     * @param packageName\n+     *        the name of the package from which to start scanning for classes, e.g. {@code net.sourceforge.stripes}\n      */\n     public void findInPackage(final Test test, String packageName) {\n         packageName = packageName.replace('.', '/');\n@@ -198,11 +208,13 @@ public void findInPackage(final Test test, String packageName) {\n                 }\n             } catch (final IOException ioe) {\n                 LOGGER.warn(\"could not read entries\", ioe);\n+            } catch (URISyntaxException e) {\n+                LOGGER.warn(\"could not read entries\", e);\n             }\n         }\n     }\n \n-    String extractPath(final URL url) throws UnsupportedEncodingException {\n+    String extractPath(final URL url) throws UnsupportedEncodingException, URISyntaxException {\n         String urlPath = url.getPath(); // same as getFile but without the Query portion\n         // System.out.println(url.getProtocol() + \"->\" + urlPath);\n \n@@ -226,9 +238,10 @@ String extractPath(final URL url) throws UnsupportedEncodingException {\n         if (neverDecode.contains(protocol)) {\n             return urlPath;\n         }\n-        if (new File(urlPath).exists()) {\n+        final String cleanPath = new URI(urlPath).getPath();\n+        if (new File(cleanPath).exists()) {\n             // if URL-encoded file exists, don't decode it\n-            return urlPath;\n+            return cleanPath;\n         }\n         urlPath = URLDecoder.decode(urlPath, Constants.UTF_8.name());\n         return urlPath;\n@@ -237,8 +250,8 @@ String extractPath(final URL url) throws UnsupportedEncodingException {\n     private void loadImplementationsInBundle(final Test test, final String packageName) {\n         // Do not remove the cast on the next line as removing it will cause a compile error on Java 7.\n         @SuppressWarnings(\"RedundantCast\")\n-        final BundleWiring wiring = (BundleWiring) FrameworkUtil.getBundle(\n-                ResolverUtil.class).adapt(BundleWiring.class);\n+        final BundleWiring wiring = (BundleWiring) FrameworkUtil.getBundle(ResolverUtil.class)\n+                .adapt(BundleWiring.class);\n         @SuppressWarnings(\"unchecked\")\n         final Collection<String> list = (Collection<String>) wiring.listResources(packageName, \"*.class\",\n                 BundleWiring.LISTRESOURCES_RECURSE);\n@@ -247,18 +260,20 @@ private void loadImplementationsInBundle(final Test test, final String packageNa\n         }\n     }\n \n-\n     /**\n-     * Finds matches in a physical directory on a filesystem.  Examines all\n-     * files within a directory - if the File object is not a directory, and ends with <i>.class</i>\n-     * the file is loaded and tested to see if it is acceptable according to the Test.  Operates\n-     * recursively to find classes within a folder structure matching the package structure.\n+     * Finds matches in a physical directory on a filesystem. Examines all files within a directory - if the File object\n+     * is not a directory, and ends with <i>.class</i> the file is loaded and tested to see if it is acceptable\n+     * according to the Test. Operates recursively to find classes within a folder structure matching the package\n+     * structure.\n      *\n-     * @param test a Test used to filter the classes that are discovered\n-     * @param parent the package name up to this directory in the package hierarchy.  E.g. if\n-     *        /classes is in the classpath and we wish to examine files in /classes/org/apache then\n-     *        the values of <i>parent</i> would be <i>org/apache</i>\n-     * @param location a File object representing a directory\n+     * @param test\n+     *        a Test used to filter the classes that are discovered\n+     * @param parent\n+     *        the package name up to this directory in the package hierarchy. E.g. if /classes is in the classpath and\n+     *        we wish to examine files in /classes/org/apache then the values of <i>parent</i> would be\n+     *        <i>org/apache</i>\n+     * @param location\n+     *        a File object representing a directory\n      */\n     private void loadImplementationsInDirectory(final Test test, final String parent, final File location) {\n         final File[] files = location.listFiles();\n@@ -285,13 +300,15 @@ private boolean isTestApplicable(final Test test, final String path) {\n     }\n \n     /**\n-     * Finds matching classes within a jar files that contains a folder structure\n-     * matching the package structure.  If the File is not a JarFile or does not exist a warning\n-     * will be logged, but no error will be raised.\n+     * Finds matching classes within a jar files that contains a folder structure matching the package structure. If the\n+     * File is not a JarFile or does not exist a warning will be logged, but no error will be raised.\n      *\n-     * @param test a Test used to filter the classes that are discovered\n-     * @param parent the parent package under which classes must be in order to be considered\n-     * @param jarFile the jar file to be examined for classes\n+     * @param test\n+     *        a Test used to filter the classes that are discovered\n+     * @param parent\n+     *        the parent package under which classes must be in order to be considered\n+     * @param jarFile\n+     *        the jar file to be examined for classes\n      */\n     private void loadImplementationsInJar(final Test test, final String parent, final File jarFile) {\n         @SuppressWarnings(\"resource\")\n@@ -325,13 +342,15 @@ private void close(final JarInputStream jarStream, final Object source) {\n     }\n \n     /**\n-     * Finds matching classes within a jar files that contains a folder structure\n-     * matching the package structure.  If the File is not a JarFile or does not exist a warning\n-     * will be logged, but no error will be raised.\n+     * Finds matching classes within a jar files that contains a folder structure matching the package structure. If the\n+     * File is not a JarFile or does not exist a warning will be logged, but no error will be raised.\n      *\n-     * @param test a Test used to filter the classes that are discovered\n-     * @param parent the parent package under which classes must be in order to be considered\n-     * @param stream The jar InputStream\n+     * @param test\n+     *        a Test used to filter the classes that are discovered\n+     * @param parent\n+     *        the parent package under which classes must be in order to be considered\n+     * @param stream\n+     *        The jar InputStream\n      */\n     private void loadImplementationsInJar(final Test test, final String parent, final String path,\n             final JarInputStream stream) {\n@@ -346,17 +365,19 @@ private void loadImplementationsInJar(final Test test, final String parent, fina\n                 }\n             }\n         } catch (final IOException ioe) {\n-            LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" +\n-                test + \" due to an IOException\", ioe);\n+            LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" + test\n+                    + \" due to an IOException\", ioe);\n         }\n     }\n \n     /**\n-     * Add the class designated by the fully qualified class name provided to the set of\n-     * resolved classes if and only if it is approved by the Test supplied.\n+     * Add the class designated by the fully qualified class name provided to the set of resolved classes if and only if\n+     * it is approved by the Test supplied.\n      *\n-     * @param test the test used to determine if the class matches\n-     * @param fqn the fully qualified name of a class\n+     * @param test\n+     *        the test used to determine if the class matches\n+     * @param fqn\n+     *        the fully qualified name of a class\n      */\n     protected void addIfMatching(final Test test, final String fqn) {\n         try {\n@@ -387,21 +408,25 @@ protected void addIfMatching(final Test test, final String fqn) {\n     }\n \n     /**\n-     * A simple interface that specifies how to test classes to determine if they\n-     * are to be included in the results produced by the ResolverUtil.\n+     * A simple interface that specifies how to test classes to determine if they are to be included in the results\n+     * produced by the ResolverUtil.\n      */\n     public interface Test {\n         /**\n-         * Will be called repeatedly with candidate classes. Must return True if a class\n-         * is to be included in the results, false otherwise.\n-         * @param type The Class to match against.\n+         * Will be called repeatedly with candidate classes. Must return True if a class is to be included in the\n+         * results, false otherwise.\n+         * \n+         * @param type\n+         *        The Class to match against.\n          * @return true if the Class matches.\n          */\n         boolean matches(Class<?> type);\n \n         /**\n          * Test for a resource.\n-         * @param resource The URI to the resource.\n+         * \n+         * @param resource\n+         *        The URI to the resource.\n          * @return true if the resource matches.\n          */\n         boolean matches(URI resource);\n", "nb_test": 745, "linesAdd": 14, "jira_id": "1008", "singleLine": false, "nb_skipped": 2, "commit": "0c20bfd8", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PatternProcessorTest.testGetNextTimeMonthlyReturnsFirstDayOfNextMonth3:78 expected:<201[5/01]/01 00:00:00.000> but was:<201[4/02]/01 00:00:00.000>", "PatternProcessorTest.testGetNextTimeMillisecondlyReturnsNextMillisec:196 expected:<2014/03/04 [10:31:53.124]> but was:<2014/03/04 [22:31:53.001]>", "PatternProcessorTest.testGetNextTimeMinutelyReturnsFirstSecondOfNextMinute:164 expected:<2014/03/04 [10]:32:00.000> but was:<2014/03/04 [22]:32:00.000>", "PatternProcessorTest.testGetNextTimeMonthlyReturnsFirstDayOfNextMonth:50 expected:<2014/[11]/01 00:00:00.000> but was:<2014/[02]/01 00:00:00.000>", "PatternProcessorTest.testGetNextTimeHourlyReturnsFirstMinuteOfNextHour:134 expected:<2014/03/04 [11]:00:00.000> but was:<2014/03/04 [23]:00:00.000>", "PatternProcessorTest.testGetNextTimeWeeklyReturnsFirstDayOfNextWeek_US:96 expected:<2014/0[3/09] 00:00:00.000> but was:<2014/0[1/08] 00:00:00.000>", "PatternProcessorTest.testGetNextTimeSecondlyReturnsFirstMillisecOfNextSecond:180 expected:<2014/03/04 [10]:31:54.000> but was:<2014/03/04 [22]:31:54.000>", "PatternProcessorTest.testGetNextTimeWeeklyReturnsFirstDayOfNextWeek_FRANCE:117 expected:<2014/0[3/10] 00:00:00.000> but was:<2014/0[1/08] 00:00:00.000>"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java\nindex 5a10f1a..82fc0ca 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java\n@@ -102,6 +102,7 @@ public long getNextTime(final long current, final int increment, final boolean m\n             nextFileTime = cal.getTimeInMillis();\n             return nextTime;\n         }\n+        cal.set(Calendar.MONTH, currentCal.get(Calendar.MONTH));\n         if (frequency == RolloverFrequency.MONTHLY) {\n             increment(cal, Calendar.MONTH, increment, modulus);\n             nextTime = cal.getTimeInMillis();\n@@ -110,7 +111,9 @@ public long getNextTime(final long current, final int increment, final boolean m\n             return nextTime;\n         }\n         if (frequency == RolloverFrequency.WEEKLY) {\n+            cal.set(Calendar.WEEK_OF_YEAR, currentCal.get(Calendar.WEEK_OF_YEAR));\n             increment(cal, Calendar.WEEK_OF_YEAR, increment, modulus);\n+            cal.set(Calendar.DAY_OF_WEEK, currentCal.getFirstDayOfWeek());\n             nextTime = cal.getTimeInMillis();\n             cal.add(Calendar.WEEK_OF_YEAR, -1);\n             nextFileTime = cal.getTimeInMillis();\n@@ -124,11 +127,11 @@ public long getNextTime(final long current, final int increment, final boolean m\n             nextFileTime = cal.getTimeInMillis();\n             return nextTime;\n         }\n-        cal.set(Calendar.HOUR, currentCal.get(Calendar.HOUR));\n+        cal.set(Calendar.HOUR_OF_DAY, currentCal.get(Calendar.HOUR_OF_DAY));\n         if (frequency == RolloverFrequency.HOURLY) {\n-            increment(cal, Calendar.HOUR, increment, modulus);\n+            increment(cal, Calendar.HOUR_OF_DAY, increment, modulus);\n             nextTime = cal.getTimeInMillis();\n-            cal.add(Calendar.HOUR, -1);\n+            cal.add(Calendar.HOUR_OF_DAY, -1);\n             nextFileTime = cal.getTimeInMillis();\n             return nextTime;\n         }\n@@ -148,6 +151,7 @@ public long getNextTime(final long current, final int increment, final boolean m\n             nextFileTime = cal.getTimeInMillis();\n             return nextTime;\n         }\n+        cal.set(Calendar.MILLISECOND, currentCal.get(Calendar.MILLISECOND));\n         increment(cal, Calendar.MILLISECOND, increment, modulus);\n         nextTime = cal.getTimeInMillis();\n         cal.add(Calendar.MILLISECOND, -1);\n", "nb_test": 537, "linesAdd": 7, "jira_id": "385", "singleLine": false, "nb_skipped": 1, "commit": "7c2ce5cf", "nb_failure": 8, "linesRem": 3}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testMsgWithKeyTooLong(org.apache.logging.log4j.message.StructuredDataMessageTest): Expected exception: java.lang.IllegalArgumentException", "testMsg(org.apache.logging.log4j.message.StructuredDataMessageTest): Structured data values are limited to 32 characters. key: memo value: This is a very long test memo to prevent regression of LOG4J2-114"], "patch": "diff --git a/api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java b/api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\nindex d3dee6d..b4e6401 100644\n--- a/api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\n+++ b/api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\n@@ -188,8 +188,8 @@ protected void setMessageFormat(String msg) {\n \n     @Override\n     protected void validate(String key, String value) {\n-        if (value.length() > MAX_LENGTH) {\n-            throw new IllegalArgumentException(\"Structured data values are limited to 32 characters. key: \" + key +\n+        if (key.length() > MAX_LENGTH) {\n+            throw new IllegalArgumentException(\"Structured data keys are limited to 32 characters. key: \" + key +\n                 \" value: \" + value);\n         }\n     }\n", "nb_test": 47, "linesAdd": 2, "jira_id": "114", "singleLine": false, "nb_skipped": 0, "commit": "afcf92eb", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testXML(org.apache.logging.log4j.message.MapMessageTest): expected:<<Map>(..)"], "patch": "diff --git a/api/src/main/java/org/apache/logging/log4j/message/MapMessage.java b/api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\nindex de1bb98..cbcd2ca 100644\n--- a/api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\n+++ b/api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\n@@ -193,7 +193,7 @@ private String asString(final MapFormat format) {\n     public void asXML(final StringBuilder sb) {\n         sb.append(\"<Map>\\n\");\n         for (final Map.Entry<String, String> entry : data.entrySet()) {\n-            sb.append(\"  <Entry key=\").append(entry.getKey()).append(\">\").append(entry.getValue()).append(\"</Entry>\\n\");\n+            sb.append(\"  <Entry key=\\\"\").append(entry.getKey()).append(\"\\\">\").append(entry.getValue()).append(\"</Entry>\\n\");\n         }\n         sb.append(\"</Map>\");\n     }\n", "nb_test": 75, "linesAdd": 1, "jira_id": "210", "singleLine": false, "nb_skipped": 0, "commit": "aeb6fc9d", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["Log4jServletContainerInitializerTest.testOnStartupWithServletVersion3_xEffectiveVersion3_x:97", "Unexpected method call ServletContext.addFilter(\"log4jServletFilter\", org.apache.logging.log4j.core.web.Log4jServletFilter@7a269f76):", "ServletContext.log(<any>): expected: 1, actual: 1", "ServletContext.addFilter(\"log4jServletFilter\", capture(Nothing captured yet)): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.tearDown:51", "Expectation failure on verify:", "ServletContext.log(<any>): expected: 1, actual: 1", "ServletContext.addFilter(\"log4jServletFilter\", capture(Nothing captured yet)): expected: 1, actual: 0", "ServletContext.getAttribute(\"org.apache.logging.log4j.core.web.Log4jWebInitializer.INSTANCE\"): expected: 1, actual: 0", "ServletContext.addListener(capture(Nothing captured yet)): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.testOnStartupCanceledDueToPreExistingFilter:123", "Unexpected method call ServletContext.addFilter(\"log4jServletFilter\", org.apache.logging.log4j.core.web.Log4jServletFilter@267a1e1c):", "ServletContext.log(<any>): expected: 1, actual: 1", "ServletContext.addFilter(\"log4jServletFilter\", capture(Nothing captured yet)): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.tearDown:51", "Expectation failure on verify:", "ServletContext.log(<any>): expected: 1, actual: 1", "ServletContext.addFilter(\"log4jServletFilter\", capture(Nothing captured yet)): expected: 1, actual: 0", "ServletContext.log(capture(Nothing captured yet)): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.testOnStartupFailedDueToInitializerFailure:152", "Unexpected method call ServletContext.addFilter(\"log4jServletFilter\", org.apache.logging.log4j.core.web.Log4jServletFilter@5a2023f3):", "ServletContext.log(<any>): expected: 1, actual: 1", "ServletContext.addFilter(\"log4jServletFilter\", capture(Nothing captured yet)): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.tearDown:51", "Expectation failure on verify:", "ServletContext.log(<any>): expected: 1, actual: 1", "ServletContext.addFilter(\"log4jServletFilter\", capture(Nothing captured yet)): expected: 1, actual: 0", "ServletContext.getAttribute(\"org.apache.logging.log4j.core.web.Log4jWebInitializer.INSTANCE\"): expected: 1, actual: 0"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\nindex 7d3ce05..84dbdb3 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n@@ -41,7 +41,7 @@ public void onStartup(final Set<Class<?>> classes, final ServletContext servletC\n             servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n \n             final FilterRegistration.Dynamic filter =\n-                    servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n+                    servletContext.addFilter(\"log4jServletFilter\", Log4jServletFilter.class);\n             if (filter == null) {\n                 servletContext.log(\"WARNING: In a Servlet 3.0+ application, you should not define a \" +\n                         \"log4jServletFilter in web.xml. Log4j 2 normally does this for you automatically. Log4j 2 \" +\n", "nb_test": 525, "linesAdd": 1, "jira_id": "344", "singleLine": false, "nb_skipped": 1, "commit": "8dead3bb", "nb_failure": 6, "linesRem": 1}, {"files": 2, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["JSONLayoutTest.testEscapeLayout:152->checkAt:157 Incorrect line index 6: \"\"message\":\"Here is a quote ' and then a double quote \"\",\""], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/Transform.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/Transform.java\nindex 6c68e4d..a502245 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/Transform.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/Transform.java\n@@ -139,7 +139,7 @@ public static String escapeJsonControlCharacters(final String input) {\n         final int len = input.length();\n         for (int i = 0; i < len; i++) {\n             final char ch = input.charAt(i);\n-            final String escBs = \"\\\\\\\\\";\n+            final String escBs = \"\\\\\";\n             switch (ch) {\n             case '\"':\n                 buf.append(escBs);\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java\nindex a6a8af0..a9005d1 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java\n@@ -189,7 +189,7 @@ public String toSerializable(final LogEvent event) {\n             if (jsonSupported) {\n                 buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));\n             } else {\n-                Transform.appendEscapingCDATA(buf, event.getMessage().getFormattedMessage());\n+                buf.append(Transform.escapeJsonControlCharacters(event.getMessage().getFormattedMessage()));\n             }\n             buf.append('\\\"');\n         }\n@@ -198,7 +198,7 @@ public String toSerializable(final LogEvent event) {\n             buf.append(\",\");\n             buf.append(this.eol);\n             buf.append(\"\\\"ndc\\\":\");\n-            Transform.appendEscapingCDATA(buf, event.getContextStack().toString());\n+            buf.append(Transform.escapeJsonControlCharacters(event.getContextStack().toString()));\n             buf.append(\"\\\"\");\n         }\n \n", "nb_test": 476, "linesAdd": 3, "jira_id": "478", "singleLine": false, "nb_skipped": 8, "commit": "11763dee", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "logging-log4j2", "nb_error": 21, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/api/src/main/java/org/apache/logging/log4j/LogManager.java b/api/src/main/java/org/apache/logging/log4j/LogManager.java\nindex 8f050ee..a6452cb 100644\n--- a/api/src/main/java/org/apache/logging/log4j/LogManager.java\n+++ b/api/src/main/java/org/apache/logging/log4j/LogManager.java\n@@ -39,7 +39,7 @@\n      */\n     public static final String ROOT_LOGGER_NAME = \"\";\n \n-    private static final String LOGGER_RESOURCE = \"META-INF/log4j-provider.xml\";\n+    private static final String LOGGER_RESOURCE = \"META-INF/log4j-provider.properties\";\n     private static final String LOGGER_CONTEXT_FACTORY = \"LoggerContextFactory\";\n     private static final String API_VERSION = \"Log4jAPIVersion\";\n     private static final String FACTORY_PRIORITY = \"FactoryPriority\";\n@@ -95,7 +95,7 @@ protected LogManager() {\n                     Properties props = new Properties();\n                     URL url = enumResources.nextElement();\n                     try {\n-                        props.loadFromXML(url.openStream());\n+                        props.load(url.openStream());\n                     } catch (IOException ioe) {\n                         logger.error(\"Unable to read \" + url.toString(), ioe);\n                     }\n", "nb_test": 45, "linesAdd": 2, "jira_id": "104", "singleLine": false, "nb_skipped": 0, "commit": "3b12e13d", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["MarkerTest.testAddNullMarker:53 \u00bb NullPointer"], "patch": "diff --git a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\nindex d57cf19..aee8dcf 100644\n--- a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n+++ b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n@@ -50,6 +50,9 @@ public Log4jMarker(final org.apache.logging.log4j.Marker marker) {\n \r\n     @Override\r\n     public void add(final Marker marker) {\r\n+\t\tif (marker == null) {\r\n+\t\t\tthrow new IllegalArgumentException();\r\n+\t\t}\r\n         final Marker m = factory.getMarker(marker.getName());\r\n         this.marker.addParents(((Log4jMarker)m).getLog4jMarker());\r\n     }\r\n", "nb_test": 20, "linesAdd": 3, "jira_id": "1062", "singleLine": false, "nb_skipped": 0, "commit": "4cf831b6", "nb_failure": 0, "linesRem": 0}, {"files": 5, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["HostNameTest.testHostname:93 Incorrect HostFile FileAppender file name - expected target/D3118-A1.log actual - target/${hostName}.log"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java\nindex 0759bc4..a8af6ae 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java\n@@ -334,10 +334,9 @@ private synchronized Configuration setConfiguration(final Configuration config)\n         }\n         final Configuration prev = this.config;\n         config.addListener(this);\n-        final Map<String, String> map = new HashMap<String, String>();\n-        map.put(\"hostName\", NetUtils.getLocalHostname());\n-        map.put(\"contextName\", name);\n-        config.addComponent(Configuration.CONTEXT_PROPERTIES, map);\n+        final ConcurrentMap<String, String> map = config.getComponent(Configuration.CONTEXT_PROPERTIES);\n+        map.putIfAbsent(\"hostName\", NetUtils.getLocalHostname());\n+        map.putIfAbsent(\"contextName\", name);\n         config.start();\n         this.config = config;\n         updateLoggers();\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\nindex 2b5c41f..986d2b9 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n@@ -104,7 +104,9 @@\n \n     private ConcurrentMap<String, LoggerConfig> loggers = new ConcurrentHashMap<String, LoggerConfig>();\n \n-    private final StrLookup tempLookup = new Interpolator();\n+    private ConcurrentMap<String, String> properties = new ConcurrentHashMap<String, String>();\n+\n+    private final StrLookup tempLookup = new Interpolator(properties);\n \n     private final StrSubstitutor subst = new StrSubstitutor(tempLookup);\n \n@@ -120,6 +122,7 @@\n      * Constructor.\n      */\n     protected BaseConfiguration() {\n+        componentMap.put(Configuration.CONTEXT_PROPERTIES, properties);\n         pluginManager = new PluginManager(\"Core\");\n         rootNode = new Node();\n     }\n@@ -127,7 +130,7 @@ protected BaseConfiguration() {\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Map<String, String> getProperties() {\n-        return (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n+        return properties;\n     }\n \n     /**\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/PropertiesPlugin.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/PropertiesPlugin.java\nindex b804d45..6c5c3f3 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/PropertiesPlugin.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/PropertiesPlugin.java\n@@ -44,7 +44,7 @@ private PropertiesPlugin() {\n     public static StrLookup configureSubstitutor(@PluginElement(\"Properties\") final Property[] properties,\n                                                  @PluginConfiguration final Configuration config) {\n         if (properties == null) {\n-            return new Interpolator(null);\n+            return new Interpolator(config.getProperties());\n         }\n         final Map<String, String> map = new HashMap<String, String>(config.getProperties());\n \ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\nindex bf463de..a768f4e 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n@@ -60,7 +60,14 @@ public Interpolator(final StrLookup defaultLookup) {\n      * Create the default Interpolator using only Lookups that work without an event.\n      */\n     public Interpolator() {\n-        this.defaultLookup = new MapLookup(new HashMap<String, String>());\n+        this((Map<String, String>) null);\n+    }\n+\n+    /**\n+     * Create the dInterpolator using only Lookups that work without an event and initial properties.\n+     */\n+    public Interpolator(Map<String, String> properties) {\n+        this.defaultLookup = new MapLookup(properties == null ? new HashMap<String, String>() : properties);\n         lookups.put(\"sys\", new SystemPropertiesLookup());\n         lookups.put(\"env\", new EnvironmentLookup());\n         lookups.put(\"jndi\", new JndiLookup());\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jWebInitializerImpl.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jWebInitializerImpl.java\nindex 7d14a14..78708dc 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jWebInitializerImpl.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jWebInitializerImpl.java\n@@ -17,12 +17,15 @@\n package org.apache.logging.log4j.core.web;\n \n import java.net.URI;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n import javax.servlet.ServletContext;\n import javax.servlet.UnavailableException;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.core.LoggerContext;\n import org.apache.logging.log4j.core.config.Configurator;\n+import org.apache.logging.log4j.core.helpers.NetUtils;\n import org.apache.logging.log4j.core.impl.ContextAnchor;\n import org.apache.logging.log4j.core.impl.Log4jContextFactory;\n import org.apache.logging.log4j.core.lookup.Interpolator;\n@@ -48,7 +51,8 @@\n         }\n     }\n \n-    private final StrSubstitutor substitutor = new StrSubstitutor(new Interpolator());\n+    private final Map<String, String> map = new ConcurrentHashMap<String, String>();\n+    private final StrSubstitutor substitutor = new StrSubstitutor(new Interpolator(map));\n     private final ServletContext servletContext;\n \n     private String name;\n@@ -60,6 +64,7 @@\n \n     private Log4jWebInitializerImpl(final ServletContext servletContext) {\n         this.servletContext = servletContext;\n+        map.put(\"hostName\", NetUtils.getLocalHostname());\n     }\n \n     @Override\n", "nb_test": 515, "linesAdd": 20, "jira_id": "470", "singleLine": false, "nb_skipped": 1, "commit": "50340d0c", "nb_failure": 1, "linesRem": 9}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testDefault(org.apache.logging.log4j.LevelTest): No enum constant org.apache.logging.log4j.Level.Information"], "patch": "diff --git a/log4j2-api/src/main/java/org/apache/logging/log4j/Level.java b/log4j2-api/src/main/java/org/apache/logging/log4j/Level.java\nindex 5d56417..4fd3115 100644\n--- a/log4j2-api/src/main/java/org/apache/logging/log4j/Level.java\n+++ b/log4j2-api/src/main/java/org/apache/logging/log4j/Level.java\n@@ -96,9 +96,12 @@ public static Level toLevel(String sArg, Level defaultLevel) {\n         if (sArg == null) {\n             return defaultLevel;\n         }\n-\n-        Level level = valueOf(sArg);\n-        return (level == null) ? defaultLevel : level;\n+        for (Level level : values()) {\n+            if (level.name().equals(sArg)) {\n+                return level;\n+            }\n+        }\n+        return defaultLevel;\n     }\n \n     /**\n", "nb_test": 18, "linesAdd": 6, "jira_id": "56", "singleLine": false, "nb_skipped": 0, "commit": "3eb44094", "nb_failure": 0, "linesRem": 3}, {"files": 2, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReconnect(org.apache.logging.log4j.core.net.SocketReconnectTest): No header"], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java b/core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\nindex 8d6b3a3..54fde20 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\n@@ -28,6 +28,7 @@\n     private OutputStream os;\n \n     private byte[] footer = null;\n+    private byte[] header = null;\n \n     protected OutputStreamManager(final OutputStream os, final String streamName) {\n         super(streamName);\n@@ -54,6 +55,7 @@ protected OutputStreamManager(final OutputStream os, final String streamName) {\n      */\n     public synchronized void setHeader(final byte[] header) {\n         if (header != null) {\n+            this.header = header;\n             try {\n                 this.os.write(header, 0, header.length);\n             } catch (final IOException ioe) {\n@@ -97,6 +99,13 @@ protected OutputStream getOutputStream() {\n \n     protected void setOutputStream(final OutputStream os) {\n         this.os = os;\n+        if (header != null) {\n+            try {\n+                this.os.write(header, 0, header.length);\n+            } catch (final IOException ioe) {\n+                LOGGER.error(\"Unable to write header\", ioe);\n+            }\n+        }\n     }\n \n     /**\ndiff --git a/core/src/main/java/org/apache/logging/log4j/core/net/DatagramOutputStream.java b/core/src/main/java/org/apache/logging/log4j/core/net/DatagramOutputStream.java\nindex bf2a2e6..2fe3d9a 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/net/DatagramOutputStream.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/net/DatagramOutputStream.java\n@@ -89,7 +89,7 @@ public synchronized void write(final byte[] bytes) throws IOException {\n \n     @Override\n     public synchronized void flush() throws IOException {\n-        if (this.ds != null && this.address != null) {\n+        if (this.data != null && this.ds != null && this.address != null) {\n             final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);\n             ds.send(packet);\n         }\n", "nb_test": 119, "linesAdd": 10, "jira_id": "177", "singleLine": false, "nb_skipped": 0, "commit": "f91ce934", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["XMLLayoutTest.testLayout:118 Missing Marker-Tag, Expected <Marker>EVENT</Marker>, Actual    <Message><![CDATA[marker test]]></Message>"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\nindex 59a511a..d0e4d48 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\n@@ -21,6 +21,7 @@\n import java.util.List;\n import java.util.Map;\n \n+import org.apache.logging.log4j.Marker;\n import org.apache.logging.log4j.core.LogEvent;\n import org.apache.logging.log4j.core.config.plugins.Plugin;\n import org.apache.logging.log4j.core.config.plugins.PluginAttribute;\n@@ -195,6 +196,28 @@ public String toSerializable(final LogEvent event) {\n             buf.append(this.eol);\n         }\n \n+        if (event.getMarker() != null) {\n+            final Marker marker = event.getMarker();\n+            buf.append(this.indent2);\n+            buf.append('<');\n+            if (!complete) {\n+                buf.append(this.namespacePrefix);\n+            }\n+            buf.append(\"Marker\");\n+            final Marker parent = marker.getParent();\n+            if (parent != null) {\n+                buf.append(\" parent=\\\"\").append(Transform.escapeHtmlTags(parent.getName())).append(\"\\\"\");\n+            }\n+            buf.append('>');\n+            buf.append(Transform.escapeHtmlTags(marker.getName()));\n+            buf.append(\"</\");\n+            if (!complete) {\n+                buf.append(this.namespacePrefix);\n+            }\n+            buf.append(\"Marker>\");\n+            buf.append(this.eol);\n+        }\n+\n         final Throwable throwable = event.getThrown();\n         if (throwable != null) {\n             final List<String> s = Throwables.toStringList(throwable);\n", "nb_test": 475, "linesAdd": 23, "jira_id": "447", "singleLine": false, "nb_skipped": 8, "commit": "0343e9c7", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["XmlCompleteFileAppenderTest.testChildElementsAreCorrectlyIndented:139 line3 incorrect: [<Event xmlns=\"http://logging.apache.org/log4j/2.0/events\" timeMillis=\"1468677004694\" thread=\"main\" level=\"INFO\" loggerName=\"com.foo.Bar\" endOfBatch=\"false\" loggerFqcn=\"org.apache.logging.log4j.spi.AbstractLogger\" threadId=\"13\" threadPriority=\"5\">], must have two-space indentation", "XmlCompleteFileAppenderTest.testFlushAtEndOfBatch:76 line3 incorrect: [  <Message>Message flushed with immediate flush=false</Message>], does not contain: [<Event ]", "XmlFileAppenderTest.testFlushAtEndOfBatch:68 line1 incorrect: [  <Message>Message flushed with immediate flush=false</Message>], does not contain: [<Event ]"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\nindex 763f42a..3b34957 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\n@@ -19,12 +19,15 @@\n import java.util.HashSet;\n import java.util.Set;\n \n+import javax.xml.stream.XMLStreamException;\n+\n import org.apache.logging.log4j.core.impl.Log4jLogEvent;\n import org.apache.logging.log4j.core.jackson.JsonConstants;\n import org.apache.logging.log4j.core.jackson.Log4jJsonObjectMapper;\n import org.apache.logging.log4j.core.jackson.Log4jXmlObjectMapper;\n import org.apache.logging.log4j.core.jackson.Log4jYamlObjectMapper;\n import org.apache.logging.log4j.core.jackson.XmlConstants;\n+import org.codehaus.stax2.XMLStreamWriter2;\n \n import com.fasterxml.jackson.core.PrettyPrinter;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n@@ -72,6 +75,8 @@ protected PrettyPrinter newPrettyPrinter() {\n \n     static class XML extends JacksonFactory {\n \n+        static final int DEFAULT_INDENT = 1;\n+        \n         @Override\n         protected String getPropertNameForContextMap() {\n             return XmlConstants.ELT_CONTEXT_MAP;\n@@ -100,7 +105,7 @@ protected ObjectMapper newObjectMapper() {\n \n         @Override\n         protected PrettyPrinter newPrettyPrinter() {\n-            return new DefaultXmlPrettyPrinter();\n+            return new Log4jXmlPrettyPrinter(DEFAULT_INDENT);\n         }\n     }\n \n@@ -137,6 +142,38 @@ protected PrettyPrinter newPrettyPrinter() {\n         }\n     }\n \n+    /**\n+     * When &lt;Event&gt;s are written into a XML file; the \"Event\" object is not the root element, but an element named\n+     * &lt;Events&gt; created using {@link #getHeader()} and {@link #getFooter()} methods.<br/>\n+     * {@link com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter} is used to print the Event object into\n+     * XML; hence it assumes &lt;Event&gt; tag as the root element, so it prints the &lt;Event&gt; tag without any\n+     * indentation. To add an indentation to the &lt;Event&gt; tag; hence an additional indentation for any\n+     * sub-elements, this class is written. As an additional task, to avoid the blank line printed after the ending\n+     * &lt;/Event&gt; tag, {@link #writePrologLinefeed(XMLStreamWriter2)} method is also overridden.\n+     */\n+    static class Log4jXmlPrettyPrinter extends DefaultXmlPrettyPrinter {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        Log4jXmlPrettyPrinter(int nesting) {\n+            _nesting = nesting;\n+        }\n+\n+        @Override\n+        public void writePrologLinefeed(XMLStreamWriter2 sw) throws XMLStreamException {\n+            // nothing\n+        }\n+\n+        /**\n+         * Sets the nesting level to 1 rather than 0, so the \"Event\" tag will get indentation of next level below root.\n+         */\n+        @Override\n+        public DefaultXmlPrettyPrinter createInstance() {\n+            return new Log4jXmlPrettyPrinter(XML.DEFAULT_INDENT);\n+        }\n+\n+    }\n+\n     abstract protected String getPropertNameForContextMap();\n \n     abstract protected String getPropertNameForSource();\n", "nb_test": 1168, "linesAdd": 25, "jira_id": "1372", "singleLine": false, "nb_skipped": 3, "commit": "1d12bf0e", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["XmlCompleteFileAppenderTest.testChildElementsAreCorrectlyIndented:139 line3 incorrect: [<Event xmlns=\"http://logging.apache.org/log4j/2.0/events\" timeMillis=\"1468675886448\" thread=\"main\" level=\"INFO\" loggerName=\"com.foo.Bar\" endOfBatch=\"false\" loggerFqcn=\"org.apache.logging.log4j.spi.AbstractLogger\" threadId=\"13\" threadPriority=\"5\">], must have two-space indentation", "XmlCompleteFileAppenderTest.testFlushAtEndOfBatch:76 line3 incorrect: [  <Message>Message flushed with immediate flush=false</Message>], does not contain: [<Event ]", "XmlFileAppenderTest.testFlushAtEndOfBatch:68 line1 incorrect: [  <Message>Message flushed with immediate flush=false</Message>], does not contain: [<Event ]"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\nindex 763f42a..3b34957 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\n@@ -19,12 +19,15 @@\n import java.util.HashSet;\n import java.util.Set;\n \n+import javax.xml.stream.XMLStreamException;\n+\n import org.apache.logging.log4j.core.impl.Log4jLogEvent;\n import org.apache.logging.log4j.core.jackson.JsonConstants;\n import org.apache.logging.log4j.core.jackson.Log4jJsonObjectMapper;\n import org.apache.logging.log4j.core.jackson.Log4jXmlObjectMapper;\n import org.apache.logging.log4j.core.jackson.Log4jYamlObjectMapper;\n import org.apache.logging.log4j.core.jackson.XmlConstants;\n+import org.codehaus.stax2.XMLStreamWriter2;\n \n import com.fasterxml.jackson.core.PrettyPrinter;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n@@ -72,6 +75,8 @@ protected PrettyPrinter newPrettyPrinter() {\n \n     static class XML extends JacksonFactory {\n \n+        static final int DEFAULT_INDENT = 1;\n+        \n         @Override\n         protected String getPropertNameForContextMap() {\n             return XmlConstants.ELT_CONTEXT_MAP;\n@@ -100,7 +105,7 @@ protected ObjectMapper newObjectMapper() {\n \n         @Override\n         protected PrettyPrinter newPrettyPrinter() {\n-            return new DefaultXmlPrettyPrinter();\n+            return new Log4jXmlPrettyPrinter(DEFAULT_INDENT);\n         }\n     }\n \n@@ -137,6 +142,38 @@ protected PrettyPrinter newPrettyPrinter() {\n         }\n     }\n \n+    /**\n+     * When &lt;Event&gt;s are written into a XML file; the \"Event\" object is not the root element, but an element named\n+     * &lt;Events&gt; created using {@link #getHeader()} and {@link #getFooter()} methods.<br/>\n+     * {@link com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter} is used to print the Event object into\n+     * XML; hence it assumes &lt;Event&gt; tag as the root element, so it prints the &lt;Event&gt; tag without any\n+     * indentation. To add an indentation to the &lt;Event&gt; tag; hence an additional indentation for any\n+     * sub-elements, this class is written. As an additional task, to avoid the blank line printed after the ending\n+     * &lt;/Event&gt; tag, {@link #writePrologLinefeed(XMLStreamWriter2)} method is also overridden.\n+     */\n+    static class Log4jXmlPrettyPrinter extends DefaultXmlPrettyPrinter {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        Log4jXmlPrettyPrinter(int nesting) {\n+            _nesting = nesting;\n+        }\n+\n+        @Override\n+        public void writePrologLinefeed(XMLStreamWriter2 sw) throws XMLStreamException {\n+            // nothing\n+        }\n+\n+        /**\n+         * Sets the nesting level to 1 rather than 0, so the \"Event\" tag will get indentation of next level below root.\n+         */\n+        @Override\n+        public DefaultXmlPrettyPrinter createInstance() {\n+            return new Log4jXmlPrettyPrinter(XML.DEFAULT_INDENT);\n+        }\n+\n+    }\n+\n     abstract protected String getPropertNameForContextMap();\n \n     abstract protected String getPropertNameForSource();\n", "nb_test": 1156, "linesAdd": 25, "jira_id": "1372", "singleLine": false, "nb_skipped": 3, "commit": "ffedf33f", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["MarkerTest.testHasParents:55 null"], "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java b/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java\nindex 2dea94e..5bf38e1 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java\n@@ -228,7 +228,7 @@ public String getName() {\n \n         @Override\n         public boolean hasParents() {\n-            return this.parents == null;\n+            return this.parents != null;\n         }\n \n         @Override\n", "nb_test": 217, "linesAdd": 1, "jira_id": "813", "singleLine": false, "nb_skipped": 3, "commit": "0bea17d7", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ReusableParameterizedMessageTest.testThrowable:139 expected same:<java.lang.UnsupportedOperationException: #2> was not:<java.lang.IllegalAccessError: #1>"], "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/ReusableParameterizedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/ReusableParameterizedMessage.java\nindex abfd620..1f4e8b9 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/ReusableParameterizedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/ReusableParameterizedMessage.java\n@@ -121,8 +121,10 @@ private static int count(final String messagePattern, final int[] indices) {\n     }\n \n     private void initThrowable(final Object[] params, final int argCount, final int usedParams) {\n-        if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {\n+        if (usedParams < argCount && params[argCount - 1] instanceof Throwable) {\n             this.throwable = (Throwable) params[argCount - 1];\n+        } else {\n+            this.throwable = null;\n         }\n     }\n \n", "nb_test": 434, "linesAdd": 3, "jira_id": "1406", "singleLine": false, "nb_skipped": 1, "commit": "a523dcd5", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["Log4jServletContainerInitializerTest.testOnStartupWithServletVersion3_xEffectiveVersion2_x:70", "Unexpected method call ServletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\"):", "ServletContext.getMajorVersion(): expected: 1, actual: 1", "ServletContext.getEffectiveMajorVersion(): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.tearDown:51", "Expectation failure on verify:", "ServletContext.getMajorVersion(): expected: 1, actual: 1", "ServletContext.getEffectiveMajorVersion(): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.testOnStartupWithServletVersion3_xEffectiveVersion3_x:97", "Unexpected method call ServletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\"):", "ServletContext.getMajorVersion(): expected: 1, actual: 1", "ServletContext.getEffectiveMajorVersion(): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.tearDown:51", "Expectation failure on verify:", "ServletContext.getMajorVersion(): expected: 1, actual: 1", "ServletContext.getEffectiveMajorVersion(): expected: 1, actual: 0", "ServletContext.log(<any>): expected: 1, actual: 0", "ServletContext.addFilter(\"log4jServletFilter\", capture(Nothing captured yet)): expected: 1, actual: 0", "ServletContext.getAttribute(\"org.apache.logging.log4j.core.web.Log4jWebInitializer.INSTANCE\"): expected: 1, actual: 0", "ServletContext.addListener(capture(Nothing captured yet)): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.testOnStartupCanceledDueToPreExistingFilter:123", "Unexpected method call ServletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\"):", "ServletContext.getMajorVersion(): expected: 1, actual: 1", "ServletContext.getEffectiveMajorVersion(): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.tearDown:51", "Expectation failure on verify:", "ServletContext.getMajorVersion(): expected: 1, actual: 1", "ServletContext.getEffectiveMajorVersion(): expected: 1, actual: 0", "ServletContext.log(<any>): expected: 1, actual: 0", "ServletContext.addFilter(\"log4jServletFilter\", capture(Nothing captured yet)): expected: 1, actual: 0", "ServletContext.log(capture(Nothing captured yet)): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.testOnStartupFailedDueToInitializerFailure:152", "Unexpected method call ServletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\"):", "ServletContext.getMajorVersion(): expected: 1, actual: 1", "ServletContext.getEffectiveMajorVersion(): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.tearDown:51", "Expectation failure on verify:", "ServletContext.getMajorVersion(): expected: 1, actual: 1", "ServletContext.getEffectiveMajorVersion(): expected: 1, actual: 0", "ServletContext.log(<any>): expected: 1, actual: 0", "ServletContext.addFilter(\"log4jServletFilter\", capture(Nothing captured yet)): expected: 1, actual: 0", "ServletContext.getAttribute(\"org.apache.logging.log4j.core.web.Log4jWebInitializer.INSTANCE\"): expected: 1, actual: 0"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\nindex 50b0820..7d3ce05 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n@@ -25,6 +25,9 @@\n import javax.servlet.ServletException;\n import javax.servlet.UnavailableException;\n \n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.status.StatusLogger;\n+\n /**\n  * In a Servlet 3.0 or newer environment, this initializer is responsible for starting up Log4j logging before anything\n  * else happens in application initialization. For consistency across all containers, if the effective Servlet major\n@@ -34,21 +37,23 @@\n \n     @Override\n     public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\n-        if (servletContext.getMajorVersion() > 2) {\n+        if (servletContext.getMajorVersion() > 2 && servletContext.getEffectiveMajorVersion() > 2) {\n             servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n \n+            final FilterRegistration.Dynamic filter =\n+                    servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n+            if (filter == null) {\n+                servletContext.log(\"WARNING: In a Servlet 3.0+ application, you should not define a \" +\n+                        \"log4jServletFilter in web.xml. Log4j 2 normally does this for you automatically. Log4j 2 \" +\n+                        \"web auto-initialization has been canceled.\");\n+                return;\n+            }\n+\n             final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\n             initializer.initialize();\n             initializer.setLoggerContext(); // the application is just now starting to start up\n \n             servletContext.addListener(new Log4jServletContextListener());\n-\n-            final FilterRegistration.Dynamic filter =\n-                    servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n-            if (filter == null) {\n-                throw new UnavailableException(\"In a Servlet 3.0+ application, you must not define a \" +\n-                        \"log4jServletFilter in web.xml. Log4j 2 defines this for you automatically.\");\n-            }\n             filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"/*\");\n         }\n     }\n", "nb_test": 526, "linesAdd": 13, "jira_id": "359", "singleLine": false, "nb_skipped": 1, "commit": "296ea4a5", "nb_failure": 8, "linesRem": 8}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["TcpJsonSocketServerTest>AbstractSocketServerTest.testMessagesWithSpecialChars:167->AbstractSocketServerTest.testServer:216 Incorrect number of events received expected:<1> but was:<0>", "UdpJsonSocketServerTest>AbstractSocketServerTest.testMessagesWithSpecialChars:167->AbstractSocketServerTest.testServer:216 Incorrect number of events received expected:<1> but was:<0>"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/JsonInputStreamLogEventBridge.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/JsonInputStreamLogEventBridge.java\nindex 1b81644..8ed2732 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/JsonInputStreamLogEventBridge.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/JsonInputStreamLogEventBridge.java\n@@ -55,8 +55,10 @@ public JsonInputStreamLogEventBridge(final int bufferSize, final Charset charset\n         boolean inEsc = false;\n         for (int i = start; i < charArray.length; i++) {\n             final char c = charArray[i];\n-            if (!inEsc) {\n+            if (inEsc) {\n+            \t// Skip this char and continue\n             \tinEsc = false;\n+            } else { \n                 switch (c) {\n                 case EVENT_START_MARKER:\n                     if (!inStr) {\n", "nb_test": 774, "linesAdd": 2, "jira_id": "1069", "singleLine": false, "nb_skipped": 2, "commit": "e9b628ec", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testError(org.apache.logging.log4j.AbstractLoggerTest): Incorrect marker. Expected TEST, actual is null", "testFatal(org.apache.logging.log4j.AbstractLoggerTest): Incorrect marker. Expected TEST, actual is null"], "patch": "diff --git a/api/src/main/java/org/apache/logging/log4j/spi/AbstractLogger.java b/api/src/main/java/org/apache/logging/log4j/spi/AbstractLogger.java\nindex 8e50b5b..675d58c 100644\n--- a/api/src/main/java/org/apache/logging/log4j/spi/AbstractLogger.java\n+++ b/api/src/main/java/org/apache/logging/log4j/spi/AbstractLogger.java\n@@ -1157,7 +1157,7 @@ public void error(Message msg, Throwable t) {\n      */\n     public void error(Marker marker, Message msg) {\n         if (isEnabled(Level.ERROR, marker, msg, null)) {\n-            log(null, FQCN, Level.ERROR, msg, null);\n+            log(marker, FQCN, Level.ERROR, msg, null);\n         }\n     }\n \n@@ -1354,7 +1354,7 @@ public void fatal(Message msg, Throwable t) {\n      */\n     public void fatal(Marker marker, Message msg) {\n         if (isEnabled(Level.FATAL, marker, msg, null)) {\n-            log(null, FQCN, Level.FATAL, msg, null);\n+            log(marker, FQCN, Level.FATAL, msg, null);\n         }\n     }\n \n", "nb_test": 47, "linesAdd": 2, "jira_id": "127", "singleLine": false, "nb_skipped": 0, "commit": "029e79da", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["FlumePersistentAppenderTest.testSingle:226 \u00bb AppenderRuntime An exception occu..."], "patch": "diff --git a/flume-ng/src/main/java/org/apache/logging/log4j/flume/appender/FlumeEvent.java b/flume-ng/src/main/java/org/apache/logging/log4j/flume/appender/FlumeEvent.java\nindex c8e4547..d448a66 100644\n--- a/flume-ng/src/main/java/org/apache/logging/log4j/flume/appender/FlumeEvent.java\n+++ b/flume-ng/src/main/java/org/apache/logging/log4j/flume/appender/FlumeEvent.java\n@@ -128,11 +128,14 @@ public FlumeEvent(final LogEvent event, final String includes, final String excl\n         final String guid =  UUIDUtil.getTimeBasedUUID().toString();\n         final Message message = event.getMessage();\n         if (message instanceof MapMessage) {\n+            // Add the guid to the Map so that it can be included in the Layout.\n             ((MapMessage) message).put(GUID, guid);\n             if (message instanceof StructuredDataMessage) {\n                 addStructuredData(eventPrefix, headers, (StructuredDataMessage) message);\n             }\n             addMapData(eventPrefix, headers, (MapMessage) message);\n+        } else {\n+            headers.put(GUID, guid);\n         }\n \n         addContextData(mdcPrefix, headers, ctx);\n", "nb_test": 18, "linesAdd": 2, "jira_id": "268", "singleLine": false, "nb_skipped": 0, "commit": "8faf7f77", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["HTMLLayoutTest.testContentType:68 expected:<text/html[; charset=UTF-8]> but was:<text/html[]>"], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java b/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\nindex 76dfdfe..bfb4939 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\n@@ -208,7 +208,7 @@ public String toSerializable(final LogEvent event) {\n      * @return The content type.\n      */\n     public String getContentType() {\n-        return \"text/html\";\n+        return \"text/html; charset=\" + this.getCharset();\n     }\n \n     private void appendThrowableAsHTML(final Throwable throwable, final StringBuilder sbuf) {\n", "nb_test": 334, "linesAdd": 1, "jira_id": "259", "singleLine": false, "nb_skipped": 3, "commit": "09175c8b", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["TestConfigurator.testFromClassPathProperty:147 Incorrect Configuration. expected:<[ConfigTes]t> but was:<[Defaul]t>"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\nindex 8490196..c935512 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\n@@ -37,6 +37,8 @@\n import org.apache.logging.log4j.core.config.plugins.PluginType;\n import org.apache.logging.log4j.core.helpers.FileUtils;\n import org.apache.logging.log4j.core.helpers.Loader;\n+import org.apache.logging.log4j.core.lookup.Interpolator;\n+import org.apache.logging.log4j.core.lookup.StrSubstitutor;\n import org.apache.logging.log4j.status.StatusLogger;\n import org.apache.logging.log4j.util.PropertiesUtil;\n \n@@ -104,6 +106,8 @@\n \n     private static ConfigurationFactory configFactory = new Factory();\n \n+    protected final StrSubstitutor substitutor = new StrSubstitutor(new Interpolator());\n+\n     /**\n      * Returns the ConfigurationFactory.\n      * @return the ConfigurationFactory.\n@@ -362,10 +366,19 @@ public int compareTo(final WeightedFactory wf) {\n         public Configuration getConfiguration(final String name, final URI configLocation) {\n \n             if (configLocation == null) {\n-                final String config = PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY);\n+                final String config = this.substitutor.replace(\n+                    PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY));\n                 if (config != null) {\n+                    ConfigurationSource source = null;\n+                    try {\n+                        source = getInputFromURI(new URI(config));\n+                    } catch (Exception ex) {\n+                        // Ignore the error and try as a String.\n+                    }\n+                    if (source == null) {\n                         final ClassLoader loader = this.getClass().getClassLoader();\n-                    final ConfigurationSource source = getInputFromString(config, loader);\n+                        source = getInputFromString(config, loader);\n+                    }\n                     if (source != null) {\n                         for (final ConfigurationFactory factory : factories) {\n                             final String[] types = factory.getSupportedTypes();\n", "nb_test": 466, "linesAdd": 14, "jira_id": "395", "singleLine": false, "nb_skipped": 6, "commit": "a19ecc9e", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ThrowableProxyTest.testLogStackTraceWithClassThatCannotInitialize:111 \u00bb NoClassDefFound"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\nindex 2320ad7..51a924e 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n@@ -500,7 +500,7 @@ private boolean ignoreElement(final StackTraceElement element, final List<String\n                 if (clazz != null) {\n                     return clazz;\n                 }\n-            } catch (final Exception ignore) {\n+            } catch (final Throwable ignore) {\n                 // Ignore exception.\n             }\n         }\n", "nb_test": 731, "linesAdd": 1, "jira_id": "832", "singleLine": false, "nb_skipped": 2, "commit": "411dad65", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["LoggerDateTest.testFileName:79 Date was not substituted: target/${date:yyyy-MM-dd HHmmss}.log"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\nindex 986d2b9..b203fb3 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n@@ -243,22 +243,28 @@ public void addComponent(final String name, final Object obj) {\n     protected void doConfigure() {\n         boolean setRoot = false;\n         boolean setLoggers = false;\n-        for (final Node child : rootNode.getChildren()) {\n-            createConfiguration(child, null);\n-            if (child.getObject() == null) {\n-                continue;\n+        if (rootNode.hasChildren() && rootNode.getChildren().get(0).getName().equalsIgnoreCase(\"Properties\")) {\n+            Node first = rootNode.getChildren().get(0);\n+            createConfiguration(first, null);\n+            if (first.getObject() != null) {\n+                subst.setVariableResolver((StrLookup) first.getObject());\n+            }\n+        } else {\n+            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n+            final StrLookup lookup = map == null ? null : new MapLookup(map);\n+            subst.setVariableResolver(new Interpolator(lookup));\n         }\n+\n+        for (final Node child : rootNode.getChildren()) {\n             if (child.getName().equalsIgnoreCase(\"Properties\")) {\n                 if (tempLookup == subst.getVariableResolver()) {\n-                    subst.setVariableResolver((StrLookup) child.getObject());\n-                } else {\n                     LOGGER.error(\"Properties declaration must be the first element in the configuration\");\n                 }\n                 continue;\n-            } else if (tempLookup == subst.getVariableResolver()) {\n-                final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n-                final StrLookup lookup = map == null ? null : new MapLookup(map);\n-                subst.setVariableResolver(new Interpolator(lookup));\n+            }\n+            createConfiguration(child, null);\n+            if (child.getObject() == null) {\n+                continue;\n             }\n             if (child.getName().equalsIgnoreCase(\"Appenders\")) {\n                 appenders = (ConcurrentMap<String, Appender>) child.getObject();\n", "nb_test": 516, "linesAdd": 16, "jira_id": "398", "singleLine": false, "nb_skipped": 1, "commit": "2c966ad9", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["StringFormattedMessageTest.testSerialization:106 \u00bb EOF"], "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\nindex f6007e4..4c8429a 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\n@@ -133,7 +133,9 @@ private void writeObject(final ObjectOutputStream out) throws IOException {\n         stringArgs = new String[argArray.length];\n         int i = 0;\n         for (final Object obj : argArray) {\n-            stringArgs[i] = obj.toString();\n+            final String string = obj.toString();\n+            stringArgs[i] = string;\n+            out.writeUTF(string);\n             ++i;\n         }\n     }\n", "nb_test": 225, "linesAdd": 3, "jira_id": "964", "singleLine": false, "nb_skipped": 3, "commit": "16ad8763", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["ThrowableProxyTest.testSerialization_getExtendedStackTraceAsStringWithNestedThrowableDepth1:152->testSerialization_getExtendedStackTraceAsStringWithNestedThrowable:174 \u00bb NullPointer", "ThrowableProxyTest.testSerialization_getExtendedStackTraceAsStringWithNestedThrowableDepth2:159->testSerialization_getExtendedStackTraceAsStringWithNestedThrowable:174 \u00bb NullPointer", "ThrowableProxyTest.testSerialization_getExtendedStackTraceAsStringWithNestedThrowableDepth3:166->testSerialization_getExtendedStackTraceAsStringWithNestedThrowable:174 \u00bb NullPointer"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\nindex 67d55ec..d0800cc 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n@@ -207,8 +207,8 @@ private void formatCause(final StringBuilder sb, final ThrowableProxy cause, fin\n \t\t\treturn;\n \t\t}\n \t\tsb.append(\"Caused by: \").append(cause).append(EOL);\n-        this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(),\n-                cause.extendedStackTrace, ignorePackages);\n+\t\tthis.formatElements(sb, cause.commonElementCount, cause.getStackTrace(), cause.extendedStackTrace,\n+\t\t\t\tignorePackages);\n \t\tthis.formatCause(sb, cause.causeProxy, ignorePackages);\n \t}\n \n", "nb_test": 766, "linesAdd": 2, "jira_id": "1067", "singleLine": false, "nb_skipped": 2, "commit": "4786a739", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["AppenderRefLevelJsonTest.logger1:88 Incorrect number of events. Expected 6, actual 0", "AppenderRefLevelJsonTest.logger2:102 Incorrect number of events. Expected 2, actual 0"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java\nindex be62509..892c45b 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java\n@@ -232,14 +232,25 @@ private Node constructNode(final String name, final Node parent, final JsonNode\n                             if (itemEntry.getValue().isObject()) {\n                                 LOGGER.debug(\"Processing node for object \" + itemEntry.getKey());\n                                 itemChildren.add(constructNode(itemEntry.getKey(), item, itemEntry.getValue()));\n+                            } else if (itemEntry.getValue().isArray()) {\n+                                JsonNode array = itemEntry.getValue();\n+                                String entryName = itemEntry.getKey();\n+                                LOGGER.debug(\"Processing array for object \" + entryName);\n+                                final PluginType<?> itemEntryType = pluginManager.getPluginType(entryName);\n+                                for (int j = 0; j < array.size(); ++j) {\n+                                    itemChildren.add(constructNode(entryName, item, array.get(j)));\n                                 }\n                             }\n+\n+                        }\n                         children.add(item);\n                     }\n                 } else {\n                     LOGGER.debug(\"Processing node for object \" + entry.getKey());\n                     children.add(constructNode(entry.getKey(), node, n));\n                 }\n+            } else {\n+                LOGGER.debug(\"Node {} is of type {}\", entry.getKey(), n.getNodeType());\n             }\n         }\n \n", "nb_test": 479, "linesAdd": 11, "jira_id": "464", "singleLine": false, "nb_skipped": 8, "commit": "484c865f", "nb_failure": 2, "linesRem": 0}, {"files": 3, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["MutableThreadContextStackTest.testToStringShowsListContents:327 expected:<[[]]> but was:<[org.apache.logging.log4j.spi.MutableThreadContextStack@39165e21]>", "DefaultThreadContextMapTest.testToStringShowsMapContext:162 expected:<[{}]> but was:<[org.apache.logging.log4j.spi.DefaultThreadContextMap@63fa3bee]>", "DefaultThreadContextStackTest.testToStringShowsListContents:324 expected:<[[]]> but was:<[org.apache.logging.log4j.spi.DefaultThreadContextStack@326a40d6]>"], "patch": "diff --git a/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextMap.java b/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextMap.java\nindex eca7126..953d1e5 100644\n--- a/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextMap.java\n+++ b/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextMap.java\n@@ -139,4 +139,10 @@ public boolean isEmpty() {\n         final Map<String, String> map = localMap.get();\n         return map == null || map.size() == 0;\n     }\n+\n+    @Override\n+    public String toString() {\n+        Map<String, String> map = localMap.get();\n+        return map == null ? \"{}\" : map.toString();\n+    }\n }\ndiff --git a/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextStack.java b/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextStack.java\nindex 20f5afb..54ea256 100644\n--- a/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextStack.java\n+++ b/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextStack.java\n@@ -251,4 +251,10 @@ public boolean retainAll(final Collection<?> objects) {\n         stack.set(Collections.unmodifiableList(copy));\n         return result;\n     }\n+    \n+    @Override\n+    public String toString() {\n+        final List<String> list = stack.get();\n+        return list == null ? \"[]\" : list.toString();\n+    }\n }\ndiff --git a/api/src/main/java/org/apache/logging/log4j/spi/MutableThreadContextStack.java b/api/src/main/java/org/apache/logging/log4j/spi/MutableThreadContextStack.java\nindex 164c5c0..1c1e654 100644\n--- a/api/src/main/java/org/apache/logging/log4j/spi/MutableThreadContextStack.java\n+++ b/api/src/main/java/org/apache/logging/log4j/spi/MutableThreadContextStack.java\n@@ -161,4 +161,9 @@ public boolean removeAll(final Collection<?> objects) {\n     public boolean retainAll(final Collection<?> objects) {\n         return list.retainAll(objects);\n     }\n+    \n+    @Override\n+    public String toString() {\n+        return String.valueOf(list);\n+    }\n }\n", "nb_test": 136, "linesAdd": 17, "jira_id": "302", "singleLine": false, "nb_skipped": 0, "commit": "300bc575", "nb_failure": 3, "linesRem": 0}, {"files": 1, "project": "logging-log4j2", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["LocalizedMessageTest.testSerializationMessageFormat:50->roundtrip:37 \u00bb Serialization", "LocalizedMessageTest.testSerializationStringFormat:58->roundtrip:37 \u00bb Serialization"], "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\nindex 8889d5f..40e3324 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\n@@ -265,6 +265,7 @@ private void writeObject(final ObjectOutputStream out) throws IOException {\n             stringArgs[i] = obj.toString();\n             ++i;\n         }\n+        out.writeObject(stringArgs);\n     }\n \n     private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n@@ -273,10 +274,7 @@ private void readObject(final ObjectInputStream in) throws IOException, ClassNot\n         messagePattern = in.readUTF();\n         baseName = in.readUTF();\n         final int length = in.readInt();\n-        stringArgs = new String[length];\n-        for (int i = 0; i < length; ++i) {\n-            stringArgs[i] = in.readUTF();\n-        }\n+        stringArgs = (String[]) in.readObject();\n         logger = StatusLogger.getLogger();\n         resourceBundle = null;\n         argArray = null;\n", "nb_test": 214, "linesAdd": 2, "jira_id": "523", "singleLine": false, "nb_skipped": 0, "commit": "837dcd89", "nb_failure": 0, "linesRem": 4}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ThrowableProxyTest.testCircularCauseExceptions \u00bb StackOverflow"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\nindex dbbc808..75aa5b4 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n@@ -121,7 +121,8 @@ public ThrowableProxy(final Throwable throwable, Set<Throwable> visited) {\n         final Stack<Class<?>> stack = ReflectionUtil.getCurrentStackTrace();\n         this.extendedStackTrace = this.toExtendedStackTrace(stack, map, null, throwable.getStackTrace());\n         final Throwable throwableCause = throwable.getCause();\n-        this.causeProxy = throwableCause == null ? null : new ThrowableProxy(throwable, stack, map, throwableCause, visited);\n+        final Set<Throwable> causeVisited = new HashSet<>(1);\n+        this.causeProxy = throwableCause == null ? null : new ThrowableProxy(throwable, stack, map, throwableCause, visited, causeVisited);\n         this.suppressedProxies = this.toSuppressedProxies(throwable, visited);\n     }\n \n@@ -137,15 +138,19 @@ public ThrowableProxy(final Throwable throwable, Set<Throwable> visited) {\n      * @param cause\n      *        The Throwable to wrap.\n      * @param suppressedVisited TODO\n+     * @param causeVisited TODO\n      */\n     private ThrowableProxy(final Throwable parent, final Stack<Class<?>> stack, final Map<String, CacheEntry> map,\n-            final Throwable cause, Set<Throwable> suppressedVisited) {\n+            final Throwable cause, Set<Throwable> suppressedVisited, Set<Throwable> causeVisited) {\n+        causeVisited.add(cause);\n         this.throwable = cause;\n         this.name = cause.getClass().getName();\n         this.message = this.throwable.getMessage();\n         this.localizedMessage = this.throwable.getLocalizedMessage();\n         this.extendedStackTrace = this.toExtendedStackTrace(stack, map, parent.getStackTrace(), cause.getStackTrace());\n-        this.causeProxy = cause.getCause() == null ? null : new ThrowableProxy(parent, stack, map, cause.getCause(), suppressedVisited);\n+        final Throwable causeCause = cause.getCause();\n+        this.causeProxy = causeCause == null || causeVisited.contains(causeCause) ? null : new ThrowableProxy(parent,\n+                stack, map, causeCause, suppressedVisited, causeVisited);\n         this.suppressedProxies = this.toSuppressedProxies(cause, suppressedVisited);\n     }\n \n", "nb_test": 759, "linesAdd": 7, "jira_id": "1046", "singleLine": false, "nb_skipped": 2, "commit": "11960820", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["BracketInNotInterpolatedMessageTest.noInterpolation:53 \u00bb IllegalArgument can't..."], "patch": "diff --git a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/ApiLogger.java b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/ApiLogger.java\nindex adac9be..92b2dff 100644\n--- a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/ApiLogger.java\n+++ b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/ApiLogger.java\n@@ -23,6 +23,7 @@\n import java.util.logging.Logger;\n \n import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.MessageFactory;\n import org.apache.logging.log4j.spi.ExtendedLogger;\n \n /**\n@@ -56,7 +57,11 @@ public void log(final LogRecord record) {\n             return;\n         }\n         final org.apache.logging.log4j.Level level = LevelTranslator.toLevel(record.getLevel());\n-        final Message message = logger.getMessageFactory().newMessage(record.getMessage(), record.getParameters());\n+        final Object[] parameters = record.getParameters();\n+        final MessageFactory messageFactory = logger.getMessageFactory();\n+        final Message message = parameters == null ?\n+            messageFactory.newMessage(record.getMessage()) /* LOG4J2-1251: not formatted case */ :\n+            messageFactory.newMessage(record.getMessage(), parameters);\n         final Throwable thrown = record.getThrown();\n         logger.logIfEnabled(FQCN, level, null, message, thrown);\n     }\n@@ -94,6 +99,7 @@ protected void doSetLevel(final Level newLevel) throws SecurityException {\n \n     /**\n      * Unsupported operation.\n+     *\n      * @throws UnsupportedOperationException always\n      */\n     @Override\n", "nb_test": 77, "linesAdd": 6, "jira_id": "1251", "singleLine": false, "nb_skipped": 0, "commit": "424068f7", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["SocketAppenderTest.testDefaultProtocol:128 \u00bb NullPointer"], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/appender/SocketAppender.java b/core/src/main/java/org/apache/logging/log4j/core/appender/SocketAppender.java\nindex f9d0665..01701f6 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/appender/SocketAppender.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/appender/SocketAppender.java\n@@ -115,8 +115,7 @@ public void stop() {\n             return null;\n         }\n \n-        final String prot = protocol != null ? protocol : Protocol.TCP.name();\n-        final Protocol p = EnglishEnums.valueOf(Protocol.class, protocol);\n+        final Protocol p = EnglishEnums.valueOf(Protocol.class, protocol != null ? protocol : Protocol.TCP.name());\n         if (p.equals(Protocol.UDP)) {\n             isFlush = true;\n         }\n", "nb_test": 341, "linesAdd": 1, "jira_id": "139", "singleLine": false, "nb_skipped": 2, "commit": "50e19247", "nb_failure": 0, "linesRem": 2}, {"files": 2, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["LoggerTest.supportsCustomSLF4JMarkers:126 \u00bb ClassCast org.apache.logging.slf4j..."], "patch": "diff --git a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jLogger.java b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jLogger.java\nindex 5d37629..e5b2e1f 100644\n--- a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jLogger.java\n+++ b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jLogger.java\n@@ -29,6 +29,7 @@\n import org.apache.logging.log4j.spi.ExtendedLogger;\n import org.slf4j.Marker;\n import org.slf4j.MarkerFactory;\n+import org.slf4j.impl.StaticMarkerBinder;\n import org.slf4j.spi.LocationAwareLogger;\n \n /**\n@@ -375,7 +376,14 @@ public void log(final Marker marker, final String fqcn, final int level, final S\n     }\n \n     private static org.apache.logging.log4j.Marker getMarker(final Marker marker) {\n-        return marker != null ? ((org.apache.logging.slf4j.Log4jMarker) marker).getLog4jMarker() : null;\n+        if (marker == null) {\n+            return null;\n+        } else if (marker instanceof Log4jMarker) {\n+            return ((Log4jMarker) marker).getLog4jMarker();\n+        } else {\n+            final Log4jMarkerFactory factory = (Log4jMarkerFactory) StaticMarkerBinder.SINGLETON.getMarkerFactory();\n+            return ((Log4jMarker) factory.getMarker(marker)).getLog4jMarker();\n+        }\n     }\n \n     @Override\ndiff --git a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarkerFactory.java b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarkerFactory.java\nindex 4efd4d1..4183f2c 100644\n--- a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarkerFactory.java\n+++ b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarkerFactory.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.logging.slf4j;\n \n+import java.util.Iterator;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n \n@@ -24,14 +25,14 @@\n import org.slf4j.Marker;\n \n /**\n- *\n+ * Log4j/SLF4J bridge to create SLF4J Markers based on name or based on existing SLF4J Markers.\n  */\n public class Log4jMarkerFactory implements IMarkerFactory {\n \n     private final ConcurrentMap<String, Marker> markerMap = new ConcurrentHashMap<String, Marker>();\n \n     /**\n-     * Return a Log4j Marker that is compatible with SLF4J.\n+     * Returns a Log4j Marker that is compatible with SLF4J.\n      * @param name The name of the Marker.\n      * @return A Marker.\n      */\n@@ -45,12 +46,49 @@ public Marker getMarker(final String name) {\n             return marker;\n         }\n         final org.apache.logging.log4j.Marker log4jMarker = MarkerManager.getMarker(name);\n-        marker = new Log4jMarker(log4jMarker);\n+        return addMarkerIfAbsent(name, log4jMarker);\n+    }\n+\n+    private Marker addMarkerIfAbsent(final String name, final org.apache.logging.log4j.Marker log4jMarker) {\n+        final Marker marker = new Log4jMarker(log4jMarker);\n         final Marker existing = markerMap.putIfAbsent(name, marker);\n         return existing == null ? marker : existing;\n     }\n \n     /**\n+     * Returns a Log4j Marker converted from an existing custom SLF4J Marker.\n+     * @param marker The SLF4J Marker to convert.\n+     * @return A converted Log4j/SLF4J Marker.\n+     * @since 2.1\n+     */\n+    public Marker getMarker(final Marker marker) {\n+        if (marker == null) {\n+            throw new IllegalArgumentException(\"Marker must not be null\");\n+        }\n+        Marker m = markerMap.get(marker.getName());\n+        if (m != null) {\n+            return m;\n+        }\n+        return addMarkerIfAbsent(marker.getName(), convertMarker(marker));\n+    }\n+\n+    private static org.apache.logging.log4j.Marker convertMarker(final Marker original) {\n+        if (original == null) {\n+            throw new IllegalArgumentException(\"Marker must not be null\");\n+        }\n+        final org.apache.logging.log4j.Marker marker = MarkerManager.getMarker(original.getName());\n+        if (original.hasReferences()) {\n+            final Iterator it = original.iterator();\n+            while (it.hasNext()) {\n+                final Marker next = (Marker) it.next();\n+                // kind of hope nobody uses cycles in their Markers. I mean, why would you do that?\n+                marker.addParents(convertMarker(next));\n+            }\n+        }\n+        return marker;\n+    }\n+\n+    /**\n      * Returns true if the Marker exists.\n      * @param name The Marker name.\n      * @return true if the Marker exists, false otherwise.\n", "nb_test": 14, "linesAdd": 41, "jira_id": "793", "singleLine": false, "nb_skipped": 0, "commit": "73400bfb", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ThrowableProxyTest.testStackWithUnloadableClass:188 \u00bb NoClassDefFound org/apac..."], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\nindex 75c8564..3aadf6c 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n@@ -451,14 +451,22 @@ private boolean ignoreElement(final StackTraceElement element, final List<String\n         try {\n             clazz = Loader.loadClass(className);\n         } catch (final ClassNotFoundException ignored) {\n+            return initializeClass(className);\n+        } catch (final NoClassDefFoundError ignored) {\n+            return initializeClass(className);\n+        }\n+        return clazz;\n+    }\n+\n+    private Class<?> initializeClass(final String className) {\n         try {\n-                clazz = Loader.initializeClass(className, this.getClass().getClassLoader());\n+            return Loader.initializeClass(className, this.getClass().getClassLoader());\n         } catch (final ClassNotFoundException ignore) {\n             return null;\n+        } catch (final NoClassDefFoundError ignore) {\n+            return null;\n         }\n     }\n-        return clazz;\n-    }\n \n     /**\n      * Construct the CacheEntry from the Class's information.\n", "nb_test": 744, "linesAdd": 11, "jira_id": "834", "singleLine": false, "nb_skipped": 2, "commit": "d3989b40", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["XMLLayoutTest.testContentType:64 expected:<text/xml[; charset=UTF-8]> but was:<text/xml[]>"], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java b/core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\nindex ddd4548..aa40961 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\n@@ -239,7 +239,7 @@ public String toSerializable(final LogEvent event) {\n      * @return The content type.\n      */\n     public String getContentType() {\n-        return \"text/xml\";\n+        return \"text/xml; charset=\" + this.getCharset();\n     }\n \n     List<String> getThrowableString(final Throwable throwable) {\n", "nb_test": 335, "linesAdd": 1, "jira_id": "260", "singleLine": false, "nb_skipped": 3, "commit": "9d817953", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["AsyncLoggersWithAsyncAppenderTest.testLoggingWorks:66 Incorrect number of events. Expected 2, got 0"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java\nindex 8178fe2..e470757 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java\n@@ -27,6 +27,7 @@\n import org.apache.logging.log4j.core.Appender;\n import org.apache.logging.log4j.core.Filter;\n import org.apache.logging.log4j.core.LogEvent;\n+import org.apache.logging.log4j.core.async.RingBufferLogEvent;\n import org.apache.logging.log4j.core.config.AppenderControl;\n import org.apache.logging.log4j.core.config.AppenderRef;\n import org.apache.logging.log4j.core.config.Configuration;\n@@ -127,12 +128,15 @@ public void stop() {\n      * @param logEvent The LogEvent.\n      */\n     @Override\n-    public void append(final LogEvent logEvent) {\n+    public void append(LogEvent logEvent) {\n         if (!isStarted()) {\n             throw new IllegalStateException(\"AsyncAppender \" + getName() + \" is not active\");\n         }\n         if (!(logEvent instanceof Log4jLogEvent)) {\n-            return; // only know how to Serialize Log4jLogEvents\n+            if (!(logEvent instanceof RingBufferLogEvent)) {\n+                return; // only know how to Serialize Log4jLogEvents and RingBufferLogEvents\n+            }\n+            logEvent = ((RingBufferLogEvent) logEvent).createMemento();\n         }\n         Log4jLogEvent coreEvent = (Log4jLogEvent) logEvent;\n         boolean appendSuccessful = false;\n", "nb_test": 658, "linesAdd": 6, "jira_id": "668", "singleLine": false, "nb_skipped": 2, "commit": "60f64cc1", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["SerializableLayoutTest.testPluginObjectSerialization:52 \u00bb NotSerializable sun...."], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/AbstractStringLayout.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/AbstractStringLayout.java\nindex c928d62..255c73b 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/AbstractStringLayout.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/AbstractStringLayout.java\n@@ -16,6 +16,9 @@\n  */\n package org.apache.logging.log4j.core.layout;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.io.UnsupportedEncodingException;\n import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n@@ -46,8 +49,8 @@\n     /**\n      * The charset for the formatted message.\n      */\n-    // TODO: Charset is not serializable. Implement read/writeObject() ?\n-    private final Charset charset;\n+    // LOG4J2-1099: charset cannot be final due to serialization needs, so we serialize as charset name instead\n+    private transient Charset charset;\n     private final String charsetName;\n     private final boolean useCustomEncoding;\n \n@@ -97,6 +100,17 @@ private static boolean isPreJava8() {\n         return null;\n     }\n \n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeUTF(charset.name());\n+    }\n+\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        final String charsetName = in.readUTF();\n+        charset = Charset.forName(charsetName);\n+    }\n+\n     /**\n      * Returns a {@code StringBuilder} that this Layout implementation can use to write the formatted log event to.\n      * \n", "nb_test": 920, "linesAdd": 15, "jira_id": "1099", "singleLine": false, "nb_skipped": 3, "commit": "3f41ff48", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ConsoleAppenderTest.testFollow:104 Incorrect message: \"\""], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/ConsoleAppender.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/ConsoleAppender.java\nindex 760db2c..c318d37 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/ConsoleAppender.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/ConsoleAppender.java\n@@ -182,23 +182,28 @@ private static OutputStream getOutputStream(final boolean follow, final Target t\n         final String enc = Charset.defaultCharset().name();\n         PrintStream printStream = null;\n         try {\n+            // Cannot use a CloseShieldOutputStream here;\n+            // see org.apache.logging.log4j.core.appender.ConsoleAppenderTest\n+            // @formatter:off\n             printStream = target == Target.SYSTEM_OUT ?\n-            follow ? new PrintStream(new CloseShieldOutputStream(System.out), true, enc) : System.out :\n-            follow ? new PrintStream(new CloseShieldOutputStream(System.err), true, enc) : System.err;\n+            follow ? new PrintStream(new SystemOutStream(), true, enc) : System.out :\n+            follow ? new PrintStream(new SystemErrStream(), true, enc) : System.err;\n+            // @formatter:on\n         } catch (final UnsupportedEncodingException ex) { // should never happen\n             throw new IllegalStateException(\"Unsupported default encoding \" + enc, ex);\n         }\n         final PropertiesUtil propsUtil = PropertiesUtil.getProperties();\n-        if (!propsUtil.getStringProperty(\"os.name\").startsWith(\"Windows\") ||\n-            propsUtil.getBooleanProperty(\"log4j.skipJansi\")) {\n+        if (!propsUtil.getStringProperty(\"os.name\").startsWith(\"Windows\")\n+                || propsUtil.getBooleanProperty(\"log4j.skipJansi\")) {\n             return printStream;\n         }\n         try {\n             // We type the parameter as a wildcard to avoid a hard reference to Jansi.\n             final Class<?> clazz = Loader.loadClass(JANSI_CLASS);\n             final Constructor<?> constructor = clazz.getConstructor(OutputStream.class);\n+            OutputStream newInstance = (OutputStream) constructor.newInstance(printStream);\n             // LOG4J-965\n-            return new CloseShieldOutputStream((OutputStream) constructor.newInstance(printStream));\n+            return follow ? new CloseShieldOutputStream(newInstance) : newInstance;\n         } catch (final ClassNotFoundException cnfe) {\n             LOGGER.debug(\"Jansi is not installed, cannot find {}\", JANSI_CLASS);\n         } catch (final NoSuchMethodException nsme) {\n@@ -210,6 +215,74 @@ private static OutputStream getOutputStream(final boolean follow, final Target t\n     }\n \n     /**\n+     * An implementation of OutputStream that redirects to the current System.err.\n+     */\n+    private static class SystemErrStream extends OutputStream {\n+        public SystemErrStream() {\n+        }\n+\n+        @Override\n+        public void close() {\n+            // do not close sys err!\n+        }\n+\n+        @Override\n+        public void flush() {\n+            System.err.flush();\n+        }\n+\n+        @Override\n+        public void write(final byte[] b) throws IOException {\n+            System.err.write(b);\n+        }\n+\n+        @Override\n+        public void write(final byte[] b, final int off, final int len)\n+            throws IOException {\n+            System.err.write(b, off, len);\n+        }\n+\n+        @Override\n+        public void write(final int b) {\n+            System.err.write(b);\n+        }\n+    }\n+\n+    /**\n+     * An implementation of OutputStream that redirects to the current System.out.\n+     */\n+    private static class SystemOutStream extends OutputStream {\n+        public SystemOutStream() {\n+        }\n+\n+        @Override\n+        public void close() {\n+            // do not close sys out!\n+        }\n+\n+        @Override\n+        public void flush() {\n+            System.out.flush();\n+        }\n+\n+        @Override\n+        public void write(final byte[] b) throws IOException {\n+            System.out.write(b);\n+        }\n+\n+        @Override\n+        public void write(final byte[] b, final int off, final int len)\n+            throws IOException {\n+            System.out.write(b, off, len);\n+        }\n+\n+        @Override\n+        public void write(final int b) throws IOException {\n+            System.out.write(b);\n+        }\n+    }\n+    \n+    /**\n      * A delegating OutputStream that does not close its delegate.\n      */\n     private static class CloseShieldOutputStream extends OutputStream {\n", "nb_test": 740, "linesAdd": 66, "jira_id": "965", "singleLine": false, "nb_skipped": 2, "commit": "43517f15", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMissingRootLogger(org.apache.logging.log4j.core.config.BaseConfigurationTest): sampleAppenders Size expected:<1> but was:<0>"], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java b/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\nindex dcdb988..8821f76 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n@@ -206,9 +206,9 @@ protected void doConfigure() {\n             setToDefault();\n             return;\n         } else if (!setRoot) {\n-            LOGGER.warn(\"No Root logger was configured, using default\");\n+            LOGGER.warn(\"No Root logger was configured, creating default ERROR-level Root logger with Console appender\");\n             setToDefault();\n-            return;\n+            // return; // LOG4J2-219: creating default root=ok, but don't exclude configured Loggers\n         }\n \n         for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {\n", "nb_test": 184, "linesAdd": 1, "jira_id": "219", "singleLine": false, "nb_skipped": 0, "commit": "ed951c76", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["RollingFilePropertiesTest.testPropertiesConfiguration:45 \u00bb NullPointer"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationBuilder.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationBuilder.java\nindex 51bdcca..2c70234 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationBuilder.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationBuilder.java\n@@ -120,26 +120,58 @@ public PropertiesConfiguration build() {\n             }\n         }\n \n-        final Map<String, Properties> filters = PropertiesUtil.partitionOnCommonPrefixes(\n-            PropertiesUtil.extractSubset(rootProperties, \"filter\"));\n+        String filterProp = rootProperties.getProperty(\"filters\");\n+        if (filterProp != null) {\n+            String[] filterNames = filterProp.split(\",\");\n+            for (String filterName : filterNames) {\n+                String name = filterName.trim();\n+                builder.add(createFilter(name, PropertiesUtil.extractSubset(rootProperties, \"filter.\" + name)));\n+            }\n+        } else {\n+\n+            final Map<String, Properties> filters = PropertiesUtil\n+                    .partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"filter\"));\n             for (final Map.Entry<String, Properties> entry : filters.entrySet()) {\n                 builder.add(createFilter(entry.getKey().trim(), entry.getValue()));\n             }\n+        }\n \n-        final Map<String, Properties> appenders = PropertiesUtil.partitionOnCommonPrefixes(\n-            PropertiesUtil.extractSubset(rootProperties, \"appender\"));\n+        String appenderProp = rootProperties.getProperty(\"appenders\");\n+        if (appenderProp != null) {\n+            String[] appenderNames = appenderProp.split(\",\");\n+            for (String appenderName : appenderNames) {\n+                String name = appenderName.trim();\n+                builder.add(createAppender(appenderName.trim(),\n+                        PropertiesUtil.extractSubset(rootProperties, \"appender.\" + name)));\n+            }\n+        } else {\n+            final Map<String, Properties> appenders = PropertiesUtil\n+                    .partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"appender\"));\n             for (final Map.Entry<String, Properties> entry : appenders.entrySet()) {\n                 builder.add(createAppender(entry.getKey().trim(), entry.getValue()));\n             }\n+        }\n \n-        final Map<String, Properties> loggers = PropertiesUtil.partitionOnCommonPrefixes(\n-            PropertiesUtil.extractSubset(rootProperties, \"logger\"));\n+        String loggerProp = rootProperties.getProperty(\"loggers\");\n+        if (loggerProp != null) {\n+            String[] loggerNames = loggerProp.split(\",\");\n+            for (String loggerName : loggerNames) {\n+                String name = loggerName.trim();\n+                if (!name.equals(LoggerConfig.ROOT)) {\n+                    builder.add(createLogger(name, PropertiesUtil.extractSubset(rootProperties, \"logger.\" +\n+                            name)));\n+                }\n+            }\n+        } else {\n+            final Map<String, Properties> loggers = PropertiesUtil\n+                    .partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"logger\"));\n             for (final Map.Entry<String, Properties> entry : loggers.entrySet()) {\n                 final String name = entry.getKey().trim();\n                 if (!name.equals(LoggerConfig.ROOT)) {\n                     builder.add(createLogger(name, entry.getValue()));\n                 }\n             }\n+        }\n \n         final Properties props = PropertiesUtil.extractSubset(rootProperties, \"rootLogger\");\n         if (props.size() > 0) {\n", "nb_test": 1181, "linesAdd": 38, "jira_id": "1402", "singleLine": false, "nb_skipped": 3, "commit": "7792679c", "nb_failure": 0, "linesRem": 6}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["Log4jServletContainerInitializerTest.testOnStartupFailedDueToPreExistingFilter:111", "Unexpected method call ServletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\"):", "ServletContext.getMajorVersion(): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.tearDown:51", "Expectation failure on verify:", "ServletContext.getMajorVersion(): expected: 1, actual: 0", "ServletContext.log(<any>): expected: 1, actual: 0", "ServletContext.getAttribute(\"org.apache.logging.log4j.core.web.Log4jWebInitializer.INSTANCE\"): expected: 1, actual: 0", "ServletContext.addListener(capture(Nothing captured yet)): expected: 1, actual: 0", "ServletContext.addFilter(\"log4jServletFilter\", capture(Nothing captured yet)): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.testOnStartupWithServletVersion2_x:60", "Unexpected method call ServletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\"):", "ServletContext.getMajorVersion(): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.tearDown:51", "Expectation failure on verify:", "ServletContext.getMajorVersion(): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.testOnStartupWithServletVersion3_x:86", "Unexpected method call ServletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\"):", "ServletContext.getMajorVersion(): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.tearDown:51", "Expectation failure on verify:", "ServletContext.getMajorVersion(): expected: 1, actual: 0", "ServletContext.log(<any>): expected: 1, actual: 0", "ServletContext.getAttribute(\"org.apache.logging.log4j.core.web.Log4jWebInitializer.INSTANCE\"): expected: 1, actual: 0", "ServletContext.addListener(capture(Nothing captured yet)): expected: 1, actual: 0", "ServletContext.addFilter(\"log4jServletFilter\", capture(Nothing captured yet)): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.testOnStartupFailedDueToInitializerFailure:135", "Unexpected method call ServletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\"):", "ServletContext.getMajorVersion(): expected: 1, actual: 0", "Log4jServletContainerInitializerTest.tearDown:51", "Expectation failure on verify:", "ServletContext.getMajorVersion(): expected: 1, actual: 0", "ServletContext.log(<any>): expected: 1, actual: 0", "ServletContext.getAttribute(\"org.apache.logging.log4j.core.web.Log4jWebInitializer.INSTANCE\"): expected: 1, actual: 0"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\nindex 6add448..50b0820 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n@@ -23,15 +23,18 @@\n import javax.servlet.ServletContainerInitializer;\n import javax.servlet.ServletContext;\n import javax.servlet.ServletException;\n+import javax.servlet.UnavailableException;\n \n /**\n  * In a Servlet 3.0 or newer environment, this initializer is responsible for starting up Log4j logging before anything\n- * else happens in application initialization.\n+ * else happens in application initialization. For consistency across all containers, if the effective Servlet major\n+ * version of the application is less than 3.0, this initializer does nothing.\n  */\n public class Log4jServletContainerInitializer implements ServletContainerInitializer {\n \n     @Override\n     public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\n+        if (servletContext.getMajorVersion() > 2) {\n             servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n \n             final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\n@@ -40,7 +43,13 @@ public void onStartup(final Set<Class<?>> classes, final ServletContext servletC\n \n             servletContext.addListener(new Log4jServletContextListener());\n \n-        final FilterRegistration.Dynamic filter = servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n+            final FilterRegistration.Dynamic filter =\n+                    servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n+            if (filter == null) {\n+                throw new UnavailableException(\"In a Servlet 3.0+ application, you must not define a \" +\n+                        \"log4jServletFilter in web.xml. Log4j 2 defines this for you automatically.\");\n+            }\n             filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"/*\");\n         }\n     }\n+}\n", "nb_test": 419, "linesAdd": 9, "jira_id": "359", "singleLine": false, "nb_skipped": 5, "commit": "1df1db27", "nb_failure": 8, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["SimpleLoggerTest.testMessageWithEmptyObjectArray:53 \u00bb ArrayIndexOutOfBounds -1"], "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLogger.java b/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLogger.java\nindex a474940..90fc598 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLogger.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLogger.java\n@@ -154,7 +154,7 @@ public void logMessage(final String fqcn, final Level level, final Marker marker\n         }\n         final Object[] params = msg.getParameters();\n         Throwable t;\n-        if (throwable == null && params != null && params[params.length - 1] instanceof Throwable) {\n+        if (throwable == null && params != null && params.length > 0 && params[params.length - 1] instanceof Throwable) {\n             t = (Throwable) params[params.length - 1];\n         } else {\n             t = throwable;\n", "nb_test": 209, "linesAdd": 1, "jira_id": "811", "singleLine": false, "nb_skipped": 2, "commit": "7bb1ad47", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java b/core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java\nindex 99fd17d..fd53a00 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java\n@@ -210,13 +210,13 @@ private static int extractConverter(\n      */\n     private static int extractOptions(String pattern, int i, List<String> options) {\n         while ((i < pattern.length()) && (pattern.charAt(i) == '{')) {\n-            int begin = i;\n+            int begin = i++;\n             int end;\n             int depth = 0;\n             do {\n                 end = pattern.indexOf('}', i);\n                 if (end != -1) {\n-                    int next = pattern.indexOf(\"{\", i + 1);\n+                    int next = pattern.indexOf(\"{\", i);\n                     if (next != -1 && next < end) {\n                         i = end + 1;\n                         ++depth;\n", "nb_test": 95, "linesAdd": 2, "jira_id": "107", "singleLine": false, "nb_skipped": 0, "commit": "88641f49", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["RFC5424LayoutTest.testParameterizedMessage:448 Incorrect message. Expected - Hello World, Actual - 65 <134>1 2016-07-16T13:41:06.433-07:00 D3118-A1 ATM - - - Hello {}"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/RFC5424Layout.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/RFC5424Layout.java\nindex e7aff72..e26fa4d 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/RFC5424Layout.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/RFC5424Layout.java\n@@ -324,7 +324,8 @@ private void appendMessageId(final StringBuilder buffer, final Message message)\n \n     private void appendMessage(final StringBuilder buffer, final LogEvent event) {\n         final Message message = event.getMessage();\n-        final String text = message.getFormat();\n+        // This layout formats StructuredDataMessages instead of delegating to the Message itself.\n+        final String text = (message instanceof StructuredDataMessage) ? message.getFormat() : message.getFormattedMessage();\n \n         if (text != null && text.length() > 0) {\n             buffer.append(\" \").append(escapeNewlines(text, escapeNewLine));\n", "nb_test": 493, "linesAdd": 1, "jira_id": "430", "singleLine": false, "nb_skipped": 8, "commit": "238ce8aa", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "logging-log4j2", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["LateConfigTest.testReconfiguration:64 Configuration not reset"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/selector/ClassLoaderContextSelector.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/selector/ClassLoaderContextSelector.java\nindex 058b630..13ba4ba 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/selector/ClassLoaderContextSelector.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/selector/ClassLoaderContextSelector.java\n@@ -28,6 +28,7 @@\n import java.util.concurrent.atomic.AtomicReference;\n \n import org.apache.logging.log4j.core.LoggerContext;\n+import org.apache.logging.log4j.core.config.Configuration;\n import org.apache.logging.log4j.core.helpers.Loader;\n import org.apache.logging.log4j.core.impl.ContextAnchor;\n import org.apache.logging.log4j.core.impl.ReflectiveCallerClassUtility;\n@@ -224,6 +225,13 @@ private LoggerContext locateContext(final ClassLoader loader, final URI configLo\n         final WeakReference<LoggerContext> r = ref.get();\n         LoggerContext ctx = r.get();\n         if (ctx != null) {\n+            if (ctx.getConfigLocation() == null && configLocation != null) {\n+                LOGGER.debug(\"Setting configuration to {}\", configLocation);\n+                ctx.setConfigLocation(configLocation);\n+            } else if (ctx.getConfigLocation() != null && !ctx.getConfigLocation().equals(configLocation)) {\n+                LOGGER.warn(\"locateContext called with URI {}. Existing LoggerContext has URI {}\", configLocation,\n+                    ctx.getConfigLocation());\n+            }\n             return ctx;\n         }\n         ctx = new LoggerContext(name, null, configLocation);\n", "nb_test": 418, "linesAdd": 8, "jira_id": "293", "singleLine": false, "nb_skipped": 5, "commit": "ca59ece6", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "logging-log4j2", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["PropertiesConfigurationRootLoggerOnlyTest.testPropertiesConfiguration:45 \u00bb NullPointer"], "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\nindex 58094f0..6be8683 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\n@@ -151,7 +151,7 @@ public PropertiesConfiguration getConfiguration(ConfigurationSource source) {\n             }\n         }\n         String loggerProp = properties.getProperty(\"loggers\");\n-        if (appenderProp != null) {\n+        if (loggerProp != null) {\n             String[] loggerNames = loggerProp.split(\",\");\n             for (String loggerName : loggerNames) {\n                 String name = loggerName.trim();\n@@ -400,7 +400,6 @@ private LayoutComponentBuilder createLayout(ConfigurationBuilder<PropertiesConfi\n         return componentBuilder;\n     }\n \n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n     private void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {\n         while (properties.size() > 0) {\n             String propertyName = properties.stringPropertyNames().iterator().next();\n", "nb_test": 915, "linesAdd": 1, "jira_id": "1153", "singleLine": false, "nb_skipped": 3, "commit": "8acedb4e", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["org.apache.maven.artifact.versioning.DefaultArtifactVersionTest#testNonNumericVersionRepresentationReturnsANumberFormatException AssertionFailedError"], "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/DefaultArtifactVersion.java b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/DefaultArtifactVersion.java\nindex 745afdd..6a6ab74 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/DefaultArtifactVersion.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/DefaultArtifactVersion.java\n@@ -21,6 +21,7 @@\n \n import java.util.StringTokenizer;\n import java.util.regex.Pattern;\n+import java.util.NoSuchElementException;\n \n /**\n  * Default implementation of artifact versioning.\n@@ -204,6 +205,7 @@ public final void parseVersion( String version )\n \n     private static Integer getNextIntegerToken( StringTokenizer tok )\n     {\n+        try {\n             String s = tok.nextToken();\n             if ( ( s.length() > 1 ) && s.startsWith( \"0\" ) )\n             {\n@@ -211,6 +213,11 @@ private static Integer getNextIntegerToken( StringTokenizer tok )\n             }\n             return Integer.valueOf( s );\n         } \n+        catch( NoSuchElementException e )\n+        {\n+            throw new NumberFormatException( \"Number is invalid\" );\n+        }\n+    }\n \n     @Override\n     public String toString()\n", "nb_test": 22, "linesAdd": 7, "jira_id": "5645", "singleLine": false, "nb_skipped": 0, "commit": "af1ecd5f", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReportingExcludeDefaultsInheritance(org.apache.maven.project.inheritance.DefaultModelInheritanceAssemblerTest): Check excludeDefaults is inherited"], "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\nindex 39b8488..2839c50 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\n@@ -16,15 +16,6 @@\n  * limitations under the License.\n  */\n \n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.StringTokenizer;\n-import java.util.TreeMap;\n-\n import org.apache.maven.model.Build;\n import org.apache.maven.model.Dependency;\n import org.apache.maven.model.DependencyManagement;\n@@ -38,6 +29,15 @@\n import org.apache.maven.project.ModelUtils;\n import org.codehaus.plexus.util.StringUtils;\n \n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.StringTokenizer;\n+import java.util.TreeMap;\n+\n /**\n  * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl </a>\n  * @version $Id: DefaultModelInheritanceAssembler.java,v 1.4 2004/08/23 20:24:54\n@@ -275,6 +275,8 @@ private void assembleReportingInheritance( Model child, Model parent )\n                 child.setReporting( childReporting );\n             }\n \n+            childReporting.setExcludeDefaults( parentReporting.isExcludeDefaults() );\n+\n             if ( StringUtils.isEmpty( childReporting.getOutputDirectory() ) )\n             {\n                 childReporting.setOutputDirectory( parentReporting.getOutputDirectory() );\n@@ -422,25 +424,28 @@ private void assembleScmInheritance( Model child, Model parent, String childPath\n \n             if ( StringUtils.isEmpty( childScm.getConnection() ) && !StringUtils.isEmpty( parentScm.getConnection() ) )\n             {\n-                childScm.setConnection( appendPath( parentScm.getConnection(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n+                childScm.setConnection(\n+                    appendPath( parentScm.getConnection(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n             }\n \n             if ( StringUtils.isEmpty( childScm.getDeveloperConnection() ) &&\n                 !StringUtils.isEmpty( parentScm.getDeveloperConnection() ) )\n             {\n                 childScm\n-                    .setDeveloperConnection(\n-                        appendPath( parentScm.getDeveloperConnection(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n+                    .setDeveloperConnection( appendPath( parentScm.getDeveloperConnection(), child.getArtifactId(),\n+                                                         childPathAdjustment, appendPaths ) );\n             }\n \n             if ( StringUtils.isEmpty( childScm.getUrl() ) && !StringUtils.isEmpty( parentScm.getUrl() ) )\n             {\n-                childScm.setUrl( appendPath( parentScm.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n+                childScm.setUrl(\n+                    appendPath( parentScm.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n             }\n         }\n     }\n \n-    private void assembleDistributionInheritence( Model child, Model parent, String childPathAdjustment, boolean appendPaths )\n+    private void assembleDistributionInheritence( Model child, Model parent, String childPathAdjustment,\n+                                                  boolean appendPaths )\n     {\n         if ( parent.getDistributionManagement() != null )\n         {\n@@ -471,7 +476,8 @@ private void assembleDistributionInheritence( Model child, Model parent, String\n \n                     if ( site.getUrl() != null )\n                     {\n-                        site.setUrl( appendPath( site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n+                        site.setUrl(\n+                            appendPath( site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n                     }\n                 }\n             }\n", "nb_test": 79, "linesAdd": 21, "jira_id": "1999", "singleLine": false, "nb_skipped": 0, "commit": "ad38e46b", "nb_failure": 1, "linesRem": 15}, {"files": 2, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOptionalIncludedAtRoot(org.apache.maven.artifact.resolver.DefaultArtifactCollectorTest): Check artifact list expected:<[test:a:jar:1.0, test:b:jar:1.0]> but was:<[test:a:jar:1.0]>"], "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\nindex 8f26cc7..3daff67 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n@@ -82,7 +82,7 @@ public ArtifactResolutionResult collect( Set artifacts, Artifact originatingArti\n                     if ( node.filterTrail( filter ) )\n                     {\n                         // If it was optional, we don't add it or its children, just allow the update of the version and scope\n-                        if ( !artifact.isOptional() )\n+                        if ( node.isChildOfRootNode() || !artifact.isOptional() )\n                         {\n                             artifact.setDependencyTrail( node.getDependencyTrail() );\n \n@@ -224,7 +224,7 @@ else if ( currentRange == null )\n             {\n                 ResolutionNode child = (ResolutionNode) i.next();\n                 // We leave in optional ones, but don't pick up its dependencies\n-                if ( !child.isResolved() && !child.getArtifact().isOptional() )\n+                if ( !child.isResolved() && ( !child.getArtifact().isOptional() || child.isChildOfRootNode() ) )\n                 {\n                     Artifact artifact = child.getArtifact();\n                     try\ndiff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\nindex ef47794..c3f1f66 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\n@@ -147,6 +147,11 @@ public boolean isResolved()\n         return children != null;\n     }\n     \n+    public boolean isChildOfRootNode()\n+    {\n+        return parent != null && parent.parent == null;\n+    }\n+\n     public Iterator getChildrenIterator()\n     {\n         return children.iterator();\n", "nb_test": 30, "linesAdd": 7, "jira_id": "1205", "singleLine": false, "nb_skipped": 0, "commit": "1bdeeccc", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testUndefinedOutputDirectory(org.apache.maven.project.MavenProjectTest)"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\nindex 088289d..1e235f2 100644\n--- a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n+++ b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n@@ -504,7 +504,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {                        \n@@ -580,9 +584,17 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 2 );\n \n-        list.add( getBuild().getTestOutputDirectory() );\n+        String d = getBuild().getTestOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n-        list.add( getBuild().getOutputDirectory() );\n+        d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n         \n         for ( Artifact a : getArtifacts() )\n         {            \n@@ -644,7 +656,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {\n@@ -717,7 +733,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {\n", "nb_test": 238, "linesAdd": 25, "jira_id": "5209", "singleLine": false, "nb_skipped": 0, "commit": "87884c7b", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["org.apache.maven.execution.scope.internal.MojoExecutionScopeTest#testMultiKeyInstance AssertionFailedError"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/execution/scope/internal/MojoExecutionScope.java b/maven-core/src/main/java/org/apache/maven/execution/scope/internal/MojoExecutionScope.java\nindex fc8b1e6..d8a5f6c 100644\n--- a/maven-core/src/main/java/org/apache/maven/execution/scope/internal/MojoExecutionScope.java\n+++ b/maven-core/src/main/java/org/apache/maven/execution/scope/internal/MojoExecutionScope.java\n@@ -19,6 +19,8 @@\n  * under the License.\n  */\n \n+import java.util.Collection;\n+import java.util.IdentityHashMap;\n import java.util.LinkedList;\n import java.util.Map;\n \n@@ -177,36 +179,42 @@ protected void configure()\n     public void beforeMojoExecution( MojoExecutionEvent event )\n         throws MojoExecutionException\n     {\n-        for ( Object provided : getScopeState().provided.values() )\n-        {\n-            if ( provided instanceof WeakMojoExecutionListener )\n+        for ( WeakMojoExecutionListener provided : getProvidedListeners() )\n         {\n-                ( (WeakMojoExecutionListener) provided ).beforeMojoExecution( event );\n-            }\n+            provided.beforeMojoExecution( event );\n         }\n     }\n \n     public void afterMojoExecutionSuccess( MojoExecutionEvent event )\n         throws MojoExecutionException\n     {\n-        for ( Object provided : getScopeState().provided.values() )\n-        {\n-            if ( provided instanceof WeakMojoExecutionListener )\n+        for ( WeakMojoExecutionListener provided : getProvidedListeners() )\n         {\n-                ( (WeakMojoExecutionListener) provided ).afterMojoExecutionSuccess( event );\n-            }\n+            provided.afterMojoExecutionSuccess( event );\n         }\n     }\n \n     public void afterExecutionFailure( MojoExecutionEvent event )\n     {\n+        for ( WeakMojoExecutionListener provided : getProvidedListeners() )\n+        {\n+            provided.afterExecutionFailure( event );\n+        }\n+    }\n+\n+    private Collection<WeakMojoExecutionListener> getProvidedListeners()\n+    {\n+        // the same instance can be provided multiple times under different Key's\n+        // deduplicate instances to avoid redundant beforeXXX/afterXXX callbacks\n+        IdentityHashMap<WeakMojoExecutionListener, Object> listeners =\n+            new IdentityHashMap<WeakMojoExecutionListener, Object>();\n         for ( Object provided : getScopeState().provided.values() )\n         {\n             if ( provided instanceof WeakMojoExecutionListener )\n             {\n-                ( (WeakMojoExecutionListener) provided ).afterExecutionFailure( event );\n+                listeners.put( (WeakMojoExecutionListener) provided, null );\n             }\n         }\n+        return listeners.keySet();\n     }\n-\n }\n", "nb_test": 245, "linesAdd": 18, "jira_id": "5655", "singleLine": false, "nb_skipped": 0, "commit": "96337372", "nb_failure": 1, "linesRem": 12}, {"files": 2, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testShouldNotCarryExclusionsOverFromDependencyToDependency(org.apache.maven.project.artifact.MavenMetadataSourceTest): expected same:<org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter@26c55db3> was not:<org.apache.maven.artifact.resolver.filter.AndArtifactFilter@678aa6a7>"], "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/profiles/DefaultProfileManager.java b/maven-project/src/main/java/org/apache/maven/profiles/DefaultProfileManager.java\nindex 5f6534d..68acd29 100644\n--- a/maven-project/src/main/java/org/apache/maven/profiles/DefaultProfileManager.java\n+++ b/maven-project/src/main/java/org/apache/maven/profiles/DefaultProfileManager.java\n@@ -66,13 +66,14 @@ public DefaultProfileManager( PlexusContainer container )\n      */\n     public DefaultProfileManager( PlexusContainer container, Properties props )\n     {\n-        this( container, (Settings)null );\n-        if (props != null) {\n-            systemProperties = props;\n-        }\n+        this( container, (Settings)null, props );\n         \n     }\n \n+    /**\n+     * @deprecated without passing in the system properties, the SystemPropertiesProfileActivator will not work correctly\n+     * in embedded envirnments.\n+     */\n     public DefaultProfileManager( PlexusContainer container, Settings settings )\n     {\n         this.container = container;\n@@ -80,6 +81,23 @@ public DefaultProfileManager( PlexusContainer container, Settings settings )\n         loadSettingsProfiles( settings );\n     }\n     \n+    /**\n+     * the properties passed to the profile manager are the props that\n+     * are passed to maven, possibly containing profile activator properties\n+     *\n+     */\n+    public DefaultProfileManager( PlexusContainer container, Settings settings, Properties props )\n+    {\n+        this.container = container;\n+\n+        loadSettingsProfiles( settings );\n+        \n+        if ( props != null )\n+        {\n+            systemProperties = props;\n+        }\n+    }\n+    \n     public Properties getSystemProperties() {\n         return systemProperties;\n     }\ndiff --git a/maven-project/src/main/java/org/apache/maven/project/artifact/MavenMetadataSource.java b/maven-project/src/main/java/org/apache/maven/project/artifact/MavenMetadataSource.java\nindex ffa3ac6..bde81f3 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/artifact/MavenMetadataSource.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/artifact/MavenMetadataSource.java\n@@ -48,7 +48,6 @@\n import java.io.File;\n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.List;\n@@ -337,7 +336,9 @@ public static Set createArtifacts( ArtifactFactory artifactFactory, List depende\n                 artifact.setFile( new File( d.getSystemPath() ) );\n             }\n \n-            if ( artifact != null && ( dependencyFilter == null || dependencyFilter.include( artifact ) ) )\n+            ArtifactFilter artifactFilter = dependencyFilter;\n+            \n+            if ( artifact != null && ( artifactFilter == null || artifactFilter.include( artifact ) ) )\n             {\n                 if ( d.getExclusions() != null && !d.getExclusions().isEmpty() )\n                 {\n@@ -350,20 +351,20 @@ public static Set createArtifacts( ArtifactFactory artifactFactory, List depende\n \n                     ArtifactFilter newFilter = new ExcludesArtifactFilter( exclusions );\n \n-                    if ( dependencyFilter != null )\n+                    if ( artifactFilter != null )\n                     {\n                         AndArtifactFilter filter = new AndArtifactFilter();\n-                        filter.add( dependencyFilter );\n+                        filter.add( artifactFilter );\n                         filter.add( newFilter );\n-                        dependencyFilter = filter;\n+                        artifactFilter = filter;\n                     }\n                     else\n                     {\n-                        dependencyFilter = newFilter;\n+                        artifactFilter = newFilter;\n                     }\n                 }\n \n-                artifact.setDependencyFilter( dependencyFilter );\n+                artifact.setDependencyFilter( artifactFilter );\n \n                 if ( project != null )\n                 {\n", "nb_test": 106, "linesAdd": 21, "jira_id": "1797", "singleLine": false, "nb_skipped": 0, "commit": "5d99b35c", "nb_failure": 1, "linesRem": 11}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPerLookupInstantiation(org.apache.maven.repository.legacy.DefaultWagonManagerTest)"], "patch": "diff --git a/maven-compat/src/main/java/org/apache/maven/repository/legacy/DefaultWagonManager.java b/maven-compat/src/main/java/org/apache/maven/repository/legacy/DefaultWagonManager.java\nindex 00e7f38..0b4f3ae 100644\n--- a/maven-compat/src/main/java/org/apache/maven/repository/legacy/DefaultWagonManager.java\n+++ b/maven-compat/src/main/java/org/apache/maven/repository/legacy/DefaultWagonManager.java\n@@ -46,6 +46,7 @@\n import org.codehaus.plexus.component.annotations.Component;\n import org.codehaus.plexus.component.annotations.Requirement;\n import org.codehaus.plexus.component.repository.exception.ComponentLifecycleException;\n+import org.codehaus.plexus.component.repository.exception.ComponentLookupException;\n import org.codehaus.plexus.logging.Logger;\n import org.codehaus.plexus.util.FileUtils;\n \n@@ -67,9 +68,6 @@\n     @Requirement\n     private PlexusContainer container;\n \n-    @Requirement(role = Wagon.class)\n-    private Map<String, Wagon> wagons;\n-\n     @Requirement\n     private UpdateCheckManager updateCheckManager;\n \n@@ -686,11 +684,16 @@ public Wagon getWagon( String protocol )\n         }\n \n         String hint = protocol.toLowerCase( java.util.Locale.ENGLISH );\n-        Wagon wagon = (Wagon) wagons.get( hint );\n \n-        if ( wagon == null )\n+        Wagon wagon;\n+        try\n+        {\n+            wagon = container.lookup( Wagon.class, hint );\n+        }\n+        catch ( ComponentLookupException e )\n         {\n-            throw new UnsupportedProtocolException( \"Cannot find wagon which supports the requested protocol: \" + protocol );\n+            throw new UnsupportedProtocolException( \"Cannot find wagon which supports the requested protocol: \"\n+                + protocol, e );\n         }\n \n         return wagon;\n", "nb_test": 173, "linesAdd": 9, "jira_id": "4474", "singleLine": false, "nb_skipped": 0, "commit": "269c956e", "nb_failure": 1, "linesRem": 6}, {"files": 2, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["DefaultToolchainManagerPrivateTest.testToolchainsForAvailableType:102 expected:<1> but was:<2>", "DefaultToolchainManagerPrivateTest.testToolchainsForConfiguredType:153 expected:<3> but was:<4>", "DefaultToolchainManagerPrivateTest.testToolchainsForUnknownType:122 expected:<0> but was:<2>"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/toolchain/DefaultToolchainManagerPrivate.java b/maven-core/src/main/java/org/apache/maven/toolchain/DefaultToolchainManagerPrivate.java\nindex 923db00..e2eacea 100644\n--- a/maven-core/src/main/java/org/apache/maven/toolchain/DefaultToolchainManagerPrivate.java\n+++ b/maven-core/src/main/java/org/apache/maven/toolchain/DefaultToolchainManagerPrivate.java\n@@ -74,7 +74,7 @@\n             throw new MisconfiguredToolchainException( e.getMessage(), e );\n         }\n         \n-        PersistedToolchains pers = buildResult.getEffectiveToolchains();\n+        PersistedToolchains effectiveToolchains = buildResult.getEffectiveToolchains();\n \n         List<ToolchainPrivate> toRet = new ArrayList<ToolchainPrivate>();\n \n@@ -84,9 +84,9 @@\n             logger.error( \"Missing toolchain factory for type: \" + type\n                 + \". Possibly caused by misconfigured project.\" );\n         }\n-        else if ( pers != null )\n+        else\n         {\n-            List<ToolchainModel> lst = pers.getToolchains();\n+            List<ToolchainModel> lst = effectiveToolchains.getToolchains();\n             if ( lst != null )\n             {\n                 for ( ToolchainModel toolchainModel : lst )\n@@ -97,11 +97,9 @@ else if ( pers != null )\n                     }\n                 }\n             }\n-        }\n             \n-        for ( ToolchainFactory toolchainFactory : factories.values() )\n-        {\n-            ToolchainPrivate tool = toolchainFactory.createDefaultToolchain();\n+            // add default toolchain\n+            ToolchainPrivate tool = fact.createDefaultToolchain();\n             if ( tool != null )\n             {\n                 toRet.add( tool );\ndiff --git a/maven-core/src/main/java/org/apache/maven/toolchain/building/DefaultToolchainsBuildingResult.java b/maven-core/src/main/java/org/apache/maven/toolchain/building/DefaultToolchainsBuildingResult.java\nindex b50473f..b72e5aa 100644\n--- a/maven-core/src/main/java/org/apache/maven/toolchain/building/DefaultToolchainsBuildingResult.java\n+++ b/maven-core/src/main/java/org/apache/maven/toolchain/building/DefaultToolchainsBuildingResult.java\n@@ -26,6 +26,7 @@\n import org.apache.maven.toolchain.model.PersistedToolchains;\n \n /**\n+ * Holds the result of the merged toolchains and holds the problems during this build, if any.\n  * \n  * @author Robert Scholte\n  * @since 3.2.6\n@@ -38,6 +39,12 @@\n     \n     private List<Problem> problems;\n     \n+    /**\n+     * Default constructor\n+     * \n+     * @param effectiveToolchains the merged toolchains, may not be {@code null}\n+     * @param problems the problems while building the effectiveToolchains, if any.\n+     */\n     public DefaultToolchainsBuildingResult( PersistedToolchains effectiveToolchains, List<Problem> problems )\n     {\n         this.effectiveToolchains = effectiveToolchains;\n", "nb_test": 262, "linesAdd": 4, "jira_id": "5716", "singleLine": false, "nb_skipped": 0, "commit": "2d0ec942", "nb_failure": 3, "linesRem": 7}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testVersionsQualifier(org.apache.maven.artifact.versioning.ComparableVersionTest)", "testVersionComparing(org.apache.maven.artifact.versioning.ComparableVersionTest)"], "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java\nindex 3f36455..cf617d6 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java\n@@ -145,7 +145,7 @@ public String toString()\n     private static class StringItem\n         implements Item\n     {\n-        private final static String[] QUALIFIERS = { \"snapshot\", \"alpha\", \"beta\", \"milestone\", \"rc\", \"\", \"sp\" };\n+        private final static String[] QUALIFIERS = { \"alpha\", \"beta\", \"milestone\", \"rc\", \"snapshot\", \"\", \"sp\" };\n \n         private final static List<String> _QUALIFIERS = Arrays.asList( QUALIFIERS );\n \n", "nb_test": 11, "linesAdd": 1, "jira_id": "2281", "singleLine": false, "nb_skipped": 0, "commit": "f0fcef7e", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testVersionRangeInclusiveBounds(org.apache.maven.model.profile.activation.JdkVersionProfileActivatorTest)", "testVersionRangeExclusiveBounds(org.apache.maven.model.profile.activation.JdkVersionProfileActivatorTest)"], "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\nindex 617ffa2..1ae90e1 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n@@ -108,20 +108,10 @@ private static int getRelationOrder( String value, RangeValue rangeValue, boolea\n         List<String> valueTokens = new ArrayList<String>( Arrays.asList( value.split( \"[\\\\.\\\\-\\\\_]\" ) ) );\n         List<String> rangeValueTokens = new ArrayList<String>( Arrays.asList( rangeValue.value.split( \"\\\\.\" ) ) );\n \n-        int max = Math.max( valueTokens.size(), rangeValueTokens.size() );\n-        addZeroTokens( valueTokens, max );\n-        addZeroTokens( rangeValueTokens, max );\n+        addZeroTokens( valueTokens, 3 );\n+        addZeroTokens( rangeValueTokens, 3 );\n \n-        if ( value.equals( rangeValue.getValue() ) )\n-        {\n-            if ( !rangeValue.isClosed() )\n-            {\n-                return isLeft ? -1 : 1;\n-            }\n-            return 0;\n-        }\n-\n-        for ( int i = 0; i < valueTokens.size() && i < rangeValueTokens.size(); i++ )\n+        for ( int i = 0; i < 3; i++ )\n         {\n             int x = Integer.parseInt( valueTokens.get( i ) );\n             int y = Integer.parseInt( rangeValueTokens.get( i ) );\n@@ -143,14 +133,11 @@ else if ( x > y )\n \n     private static void addZeroTokens( List<String> tokens, int max )\n     {\n-        if ( tokens.size() < max )\n-        {\n-            for ( int i = 0; i < ( max - tokens.size() ); i++ )\n+        while ( tokens.size() < max )\n         {\n             tokens.add( \"0\" );\n         }\n     }\n-    }\n \n     private static boolean isRange( String value )\n     {\n", "nb_test": 45, "linesAdd": 4, "jira_id": "4518", "singleLine": false, "nb_skipped": 0, "commit": "f5ebc72d", "nb_failure": 2, "linesRem": 17}, {"files": 1, "project": "maven", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testThatPluginDependencyThatHasSystemScopeIsResolved(org.apache.maven.plugin.PluginManagerTest)"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginDependenciesResolver.java b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginDependenciesResolver.java\nindex 954616f..57374d2 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginDependenciesResolver.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginDependenciesResolver.java\n@@ -98,7 +98,10 @@ public Artifact resolve( Plugin plugin, ArtifactResolutionRequest request )\n         Set<Artifact> overrideArtifacts = new LinkedHashSet<Artifact>();\n         for ( Dependency dependency : plugin.getDependencies() )\n         {\n+\t          if ( !Artifact.SCOPE_SYSTEM.equals( dependency.getScope() ) )\n+\t          {\n \t              dependency.setScope( Artifact.SCOPE_RUNTIME );\n+\t          }\n             overrideArtifacts.add( repositorySystem.createDependencyArtifact( dependency ) );\n         }\n \n", "nb_test": 226, "linesAdd": 3, "jira_id": "4761", "singleLine": false, "nb_skipped": 0, "commit": "8cdb461f", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCloneWithActiveProfile(org.apache.maven.project.MavenProjectTest)"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\nindex 8a7d64b..de3c278 100644\n--- a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n+++ b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n@@ -1407,7 +1407,7 @@ public ArtifactRepository getDistributionManagementArtifactRepository()\n \n     public void setActiveProfiles( List<Profile> activeProfiles )\n     {\n-        this.activeProfiles.addAll( activeProfiles );\n+        this.activeProfiles = activeProfiles;\n     }\n \n     public List<Profile> getActiveProfiles()\n", "nb_test": 232, "linesAdd": 1, "jira_id": "4918", "singleLine": false, "nb_skipped": 0, "commit": "691a03a7", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "maven", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testPluginManagementDependencies(org.apache.maven.project.builder.PomConstructionTest)"], "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/project/builder/PomClassicDomainModel.java b/maven-project/src/main/java/org/apache/maven/project/builder/PomClassicDomainModel.java\nindex 5475819..5abb68c 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/builder/PomClassicDomainModel.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/builder/PomClassicDomainModel.java\n@@ -306,6 +306,7 @@ public File getFile()\n             s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri);\n             s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);\n             s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration);\n+            s.add(ProjectUri.Profiles.Profile.Build.Plugins.Plugin.configuration);//TODO: More profile info\n             modelProperties = ModelMarshaller.marshallXmlToModelProperties(\n                 getInputStream(), ProjectUri.baseUri, s );\n         }\ndiff --git a/maven-project/src/main/java/org/apache/maven/project/builder/impl/DefaultProjectBuilder.java b/maven-project/src/main/java/org/apache/maven/project/builder/impl/DefaultProjectBuilder.java\nindex c5604bb..085bc4d 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/builder/impl/DefaultProjectBuilder.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/builder/impl/DefaultProjectBuilder.java\n@@ -213,14 +213,29 @@ private PomClassicDomainModel buildModel( File pom,\n \n         PomClassicDomainModel domainModel = new PomClassicDomainModel( pom );\n         domainModel.setProjectDirectory( pom.getParentFile() );\n+        List<DomainModel> domainModels = new ArrayList<DomainModel>();\n+        domainModels.add( domainModel );\n \n         ProfileContext profileContext = new ProfileContext(new DefaultModelDataSource(domainModel.getModelProperties(),\n                 PomTransformer.MODEL_CONTAINER_FACTORIES), activeProfileIds, properties);\n+\n         Collection<ModelContainer> profileContainers = profileContext.getActiveProfiles();\n-        //get mixin\n \n-        List<DomainModel> domainModels = new ArrayList<DomainModel>();\n-        domainModels.add( domainModel );\n+        for(ModelContainer mc : profileContainers)\n+        {\n+            List<ModelProperty> transformed = new ArrayList<ModelProperty>();\n+            transformed.add(new ModelProperty(ProjectUri.xUri, null));\n+            for(ModelProperty mp : mc.getProperties())\n+            {\n+                if(mp.getUri().startsWith(ProjectUri.Profiles.Profile.xUri) && !mp.getUri().equals(ProjectUri.Profiles.Profile.id)\n+                        && !mp.getUri().startsWith(ProjectUri.Profiles.Profile.Activation.xUri) )\n+                {\n+                    transformed.add(new ModelProperty(mp.getUri().replace(ProjectUri.Profiles.Profile.xUri, ProjectUri.xUri),\n+                            mp.getResolvedValue()));\n+                }\n+            }\n+            domainModels.add(new PomClassicDomainModel(transformed));\n+        }\n \n         File parentFile = null;\n         int lineageCount = 0;\n", "nb_test": 146, "linesAdd": 19, "jira_id": "2174", "singleLine": false, "nb_skipped": 0, "commit": "778f044e", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["org.apache.maven.DefaultProjectDependencyGraphTest#testVerifyThatDownsteamProjectsComeInSortedOrder AssertionFailedError", "org.apache.maven.DefaultProjectDependencyGraphTest#testTransitivesInOrder AssertionFailedError", "org.apache.maven.DefaultProjectDependencyGraphTest#testNonTransitivesInOrder AssertionFailedError", "org.apache.maven.DefaultProjectDependencyGraphTest#testWithTranistiveOnly AssertionFailedError"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/DefaultProjectDependencyGraph.java b/maven-core/src/main/java/org/apache/maven/DefaultProjectDependencyGraph.java\nindex 84d2cc5..4074e58 100644\n--- a/maven-core/src/main/java/org/apache/maven/DefaultProjectDependencyGraph.java\n+++ b/maven-core/src/main/java/org/apache/maven/DefaultProjectDependencyGraph.java\n@@ -23,6 +23,7 @@\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n \n import org.apache.maven.execution.ProjectDependencyGraph;\n import org.apache.maven.project.DuplicateProjectException;\n@@ -48,7 +49,8 @@\n      * @throws DuplicateProjectException\n      * @throws CycleDetectedException\n      */\n-    public DefaultProjectDependencyGraph( Collection<MavenProject> projects ) throws CycleDetectedException, DuplicateProjectException\n+    public DefaultProjectDependencyGraph( Collection<MavenProject> projects )\n+        throws CycleDetectedException, DuplicateProjectException\n     {\n         this.sorter = new ProjectSorter( projects );\n     }\n@@ -65,14 +67,14 @@ public DefaultProjectDependencyGraph( Collection<MavenProject> projects ) throws\n             throw new IllegalArgumentException( \"project missing\" );\n         }\n \n-        Collection<String> projectIds = new HashSet<String>();\n+        Set<String> projectIds = new HashSet<String>();\n \n         getDownstreamProjects( ProjectSorter.getId( project ), projectIds, transitive );\n \n-        return getProjects( projectIds );\n+        return getSortedProjects( projectIds );\n     }\n \n-    private void getDownstreamProjects( String projectId, Collection<String> projectIds, boolean transitive )\n+    private void getDownstreamProjects( String projectId, Set<String> projectIds, boolean transitive )\n     {\n         for ( String id : sorter.getDependents( projectId ) )\n         {\n@@ -90,11 +92,11 @@ private void getDownstreamProjects( String projectId, Collection<String> project\n             throw new IllegalArgumentException( \"project missing\" );\n         }\n \n-        Collection<String> projectIds = new HashSet<String>();\n+        Set<String> projectIds = new HashSet<String>();\n \n         getUpstreamProjects( ProjectSorter.getId( project ), projectIds, transitive );\n \n-        return getProjects( projectIds );\n+        return getSortedProjects( projectIds );\n     }\n \n     private void getUpstreamProjects( String projectId, Collection<String> projectIds, boolean transitive )\n@@ -108,21 +110,19 @@ private void getUpstreamProjects( String projectId, Collection<String> projectId\n         }\n     }\n \n-    private List<MavenProject> getProjects( Collection<String> projectIds )\n+    private List<MavenProject> getSortedProjects( Set<String> projectIds )\n     {\n-        List<MavenProject> projects = new ArrayList<MavenProject>( projectIds.size() );\n+        List<MavenProject> result = new ArrayList<MavenProject>( projectIds.size() );\n \n-        for ( String projectId : projectIds )\n+        for ( MavenProject mavenProject : sorter.getSortedProjects() )\n         {\n-            MavenProject project = sorter.getProjectMap().get( projectId );\n-\n-            if ( project != null )\n+            if ( projectIds.contains( ProjectSorter.getId( mavenProject ) ) )\n             {\n-                projects.add( project );\n+                result.add( mavenProject );\n             }\n         }\n \n-        return projects;\n+        return result;\n     }\n \n     @Override\n", "nb_test": 252, "linesAdd": 14, "jira_id": "5687", "singleLine": false, "nb_skipped": 0, "commit": "3d2d8619", "nb_failure": 4, "linesRem": 14}, {"files": 6, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["org.apache.maven.model.building.ComplexActivationTest#testAndConditionInActivation AssertionFailedError"], "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileSelector.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileSelector.java\nindex c376c99..0aeed9d 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileSelector.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileSelector.java\n@@ -104,13 +104,19 @@ else if ( isActiveByDefault( profile ) )\n \n     private boolean isActive( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )\n     {\n+        boolean isActive = false;\n+        for ( ProfileActivator activator : activators ) {\n+            if ( activator.presentInConfig( profile, context, problems ) ) {\n+                isActive = true;\n+            }\n+        }\n         for ( ProfileActivator activator : activators )\n         {\n             try\n             {\n-                if ( activator.isActive( profile, context, problems ) )\n+                if ( activator.presentInConfig( profile, context, problems ) )\n                 {\n-                    return true;\n+                    isActive &=  activator.isActive( profile, context, problems );\n                 }\n             }\n             catch ( RuntimeException e )\n@@ -122,7 +128,7 @@ private boolean isActive( Profile profile, ProfileActivationContext context, Mod\n                 return false;\n             }\n         }\n-        return false;\n+        return isActive;\n     }\n \n     private boolean isActiveByDefault( Profile profile )\ndiff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/FileProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/FileProfileActivator.java\nindex 07ba79b..b1d0442 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/FileProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/FileProfileActivator.java\n@@ -167,4 +167,23 @@ else if ( path.contains( \"${basedir}\" ) )\n         return missing ? !fileExists : fileExists;\n     }\n \n+    @Override\n+    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )\n+    {\n+        Activation activation = profile.getActivation();\n+\n+        if ( activation == null )\n+        {\n+            return false;\n+        }\n+\n+        ActivationFile file = activation.getFile();\n+\n+        if ( file == null )\n+        {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n }\ndiff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\nindex 62b6cfb..10747de 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n@@ -83,6 +83,25 @@ else if ( isRange( jdk ) )\n         }\n     }\n \n+    @Override\n+    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )\n+    {\n+        Activation activation = profile.getActivation();\n+\n+        if ( activation == null )\n+        {\n+            return false;\n+        }\n+\n+        String jdk = activation.getJdk();\n+\n+        if ( jdk == null )\n+        {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private static boolean isInRange( String value, List<RangeValue> range )\n     {\n         int leftRelation = getRelationOrder( value, range.get( 0 ), true );\ndiff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java\nindex 94d380c..b6d3f05 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java\n@@ -76,6 +76,25 @@ public boolean isActive( Profile profile, ProfileActivationContext context, Mode\n         return active;\n     }\n \n+    @Override\n+    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )\n+    {\n+        Activation activation = profile.getActivation();\n+\n+        if ( activation == null )\n+        {\n+            return false;\n+        }\n+\n+        ActivationOS os = activation.getOs();\n+\n+        if ( os == null )\n+        {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private boolean ensureAtLeastOneNonNull( ActivationOS os )\n     {\n         return os.getArch() != null || os.getFamily() != null || os.getName() != null || os.getVersion() != null;\ndiff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/ProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/ProfileActivator.java\nindex 142dddf..7094a3f 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/ProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/ProfileActivator.java\n@@ -43,4 +43,17 @@\n      */\n     boolean isActive( Profile profile, ProfileActivationContext context, ModelProblemCollector problems );\n \n+    /**\n+     * Determines whether specified activation method is present in configuration or not. It should help to have AND between\n+     * activation conditions\n+     * Need for solving http://jira.codehaus.org/browse/MNG-4565\n+     * @param profile The profile whose activation status should be determined, must not be {@code null}.\n+     * @param context The environmental context used to determine the activation status of the profile, must not be\n+     *            {@code null}.\n+     * @param problems The container used to collect problems (e.g. bad syntax) that were encountered, must not be\n+     *            {@code null}.\n+     * @return {@code true} if the profile is active, {@code false} otherwise.\n+     */\n+    boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems );\n+\n }\ndiff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java\nindex 374647f..e8e6e99 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java\n@@ -103,4 +103,23 @@ public boolean isActive( Profile profile, ProfileActivationContext context, Mode\n         }\n     }\n \n+    @Override\n+    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )\n+    {\n+        Activation activation = profile.getActivation();\n+\n+        if ( activation == null )\n+        {\n+            return false;\n+        }\n+\n+        ActivationProperty property = activation.getProperty();\n+\n+        if ( property == null )\n+        {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n }\n", "nb_test": 96, "linesAdd": 87, "jira_id": "4565", "singleLine": false, "nb_skipped": 0, "commit": "c6529932", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMissingRequiredPropertiesTypeParameter(org.apache.maven.plugin.PluginParameterExceptionTest): expected:<... <toAddresses>(..)"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java b/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\nindex 350349d..4027fcc 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\n@@ -23,6 +23,7 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Properties;\n \n import org.apache.maven.plugin.descriptor.MojoDescriptor;\n import org.apache.maven.plugin.descriptor.Parameter;\n@@ -83,6 +84,7 @@ private static void decomposeParameterIntoUserInstructions( MojoDescriptor mojo,\n             boolean isArray = param.getType().endsWith( \"[]\" );\n             boolean isCollection = false;\n             boolean isMap = false;\n+            boolean isProperties = false;\n             if ( !isArray )\n             {\n                 try\n@@ -90,6 +92,7 @@ private static void decomposeParameterIntoUserInstructions( MojoDescriptor mojo,\n                     //assuming Type is available in current ClassLoader\n                     isCollection = Collection.class.isAssignableFrom( Class.forName( param.getType() ) );\n                     isMap = Map.class.isAssignableFrom( Class.forName( param.getType() ) );\n+                    isProperties = Properties.class.isAssignableFrom( Class.forName( param.getType() ) );\n                 }\n                 catch ( ClassNotFoundException e )\n                 {\n@@ -106,6 +109,13 @@ private static void decomposeParameterIntoUserInstructions( MojoDescriptor mojo,\n                 messageBuffer.append(  '\\n' );\n                 messageBuffer.append( \"    <item>\" );\n             }\n+            else if ( isProperties )\n+            {\n+                messageBuffer.append(  '\\n' );\n+                messageBuffer.append( \"    <property>\\n\" );\n+                messageBuffer.append( \"      <name>KEY</name>\\n\" );\n+                messageBuffer.append( \"      <value>\" );\n+            }\n             else if ( isMap )\n             {\n                 messageBuffer.append(  '\\n' );\n@@ -117,6 +127,12 @@ else if ( isMap )\n                 messageBuffer.append( \"</item>\\n\" );\n                 messageBuffer.append( \"  \" );\n             }\n+            else if ( isProperties )\n+            {\n+                messageBuffer.append( \"</value>\\n\" );\n+                messageBuffer.append( \"    </property>\\n\" );\n+                messageBuffer.append( \"  \" );\n+            }\n             else if ( isMap )\n             {\n                 messageBuffer.append( \"</KEY>\\n\" );\n", "nb_test": 246, "linesAdd": 16, "jira_id": "3131", "singleLine": false, "nb_skipped": 0, "commit": "f6f4ef5e", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testScopeUpdate(org.apache.maven.artifact.resolver.DefaultArtifactCollectorTest): Check version expected:<1...> but was:<2...>"], "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\nindex b6d379e..108a976 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n@@ -137,18 +137,7 @@ private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVer\n                     VersionRange previousRange = previous.getArtifact().getVersionRange();\n                     VersionRange currentRange = node.getArtifact().getVersionRange();\n \n-                    // TODO: why do we force the version on it? what if they don't match?\n-                    if ( previousRange == null )\n-                    {\n-                        // version was already resolved\n-                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );\n-                    }\n-                    else if ( currentRange == null )\n-                    {\n-                        // version was already resolved\n-                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );\n-                    }\n-                    else\n+                    if ( previousRange != null && currentRange != null )\n                     {\n                         // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\n                         // version but the restriction is identical\n@@ -185,7 +174,8 @@ else if ( currentRange == null )\n \n                     // TODO: should this be part of mediation?\n                     // previous one is more dominant\n-                    ResolutionNode nearest, farthest;\n+                    ResolutionNode nearest;\n+                    ResolutionNode farthest;\n                     if ( previous.getDepth() <= node.getDepth() )\n                     {\n                         nearest = previous;\n@@ -197,11 +187,9 @@ else if ( currentRange == null )\n                         farthest = previous;\n                     }\n \n-                    /* if we need to update scope of nearest to use farthest scope */\n                     if ( checkScopeUpdate( farthest, nearest, listeners ) )\n                     {\n-                        fireEvent( ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthest.getArtifact() );\n-                        /* we need nearest version but farthest scope */\n+                        // if we need to update scope of nearest to use farthest scope, use the nearest version, but farthest scope\n                         nearest.disable();\n                         farthest.getArtifact().setVersion( nearest.getArtifact().getVersion() );\n                     }\n@@ -321,13 +309,14 @@ else if ( currentRange == null )\n     }\n \n     /**\n-     * Check if the scope of the nearest needs to be updated with the scope of the farthest.\n+     * Check if the scope needs to be updated.\n      * <a href=\"http://docs.codehaus.org/x/IGU#DependencyMediationandConflictResolution-Scoperesolution\">More info</a>.\n+     *\n      * @param farthest  farthest resolution node\n      * @param nearest   nearest resolution node\n      * @param listeners\n      */\n-    private boolean checkScopeUpdate( ResolutionNode farthest, ResolutionNode nearest, List listeners )\n+    boolean checkScopeUpdate( ResolutionNode farthest, ResolutionNode nearest, List listeners )\n     {\n         boolean updateScope = false;\n         Artifact farthestArtifact = farthest.getArtifact();\n@@ -354,6 +343,16 @@ private boolean checkScopeUpdate( ResolutionNode farthest, ResolutionNode neares\n             fireEvent( ResolutionListener.UPDATE_SCOPE_CURRENT_POM, listeners, nearest, farthestArtifact );\n         }\n \n+        if ( updateScope )\n+        {\n+            fireEvent( ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthestArtifact );\n+\n+            // previously we cloned the artifact, but it is more effecient to just update the scope\n+            // if problems are later discovered that the original object needs its original scope value, cloning may\n+            // again be appropriate\n+            nearestArtifact.setScope( farthestArtifact.getScope() );\n+        }\n+\n         return updateScope;\n     }\n \ndiff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\nindex 067e790..7d39bf9 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\n@@ -219,7 +219,7 @@ public boolean filterTrail( ArtifactFilter filter )\n \n     public String toString()\n     {\n-        return artifact.toString() + \" (\" + depth + \")\";\n+        return artifact.toString() + \" (\" + depth + \"; \" + ( active ? \"enabled\" : \"disabled\" ) + \")\";\n     }\n \n }\n", "nb_test": 39, "linesAdd": 12, "jira_id": "1895", "singleLine": false, "nb_skipped": 0, "commit": "806eaeb0", "nb_failure": 1, "linesRem": 13}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testUndefinedOutputDirectory(org.apache.maven.project.MavenProjectTest)"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\nindex 088289d..1e235f2 100644\n--- a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n+++ b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n@@ -504,7 +504,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {                        \n@@ -580,9 +584,17 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 2 );\n \n-        list.add( getBuild().getTestOutputDirectory() );\n+        String d = getBuild().getTestOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n-        list.add( getBuild().getOutputDirectory() );\n+        d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n         \n         for ( Artifact a : getArtifacts() )\n         {            \n@@ -644,7 +656,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {\n@@ -717,7 +733,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {\n", "nb_test": 238, "linesAdd": 25, "jira_id": "5209", "singleLine": false, "nb_skipped": 0, "commit": "ed651a4d", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testValidateMirror(org.apache.maven.settings.validation.DefaultSettingsValidatorTest)"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/settings/validation/DefaultSettingsValidator.java b/maven-core/src/main/java/org/apache/maven/settings/validation/DefaultSettingsValidator.java\nindex b44d8d9..0b6eaaf 100644\n--- a/maven-core/src/main/java/org/apache/maven/settings/validation/DefaultSettingsValidator.java\n+++ b/maven-core/src/main/java/org/apache/maven/settings/validation/DefaultSettingsValidator.java\n@@ -21,12 +21,15 @@\n \n import java.util.List;\n \n+import org.apache.maven.settings.Mirror;\n import org.apache.maven.settings.Profile;\n import org.apache.maven.settings.Repository;\n+import org.apache.maven.settings.Server;\n import org.apache.maven.settings.Settings;\n import org.apache.maven.settings.building.SettingsProblem;\n import org.apache.maven.settings.building.SettingsProblemCollector;\n import org.codehaus.plexus.component.annotations.Component;\n+import org.codehaus.plexus.util.StringUtils;\n \n /**\n  * @author Milos Kleint\n@@ -36,16 +39,69 @@\n     implements SettingsValidator\n {\n \n+    private static final String ID_REGEX = \"[A-Za-z0-9_\\\\-.]+\";\n+\n     public void validate( Settings settings, SettingsProblemCollector problems )\n     {\n+        if ( settings.isUsePluginRegistry() )\n+        {\n+            addWarn( problems, \"'usePluginRegistry' is deprecated and has no effect.\" );\n+        }\n+\n+        List<String> pluginGroups = settings.getPluginGroups();\n+\n+        if ( pluginGroups != null )\n+        {\n+            for ( int i = 0; i < pluginGroups.size(); i++ )\n+            {\n+                String pluginGroup = pluginGroups.get( i ).trim();\n+\n+                if ( StringUtils.isBlank( pluginGroup ) )\n+                {\n+                    addError( problems, \"'pluginGroups.pluginGroup[\" + i + \"]' must not be empty.\" );\n+                }\n+                else if ( !pluginGroup.matches( ID_REGEX ) )\n+                {\n+                    addError( problems, \"'pluginGroups.pluginGroup[\" + i\n+                        + \"]' must denote a valid group id and match the pattern \" + ID_REGEX );\n+                }\n+            }\n+        }\n+\n+        List<Server> servers = settings.getServers();\n+\n+        if ( servers != null )\n+        {\n+            for ( int i = 0; i < servers.size(); i++ )\n+            {\n+                Server server = servers.get( i );\n+\n+                validateStringNotEmpty( problems, \"servers.server[\" + i + \"].id\", server.getId(), null );\n+            }\n+        }\n+\n+        List<Mirror> mirrors = settings.getMirrors();\n+\n+        if ( mirrors != null )\n+        {\n+            for ( Mirror mirror : mirrors )\n+            {\n+                validateStringNotEmpty( problems, \"mirrors.mirror.id\", mirror.getId(), mirror.getUrl() );\n+\n+                validateStringNotEmpty( problems, \"mirrors.mirror.url\", mirror.getUrl(), mirror.getId() );\n+\n+                validateStringNotEmpty( problems, \"mirrors.mirror.mirrorOf\", mirror.getMirrorOf(), mirror.getId() );\n+            }\n+        }\n+\n         List<Profile> profiles = settings.getProfiles();\n \n         if ( profiles != null )\n         {\n-            for ( Profile prof : profiles )\n+            for ( Profile profile : profiles )\n             {\n-                validateRepositories( problems, prof.getRepositories(), \"repositories.repository\" );\n-                validateRepositories( problems, prof.getPluginRepositories(), \"pluginRepositories.pluginRepository\" );\n+                validateRepositories( problems, profile.getRepositories(), \"repositories.repository\" );\n+                validateRepositories( problems, profile.getPluginRepositories(), \"pluginRepositories.pluginRepository\" );\n             }\n         }\n     }\n@@ -54,9 +110,15 @@ private void validateRepositories( SettingsProblemCollector problems, List<Repos\n     {\n         for ( Repository repository : repositories )\n         {\n-            validateStringNotEmpty( problems, prefix + \".id\", repository.getId() );\n+            validateStringNotEmpty( problems, prefix + \".id\", repository.getId(), repository.getUrl() );\n \n-            validateStringNotEmpty( problems, prefix + \".url\", repository.getUrl() );\n+            validateStringNotEmpty( problems, prefix + \".url\", repository.getUrl(), repository.getId() );\n+\n+            if ( \"legacy\".equals( repository.getLayout() ) )\n+            {\n+                addWarn( problems, \"'\" + prefix + \".layout' for \" + repository.getId()\n+                    + \" uses the deprecated value 'legacy'.\" );\n+            }\n         }\n     }\n \n@@ -64,11 +126,6 @@ private void validateRepositories( SettingsProblemCollector problems, List<Repos\n     // Field validation\n     // ----------------------------------------------------------------------\n \n-    private boolean validateStringNotEmpty( SettingsProblemCollector problems, String fieldName, String string )\n-    {\n-        return validateStringNotEmpty( problems, fieldName, string, null );\n-    }\n-\n     /**\n      * Asserts:\n      * <p/>\n@@ -137,4 +194,9 @@ private void addError( SettingsProblemCollector problems, String msg )\n         problems.add( SettingsProblem.Severity.ERROR, msg, -1, -1, null );\n     }\n \n+    private void addWarn( SettingsProblemCollector problems, String msg )\n+    {\n+        problems.add( SettingsProblem.Severity.WARNING, msg, -1, -1, null );\n+    }\n+\n }\n", "nb_test": 198, "linesAdd": 72, "jira_id": "3616", "singleLine": false, "nb_skipped": 0, "commit": "912a565f", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCollectChangesVersionOfOriginatingArtifactIfInDependencyManagementHasDifferentVersion(org.apache.maven.artifact.resolver.DefaultArtifactCollectorTest): collect has modified version in originating artifact expected:<1...> but was:<2...>"], "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\nindex 47e7acf..9a923d8 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n@@ -69,8 +69,7 @@ public ArtifactResolutionResult collect( Set artifacts, Artifact originatingArti\n \n         root.addDependencies( artifacts, remoteRepositories, filter );\n \n-        ManagedVersionMap versionMap = (managedVersions != null && managedVersions instanceof ManagedVersionMap) ?\n-            (ManagedVersionMap)managedVersions : new ManagedVersionMap(managedVersions);\n+        ManagedVersionMap versionMap = getManagedVersionsMap( originatingArtifact, managedVersions );\n \n         recurse( root, resolvedArtifacts, versionMap, localRepository, remoteRepositories, source, filter,\n                  listeners );\n@@ -107,6 +106,45 @@ public ArtifactResolutionResult collect( Set artifacts, Artifact originatingArti\n         return result;\n     }\n \n+    /**\n+     * Get the map of managed versions, removing the originating artifact if it is also in managed versions\n+     * @param originatingArtifact artifact we are processing\n+     * @param managedVersions original managed versions\n+     */\n+    private ManagedVersionMap getManagedVersionsMap( Artifact originatingArtifact, Map managedVersions )\n+    {\n+        ManagedVersionMap versionMap;\n+        if ( managedVersions != null && managedVersions instanceof ManagedVersionMap )\n+        {\n+            versionMap = (ManagedVersionMap) managedVersions;\n+        }\n+        else\n+        {\n+            versionMap = new ManagedVersionMap( managedVersions );\n+        }\n+\n+        /* remove the originating artifact if it is also in managed versions to avoid being modified during resolution */\n+        Artifact managedOriginatingArtifact = (Artifact) versionMap.get( originatingArtifact.getDependencyConflictId() );\n+        if ( managedOriginatingArtifact != null )\n+        {\n+            String managedVersion = managedOriginatingArtifact.getVersion();\n+            String version = originatingArtifact.getVersion();\n+            if ( !managedVersion.equals( version ) )\n+            {\n+                // TODO we probably want to warn the user that he is building and artifact with a\n+                // different version than in dependencyManagement \n+                if ( managedVersions instanceof ManagedVersionMap )\n+                {\n+                    /* avoid modifying the managedVersions parameter creating a new map */\n+                    versionMap = new ManagedVersionMap( managedVersions );\n+                }\n+                versionMap.remove( originatingArtifact.getDependencyConflictId() );\n+            }\n+        }\n+\n+        return versionMap;\n+    }\n+\n     private void recurse( ResolutionNode node, Map resolvedArtifacts, ManagedVersionMap managedVersions,\n                           ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                           ArtifactFilter filter, List listeners )\n", "nb_test": 40, "linesAdd": 31, "jira_id": "2931", "singleLine": false, "nb_skipped": 0, "commit": "d7422212", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDuplicatePlugin(org.apache.maven.model.validation.DefaultModelValidatorTest)", "testDuplicatePluginExecution(org.apache.maven.model.validation.DefaultModelValidatorTest)"], "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\nindex 4291443..73fb915 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n@@ -28,6 +28,7 @@\n import java.util.Set;\n \n import org.apache.maven.model.Build;\n+import org.apache.maven.model.BuildBase;\n import org.apache.maven.model.Dependency;\n import org.apache.maven.model.DependencyManagement;\n import org.apache.maven.model.DistributionManagement;\n@@ -103,12 +104,12 @@ public void validateRawModel( Model model, ModelBuildingRequest request, ModelPr\n             Build build = model.getBuild();\n             if ( build != null )\n             {\n-                validateRawPlugins( problems, build.getPlugins(), false, request );\n+                validateRawPlugins( problems, build.getPlugins(), \"build.plugins.plugin\", request );\n \n                 PluginManagement mngt = build.getPluginManagement();\n                 if ( mngt != null )\n                 {\n-                    validateRawPlugins( problems, mngt.getPlugins(), true, request );\n+                    validateRawPlugins( problems, mngt.getPlugins(), \"build.pluginManagement.plugins.plugin\", request );\n                 }\n             }\n \n@@ -116,38 +117,49 @@ public void validateRawModel( Model model, ModelBuildingRequest request, ModelPr\n \n             for ( Profile profile : model.getProfiles() )\n             {\n+                String prefix = \"profiles.profile[\" + profile.getId() + \"]\";\n+\n                 if ( !profileIds.add( profile.getId() ) )\n                 {\n                     addViolation( problems, errOn30, \"profiles.profile.id\", null,\n                                   \"must be unique but found duplicate profile with id \" + profile.getId(), profile );\n                 }\n \n-                validateRawDependencies( problems, profile.getDependencies(), \"profiles.profile[\" + profile.getId()\n-                    + \"].dependencies.dependency\", request );\n+                validateRawDependencies( problems, profile.getDependencies(), prefix + \".dependencies.dependency\",\n+                                         request );\n \n                 if ( profile.getDependencyManagement() != null )\n                 {\n-                    validateRawDependencies( problems, profile.getDependencyManagement().getDependencies(),\n-                                          \"profiles.profile[\" + profile.getId()\n-                                              + \"].dependencyManagement.dependencies.dependency\", request );\n+                    validateRawDependencies( problems, profile.getDependencyManagement().getDependencies(), prefix\n+                        + \".dependencyManagement.dependencies.dependency\", request );\n                 }\n \n-                validateRepositories( problems, profile.getRepositories(), \"profiles.profile[\" + profile.getId()\n-                    + \"].repositories.repository\", request );\n+                validateRepositories( problems, profile.getRepositories(), prefix + \".repositories.repository\", request );\n+\n+                validateRepositories( problems, profile.getPluginRepositories(), prefix\n+                    + \".pluginRepositories.pluginRepository\", request );\n \n-                validateRepositories( problems, profile.getPluginRepositories(), \"profiles.profile[\" + profile.getId()\n-                    + \"].pluginRepositories.pluginRepository\", request );\n+                BuildBase buildBase = profile.getBuild();\n+                if ( buildBase != null )\n+                {\n+                    validateRawPlugins( problems, buildBase.getPlugins(), prefix + \".plugins.plugin\", request );\n+\n+                    PluginManagement mngt = buildBase.getPluginManagement();\n+                    if ( mngt != null )\n+                    {\n+                        validateRawPlugins( problems, mngt.getPlugins(), prefix + \".pluginManagement.plugins.plugin\",\n+                                            request );\n+                    }\n+                }\n             }\n         }\n     }\n \n-    private void validateRawPlugins( ModelProblemCollector problems, List<Plugin> plugins, boolean managed,\n+    private void validateRawPlugins( ModelProblemCollector problems, List<Plugin> plugins, String prefix,\n                                      ModelBuildingRequest request )\n     {\n         Severity errOn31 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1 );\n \n-        String prefix = ( managed ? \"build.pluginManagement.\" : \"build.\" ) + \"plugins.plugin.\";\n-\n         Map<String, Plugin> index = new HashMap<String, Plugin>();\n \n         for ( Plugin plugin : plugins )\n@@ -158,7 +170,7 @@ private void validateRawPlugins( ModelProblemCollector problems, List<Plugin> pl\n \n             if ( existing != null )\n             {\n-                addViolation( problems, errOn31, prefix + \"(groupId:artifactId)\", null,\n+                addViolation( problems, errOn31, prefix + \".(groupId:artifactId)\", null,\n                               \"must be unique but found duplicate declaration of plugin \" + key, plugin );\n             }\n             else\n@@ -172,7 +184,7 @@ private void validateRawPlugins( ModelProblemCollector problems, List<Plugin> pl\n             {\n                 if ( !executionIds.add( exec.getId() ) )\n                 {\n-                    addViolation( problems, Severity.ERROR, \"build.plugins.plugin[\" + plugin.getKey()\n+                    addViolation( problems, Severity.ERROR, prefix + \"[\" + plugin.getKey()\n                         + \"].executions.execution.id\", null, \"must be unique but found duplicate execution with id \"\n                         + exec.getId(), exec );\n                 }\n", "nb_test": 83, "linesAdd": 28, "jira_id": "4695", "singleLine": false, "nb_skipped": 0, "commit": "bb39b480", "nb_failure": 2, "linesRem": 16}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PluginManagerTest.testBuildExtensionsPluginLoading:340 expected:<ClassRealm[extension>org.apache.maven.its.plugins:maven-it-plugin:0.1, parent: sun.misc.Launcher$AppClassLoader@1395ddba]> but was:<null>"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\nindex c815920..5704276 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\n@@ -390,8 +390,6 @@ private void createPluginRealm( PluginDescriptor pluginDescriptor, MavenSession\n         RepositorySystemSession repositorySession = session.getRepositorySession();\n         if ( plugin.isExtensions() )\n         {\n-            // TODO discover components in #setupExtensionsRealm\n-\n             ExtensionRealmCache.CacheRecord extensionRecord;\n             try\n             {\n@@ -406,6 +404,11 @@ private void createPluginRealm( PluginDescriptor pluginDescriptor, MavenSession\n \n             pluginRealm = extensionRecord.realm;\n             pluginArtifacts = extensionRecord.artifacts;\n+\n+            for ( ComponentDescriptor<?> componentDescriptor : pluginDescriptor.getComponents() )\n+            {\n+                componentDescriptor.setRealm( pluginRealm );\n+            }\n         }\n         else\n         {\n@@ -877,6 +880,8 @@ public void releaseMojo( Object mojo, MojoExecution mojoExecution )\n         {\n             ClassRealm extensionRealm = classRealmManager.createExtensionRealm( plugin, toAetherArtifacts( artifacts ) );\n \n+            // TODO figure out how to use the same PluginDescriptor when running mojos\n+\n             PluginDescriptor pluginDescriptor = null;\n             if ( plugin.isExtensions() && !artifacts.isEmpty() )\n             {\n", "nb_test": 259, "linesAdd": 6, "jira_id": "5742", "singleLine": false, "nb_skipped": 0, "commit": "6ab41ee8", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testScopeUpdate(org.apache.maven.artifact.resolver.DefaultArtifactCollectorTest): MNG-1895 Dependency was not added to resolution"], "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\nindex c467098..b6d379e 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n@@ -201,15 +201,16 @@ else if ( currentRange == null )\n                     if ( checkScopeUpdate( farthest, nearest, listeners ) )\n                     {\n                         fireEvent( ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthest.getArtifact() );\n-\n-                        // previously we cloned the artifact, but it is more effecient to just update the scope\n-                        // if problems are later discovered that the original object needs its original scope value, cloning may\n-                        // again be appropriate\n-                        nearest.getArtifact().setScope( farthest.getArtifact().getScope() );\n+                        /* we need nearest version but farthest scope */\n+                        nearest.disable();\n+                        farthest.getArtifact().setVersion( nearest.getArtifact().getVersion() );\n                     }\n-                    fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact() );\n+                    else\n+                    {\n                         farthest.disable();\n                     }\n+                    fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact() );\n+                }\n             }\n         }\n         else\n", "nb_test": 31, "linesAdd": 6, "jira_id": "1895", "singleLine": false, "nb_skipped": 0, "commit": "24db0eb9", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPluginRealmCache(org.apache.maven.plugin.PluginManagerTest): expected:<1> but was:<0>"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java b/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\nindex 96b8274..8bb6909 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\n@@ -96,6 +96,8 @@ protected static PluginDescriptor clone( PluginDescriptor original )\n             clone.setId( original.getId() );\n             clone.setIsolatedRealm( original.isIsolatedRealm() );\n             clone.setSource( original.getSource() );\n+\n+            clone.setDependencies( original.getDependencies() );\n         }\n \n         return clone;\n", "nb_test": 237, "linesAdd": 2, "jira_id": "5212", "singleLine": false, "nb_skipped": 0, "commit": "c53d95ce", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testShouldKeepOriginalPluginExecutionOrdering(org.apache.maven.project.ModelUtilsTest): expected:<1> but was:<0>"], "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\nindex ec56f1b..b0c6c75 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\n@@ -53,6 +53,7 @@\n import java.util.Map;\n import java.util.Properties;\n import java.util.TreeMap;\n+import java.util.HashMap;\n \n public final class ModelUtils\n {\n@@ -208,6 +209,8 @@ public static void mergePluginDefinitions( Plugin child, Plugin parent, boolean\n \n         child.setConfiguration( childConfiguration );\n \n+        child.setDependencies( mergeDependencyList( child.getDependencies(), parent.getDependencies() ) );\n+\n         // from here to the end of the method is dealing with merging of the <executions/> section.\n         String parentInherited = parent.getInherited();\n \n@@ -1000,4 +1003,30 @@ public static void mergeFilterLists( List childFilters, List parentFilters )\n             }\n         }\n     }\n+\n+    public static List mergeDependencyList( List child, List parent )\n+    {\n+        Map depsMap = new HashMap();\n+\n+        if ( parent != null )\n+        {\n+            for ( Iterator it = parent.iterator(); it.hasNext(); )\n+            {\n+                Dependency dependency = (Dependency) it.next();\n+                depsMap.put( dependency.getManagementKey(), dependency );\n+            }\n+        }\n+\n+        if ( child != null )\n+        {\n+            for ( Iterator it = child.iterator(); it.hasNext(); )\n+            {\n+                Dependency dependency = (Dependency) it.next();\n+                depsMap.put( dependency.getManagementKey(), dependency );\n+            }\n+        }\n+\n+        return new ArrayList( depsMap.values() );\n+    }\n+\n }\n", "nb_test": 80, "linesAdd": 29, "jira_id": "1703", "singleLine": false, "nb_skipped": 0, "commit": "b68c84b8", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "maven", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testInvalidParent(org.apache.maven.project.MavenProjectTest): Failed to build parent project for [inherited]:child-artifact:jar:[inherited]"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\nindex d6f308f..91038b3 100644\n--- a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n+++ b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n@@ -102,6 +102,8 @@\n \n     public static final String EMPTY_PROJECT_VERSION = \"0\";\n \n+    private static final MavenProject ERROR_BUILDING_PARENT = new MavenProject();\n+\n     private Model model;\n \n     private MavenProject parent;\n@@ -343,6 +345,10 @@ public Model getModel()\n         return model;\n     }\n \n+    /**\n+     * Returns the project corresponding to a declared parent.\n+     * @return the parent, or null if no parent is declared or there was an error building it\n+     */\n     public MavenProject getParent()\n     {\n         if ( parent == null )\n@@ -363,7 +369,11 @@ public MavenProject getParent()\n                 }\n                 catch ( ProjectBuildingException e )\n                 {\n-                    throw new IllegalStateException( \"Failed to build parent project for \" + getId(), e );\n+                    if ( logger != null )\n+                    {\n+                        logger.error( \"Failed to build parent project for \" + getId(), e );\n+                    }\n+                    parent = ERROR_BUILDING_PARENT;\n                 }\n             }\n             else if ( model.getParent() != null )\n@@ -378,11 +388,15 @@ else if ( model.getParent() != null )\n                 }\n                 catch ( ProjectBuildingException e )\n                 {\n-                    throw new IllegalStateException( \"Failed to build parent project for \" + getId(), e );\n+                    if ( logger != null )\n+                    {\n+                        logger.error( \"Failed to build parent project for \" + getId(), e );\n+                    }\n+                    parent = ERROR_BUILDING_PARENT;\n                 }\n             }\n         }\n-        return parent;\n+        return parent == ERROR_BUILDING_PARENT ? null : parent;\n     }\n \n     public void setParent( MavenProject parent )\n", "nb_test": 251, "linesAdd": 13, "jira_id": "5075", "singleLine": false, "nb_skipped": 0, "commit": "2eb419ed", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBadDependencyVersion(org.apache.maven.model.validation.DefaultModelValidatorTest)", "testBadPluginVersion(org.apache.maven.model.validation.DefaultModelValidatorTest)"], "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\nindex 33b2f26..8a2f634 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n@@ -764,41 +764,49 @@ private boolean validateVersion( String fieldName, ModelProblemCollector problem\n             return true;\n         }\n \n-        if ( !hasExpression( string ) )\n+        if ( hasExpression( string ) )\n         {\n-            return true;\n+            addViolation( problems, severity, fieldName, sourceHint,\n+                          \"must be a valid version but is '\" + string + \"'.\", tracker );\n+            return false;\n         }\n \n-        addViolation( problems, severity, fieldName, sourceHint, \"must be a valid version but is '\" + string + \"'.\",\n-                      tracker );\n-\n+        if ( !validateBannedCharacters( fieldName, problems, severity, string, sourceHint, tracker,\n+                                        ILLEGAL_VERSION_CHARS ) )\n+        {\n             return false;\n         }\n \n+        return true;\n+    }\n+\n     private boolean validatePluginVersion( String fieldName, ModelProblemCollector problems, String string,\n                                            String sourceHint, InputLocationTracker tracker,\n                                            ModelBuildingRequest request )\n     {\n-        Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );\n-\n         if ( string == null )\n         {\n             // NOTE: The check for missing plugin versions is handled directly by the model builder\n             return true;\n         }\n \n-        if ( string.length() > 0 && !hasExpression( string ) && !\"RELEASE\".equals( string )\n-            && !\"LATEST\".equals( string ) )\n+        Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );\n+\n+        if ( !validateVersion( fieldName, problems, errOn30, string, sourceHint, tracker ) )\n         {\n-            return true;\n+            return false;\n         }\n \n+        if ( string.length() <= 0 || \"RELEASE\".equals( string ) || \"LATEST\".equals( string ) )\n+        {\n             addViolation( problems, errOn30, fieldName, sourceHint, \"must be a valid version but is '\" + string + \"'.\",\n                           tracker );\n-\n             return false;\n         }\n \n+        return true;\n+    }\n+\n     private static void addViolation( ModelProblemCollector problems, Severity severity, String fieldName,\n                                       String sourceHint, String message, InputLocationTracker tracker )\n     {\n", "nb_test": 91, "linesAdd": 19, "jira_id": "4915", "singleLine": false, "nb_skipped": 0, "commit": "1c3abfba", "nb_failure": 2, "linesRem": 11}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPluginRealmCache(org.apache.maven.plugin.PluginManagerTest)"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\nindex 0c541b1..603e670 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\n@@ -311,6 +311,10 @@ public synchronized void setupPluginRealm( PluginDescriptor pluginDescriptor, Ma\n         {\n             pluginDescriptor.setClassRealm( cacheRecord.realm );\n             pluginDescriptor.setArtifacts( new ArrayList<Artifact>( cacheRecord.artifacts ) );\n+            for ( ComponentDescriptor<?> componentDescriptor : pluginDescriptor.getComponents() )\n+            {\n+                componentDescriptor.setRealm( cacheRecord.realm );\n+            }\n         }\n         else\n         {\n", "nb_test": 236, "linesAdd": 4, "jira_id": "5003", "singleLine": false, "nb_skipped": 0, "commit": "a7d9b689", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "maven", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testUnalignToBasedirWherePathEqualsBasedir(org.apache.maven.project.path.DefaultPathTranslatorTest)"], "patch": "diff --git a/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java b/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java\nindex c9ec15d..020b652 100644\n--- a/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java\n+++ b/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java\n@@ -38,6 +38,11 @@\n \n     public void alignToBaseDirectory( Model model, File basedir )\n     {\n+        if ( basedir == null )\n+        {\n+            return;\n+        }\n+\n         Build build = model.getBuild();\n \n         if ( build != null )\n@@ -83,6 +88,11 @@ public void alignToBaseDirectory( Model model, File basedir )\n \n     public String alignToBaseDirectory( String path, File basedir )\n     {\n+        if ( basedir == null )\n+        {\n+            return path;\n+        }\n+\n         if ( path == null )\n         {\n             return null;\n@@ -166,6 +176,11 @@ private String chopLeadingFileSeparator( String path )\n \n     public void unalignFromBaseDirectory( Model model, File basedir )\n     {\n+        if ( basedir == null )\n+        {\n+            return;\n+        }\n+\n         Build build = model.getBuild();\n \n         if ( build != null )\n@@ -209,14 +224,37 @@ public void unalignFromBaseDirectory( Model model, File basedir )\n         }\n     }\n \n-    public String unalignFromBaseDirectory( String directory, File basedir )\n+    public String unalignFromBaseDirectory( String path, File basedir )\n+    {\n+        if ( basedir == null )\n+        {\n+            return path;\n+        }\n+\n+        if ( path == null )\n+        {\n+            return null;\n+        }\n+\n+        path = path.trim();\n+\n+        String base = basedir.getAbsolutePath();\n+        if ( path.startsWith( base ) )\n+        {\n+            path = chopLeadingFileSeparator( path.substring( base.length() ) );\n+        }\n+\n+        if ( path.length() <= 0 )\n         {\n-        String path = basedir.getPath();\n-        if ( directory.startsWith( path ) )\n+            path = \".\";\n+        }\n+\n+        if ( !new File( path ).isAbsolute() )\n         {\n-            directory = directory.substring( path.length() + 1 ).replace( '\\\\', '/' );\n+            path = path.replace( '\\\\', '/' );\n         }\n-        return directory;\n+\n+        return path;\n     }\n \n }\n", "nb_test": 155, "linesAdd": 43, "jira_id": "4933", "singleLine": false, "nb_skipped": 0, "commit": "469d0096", "nb_failure": 0, "linesRem": 5}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testLocationTrackerShouldBeExcludedFromInterpolation(org.apache.maven.model.interpolation.StringSearchModelInterpolatorTest)"], "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\nindex 8f7085a..590f2da 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\n@@ -324,6 +324,11 @@ private boolean isQualifiedForInterpolation( Class<?> cls )\n \n         private boolean isQualifiedForInterpolation( Field field, Class<?> fieldType )\n         {\n+            if ( Map.class.equals( fieldType ) && \"locations\".equals( field.getName() ) )\n+            {\n+                return false;\n+            }\n+\n             Boolean primitive = fieldIsPrimitiveByClass.get( fieldType );\n             if ( primitive == null )\n             {\n", "nb_test": 89, "linesAdd": 5, "jira_id": "4837", "singleLine": false, "nb_skipped": 0, "commit": "3fca2bb2", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testUpdateRepositoryMetadata_ShouldNotStoreIfMainVersionIsLATEST(org.apache.maven.artifact.repository.metadata.AbstractRepositoryMetadataTest)", "testUpdateRepositoryMetadata_ShouldNotStoreIfMainVersionIsRELEASE(org.apache.maven.artifact.repository.metadata.AbstractRepositoryMetadataTest)"], "patch": "diff --git a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\nindex 3b09252..603dfea 100644\n--- a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\n+++ b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\n@@ -114,6 +114,14 @@ protected void updateRepositoryMetadata( ArtifactRepository localRepository, Art\n             changed = metadata.merge( this.metadata );\n         }\n         \n+        // beware meta-versions!\n+        String version = metadata.getVersion();\n+        if ( version != null && ( Artifact.LATEST_VERSION.equals( version ) || Artifact.RELEASE_VERSION.equals( version ) ) )\n+        {\n+            // meta-versions are not valid <version/> values...don't write them.\n+            changed = false;\n+        }\n+\n         if ( changed )\n         {\n             Writer writer = null;\n", "nb_test": 13, "linesAdd": 6, "jira_id": "2408", "singleLine": false, "nb_skipped": 0, "commit": "b92af0e4", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBadDependencyScope(org.apache.maven.model.validation.DefaultModelValidatorTest)"], "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\nindex 586141e..c60c446 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n@@ -181,7 +181,11 @@ else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n                 validateBoolean( \"dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(),\n                                  d.getManagementKey() );\n \n-                validateEnum( \"dependencies.dependency.scope\", problems, warnOnBadDependencyScope, d.getScope(),\n+                /*\n+                 * TODO: Extensions like Flex Mojos use custom scopes like \"merged\", \"internal\", \"external\", etc. In\n+                 * order to don't break backward-compat with those, only warn but don't error our.\n+                 */\n+                validateEnum( \"dependencies.dependency.scope\", problems, true, d.getScope(),\n                               d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\" );\n             }\n         }\n", "nb_test": 34, "linesAdd": 1, "jira_id": "3991", "singleLine": false, "nb_skipped": 0, "commit": "2169c4a3", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "maven", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testOsActivationProfile(org.apache.maven.profiles.DefaultProfileManagerTest)"], "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java b/maven-project/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java\nindex 72575fe..7b068e7 100644\n--- a/maven-project/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java\n+++ b/maven-project/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java\n@@ -36,14 +36,25 @@ public boolean isActive( Profile profile )\n         Activation activation = profile.getActivation();\n         ActivationOS os = activation.getOs();\n \n-        boolean hasNonNull = ensureAtLeastOneNonNull( os );\n+        boolean result = ensureAtLeastOneNonNull( os );\n \n-        boolean isFamily = determineFamilyMatch( os.getFamily() );\n-        boolean isName = determineNameMatch( os.getName() );\n-        boolean isArch = determineArchMatch( os.getArch() );\n-        boolean isVersion = determineVersionMatch( os.getVersion() );\n-        \n-        return hasNonNull && isFamily && isName && isArch && isVersion;\n+        if ( result && os.getFamily() != null )\n+        {\n+            result = determineFamilyMatch( os.getFamily() );\n+        }\n+        if ( result && os.getName() != null )\n+        {\n+            result = determineNameMatch( os.getName() );\n+        }\n+        if ( result && os.getArch() != null )\n+        {\n+            result = determineArchMatch( os.getArch() );\n+        }\n+        if ( result && os.getVersion() != null )\n+        {\n+            result = determineVersionMatch( os.getVersion() );\n+        }\n+        return result;\n     }\n \n     private boolean ensureAtLeastOneNonNull( ActivationOS os )\n", "nb_test": 74, "linesAdd": 18, "jira_id": "1509", "singleLine": false, "nb_skipped": 0, "commit": "4e955c05", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDistributionManagementInheritance(org.apache.maven.project.inheritance.DefaultModelInheritanceAssemblerTest): Check relocation NOT inherited"], "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\nindex 2839c50..1d2268f 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\n@@ -107,10 +107,6 @@ private void assembleModelInheritance( Model child, Model parent, String childPa\n             }\n         }\n \n-        // ----------------------------------------------------------------------\n-        // Distribution\n-        // ----------------------------------------------------------------------\n-\n         assembleDistributionInheritence( child, parent, childPathAdjustment, appendPaths );\n \n         // issueManagement\n@@ -177,8 +173,6 @@ private void assembleModelInheritance( Model child, Model parent, String childPa\n \n         assembleDependencyManagementInheritance( child, parent );\n \n-        assembleDistributionManagementInheritance( child, parent );\n-\n         Properties props = new Properties();\n         props.putAll( parent.getProperties() );\n         props.putAll( child.getProperties() );\n@@ -186,46 +180,6 @@ private void assembleModelInheritance( Model child, Model parent, String childPa\n         child.setProperties( props );\n     }\n \n-    private void assembleDistributionManagementInheritance( Model child, Model parent )\n-    {\n-        DistributionManagement cDistMgmt = child.getDistributionManagement();\n-        DistributionManagement pDistMgmt = parent.getDistributionManagement();\n-\n-        if ( cDistMgmt == null )\n-        {\n-            child.setDistributionManagement( pDistMgmt );\n-        }\n-        else if ( pDistMgmt != null )\n-        {\n-            if ( cDistMgmt.getRepository() == null )\n-            {\n-                cDistMgmt.setRepository( pDistMgmt.getRepository() );\n-            }\n-\n-            if ( cDistMgmt.getSnapshotRepository() == null )\n-            {\n-                cDistMgmt.setSnapshotRepository( pDistMgmt.getSnapshotRepository() );\n-            }\n-\n-            if ( StringUtils.isEmpty( cDistMgmt.getDownloadUrl() ) )\n-            {\n-                cDistMgmt.setDownloadUrl( pDistMgmt.getDownloadUrl() );\n-            }\n-\n-            if ( cDistMgmt.getRelocation() == null )\n-            {\n-                cDistMgmt.setRelocation( pDistMgmt.getRelocation() );\n-            }\n-\n-            if ( cDistMgmt.getSite() == null )\n-            {\n-                cDistMgmt.setSite( pDistMgmt.getSite() );\n-            }\n-\n-            // NOTE: We SHOULD NOT be inheriting status, since this is an assessment of the POM quality.\n-        }\n-    }\n-\n     private void assembleDependencyManagementInheritance( Model child, Model parent )\n     {\n         DependencyManagement parentDepMgmt = parent.getDependencyManagement();\n@@ -486,17 +440,8 @@ private void assembleDistributionInheritence( Model child, Model parent, String\n             {\n                 if ( parentDistMgmt.getRepository() != null )\n                 {\n-                    DeploymentRepository repository = new DeploymentRepository();\n-\n+                    DeploymentRepository repository = copyDistributionRepository( parentDistMgmt.getRepository() );\n                     childDistMgmt.setRepository( repository );\n-\n-                    repository.setId( parentDistMgmt.getRepository().getId() );\n-\n-                    repository.setName( parentDistMgmt.getRepository().getName() );\n-\n-                    repository.setUrl( parentDistMgmt.getRepository().getUrl() );\n-\n-                    repository.setUniqueVersion( parentDistMgmt.getRepository().isUniqueVersion() );\n                 }\n             }\n \n@@ -504,20 +449,37 @@ private void assembleDistributionInheritence( Model child, Model parent, String\n             {\n                 if ( parentDistMgmt.getSnapshotRepository() != null )\n                 {\n+                    DeploymentRepository repository =\n+                        copyDistributionRepository( parentDistMgmt.getSnapshotRepository() );\n+                    childDistMgmt.setSnapshotRepository( repository );\n+                }\n+            }\n+\n+            if ( StringUtils.isEmpty( childDistMgmt.getDownloadUrl() ) )\n+            {\n+                childDistMgmt.setDownloadUrl( parentDistMgmt.getDownloadUrl() );\n+            }\n+\n+            // NOTE: We SHOULD NOT be inheriting status, since this is an assessment of the POM quality.\n+            // NOTE: We SHOULD NOT be inheriting relocation, since this relates to a single POM\n+        }\n+    }\n+\n+    private static DeploymentRepository copyDistributionRepository( DeploymentRepository parentRepository )\n+    {\n         DeploymentRepository repository = new DeploymentRepository();\n \n-                    childDistMgmt.setSnapshotRepository( repository );\n+        repository.setId( parentRepository.getId() );\n \n-                    repository.setId( parentDistMgmt.getSnapshotRepository().getId() );\n+        repository.setName( parentRepository.getName() );\n \n-                    repository.setName( parentDistMgmt.getSnapshotRepository().getName() );\n+        repository.setUrl( parentRepository.getUrl() );\n \n-                    repository.setUrl( parentDistMgmt.getSnapshotRepository().getUrl() );\n+        repository.setLayout( parentRepository.getLayout() );\n \n-                    repository.setUniqueVersion( parentDistMgmt.getSnapshotRepository().isUniqueVersion() );\n-                }\n-            }\n-        }\n+        repository.setUniqueVersion( parentRepository.isUniqueVersion() );\n+\n+        return repository;\n     }\n \n     protected String appendPath( String parentPath, String childPath, String pathAdjustment, boolean appendPaths )\n", "nb_test": 80, "linesAdd": 24, "jira_id": "1856", "singleLine": false, "nb_skipped": 0, "commit": "faa5cf27", "nb_failure": 1, "linesRem": 60}, {"files": 2, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testUpdateRepositoryMetadata_NoVersionTagIfMainVersionIsLATEST(org.apache.maven.artifact.repository.metadata.AbstractRepositoryMetadataTest)", "testUpdateRepositoryMetadata_NoVersionTagIfVersionIsRELEASE(org.apache.maven.artifact.repository.metadata.AbstractRepositoryMetadataTest)"], "patch": "diff --git a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\nindex 603dfea..d5a6460 100644\n--- a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\n+++ b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\n@@ -119,10 +119,10 @@ protected void updateRepositoryMetadata( ArtifactRepository localRepository, Art\n         if ( version != null && ( Artifact.LATEST_VERSION.equals( version ) || Artifact.RELEASE_VERSION.equals( version ) ) )\n         {\n             // meta-versions are not valid <version/> values...don't write them.\n-            changed = false;\n+            metadata.setVersion( null );\n         }\n \n-        if ( changed )\n+        if ( changed || !metadataFile.exists() )\n         {\n             Writer writer = null;\n             try\ndiff --git a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java\nindex c82d607..ddc23c0 100644\n--- a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java\n+++ b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java\n@@ -106,7 +108,7 @@ else if ( repository.isBlacklisted() )\n                     {\n                         file.setLastModified( System.currentTimeMillis() );\n                     }\n-                    else if ( !metadataIsEmpty )\n+                    else\n                     {\n                         // this ensures that files are not continuously checked when they don't exist remotely\n                         try\n", "nb_test": 13, "linesAdd": 3, "jira_id": "2712", "singleLine": false, "nb_skipped": 0, "commit": "06090da4", "nb_failure": 2, "linesRem": 3}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPluginRealmCache(org.apache.maven.plugin.PluginManagerTest): expected:<1> but was:<0>"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java b/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\nindex 96b8274..8bb6909 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\n@@ -96,6 +96,8 @@ protected static PluginDescriptor clone( PluginDescriptor original )\n             clone.setId( original.getId() );\n             clone.setIsolatedRealm( original.isIsolatedRealm() );\n             clone.setSource( original.getSource() );\n+\n+            clone.setDependencies( original.getDependencies() );\n         }\n \n         return clone;\n", "nb_test": 237, "linesAdd": 2, "jira_id": "5212", "singleLine": false, "nb_skipped": 0, "commit": "712c4fff", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testShouldMergeOnePluginWithInheritExecutionWithoutDuplicatingPluginInList(org.apache.maven.project.ModelUtilsTest): expected:<1> but was:<2>", "testShouldMergePluginWithDifferentExecutionFromParentWithoutDuplicatingPluginInList(org.apache.maven.project.ModelUtilsTest): expected:<1> but was:<2>"], "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\nindex 66527df..7e6de40 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\n@@ -82,6 +82,11 @@ public static void mergePluginLists( PluginContainer childContainer, PluginConta\n \n                 String parentInherited = parentPlugin.getInherited();\n \n+                // only merge plugin definition from the parent if at least one \n+                // of these is true:\n+                // 1. we're not processing the plugins in an inheritance-based merge\n+                // 2. the parent's <inherited/> flag is not set\n+                // 3. the parent's <inherited/> flag is set to true\n                 if ( !handleAsInheritance || parentInherited == null ||\n                     Boolean.valueOf( parentInherited ).booleanValue() )\n                 {\n@@ -97,18 +102,21 @@ public static void mergePluginLists( PluginContainer childContainer, PluginConta\n                         mergePluginDefinitions( childPlugin, parentPlugin, handleAsInheritance );\n                     }\n \n+                    // if we're processing this as an inheritance-based merge, and\n+                    // the parent's <inherited/> flag is not set, then we need to\n+                    // clear the inherited flag in the merge result.\n                     if ( handleAsInheritance && parentInherited == null )\n                     {\n                         assembledPlugin.unsetInheritanceApplied();\n                     }\n \n                     mergedPlugins.add(assembledPlugin);\n+\n+                    // fix for MNG-2221 (assembly cache was not being populated for later reference):\n+                    assembledPlugins.put(  assembledPlugin.getKey(), assembledPlugin );\n                 }\n             }\n \n-\t    // FIXME: not sure what's intended here, but this entire\n-\t    // loop can be replaced by 'mergedPlugins.addAll( childPlugins.values() );\n-\t    // since assembledPlugins is never updated and remains empty.\n             for ( Iterator it = childPlugins.values().iterator(); it.hasNext(); )\n             {\n                 Plugin childPlugin = (Plugin) it.next();\n", "nb_test": 93, "linesAdd": 2, "jira_id": "2221", "singleLine": false, "nb_skipped": 0, "commit": "cc859f5c", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMissingRequiredMapTypeParameter(org.apache.maven.plugin.PluginParameterExceptionTest): expected:<... ...(..)", "testMissingRequiredStringArrayTypeParameter(org.apache.maven.plugin.PluginParameterExceptionTest): expected:<... ...(..)", "testMissingRequiredCollectionTypeParameter(org.apache.maven.plugin.PluginParameterExceptionTest): expected:<... ...(..)"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java b/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\nindex 07302e5..350349d 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\n@@ -19,8 +19,10 @@\n  * under the License.\n  */\n \n+import java.util.Collection;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n import org.apache.maven.plugin.descriptor.MojoDescriptor;\n import org.apache.maven.plugin.descriptor.Parameter;\n@@ -78,9 +80,50 @@ private static void decomposeParameterIntoUserInstructions( MojoDescriptor mojo,\n         \n         if ( param.isEditable() )\n         {\n-            messageBuffer.append( \"Inside the definition for plugin \\'\" + mojo.getPluginDescriptor().getArtifactId()\n-                + \"\\', specify the following:\\n\\n<configuration>\\n  ...\\n  <\" + param.getName() + \">VALUE</\"\n-                + param.getName() + \">\\n</configuration>\" );\n+            boolean isArray = param.getType().endsWith( \"[]\" );\n+            boolean isCollection = false;\n+            boolean isMap = false;\n+            if ( !isArray )\n+            {\n+                try\n+                {\n+                    //assuming Type is available in current ClassLoader\n+                    isCollection = Collection.class.isAssignableFrom( Class.forName( param.getType() ) );\n+                    isMap = Map.class.isAssignableFrom( Class.forName( param.getType() ) );\n+                }\n+                catch ( ClassNotFoundException e )\n+                {\n+                    // assume it is not assignable from Collection or Map\n+                }\n+            }\n+            \n+            messageBuffer.append( \"Inside the definition for plugin \\'\");\n+            messageBuffer.append( mojo.getPluginDescriptor().getArtifactId() );\n+            messageBuffer.append( \"\\', specify the following:\\n\\n<configuration>\\n  ...\\n\" );\n+            messageBuffer.append( \"  <\" ).append( param.getName() ).append( '>' );\n+            if( isArray || isCollection )\n+            {\n+                messageBuffer.append(  '\\n' );\n+                messageBuffer.append( \"    <item>\" );\n+            }\n+            else if ( isMap )\n+            {\n+                messageBuffer.append(  '\\n' );\n+                messageBuffer.append( \"    <KEY>\" );\n+            }\n+            messageBuffer.append( \"VALUE\" );\n+            if( isArray || isCollection )\n+            {\n+                messageBuffer.append( \"</item>\\n\" );\n+                messageBuffer.append( \"  \" );\n+            }    \n+            else if ( isMap )\n+            {\n+                messageBuffer.append( \"</KEY>\\n\" );\n+                messageBuffer.append( \"  \" );\n+            }    \n+            messageBuffer.append( \"</\" ).append( param.getName() ).append( \">\\n\" );\n+            messageBuffer.append( \"</configuration>\" );\n \n             String alias = param.getAlias();\n             if ( StringUtils.isNotEmpty( alias ) && !alias.equals( param.getName() ) )\n", "nb_test": 245, "linesAdd": 44, "jira_id": "3131", "singleLine": false, "nb_skipped": 0, "commit": "56cd921f", "nb_failure": 3, "linesRem": 3}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["org.apache.maven.DefaultMavenTest#testThatErrorDuringProjectDependencyGraphCreationAreStored AssertionFailedError"], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/DefaultMaven.java b/maven-core/src/main/java/org/apache/maven/DefaultMaven.java\nindex 6328819..ab47efd 100644\n--- a/maven-core/src/main/java/org/apache/maven/DefaultMaven.java\n+++ b/maven-core/src/main/java/org/apache/maven/DefaultMaven.java\n@@ -267,13 +267,13 @@ private MavenExecutionResult doExecute( MavenExecutionRequest request )\n         //\n         ProjectDependencyGraph projectDependencyGraph = createProjectDependencyGraph( projects, request, result, true );\n \n-        session.setProjects( projectDependencyGraph.getSortedProjects() );\n-        \n         if ( result.hasExceptions() )\n         {\n             return result;\n         }\n \n+        session.setProjects( projectDependencyGraph.getSortedProjects() );\n+\n         try\n         {\n             session.setProjectMap( getProjectMap( session.getProjects() ) );\n", "nb_test": 243, "linesAdd": 2, "jira_id": "5613", "singleLine": false, "nb_skipped": 0, "commit": "bef7fac6", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBuildReader(org.apache.maven.plugin.descriptor.PluginDescriptorBuilderTest)"], "patch": "diff --git a/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptorBuilder.java b/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptorBuilder.java\nindex 8947094..66b1691 100644\n--- a/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptorBuilder.java\n+++ b/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptorBuilder.java\n@@ -255,6 +255,13 @@ public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDes\n         }\n \n         // ----------------------------------------------------------------------\n+        // Configuration\n+        // ----------------------------------------------------------------------\n+\n+        PlexusConfiguration mojoConfig = c.getChild( \"configuration\" );\n+        mojo.setMojoConfiguration( mojoConfig );\n+\n+        // ----------------------------------------------------------------------\n         // Parameters\n         // ----------------------------------------------------------------------\n \n@@ -292,6 +299,13 @@ public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDes\n \n             parameter.setImplementation( d.getChild( \"implementation\" ).getValue() );\n \n+            PlexusConfiguration paramConfig = mojoConfig.getChild( parameter.getName(), false );\n+            if ( paramConfig != null )\n+            {\n+                parameter.setExpression( paramConfig.getValue( null ) );\n+                parameter.setDefaultValue( paramConfig.getAttribute( \"default-value\" ) );\n+            }\n+\n             parameters.add( parameter );\n         }\n \n@@ -300,15 +314,6 @@ public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDes\n         // TODO: this should not need to be handed off...\n \n         // ----------------------------------------------------------------------\n-        // Configuration\n-        // ----------------------------------------------------------------------\n-\n-        mojo.setMojoConfiguration( c.getChild( \"configuration\" ) );\n-\n-        // TODO: Go back to this when we get the container ready to configure mojos...\n-        //        mojo.setConfiguration( c.getChild( \"configuration\" ) );\n-\n-        // ----------------------------------------------------------------------\n         // Requirements\n         // ----------------------------------------------------------------------\n \n", "nb_test": 2, "linesAdd": 11, "jira_id": "4941", "singleLine": false, "nb_skipped": 0, "commit": "c4002945", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMng5459(org.apache.maven.repository.internal.DefaultArtifactDescriptorReaderTest): expected:<...om:0.4.0-20130404.09[0532-2] in repo (file:/home...> but was:<...om:0.4.0-20130404.09[3655-3] in repo (file:/home...>"], "patch": "diff --git a/maven-aether-provider/src/main/java/org/apache/maven/repository/internal/DefaultArtifactDescriptorReader.java b/maven-aether-provider/src/main/java/org/apache/maven/repository/internal/DefaultArtifactDescriptorReader.java\nindex 380a607..59a955d 100644\n--- a/maven-aether-provider/src/main/java/org/apache/maven/repository/internal/DefaultArtifactDescriptorReader.java\n+++ b/maven-aether-provider/src/main/java/org/apache/maven/repository/internal/DefaultArtifactDescriptorReader.java\n@@ -275,6 +275,7 @@ private Model loadPom( RepositorySystemSession session, ArtifactDescriptorReques\n         Set<String> visited = new LinkedHashSet<String>();\n         for ( Artifact artifact = request.getArtifact();; )\n         {\n+            Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact( artifact );\n             try\n             {\n                 VersionRequest versionRequest =\n@@ -283,6 +284,13 @@ private Model loadPom( RepositorySystemSession session, ArtifactDescriptorReques\n                 VersionResult versionResult = versionResolver.resolveVersion( session, versionRequest );\n \n                 artifact = artifact.setVersion( versionResult.getVersion() );\n+\n+                versionRequest =\n+                    new VersionRequest( pomArtifact, request.getRepositories(), request.getRequestContext() );\n+                versionRequest.setTrace( trace );\n+                versionResult = versionResolver.resolveVersion( session, versionRequest );\n+\n+                pomArtifact = pomArtifact.setVersion( versionResult.getVersion() );\n             }\n             catch ( VersionResolutionException e )\n             {\n@@ -303,8 +311,6 @@ private Model loadPom( RepositorySystemSession session, ArtifactDescriptorReques\n                 throw new ArtifactDescriptorException( result );\n             }\n \n-            Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact( artifact );\n-\n             ArtifactResult resolveResult;\n             try\n             {\n", "nb_test": 16, "linesAdd": 8, "jira_id": "5459", "singleLine": false, "nb_skipped": 0, "commit": "c225847e", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBadDependencyVersion(org.apache.maven.model.validation.DefaultModelValidatorTest)"], "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\nindex c60c446..4e429a4 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n@@ -139,8 +139,7 @@ public void validateEffectiveModel( Model model, ModelBuildingRequest request, M\n \n         validateStringNotEmpty( \"version\", problems, false, model.getVersion() );\n \n-        boolean warnOnBadBoolean = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n-        boolean warnOnBadDependencyScope = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n+        boolean warnOnly = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n \n         for ( Dependency d : model.getDependencies() )\n         {\n@@ -178,12 +177,15 @@ else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n \n             if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )\n             {\n-                validateBoolean( \"dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(),\n+                validateVersion( \"dependencies.dependency.version\", problems, warnOnly, d.getVersion(),\n+                                 d.getManagementKey() );\n+\n+                validateBoolean( \"dependencies.dependency.optional\", problems, warnOnly, d.getOptional(),\n                                  d.getManagementKey() );\n \n                 /*\n                  * TODO: Extensions like Flex Mojos use custom scopes like \"merged\", \"internal\", \"external\", etc. In\n-                 * order to don't break backward-compat with those, only warn but don't error our.\n+                 * order to don't break backward-compat with those, only warn but don't error out.\n                  */\n                 validateEnum( \"dependencies.dependency.scope\", problems, true, d.getScope(),\n                               d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\" );\n@@ -227,8 +229,8 @@ else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n \n                 if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )\n                 {\n-                    validateBoolean( \"dependencyManagement.dependencies.dependency.optional\", problems,\n-                                     warnOnBadBoolean, d.getOptional(), d.getManagementKey() );\n+                    validateBoolean( \"dependencyManagement.dependencies.dependency.optional\", problems, warnOnly,\n+                                     d.getOptional(), d.getManagementKey() );\n                 }\n             }\n         }\n@@ -250,16 +252,16 @@ else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n                     validateStringNotEmpty( \"build.plugins.plugin.version\", problems, warnOnMissingPluginVersion,\n                                             p.getVersion(), p.getKey() );\n \n-                    validateBoolean( \"build.plugins.plugin.inherited\", problems, warnOnBadBoolean, p.getInherited(),\n+                    validateBoolean( \"build.plugins.plugin.inherited\", problems, warnOnly, p.getInherited(),\n                                      p.getKey() );\n \n-                    validateBoolean( \"build.plugins.plugin.extensions\", problems, warnOnBadBoolean, p.getExtensions(),\n+                    validateBoolean( \"build.plugins.plugin.extensions\", problems, warnOnly, p.getExtensions(),\n                                      p.getKey() );\n \n                     for ( Dependency d : p.getDependencies() )\n                     {\n                         validateEnum( \"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\",\n-                                      problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(),\n+                                      problems, warnOnly, d.getScope(), d.getManagementKey(),\n                                       \"compile\", \"runtime\", \"system\" );\n                     }\n                 }\n@@ -578,11 +580,12 @@ private boolean validateBoolean( String fieldName, ModelProblemCollector problem\n \n         if ( sourceHint != null )\n         {\n-            addViolation( problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false' for \" + sourceHint );\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false' for \" + sourceHint\n+                + \" but is '\" + string + \"'.\" );\n         }\n         else\n         {\n-            addViolation( problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false'.\" );\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false' but is '\" + string + \"'.\" );\n         }\n \n         return false;\n@@ -605,11 +608,39 @@ private boolean validateEnum( String fieldName, ModelProblemCollector problems,\n \n         if ( sourceHint != null )\n         {\n-            addViolation( problems, warning, \"'\" + fieldName + \"' must be one of \" + values + \" for \" + sourceHint );\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be one of \" + values + \" for \" + sourceHint\n+                + \" but is '\" + string + \"'.\" );\n+        }\n+        else\n+        {\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be one of \" + values + \" but is '\" + string\n+                + \"'.\" );\n+        }\n+\n+        return false;\n+    }\n+\n+    private boolean validateVersion( String fieldName, ModelProblemCollector problems, boolean warning, String string,\n+                                     String sourceHint )\n+    {\n+        if ( string == null || string.length() <= 0 )\n+        {\n+            return true;\n+        }\n+\n+        if ( !hasExpression( string ) )\n+        {\n+            return true;\n+        }\n+\n+        if ( sourceHint != null )\n+        {\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be a valid version for \" + sourceHint\n+                + \" but is '\" + string + \"'.\" );\n         }\n         else\n         {\n-            addViolation( problems, warning, \"'\" + fieldName + \"' must be one of \" + values );\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be a valid version but is '\" + string + \"'.\" );\n         }\n \n         return false;\n", "nb_test": 35, "linesAdd": 43, "jira_id": "4383", "singleLine": false, "nb_skipped": 0, "commit": "0f3d4d24", "nb_failure": 1, "linesRem": 12}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMissingPluginDependencyGroupId(org.apache.maven.model.validation.DefaultModelValidatorTest)", "testMissingPluginDependencyArtifactId(org.apache.maven.model.validation.DefaultModelValidatorTest)", "testMissingPluginDependencyVersion(org.apache.maven.model.validation.DefaultModelValidatorTest)", "testBadPluginDependencyVersion(org.apache.maven.model.validation.DefaultModelValidatorTest)"], "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\nindex fa262c8..bed7b47 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n@@ -253,12 +253,7 @@ public void validateEffectiveModel( Model model, ModelBuildingRequest request, M\n                     validateBoolean( \"build.plugins.plugin.extensions\", problems, errOn30, p.getExtensions(),\n                                      p.getKey() );\n \n-                    for ( Dependency d : p.getDependencies() )\n-                    {\n-                        validateEnum( \"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\",\n-                                      problems, errOn30, d.getScope(), d.getManagementKey(),\n-                                      \"compile\", \"runtime\", \"system\" );\n-                    }\n+                    validateEffectivePluginDependencies( problems, p, request );\n                 }\n \n                 validateResources( problems, build.getResources(), \"build.resources.resource\", request );\n@@ -365,24 +360,70 @@ else if ( \"system\".equals( dependency.getScope() ) )\n     }\n \n     private void validateEffectiveDependencies( ModelProblemCollector problems, List<Dependency> dependencies,\n-                                                boolean managed, ModelBuildingRequest request )\n+                                                boolean management, ModelBuildingRequest request )\n     {\n         Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );\n \n-        String prefix = managed ? \"dependencyManagement.dependencies.dependency.\" : \"dependencies.dependency.\";\n+        String prefix = management ? \"dependencyManagement.dependencies.dependency.\" : \"dependencies.dependency.\";\n \n         for ( Dependency d : dependencies )\n         {\n+            validateEffectiveDependency( problems, d, management, prefix, request );\n+\n+            if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )\n+            {\n+                validateBoolean( prefix + \"optional\", problems, errOn30, d.getOptional(), d.getManagementKey() );\n+\n+                if ( !management )\n+                {\n+                    validateVersion( prefix + \"version\", problems, errOn30, d.getVersion(), d.getManagementKey() );\n+\n+                    /*\n+                     * TODO: Extensions like Flex Mojos use custom scopes like \"merged\", \"internal\", \"external\", etc. In\n+                     * order to don't break backward-compat with those, only warn but don't error out.\n+                     */\n+                    validateEnum( prefix + \"scope\", problems, Severity.WARNING, d.getScope(), d.getManagementKey(),\n+                                  \"provided\", \"compile\", \"runtime\", \"test\", \"system\" );\n+                }\n+            }\n+        }\n+    }\n+\n+    private void validateEffectivePluginDependencies( ModelProblemCollector problems, Plugin plugin,\n+                                                      ModelBuildingRequest request )\n+    {\n+        List<Dependency> dependencies = plugin.getDependencies();\n+\n+        if ( !dependencies.isEmpty() )\n+        {\n+            String prefix = \"build.plugins.plugin[\" + plugin.getKey() + \"].dependencies.dependency.\";\n+\n+            Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );\n+\n+            for ( Dependency d : dependencies )\n+            {\n+                validateEffectiveDependency( problems, d, false, prefix, request );\n+\n+                validateVersion( prefix + \"version\", problems, errOn30, d.getVersion(), d.getManagementKey() );\n+\n+                validateEnum( prefix + \"scope\", problems, errOn30, d.getScope(), d.getManagementKey(), \"compile\",\n+                              \"runtime\", \"system\" );\n+            }\n+        }\n+    }\n+\n+    private void validateEffectiveDependency( ModelProblemCollector problems, Dependency d, boolean management,\n+                                              String prefix, ModelBuildingRequest request )\n+    {\n         validateId( prefix + \"artifactId\", problems, d.getArtifactId(), d.getManagementKey() );\n \n         validateId( prefix + \"groupId\", problems, d.getGroupId(), d.getManagementKey() );\n \n-            if ( !managed )\n+        if ( !management )\n         {\n             validateStringNotEmpty( prefix + \"type\", problems, Severity.ERROR, d.getType(), d.getManagementKey() );\n \n-                validateStringNotEmpty( prefix + \"version\", problems, Severity.ERROR, d.getVersion(),\n-                                        d.getManagementKey() );\n+            validateStringNotEmpty( prefix + \"version\", problems, Severity.ERROR, d.getVersion(), d.getManagementKey() );\n         }\n \n         if ( \"system\".equals( d.getScope() ) )\n@@ -420,24 +461,6 @@ else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n             addViolation( problems, Severity.ERROR, prefix + \"systemPath\", d.getManagementKey(), \"must be omitted.\"\n                 + \" This field may only be specified for a dependency with system scope.\" );\n         }\n-\n-            if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )\n-            {\n-                validateBoolean( prefix + \"optional\", problems, errOn30, d.getOptional(), d.getManagementKey() );\n-\n-                if ( !managed )\n-                {\n-                    validateVersion( prefix + \"version\", problems, errOn30, d.getVersion(), d.getManagementKey() );\n-\n-                    /*\n-                     * TODO: Extensions like Flex Mojos use custom scopes like \"merged\", \"internal\", \"external\", etc. In\n-                     * order to don't break backward-compat with those, only warn but don't error out.\n-                     */\n-                    validateEnum( prefix + \"scope\", problems, Severity.WARNING, d.getScope(), d.getManagementKey(),\n-                                  \"provided\", \"compile\", \"runtime\", \"test\", \"system\" );\n-                }\n-            }\n-        }\n     }\n \n     private void validateRepositories( ModelProblemCollector problems, List<Repository> repositories, String prefix,\n", "nb_test": 82, "linesAdd": 48, "jira_id": "4648", "singleLine": false, "nb_skipped": 0, "commit": "83389c34", "nb_failure": 4, "linesRem": 25}, {"files": 2, "project": "maven", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ProjectBuilderTest.testVersionlessManagedDependency:79 \u00bb InvalidArtifactRT For..."], "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java b/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java\nindex 839c089..e01ffc3 100644\n--- a/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java\n+++ b/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java\n@@ -107,6 +107,11 @@ public Artifact createProjectArtifact( String groupId, String artifactId, String\n     // DefaultProjectBuilder\n     public Artifact createDependencyArtifact( Dependency d )\n     {\n+        if ( d.getVersion() == null )\n+        {\n+            return null;\n+        }\n+\n         VersionRange versionRange;\n         try\n         {\ndiff --git a/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java b/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java\nindex e359bcf..5365756 100644\n--- a/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java\n+++ b/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java\n@@ -807,14 +807,12 @@ private void initProject( MavenProject project, Map<String, MavenProject> projec\n                 {\n                     Artifact artifact = repositorySystem.createDependencyArtifact( d );\n \n-                    if ( artifact == null )\n+                    if ( artifact != null )\n                     {\n-                        map = Collections.emptyMap();\n-                    }\n-\n                         map.put( d.getManagementKey(), artifact );\n                     }\n                 }\n+            }\n             else\n             {\n                 map = Collections.emptyMap();\n", "nb_test": 258, "linesAdd": 7, "jira_id": "5727", "singleLine": false, "nb_skipped": 0, "commit": "ce6f0bfd", "nb_failure": 0, "linesRem": 4}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReleaseRangeBoundsCannotContainSnapshots(org.apache.maven.artifact.versioning.VersionRangeTest)", "testSnapshotRangeBoundsCanContainSnapshots(org.apache.maven.artifact.versioning.VersionRangeTest)"], "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/Restriction.java b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/Restriction.java\nindex a3a1b77..f8de2c9 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/Restriction.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/Restriction.java\n@@ -20,6 +19,8 @@\n  * under the License.\n  */\n \n+import org.apache.maven.artifact.Artifact;\n+\n /**\n  * Describes a restriction in versioning.\n  *\n@@ -71,9 +72,17 @@ public boolean isUpperBoundInclusive()\n \n     public boolean containsVersion( ArtifactVersion version )\n     {\n+        boolean snapshot = isSnapshot( version );\n+\n         if ( lowerBound != null )\n         {\n             int comparison = lowerBound.compareTo( version );\n+\n+            if ( snapshot && comparison == 0 )\n+            {\n+                return true;\n+            }\n+\n             if ( ( comparison == 0 ) && !lowerBoundInclusive )\n             {\n                 return false;\n@@ -86,6 +95,12 @@ public boolean containsVersion( ArtifactVersion version )\n         if ( upperBound != null )\n         {\n             int comparison = upperBound.compareTo( version );\n+\n+            if ( snapshot && comparison == 0 )\n+            {\n+                return true;\n+            }\n+\n             if ( ( comparison == 0 ) && !upperBoundInclusive )\n             {\n                 return false;\n@@ -95,9 +110,20 @@ public boolean containsVersion( ArtifactVersion version )\n                 return false;\n             }\n         }\n+\n+        if ( lowerBound != null || upperBound != null )\n+        {\n+            return !snapshot;\n+        }\n+\n         return true;\n     }\n \n+    private boolean isSnapshot( ArtifactVersion version )\n+    {\n+        return Artifact.SNAPSHOT_VERSION.equals( version.getQualifier() );\n+    }\n+\n     @Override\n     public int hashCode()\n     {\n", "nb_test": 21, "linesAdd": 27, "jira_id": "3092", "singleLine": false, "nb_skipped": 0, "commit": "5ffd8903", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["org.apache.maven.model.interpolation.StringSearchModelInterpolatorTest#testDefaultBuildTimestampFormatShouldFormatTimeIn24HourFormat ComparisonFailure", "org.apache.maven.model.interpolation.StringSearchModelInterpolatorTest#testDefaultBuildTimestampFormatWithLocalTimeZoneMidnightRollover ComparisonFailure"], "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/MavenBuildTimestamp.java b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/MavenBuildTimestamp.java\nindex d342566..447f0ef 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/MavenBuildTimestamp.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/MavenBuildTimestamp.java\n@@ -26,7 +26,8 @@\n \n public class MavenBuildTimestamp\n {\n-    public static final String DEFAULT_BUILD_TIMESTAMP_FORMAT = \"yyyyMMdd-HHmm\";\n+    // ISO 8601-compliant timestamp for machine readability\n+    public static final String DEFAULT_BUILD_TIMESTAMP_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss'Z'\";\n \n     public static final String BUILD_TIMESTAMP_FORMAT_PROPERTY = \"maven.build.timestamp.format\";\n \n", "nb_test": 98, "linesAdd": 1, "jira_id": "5647", "singleLine": false, "nb_skipped": 0, "commit": "cdb8ad6d", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "maven", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["testVersionRangeInclusiveBounds(org.apache.maven.model.profile.activation.JdkVersionProfileActivatorTest)", "testVersionRangeInclusiveLowerBound(org.apache.maven.model.profile.activation.JdkVersionProfileActivatorTest)", "testVersionRangeExclusiveUpperBound(org.apache.maven.model.profile.activation.JdkVersionProfileActivatorTest)"], "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\nindex 9cf3123..617ffa2 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n@@ -103,7 +103,9 @@ private static int getRelationOrder( String value, RangeValue rangeValue, boolea\n             return isLeft ? 1 : -1;\n         }\n \n-        List<String> valueTokens = new ArrayList<String>( Arrays.asList( value.split( \"\\\\.\" ) ) );\n+        value = value.replaceAll( \"[^0-9\\\\.\\\\-\\\\_]\", \"\" );\n+\n+        List<String> valueTokens = new ArrayList<String>( Arrays.asList( value.split( \"[\\\\.\\\\-\\\\_]\" ) ) );\n         List<String> rangeValueTokens = new ArrayList<String>( Arrays.asList( rangeValue.value.split( \"\\\\.\" ) ) );\n \n         int max = Math.max( valueTokens.size(), rangeValueTokens.size() );\n@@ -119,7 +121,7 @@ private static int getRelationOrder( String value, RangeValue rangeValue, boolea\n             return 0;\n         }\n \n-        for ( int i = 0; i < valueTokens.size(); i++ )\n+        for ( int i = 0; i < valueTokens.size() && i < rangeValueTokens.size(); i++ )\n         {\n             int x = Integer.parseInt( valueTokens.get( i ) );\n             int y = Integer.parseInt( rangeValueTokens.get( i ) );\n", "nb_test": 45, "linesAdd": 4, "jira_id": "4512", "singleLine": false, "nb_skipped": 0, "commit": "8cb04253", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "maven", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFinalFieldsExcludedFromInterpolation(org.apache.maven.model.interpolation.StringSearchModelInterpolatorTest)"], "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\nindex 712508d..6ff36b4 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\n@@ -32,6 +32,7 @@\n import java.io.File;\n import java.lang.reflect.Array;\n import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n import java.security.AccessController;\n import java.security.PrivilegedAction;\n import java.util.ArrayList;\n@@ -329,6 +330,11 @@ private boolean isQualifiedForInterpolation( Field field, Class<?> fieldType )\n                 return false;\n             }\n \n+            if ( Modifier.isFinal( field.getModifiers() ) )\n+            {\n+                return false;\n+            }\n+\n             return true;\n         }\n \n", "nb_test": 46, "linesAdd": 6, "jira_id": "4529", "singleLine": false, "nb_skipped": 0, "commit": "03a383e3", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["recoverBranchCommit(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\nindex 899995a..cc57477 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n@@ -289,7 +289,8 @@ private Revision determineMissedLastRev(NodeDocument doc, int clusterId) {\n         // if found then lastRev needs to be fixed\n         for (Revision rev : revs) {\n             if (rev.compareRevisionTime(currentLastRev) > 0) {\n-                if (doc.isCommitted(rev)) {\n+                rev = doc.getCommitRevision(rev);\n+                if (rev != null) {\n                     return rev;\n                 }\n             } else {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 388cca2..912237b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -545,6 +545,26 @@ public boolean isCommitted(@Nonnull Revision revision) {\n     }\n \n     /**\n+     * Returns the commit revision for the change with the given revision.\n+     *\n+     * @param revision the revision of a change.\n+     * @return the commit revision of the change or {@code null} if the change\n+     *          is not committed or unknown.\n+     */\n+    @CheckForNull\n+    public Revision getCommitRevision(@Nonnull Revision revision) {\n+        NodeDocument commitRoot = getCommitRoot(checkNotNull(revision));\n+        if (commitRoot == null) {\n+            return null;\n+        }\n+        String value = commitRoot.getCommitValue(revision);\n+        if (Utils.isCommitted(value)) {\n+            return Utils.resolveCommitRevision(revision, value);\n+        }\n+        return null;\n+    }\n+\n+    /**\n      * Returns <code>true</code> if this document contains an entry for the\n      * given <code>revision</code> in the {@link #REVISIONS} map. Please note\n      * that an entry in the {@link #REVISIONS} map does not necessarily mean\n", "nb_test": 1975, "linesAdd": 15, "jira_id": "2308", "singleLine": false, "nb_skipped": 9, "commit": "f4d5bbe1", "nb_failure": 1, "linesRem": 1}, {"files": 5, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["changeChangedPropertyTwoBranches(org.apache.jackrabbit.mongomk.ConflictTest): Must fail with conflict for changeChangedProperty"], "patch": "diff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java\nindex 6165295..f9c1466 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java\n@@ -20,6 +20,8 @@\n \n import javax.annotation.Nonnull;\n \n+import org.apache.jackrabbit.mk.api.MicroKernelException;\n+import org.apache.jackrabbit.mongomk.DocumentStore.Collection;\n import org.apache.jackrabbit.mongomk.util.Utils;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.slf4j.Logger;\n@@ -29,7 +31,16 @@\n \n /**\n  * A <code>Collision</code> happens when a commit modifies a node, which was\n- * also modified in a branch commit, but the branch commit is not yet merged.\n+ * also modified in another branch not visible to the current session. This\n+ * includes the following situations:\n+ * <ul>\n+ * <li>Our commit goes to trunk and another session committed to a branch\n+ * not yet merged back.</li>\n+ * <li>Our commit goes to a branch and another session committed to trunk\n+ * or some other branch.</li>\n+ * </ul>\n+ * Other collisions like concurrent commits to trunk are handled earlier and\n+ * do not require collision marking. See {@link Commit#createOrUpdateNode()}.\n  */\n class Collision {\n \n@@ -50,47 +61,115 @@\n         this.ourRev = checkNotNull(ourRev).toString();\n     }\n \n-    boolean mark(DocumentStore store) {\n+    /**\n+     * Marks the collision in the document store. Either our or their\n+     * revision is annotated with a collision marker. Their revision is\n+     * marked if it is not yet committed, otherwise our revision is marked.\n+     * \n+     * @param store the document store.\n+     * @throws MicroKernelException if the mark operation fails.\n+     */\n+    void mark(DocumentStore store) throws MicroKernelException {\n+        // first try to mark their revision\n         if (markCommitRoot(document, theirRev, store)) {\n-            return true;\n+            return;\n         }\n-        @SuppressWarnings(\"unchecked\")\n-        Map<String, String> revisions = (Map<String, String>) document.get(UpdateOp.REVISIONS);\n-        if (revisions.containsKey(theirRev)) {\n-            String value = revisions.get(theirRev);\n-            if (\"true\".equals(value)) {\n         // their commit wins, we have to mark ourRev\n         Map<String, Object> newDoc = Utils.newMap();\n         Utils.deepCopyMap(document, newDoc);\n         MemoryDocumentStore.applyChanges(newDoc, ourOp);\n-                if (markCommitRoot(newDoc, ourRev, store)) {\n-                    return true;\n-                }\n+        if (!markCommitRoot(newDoc, ourRev, store)) {\n+            throw new MicroKernelException(\"Unable to annotate our revision \"\n+                    + \"with collision marker. Our revision: \" + ourRev\n+                    + \", document:\\n\" + Utils.formatDocument(newDoc));\n         }\n     }\n-        return true;\n-    }\n \n+    /**\n+     * Marks the commit root of the change to the given <code>document</code> in\n+     * <code>revision</code>.\n+     * \n+     * @param document the MongoDB document.\n+     * @param revision the revision of the commit to annotated with a collision\n+     *            marker.\n+     * @param store the document store.\n+     * @return <code>true</code> if the commit for the given revision was marked\n+     *         successfully; <code>false</code> otherwise.\n+     */\n     private static boolean markCommitRoot(@Nonnull Map<String, Object> document,\n                                           @Nonnull String revision,\n                                           @Nonnull DocumentStore store) {\n+        String p = Utils.getPathFromId((String) document.get(UpdateOp.ID));\n+        String commitRootPath = null;\n+        // first check if we can mark the commit with the given revision\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, String> revisions = (Map<String, String>) document.get(UpdateOp.REVISIONS);\n+        if (revisions != null && revisions.containsKey(revision)) {\n+            String value = revisions.get(revision);\n+            if (\"true\".equals(value)) {\n+                // already committed\n+                return false;\n+            } else {\n+                // node is also commit root, but not yet committed\n+                // i.e. a branch commit, which is not yet merged\n+                commitRootPath = p;\n+            }\n+        } else {\n+            // next look at commit root\n             @SuppressWarnings(\"unchecked\")\n             Map<String, Integer> commitRoots = (Map<String, Integer>) document.get(UpdateOp.COMMIT_ROOT);\n             if (commitRoots != null) {\n                 Integer depth = commitRoots.get(revision);\n                 if (depth != null) {\n-                String p = Utils.getPathFromId((String) document.get(UpdateOp.ID));\n-                String commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);\n+                    commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);\n+                } else {\n+                    throwNoCommitRootException(revision, document);\n+                }\n+            } else {\n+                throwNoCommitRootException(revision, document);\n+            }\n+        }\n+        // at this point we have a commitRootPath\n         UpdateOp op = new UpdateOp(commitRootPath,\n                 Utils.getIdFromPath(commitRootPath), false);\n+        document = store.find(Collection.NODES, op.getKey());\n+        // check commit status of revision\n+        if (isCommitted(revision, document)) {\n+            return false;\n+        }\n         op.setMapEntry(UpdateOp.COLLISIONS, revision, true);\n-                // TODO: detect concurrent commit of previously un-merged changes\n-                // TODO: check _commitRoot for revision is not 'true'\n-                store.createOrUpdate(DocumentStore.Collection.NODES, op);\n+        document = store.createOrUpdate(DocumentStore.Collection.NODES, op);\n+        // check again on old document right before our update was applied\n+        if (isCommitted(revision, document)) {\n+            return false;\n+        }\n+        // otherwise collision marker was set successfully\n         LOG.debug(\"Marked collision on: {} for {} ({})\",\n                 new Object[]{commitRootPath, p, revision});\n         return true;\n     }\n+    \n+    private static void throwNoCommitRootException(@Nonnull String revision,\n+                                                   @Nonnull Map<String, Object> document)\n+                                                           throws MicroKernelException {\n+        throw new MicroKernelException(\"No commit root for revision: \"\n+                + revision + \", document: \" + Utils.formatDocument(document));\n+    }\n+    \n+    /**\n+     * Returns <code>true</code> if the given <code>revision</code> is marked\n+     * committed on the given <code>document</code>.\n+     * \n+     * @param revision the revision.\n+     * @param document a MongoDB document.\n+     * @return <code>true</code> if committed; <code>false</code> otherwise.\n+     */\n+    private static boolean isCommitted(String revision, Map<String, Object> document) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, String> revisions = (Map<String, String>) document.get(UpdateOp.REVISIONS);\n+        if (revisions != null && revisions.containsKey(revision)) {\n+            String value = revisions.get(revision);\n+            return \"true\".equals(value);\n         }\n         return false;\n     }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java\nindex 8695126..b311ec9 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java\n@@ -23,16 +23,16 @@\n \n     static final CollisionHandler DEFAULT = new CollisionHandler() {\n         @Override\n-        void uncommittedModification(Revision uncommitted) {\n+        void concurrentModification(Revision other) {\n             // do nothing\n         }\n     };\n \n     /**\n-     * Callback for an uncommitted modification in {@link Revision}\n-     * <code>uncommitted</code>.\n+     * Callback for an concurrent modification in {@link Revision}\n+     * <code>other</code>.\n      *\n-     * @param uncommitted the uncommitted revision of the change.\n+     * @param other the revision of the concurrent change.\n      */\n-    abstract void uncommittedModification(Revision uncommitted);\n+    abstract void concurrentModification(Revision other);\n }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java\nindex 5922f7e..b565658 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java\n@@ -268,11 +268,11 @@ private void createOrUpdateNode(DocumentStore store, UpdateOp op) {\n             Revision newestRev = mk.getNewestRevision(map, revision,\n                     new CollisionHandler() {\n                 @Override\n-                void uncommittedModification(Revision uncommitted) {\n+                void concurrentModification(Revision other) {\n                     if (collisions.get() == null) {\n                         collisions.set(new ArrayList<Revision>());\n                     }\n-                    collisions.get().add(uncommitted);\n+                    collisions.get().add(other);\n                 }\n             });\n             String conflictMessage = null;\n@@ -296,7 +296,7 @@ void uncommittedModification(Revision uncommitted) {\n             }\n             if (conflictMessage != null) {\n                 conflictMessage += \", before\\n\" + revision + \n-                        \"; document:\\n\" + map.toString().replaceAll(\", _\", \",\\n_\").replaceAll(\"}, \", \"},\\n\") + \n+                        \"; document:\\n\" + Utils.formatDocument(map) + \n                         \",\\nrevision order:\\n\" + mk.getRevisionComparator();\n                 throw new MicroKernelException(conflictMessage);\n             }\n@@ -306,11 +306,7 @@ void uncommittedModification(Revision uncommitted) {\n             if (collisions.get() != null && isConflicting(map, op)) {\n                 for (Revision r : collisions.get()) {\n                     // mark collisions on commit root\n-                    Collision c = new Collision(map, r, op, revision);\n-                    boolean success = c.mark(store);\n-                    if (!success) {\n-                        // TODO: fail this commit\n-                    }\n+                    new Collision(map, r, op, revision).mark(store);\n                 }\n             }\n         }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java\nindex a77ac51..57f1fcc 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java\n@@ -1117,7 +1117,7 @@ private Revision getLiveRevision(Map<String, Object> nodeMap,\n      * \n      * @param nodeMap the document\n      * @param changeRev the revision of the current change\n-     * @param handler the conflict handler, which is called for un-committed revisions\n+     * @param handler the conflict handler, which is called for concurrent changes\n      *                preceding <code>before</code>.\n      * @return the revision, or null if deleted\n      */\n@@ -1152,7 +1152,7 @@ private Revision getLiveRevision(Map<String, Object> nodeMap,\n                 if (!propRev.equals(changeRev)) {\n                     if (!isValidRevision(\n                             propRev, changeRev, nodeMap, new HashSet<Revision>())) {\n-                        handler.uncommittedModification(propRev);\n+                        handler.concurrentModification(propRev);\n                     } else {\n                         newestRev = propRev;\n                     }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java\nindex 79eb21d..3fe75f3 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java\n@@ -182,4 +182,14 @@ public static String getPathFromId(String id) {\n         }\n     }\n     \n+    /**\n+     * Formats a MongoDB document for use in a log message.\n+     * \n+     * @param document the MongoDB document.\n+     * @return\n+     */\n+    public static String formatDocument(Map<String, Object> document) {\n+    \treturn document.toString().replaceAll(\", _\", \",\\n_\").replaceAll(\"}, \", \"},\\n\");\n+    }\n+\n }\n", "nb_test": 195, "linesAdd": 61, "jira_id": "846", "singleLine": false, "nb_skipped": 4, "commit": "7acb091a", "nb_failure": 1, "linesRem": 25}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTokenizeCN(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest): Result set size is different expected:<1> but was:<0>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexConstants.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexConstants.java\nindex cfdf7c4..fb0d8f3 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexConstants.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexConstants.java\n@@ -25,7 +25,7 @@\n \n     String INDEX_DATA_CHILD_NAME = \":data\";\n \n-    Version VERSION = Version.LUCENE_46;\n+    Version VERSION = Version.LUCENE_47;\n \n     Analyzer ANALYZER = new OakAnalyzer(VERSION);\n \ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakAnalyzer.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakAnalyzer.java\nindex 3fbc602..6368a85 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakAnalyzer.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakAnalyzer.java\n@@ -21,8 +21,8 @@\n import org.apache.lucene.analysis.Analyzer;\n import org.apache.lucene.analysis.TokenStream;\n import org.apache.lucene.analysis.core.LowerCaseFilter;\n-import org.apache.lucene.analysis.core.WhitespaceTokenizer;\n import org.apache.lucene.analysis.miscellaneous.WordDelimiterFilter;\n+import org.apache.lucene.analysis.standard.ClassicTokenizer;\n import org.apache.lucene.util.Version;\n \n public class OakAnalyzer extends Analyzer {\n@@ -43,7 +43,7 @@ public OakAnalyzer(Version matchVersion) {\n     @Override\n     protected TokenStreamComponents createComponents(final String fieldName,\n             final Reader reader) {\n-        WhitespaceTokenizer src = new WhitespaceTokenizer(matchVersion, reader);\n+        ClassicTokenizer src = new ClassicTokenizer(matchVersion, reader);\n         TokenStream tok = new LowerCaseFilter(matchVersion, src);\n         tok = new WordDelimiterFilter(tok,\n                 WordDelimiterFilter.GENERATE_WORD_PARTS\n", "nb_test": 252, "linesAdd": 3, "jira_id": "1614", "singleLine": false, "nb_skipped": 1, "commit": "86edbffb", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["uniqueRevision2(org.apache.jackrabbit.oak.plugins.document.RevisionTest): Duplicate revision"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\nindex 79043e9..a7806cd 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n@@ -156,6 +156,12 @@ static Revision newRevision(int clusterId) {\n         long timestamp = getCurrentTimestamp();\n         int c;\n         synchronized (Revision.class) {\n+            // need to check again, because threads\n+            // could arrive inside the synchronized block\n+            // out of order\n+            if (timestamp < lastRevisionTimestamp) {\n+                timestamp = lastRevisionTimestamp;\n+            }\n             if (timestamp == lastRevisionTimestamp) {\n                 c = ++lastRevisionCount;\n             } else {\n", "nb_test": 1853, "linesAdd": 3, "jira_id": "1807", "singleLine": false, "nb_skipped": 9, "commit": "077efee5", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["gcIntermediateDocs[0](org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollectorTest): expected:<10> but was:<12>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 8f5e1ab..920cb9c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -51,10 +51,12 @@\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.transform;\n+import static java.util.Collections.disjoint;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation;\n \n@@ -1339,7 +1341,7 @@ private static void setSplitDocProps(NodeDocument mainDoc, NodeDocument oldDoc,\n         setSplitDocMaxRev(old, maxRev);\n \n         SplitDocType type = SplitDocType.DEFAULT;\n-        if(!mainDoc.hasChildren()){\n+        if(!mainDoc.hasChildren() && !referencesOldDocAfterSplit(mainDoc, oldDoc)){\n             type = SplitDocType.DEFAULT_NO_CHILD;\n         } else if (oldDoc.getLocalRevisions().isEmpty()){\n             type = SplitDocType.PROP_COMMIT_ONLY;\n@@ -1354,6 +1356,31 @@ private static void setSplitDocProps(NodeDocument mainDoc, NodeDocument oldDoc,\n     }\n \n     /**\n+     * Checks if the main document has changes referencing {@code oldDoc} after\n+     * the split.\n+     *\n+     * @param mainDoc the main document before the split.\n+     * @param oldDoc  the old document created by the split.\n+     * @return {@code true} if the main document contains references to the\n+     *         old document after the split; {@code false} otherwise.\n+     */\n+    private static boolean referencesOldDocAfterSplit(NodeDocument mainDoc,\n+                                                      NodeDocument oldDoc) {\n+        Set<Revision> revs = oldDoc.getLocalRevisions().keySet();\n+        for (String property : mainDoc.data.keySet()) {\n+            if (IGNORE_ON_SPLIT.contains(property)) {\n+                continue;\n+            }\n+            Set<Revision> changes = Sets.newHashSet(mainDoc.getLocalMap(property).keySet());\n+            changes.removeAll(oldDoc.getLocalMap(property).keySet());\n+            if (!disjoint(changes, revs)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n      * Set various properties for intermediate split document\n      *\n      * @param intermediate updateOp of the intermediate doc getting created\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\nindex 320afb7..e671b66 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n@@ -46,8 +46,7 @@\n      */\n     private static final Set<NodeDocument.SplitDocType> GC_TYPES = EnumSet.of(\n             NodeDocument.SplitDocType.DEFAULT_NO_CHILD,\n-            NodeDocument.SplitDocType.PROP_COMMIT_ONLY,\n-            NodeDocument.SplitDocType.INTERMEDIATE);\n+            NodeDocument.SplitDocType.PROP_COMMIT_ONLY);\n \n \n     VersionGarbageCollector(DocumentNodeStore nodeStore) {\n", "nb_test": 1847, "linesAdd": 20, "jira_id": "1729", "singleLine": false, "nb_skipped": 8, "commit": "7ba9dd66", "nb_failure": 1, "linesRem": 3}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testListRecord(org.apache.jackrabbit.oak.plugins.segment.RecordTest): OAK-1287"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\nindex df2735e..27b5cba 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\n@@ -57,8 +57,10 @@ public RecordId getEntry(int index) {\n             int bucketIndex = index / bucketSize;\r\n             int bucketOffset = index % bucketSize;\r\n             Segment segment = getSegment();\r\n-            RecordId bucketId = segment.readRecordId(getOffset(0, bucketIndex));\r\n-            ListRecord bucket = new ListRecord(segment, bucketId, bucketSize);\r\n+            RecordId id = segment.readRecordId(getOffset(0, bucketIndex));\r\n+            ListRecord bucket = new ListRecord(\r\n+                    segment, id,\r\n+                    Math.min(bucketSize, size - bucketIndex * bucketSize));\r\n             return bucket.getEntry(bucketOffset);\r\n         }\r\n     }\r\n@@ -78,7 +80,7 @@ public RecordId getEntry(int index) {\n                     list.add(id);\r\n                 } else {\r\n                     ListRecord bucket = new ListRecord(\r\n-                            segment, id, Math.min(bucketSize, size - offset));\r\n+                            segment, id, Math.min(bucketSize, size - i));\r\n                     list.addAll(bucket.getEntries());\r\n                 }\r\n                 offset += Segment.RECORD_ID_BYTES;\r\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\nindex a961cbf..aeb7e98 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n@@ -340,6 +340,7 @@ private MapRecord writeMapBranch(int level, int size, MapRecord[] buckets) {\n \n \n     private synchronized RecordId writeListBucket(List<RecordId> bucket) {\n+        checkArgument(bucket.size() > 1);\n         RecordId bucketId = prepare(RecordType.BUCKET, 0, bucket);\n         for (RecordId id : bucket) {\n             writeRecordId(id);\n@@ -516,7 +517,11 @@ public RecordId writeList(List<RecordId> list) {\n             List<RecordId> nextLevel = Lists.newArrayList();\n             for (List<RecordId> bucket :\n                     Lists.partition(thisLevel, ListRecord.LEVEL_SIZE)) {\n+                if (bucket.size() > 1) {\n                     nextLevel.add(writeListBucket(bucket));\n+                } else {\n+                    nextLevel.add(bucket.get(0));\n+                }\n             }\n             thisLevel = nextLevel;\n         }\n", "nb_test": 1497, "linesAdd": 10, "jira_id": "1287", "singleLine": false, "nb_skipped": 6, "commit": "14849e22", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCheckpointMax(org.apache.jackrabbit.oak.segment.CheckpointTest)"], "patch": "diff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentNodeStore.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentNodeStore.java\nindex 61d16aa..af2ade6 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentNodeStore.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentNodeStore.java\n@@ -404,7 +404,11 @@ public Boolean call() {\n             }\n \n             NodeBuilder cp = checkpoints.child(name);\n+            if (Long.MAX_VALUE - now > lifetime) {\n                 cp.setProperty(\"timestamp\", now + lifetime);\n+            } else {\n+                cp.setProperty(\"timestamp\", Long.MAX_VALUE);\n+            }\n             cp.setProperty(\"created\", now);\n \n             NodeBuilder props = cp.setChildNode(\"properties\");\n", "nb_test": 141, "linesAdd": 4, "jira_id": "4423", "singleLine": false, "nb_skipped": 1, "commit": "08f0b280", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["putTokenImpl(org.apache.jackrabbit.mk.store.DefaultRevisionStoreTest): java.lang.AssertionError"], "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\nindex 4e299c3..533ccc8 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\n@@ -223,12 +223,12 @@ protected static int determineInitialCacheSize() {\n      */\n     static class PutTokenImpl extends PutToken {\n \n-        private static int idCounter;\n+        private static final AtomicInteger ID_COUNTER = new AtomicInteger();\n         private int id;\n         private StoredNode lastModifiedNode;\n \n         public PutTokenImpl() {\n-            this.id = ++idCounter;\n+            this.id = ID_COUNTER.incrementAndGet();\n         }\n \n         @Override\n", "nb_test": 78, "linesAdd": 2, "jira_id": "543", "singleLine": false, "nb_skipped": 2, "commit": "3ce758b7", "nb_failure": 0, "linesRem": 2}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testHasPermissionWithRestrictions(org.apache.jackrabbit.oak.security.authorization.restriction.PermissionTest): user should not have 64 on /testRoot/a/b/c expected:<false> but was:<true>", "testHasPermissionWithRestrictions2(org.apache.jackrabbit.oak.security.authorization.restriction.PermissionTest): user should have 64 on /testRoot/a/b/c/d expected:<true> but was:<false>", "testProtectByRestriction(org.apache.jackrabbit.oak.security.authorization.restriction.CustomRestrictionProviderTest): user should have 64 on /testRoot/a/b/c/d expected:<true> but was:<false>", "testUnProtectByRestriction(org.apache.jackrabbit.oak.security.authorization.restriction.CustomRestrictionProviderTest): user should not have 64 on /testRoot/a/b/c expected:<false> but was:<true>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\nindex 84f16ae..153884f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\n@@ -145,7 +145,8 @@ public RepositoryPermission getRepositoryPermission() {\n         return new RepositoryPermission() {\n             @Override\n             public boolean isGranted(long repositoryPermissions) {\n-                return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);\n+                EntryPredicate predicate = new EntryPredicate();\n+                return hasPermissions(getEntryIterator(predicate), predicate, repositoryPermissions, null);\n             }\n         };\n     }\n@@ -242,8 +243,8 @@ public boolean isGranted(@Nonnull Tree tree, @Nullable PropertyState property, l\n \n     @Override\n     public boolean isGranted(@Nonnull String path, long permissions) {\n-        Iterator<PermissionEntry> it = getEntryIterator(new EntryPredicate(path, Permissions.respectParentPermissions(permissions)));\n-        return hasPermissions(it, permissions, path);\n+        EntryPredicate predicate = new EntryPredicate(path, Permissions.respectParentPermissions(permissions));\n+        return hasPermissions(getEntryIterator(predicate), predicate, permissions, path);\n     }\n \n     @Nonnull\n@@ -260,11 +261,12 @@ public boolean hasPrivileges(@Nullable Tree tree, @Nonnull String... privilegeNa\n     //------------------------------------------------------------< private >---\n \n     private boolean internalIsGranted(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {\n-        Iterator<PermissionEntry> it = getEntryIterator(tree, property, permissions);\n-        return hasPermissions(it, permissions, tree.getPath());\n+        EntryPredicate predicate = new EntryPredicate(tree, property, Permissions.respectParentPermissions(permissions));\n+        return hasPermissions(getEntryIterator(predicate), predicate, permissions, tree.getPath());\n     }\n \n     private boolean hasPermissions(@Nonnull Iterator<PermissionEntry> entries,\n+                                   @Nonnull EntryPredicate predicate,\n                                    long permissions, @Nullable String path) {\n         // calculate readable paths if the given permissions includes any read permission.\n         boolean isReadable = Permissions.diff(Permissions.READ, permissions) != Permissions.READ && readPolicy.isReadablePath(path, false);\n@@ -310,14 +312,18 @@ private boolean hasPermissions(@Nonnull Iterator<PermissionEntry> entries,\n             }\n \n             if (entry.isAllow) {\n+                if (!respectParent || predicate.apply(entry, false)) {\n                     allowBits.addDifference(entry.privilegeBits, denyBits);\n+                }\n                 long ap = PrivilegeBits.calculatePermissions(allowBits, parentAllowBits, true);\n                 allows |= Permissions.diff(ap, denies);\n                 if ((allows | ~permissions) == -1) {\n                     return true;\n                 }\n             } else {\n+                if (!respectParent || predicate.apply(entry, false)) {\n                     denyBits.addDifference(entry.privilegeBits, allowBits);\n+                }\n                 long dp = PrivilegeBits.calculatePermissions(denyBits, parentDenyBits, false);\n                 denies |= Permissions.diff(dp, allows);\n                 if (Permissions.includes(denies, permissions)) {\n@@ -377,11 +383,6 @@ private PrivilegeBits getPrivilegeBits(@Nullable Tree tree) {\n     }\n \n     @Nonnull\n-    private Iterator<PermissionEntry> getEntryIterator(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {\n-        return getEntryIterator(new EntryPredicate(tree, property, Permissions.respectParentPermissions(permissions)));\n-    }\n-\n-    @Nonnull\n     private Iterator<PermissionEntry> getEntryIterator(@Nonnull EntryPredicate predicate) {\n         Iterator<PermissionEntry> userEntries = userStore.getEntryIterator(predicate);\n         Iterator<PermissionEntry> groupEntries = groupStore.getEntryIterator(predicate);\n@@ -526,12 +527,16 @@ public boolean canReadProperties() {\n \n         @Override\n         public boolean isGranted(long permissions) {\n-            return hasPermissions(getIterator(null, permissions), permissions, tree.getPath());\n+            EntryPredicate predicate = new EntryPredicate(tree, null, Permissions.respectParentPermissions(permissions));\n+            Iterator<PermissionEntry> it = concat(new LazyIterator(this, true, predicate), new LazyIterator(this, false, predicate));\n+            return hasPermissions(it, predicate, permissions, tree.getPath());\n         }\n \n         @Override\n         public boolean isGranted(long permissions, @Nonnull PropertyState property) {\n-            return hasPermissions(getIterator(property, permissions), permissions, tree.getPath());\n+            EntryPredicate predicate = new EntryPredicate(tree, property, Permissions.respectParentPermissions(permissions));\n+            Iterator<PermissionEntry> it = concat(new LazyIterator(this, true, predicate), new LazyIterator(this, false, predicate));\n+            return hasPermissions(it, predicate, permissions, tree.getPath());\n         }\n \n         //--------------------------------------------------------< private >---\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/EntryPredicate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/EntryPredicate.java\nindex 20fe765..023e18e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/EntryPredicate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/EntryPredicate.java\n@@ -37,6 +37,7 @@\n \n     private final String parentPath;\n     private final Tree parent;\n+    private final boolean respectParent;\n \n     public EntryPredicate(@Nonnull Tree tree, @Nullable PropertyState property,\n                           boolean respectParent) {\n@@ -64,6 +65,7 @@ private EntryPredicate(@Nullable Tree tree, @Nullable PropertyState property,\n             parentPath = null;\n             parent = null;\n         }\n+        this.respectParent = parent != null || parentPath != null;\n     }\n \n     @CheckForNull\n@@ -73,25 +75,22 @@ public String getPath() {\n \n     @Override\n     public boolean apply(@Nullable PermissionEntry entry) {\n+        return apply(entry, true);\n+    }\n+\n+    public boolean apply(@Nullable PermissionEntry entry, boolean respectParent) {\n         if (entry == null) {\n             return false;\n         }\n+        respectParent &= this.respectParent;\n+\n         if (tree != null) {\n-            return entry.matches(tree, property) || applyToParent(entry);\n+            return entry.matches(tree, property) || (respectParent && parent != null && entry.matches(parent, null));\n         } else if (path != null) {\n-            return entry.matches(path) || applyToParent(entry);\n+            return entry.matches(path) || (respectParent && parentPath != null && entry.matches(parentPath));\n         } else {\n             return entry.matches();\n         }\n     }\n \n-    private boolean applyToParent(@Nonnull PermissionEntry entry) {\n-        if (parent != null) {\n-            return entry.matches(parent, null);\n-        } else if (parentPath != null) {\n-            return entry.matches(parentPath);\n-        } else {\n-            return false;\n-        }\n-    }\n }\n\\ No newline at end of file\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntry.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntry.java\nindex 36dbe01..136ccb9 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntry.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntry.java\n@@ -122,4 +122,16 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hashCode(privilegeBits, index, path, isAllow, restriction);\n     }\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder(\"PermissionEntry{\");\n+        sb.append(\"isAllow=\").append(isAllow);\n+        sb.append(\", privilegeBits=\").append(privilegeBits);\n+        sb.append(\", index=\").append(index);\n+        sb.append(\", path='\").append(path).append('\\'');\n+        sb.append(\", restriction=\").append(restriction);\n+        sb.append('}');\n+        return sb.toString();\n+    }\n }\n\\ No newline at end of file\n", "nb_test": 2413, "linesAdd": 39, "jira_id": "3324", "singleLine": false, "nb_skipped": 1, "commit": "5f863af6", "nb_failure": 4, "linesRem": 23}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testUnique(org.apache.jackrabbit.oak.plugins.index.p2.strategy.ContentMirrorStoreStrategyTest): ContentMirrorStoreStrategy should guarantee uniqueness on insert"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\nindex 0d3b259..f3d4804 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\n@@ -42,7 +42,26 @@\n import com.google.common.collect.Sets;\n \n /**\n- * TODO document\n+ * An IndexStoreStrategy implementation that saves the nodes under a hierarchy\n+ * that mirrors the repository tree. <br>\n+ * This should minimize the chance that concurrent updates overlap on the same\n+ * content node.<br>\n+ * <br>\n+ * For example for a node that is under <code>/test/node</code>, the index\n+ * structure will be <code>/oak:index/index/test/node</code>:\n+ * \n+ * <pre>\n+ * <code>\n+ * /\n+ *   test\n+ *     node\n+ *   oak:index\n+ *     index\n+ *       test\n+ *         node\n+ * </code>\n+ * </pre>\n+ * \n  */\n public class ContentMirrorStoreStrategy implements IndexStoreStrategy {\n \n@@ -118,6 +137,12 @@ private static void pruneNode(NodeBuilder parent) {\n     public void insert(NodeBuilder index, String key, boolean unique,\n             Iterable<String> values) throws CommitFailedException {\n         NodeBuilder child = index.child(key);\n+        if (unique\n+                && (child.getProperty(\"match\") != null || child\n+                        .getChildNodeCount() > 0)) {\n+            throw new CommitFailedException(\n+                    \"Uniqueness constraint violated for key \" + key);\n+        }\n \n         for (String add : values) {\n             NodeBuilder indexEntry = child;\n@@ -126,14 +151,6 @@ public void insert(NodeBuilder index, String key, boolean unique,\n             }\n             indexEntry.setProperty(\"match\", true);\n         }\n-        CountingNodeVisitor v = new CountingNodeVisitor(2);\n-        v.visit(child.getNodeState());\n-        int matchCount = v.getCount();\n-        if (matchCount == 0) {\n-            index.removeNode(key);\n-        } else if (unique && matchCount > 1) {\n-            throw new CommitFailedException(\"Uniqueness constraint violated for key \" + key);\n-        }\n     }\n \n     @Override\n", "nb_test": 699, "linesAdd": 6, "jira_id": "748", "singleLine": false, "nb_skipped": 1, "commit": "503451c1", "nb_failure": 1, "linesRem": 8}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["sortCompareCalls(org.apache.jackrabbit.oak.query.IteratorsTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/FilterIterators.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/FilterIterators.java\nindex 11ae007..6fba745 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/FilterIterators.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/FilterIterators.java\n@@ -205,9 +205,9 @@ private void init() {\n                 list.add(x);\n                 checkMemoryLimit(list.size(), settings);\n                 // from time to time, sort and truncate\n-                // this should results in O(n*log(2*keep)) operations,\n+                // this should need less than O(n*log(3*keep)) operations,\n                 // which is close to the optimum O(n*log(keep))\n-                if (list.size() > max * 2) {\n+                if (list.size() > (long) max * 2) {\n                     // remove tail entries right now, to save memory\n                     Collections.sort(list, orderBy);\n                     keepFirst(list, max);\n", "nb_test": 1859, "linesAdd": 1, "jira_id": "2418", "singleLine": false, "nb_skipped": 9, "commit": "039f892d", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOverflow(org.apache.jackrabbit.oak.plugins.index.lucene.OakDirectoryTest): expected:<2976743424> but was:<-1318223872>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\nindex 8e57339..8256394 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n@@ -187,7 +187,7 @@ public OakIndexFile(String name, NodeBuilder file) {\n                 this.data = newArrayList();\n             }\n \n-            this.length = data.size() * blobSize;\n+            this.length = (long)data.size() * blobSize;\n             if (!data.isEmpty()) {\n                 Blob last = data.get(data.size() - 1);\n                 this.length -= blobSize - last.length();\n@@ -253,7 +253,9 @@ public void readBytes(byte[] b, int offset, int len)\n             checkPositionIndexes(offset, offset + len, checkNotNull(b).length);\n \n             if (len < 0 || position + len > length) {\n-                throw new IOException(\"Invalid byte range request\");\n+                String msg = String.format(\"Invalid byte range request [%s] : position : %d, length : \" +\n+                                \"%d, len : %d\", name, position, length, len);\n+                throw new IOException(msg);\n             }\n \n             int i = (int) (position / blobSize);\n", "nb_test": 374, "linesAdd": 4, "jira_id": "2388", "singleLine": false, "nb_skipped": 0, "commit": "487de751", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testEmpty(org.apache.jackrabbit.oak.plugins.segment.RecordIdMapTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/RecordIdMap.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/RecordIdMap.java\nindex 0b6660c..fe62ffd 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/RecordIdMap.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/RecordIdMap.java\n@@ -29,8 +29,11 @@\n  * A memory optimised map of {@code short} key to {@link RecordId} values.\n  */\n public class RecordIdMap {\n-    private short[] keys;\n-    private RecordId[] values;\n+    private static final short[] NO_KEYS = new short[0];\n+    private static final RecordId[] NO_VALUES = new RecordId[0];\n+\n+    private short[] keys = NO_KEYS;\n+    private RecordId[] values = NO_VALUES;\n \n     /**\n      * Associates {@code key} with {@code value} if not already present\n@@ -39,7 +42,7 @@\n      * @return  {@code true} if added, {@code false} if already present\n      */\n     public boolean put(short key, @Nonnull RecordId value) {\n-        if (keys == null) {\n+        if (keys.length == 0) {\n             keys = new short[1];\n             values = new RecordId[1];\n             keys[0] = key;\n@@ -90,7 +93,7 @@ public RecordId get(short key) {\n      * @return  {@code true} iff {@code key} is present.\n      */\n     public boolean containsKey(short key) {\n-        return keys != null && binarySearch(keys, key) >= 0;\n+        return binarySearch(keys, key) >= 0;\n     }\n \n     /**\n@@ -105,6 +108,7 @@ public int size() {\n      * the natural ordering of shorts.\n      * @param index\n      * @return the key at {@code index}\n+     * @throws ArrayIndexOutOfBoundsException if not {@code 0 <= index < size()}\n      */\n     public short getKey(int index) {\n         return keys[index];\n@@ -115,6 +119,7 @@ public short getKey(int index) {\n      * the natural ordering of shorts.\n      * @param index\n      * @return the value at {@code index}\n+     * @throws ArrayIndexOutOfBoundsException if not {@code 0 <= index < size()}\n      */\n     @Nonnull\n     public RecordId getRecordId(int index) {\n", "nb_test": 2232, "linesAdd": 7, "jira_id": "3123", "singleLine": false, "nb_skipped": 1, "commit": "f3c9c818", "nb_failure": 0, "linesRem": 4}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["indexSelectionFulltextVsNodeType(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): (..)", "pureNodeTypeWithEvaluatePathRestrictionEnabled(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlannerTest)"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\nindex 522aa66..19ad3cf 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\n@@ -315,7 +315,12 @@ private void visitTerm(String propertyName) {\n     }\n \n     private boolean canEvalPathRestrictions(IndexingRule rule) {\n-        if (filter.getPathRestriction() == Filter.PathRestriction.NO_RESTRICTION){\n+        //Opt out if one is looking for all children for '/' as its equivalent to\n+        //NO_RESTRICTION\n+        if (filter.getPathRestriction() == Filter.PathRestriction.NO_RESTRICTION\n+                || (filter.getPathRestriction() == Filter.PathRestriction.ALL_CHILDREN\n+                        && PathUtils.denotesRoot(filter.getPath()))\n+                ){\n             return false;\n         }\n         //If no other restrictions is provided and query is pure\n", "nb_test": 468, "linesAdd": 4, "jira_id": "3137", "singleLine": false, "nb_skipped": 4, "commit": "c65b07c3", "nb_failure": 2, "linesRem": 1}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["rebaseWithFailedMerge[0](org.apache.jackrabbit.oak.kernel.NodeStoreTest)", "rebaseWithFailedMerge[1](org.apache.jackrabbit.oak.kernel.NodeStoreTest)", "rebaseWithFailedMerge[2](org.apache.jackrabbit.oak.kernel.NodeStoreTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\nindex c7da536..440e47b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\n@@ -145,7 +145,19 @@ NodeState reset() {\n      */\n     NodeState merge(CommitHook hook, CommitInfo info) throws CommitFailedException {\n         purge();\n+        boolean success = false;\n+        try {\n             branch.merge(hook, info);\n+            success = true;\n+        } finally {\n+            if (!success) {\n+                // need to adjust base and head of this builder\n+                // in case branch.merge() did a rebase and then\n+                // a commit hook failed the merge\n+                super.reset(branch.getHead());\n+                this.base = branch.getBase();\n+            }\n+        }\n         return reset();\n     }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\nindex f4ac698..268f3df 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\n@@ -142,7 +142,19 @@ NodeState reset() {\n      */\n     NodeState merge(CommitHook hook, CommitInfo info) throws CommitFailedException {\n         purge();\n+        boolean success = false;\n+        try {\n             branch.merge(hook, info);\n+            success = true;\n+        } finally {\n+            if (!success) {\n+                // need to adjust base and head of this builder\n+                // in case branch.merge() did a rebase and then\n+                // a commit hook failed the merge\n+                super.reset(branch.getHead());\n+                this.base = branch.getBase();\n+            }\n+        }\n         return reset();\n     }\n \n", "nb_test": 1530, "linesAdd": 18, "jira_id": "1320", "singleLine": false, "nb_skipped": 6, "commit": "64045631", "nb_failure": 3, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testLowercaseOnArrays(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/LowerCaseImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/LowerCaseImpl.java\nindex 3f36512..1b13e1d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/LowerCaseImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/LowerCaseImpl.java\n@@ -27,7 +27,11 @@\n import org.apache.jackrabbit.oak.query.index.FilterImpl;\n import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n \n+import com.google.common.base.Function;\n+\n+import static com.google.common.collect.Iterables.transform;\n import static org.apache.jackrabbit.oak.api.Type.STRING;\n+import static org.apache.jackrabbit.oak.api.Type.STRINGS;\n \n /**\n  * The function \"lower(..)\".\n@@ -70,12 +74,21 @@ public PropertyValue currentProperty() {\n         if (p == null) {\n             return null;\n         }\n-        // TODO what is the expected result of LOWER(x) for an array property?\n-        // currently throws an exception\n-        String value = p.getValue(STRING);\n         // TODO toLowerCase(): document the Turkish locale problem\n+        if (p.getType().isArray()) {\n+            Iterable<String> lowerCase = transform(p.getValue(STRINGS),\n+                    new Function<String, String>() {\n+                        @Override\n+                        public String apply(String input) {\n+                            return input.toLowerCase();\n+                        }\n+                    });\n+            return PropertyValues.newString(lowerCase);\n+        } else {\n+            String value = p.getValue(STRING);\n             return PropertyValues.newString(value.toLowerCase());\n         }\n+    }\n \n     @Override\n     public void restrict(FilterImpl f, Operator operator, PropertyValue v) {\n", "nb_test": 1874, "linesAdd": 16, "jira_id": "1829", "singleLine": false, "nb_skipped": 9, "commit": "ca36450e", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 146, "classification": {"singleLine": false}, "failing_tests": ["testInvalidImpersonation(org.apache.jackrabbit.oak.security.authentication.DefaultLoginModuleTest)", "testUserLogin(org.apache.jackrabbit.oak.security.authentication.DefaultLoginModuleTest)", "testSelfImpersonation(org.apache.jackrabbit.oak.security.authentication.DefaultLoginModuleTest)", "testTokenCreationAndLogin(org.apache.jackrabbit.oak.security.authentication.TokenDefaultLoginModuleTest): Invalid token ''", "testValidTokenCredentials(org.apache.jackrabbit.oak.security.authentication.TokenDefaultLoginModuleTest)", "testAuthenticateSimpleCredentials(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateSimpleCredentials(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateInvalidImpersonationCredentials(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateInvalidImpersonationCredentials(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateImpersonationCredentials(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateImpersonationCredentials(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateImpersonationCredentials2(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateImpersonationCredentials2(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateWithoutUserManager(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateWithoutUserManager(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateWithoutUserId(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateWithoutUserId(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateInvalidCredentials(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateInvalidCredentials(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateInvalidSimpleCredentials(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateInvalidSimpleCredentials(org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest)", "testAuthenticateWithoutTokenProvider(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testAuthenticateWithoutTokenProvider(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testAuthenticateWithInvalidCredentials(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testAuthenticateWithInvalidCredentials(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testAuthenticateWithInvalidTokenCredentials(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testAuthenticateWithInvalidTokenCredentials(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testAuthenticate(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testAuthenticate(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testGetTokenInfoBeforeAuthenticate(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testGetTokenInfoBeforeAuthenticate(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testGetTokenInfoAfterAuthenticate(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testGetTokenInfoAfterAuthenticate(org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest)", "testGetTokenInfoFromInvalidToken(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testGetTokenInfoFromInvalidToken(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testGetTokenInfo(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testGetTokenInfo(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testRemoveTokenInvalidInfo(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testRemoveTokenInvalidInfo(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testRemoveToken(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testRemoveToken(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testRemoveToken2(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testRemoveToken2(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testRemoveTokenRemovesNode(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testRemoveTokenRemovesNode(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testResetTokenExpirationInvalidToken(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testResetTokenExpirationInvalidToken(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testResetTokenExpirationExpiredToken(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testResetTokenExpirationExpiredToken(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testResetTokenExpiration(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testResetTokenExpiration(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testTokenNode(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testTokenNode(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testDoCreateToken(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testDoCreateToken(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testCreateTokenFromInvalidCredentials(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testCreateTokenFromInvalidCredentials(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testCreateTokenFromCredentials(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testCreateTokenFromCredentials(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testCreateTokenFromInvalidUserId(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testCreateTokenFromInvalidUserId(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testCreateTokenFromUserId(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testCreateTokenFromUserId(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)", "testGetUserId(org.apache.jackrabbit.oak.security.authentication.token.TokenInfoTest)", "testGetUserId(org.apache.jackrabbit.oak.security.authentication.token.TokenInfoTest)", "testGetToken(org.apache.jackrabbit.oak.security.authentication.token.TokenInfoTest)", "testGetToken(org.apache.jackrabbit.oak.security.authentication.token.TokenInfoTest)", "testIsExpired(org.apache.jackrabbit.oak.security.authentication.token.TokenInfoTest)", "testIsExpired(org.apache.jackrabbit.oak.security.authentication.token.TokenInfoTest)", "testMatches(org.apache.jackrabbit.oak.security.authentication.token.TokenInfoTest)", "testMatches(org.apache.jackrabbit.oak.security.authentication.token.TokenInfoTest)", "testGetAttributes(org.apache.jackrabbit.oak.security.authentication.token.TokenInfoTest)", "testGetAttributes(org.apache.jackrabbit.oak.security.authentication.token.TokenInfoTest)", "testValidTokenCredentials(org.apache.jackrabbit.oak.security.authentication.TokenLoginModuleTest)", "testEveryone(org.apache.jackrabbit.oak.security.principal.PrincipalProviderImplTest)", "removePassword(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "removePassword(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "removePrincipalName(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "removePrincipalName(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "removeAuthorizableId(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "removeAuthorizableId(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "createWithoutPrincipalName(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "createWithoutPrincipalName(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "createWithInvalidUUID(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "createWithInvalidUUID(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "changeUUID(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "changeUUID(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "changePrincipalName(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "changePrincipalName(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "changeAuthorizableId(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "changeAuthorizableId(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "changePasswordToPlainText(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "changePasswordToPlainText(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "testRemoveAdminUser(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "testRemoveAdminUser(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "testDisableAdminUser(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "testDisableAdminUser(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "testEnforceHierarchy(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "testEnforceHierarchy(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "setPasswordNull(org.apache.jackrabbit.oak.security.user.UserManagerImplTest)", "testGetPasswordHash(org.apache.jackrabbit.oak.security.user.UserManagerImplTest)", "testEnforceAuthorizableFolderHierarchy(org.apache.jackrabbit.oak.security.user.UserManagerImplTest)", "testSetPassword(org.apache.jackrabbit.oak.security.user.UserManagerImplTest)", "testSetMultiValueProperty(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSetMultiValueProperty(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSetPropertyByRelPath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSetPropertyByRelPath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSetProperty(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSetProperty(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSetPropertyInvalidRelativePath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSetPropertyInvalidRelativePath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testGetPropertyByInvalidRelativePath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testGetPropertyByInvalidRelativePath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testHasPropertyByInvalidRelativePath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testHasPropertyByInvalidRelativePath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testGetPropertyNames(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testGetPropertyNames(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testGetPropertyNamesByRelPath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testGetPropertyNamesByRelPath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testGetPropertyNamesByInvalidRelPath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testGetPropertyNamesByInvalidRelPath(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testGetNotExistingProperty(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testGetNotExistingProperty(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testRemoveNotExistingProperty(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testRemoveNotExistingProperty(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSetSpecialProperties(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSetSpecialProperties(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testRemoveSpecialProperties(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testRemoveSpecialProperties(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSingleToMultiValued(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSingleToMultiValued(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testMultiValuedToSingle(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testMultiValuedToSingle(org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest)", "testSyncCreateUser(org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalLoginModuleTest): java.lang.NullPointerException", "testSyncCreateUserAndGroups(org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalLoginModuleTest): java.lang.NullPointerException", "testSyncUpdate(org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalLoginModuleTest)", "testSyncUpdate(org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalLoginModuleTest)", "testSyncUpdateAndGroups(org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalLoginModuleTest)", "testSyncUpdateAndGroups(org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalLoginModuleTest)", "testDefaultSync(org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalLoginModuleTest): java.lang.NullPointerException", "testPasswordValidationActionOnChange(org.apache.jackrabbit.oak.spi.security.user.action.PasswordValidationActionTest)", "testPasswordValidationActionOnChange(org.apache.jackrabbit.oak.spi.security.user.action.PasswordValidationActionTest)", "testActionIsCalled(org.apache.jackrabbit.oak.spi.security.user.action.PasswordValidationActionTest)", "testActionIsCalled(org.apache.jackrabbit.oak.spi.security.user.action.PasswordValidationActionTest)", "testPasswordValidationActionOnCreate(org.apache.jackrabbit.oak.spi.security.user.action.PasswordValidationActionTest)", "testPasswordValidationActionOnCreate(org.apache.jackrabbit.oak.spi.security.user.action.PasswordValidationActionTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/commit/ValidatingHook.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/commit/ValidatingHook.java\nindex b3d10b3..7840eca 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/commit/ValidatingHook.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/commit/ValidatingHook.java\n@@ -151,7 +151,19 @@ public void propertyDeleted(PropertyState before) {\n \n         @Override\n         public void childNodeAdded(String name, NodeState after) {\n-            childNodeChanged(name, EMPTY_NODE, after);\n+            if (NodeStateUtils.isHidden(name)) {\n+                return;\n+            }\n+            if (exception == null) {\n+                try {\n+                    Validator v = validator.childNodeAdded(name, after);\n+                    if (v != null) {\n+                        validate(v, EMPTY_NODE, after);\n+                    }\n+                } catch (CommitFailedException e) {\n+                    exception = e;\n+                }\n+            }\n         }\n \n         @Override\n@@ -175,7 +187,19 @@ public void childNodeChanged(\n \n         @Override\n         public void childNodeDeleted(String name, NodeState before) {\n-            childNodeChanged(name, before, EMPTY_NODE);\n+            if (NodeStateUtils.isHidden(name)) {\n+                return;\n+            }\n+            if (exception == null) {\n+                try {\n+                    Validator v = validator.childNodeDeleted(name, before);\n+                    if (v != null) {\n+                        validate(v, before, EMPTY_NODE);\n+                    }\n+                } catch (CommitFailedException e) {\n+                    exception = e;\n+                }\n+            }\n         }\n \n     }\n", "nb_test": 467, "linesAdd": 26, "jira_id": "478", "singleLine": false, "nb_skipped": 0, "commit": "a7f0e808", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["setNext(org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest): 1"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\nindex 3f78b78..abb7e5a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n@@ -23,6 +23,7 @@\n import java.util.Collections;\n import java.util.Deque;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.NoSuchElementException;\n import java.util.Random;\n \n@@ -47,6 +48,7 @@\n import com.google.common.base.Strings;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n \n /**\n  * Same as for {@link ContentMirrorStoreStrategy} but the order of the keys is kept by using the\n@@ -149,6 +151,7 @@ NodeBuilder fetchKeyNode(@Nonnull NodeBuilder index, @Nonnull String key) {\n                                         \n     @Override\n     void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final String key) {\n+        LOG.debug(\"prune() - deleting: {}\", key);\n         for (NodeBuilder node : builders) {\n             if (node.hasProperty(\"match\") || node.getChildNodeCount(1) > 0) {\n                 return;\n@@ -166,11 +169,25 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n                             walkedLanes\n                             );\n                         lane0Next = getPropertyNext(walkedLanes[0]);\n+                        if (LOG.isDebugEnabled()) {\n+                            for (int i = 0; i < walkedLanes.length; i++) {\n+                                LOG.debug(\"prune() - walkedLanes[{}]: {}\", i,\n+                                    walkedLanes[i].getName());\n+                            }\n+                        }\n                         for (int lane = walkedLanes.length - 1; lane >= 0; lane--) {\n                             prevNext = getPropertyNext(walkedLanes[lane], lane);\n                             if (key.equals(prevNext)) {\n                                 // if it's actually pointing to us let's deal with it\n                                 currNext = getPropertyNext(node, lane);\n+                                if (LOG.isDebugEnabled()) {\n+                                    LOG.debug(\n+                                        \"prune() - setting next for '{}' on lane '{}' with '{}'\",\n+                                        new Object[] {\n+                                        walkedLanes[lane].getName(),\n+                                        lane,\n+                                        currNext});\n+                                }\n                                 setPropertyNext(index.getChildNode(walkedLanes[lane].getName()),\n                                     currNext, lane);\n                             }\n@@ -997,7 +1014,23 @@ static void setPropertyNext(@Nonnull final NodeBuilder node,\n         if (node != null && value != null && lane >= 0 && lane < OrderedIndex.LANES) {\n             PropertyState next = node.getProperty(NEXT);\n             if (next != null) {\n-                String[] values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);\n+                String[] values;\n+                if (next.isArray()) {\n+                    values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);\n+                    if (values.length < OrderedIndex.LANES) {\n+                        // it could be we increased the number of lanes and running on some existing\n+                        // content\n+                        LOG.debug(\"topping-up the number of lanes.\");\n+                        List<String> vv = Lists.newArrayList(values);\n+                        for (int i = vv.size(); i <= OrderedIndex.LANES; i++) {\n+                            vv.add(\"\");\n+                        }\n+                        values = vv.toArray(new String[0]);\n+                    }\n+                } else {\n+                    values = Iterables.toArray(EMPTY_NEXT, String.class);\n+                    values[0] = next.getValue(Type.STRING);\n+                }\n                 values[lane] = value;\n                 setPropertyNext(node, values);\n             }\n", "nb_test": 1809, "linesAdd": 32, "jira_id": "1899", "singleLine": false, "nb_skipped": 9, "commit": "df59fb45", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testInitLongOverflow2(org.apache.jackrabbit.oak.security.authorization.permission.PermissionEntryProviderImplTest): The number of  entries exceeds the max cache size", "testExistingNamesAndLongOverFlow(org.apache.jackrabbit.oak.security.authorization.permission.PermissionEntryProviderImplTest): The number of  entries exceeds the max cache size", "testNoExistingName(org.apache.jackrabbit.oak.security.authorization.permission.PermissionEntryProviderImplTest): The number of  entries exceeds the max cache size"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java\nindex cce6a71..d77fe97 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java\n@@ -28,10 +29,14 @@\n \n import com.google.common.base.Strings;\n import com.google.common.collect.Iterators;\n+import com.google.common.math.LongMath;\n+\n import org.apache.jackrabbit.commons.iterator.AbstractLazyIterator;\n import org.apache.jackrabbit.oak.api.Tree;\n import org.apache.jackrabbit.oak.spi.security.ConfigurationParameters;\n import org.apache.jackrabbit.oak.spi.security.authorization.accesscontrol.AccessControlConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n class PermissionEntryProviderImpl implements PermissionEntryProvider {\n \n@@ -39,18 +44,31 @@\n \n     private static final long DEFAULT_SIZE = 250;\n \n+    private static final Logger log = LoggerFactory.getLogger(PermissionEntryProviderImpl.class);\n+\n+    /**\n+     * The set of principal names for which this {@code PermissionEntryProvider}\n+     * has been created.\n+     */\n     private final Set<String> principalNames;\n \n+    /**\n+     * The set of principal names for which the store contains any permission\n+     * entries. This set is equals or just a subset of the {@code principalNames}\n+     * defined above. The methods collecting the entries will shortcut in case\n+     * this set is empty and thus no permission entries exist for the specified\n+     * set of principal.\n+     */\n     private final Set<String> existingNames = new HashSet<String>();\n \n-    private Map<String, Collection<PermissionEntry>> pathEntryMap;\n-\n     private final PermissionStore store;\n \n     private final PermissionEntryCache cache;\n \n     private final long maxSize;\n \n+    private Map<String, Collection<PermissionEntry>> pathEntryMap;\n+\n     PermissionEntryProviderImpl(@Nonnull PermissionStore store, @Nonnull PermissionEntryCache cache,\n                                 @Nonnull Set<String> principalNames, @Nonnull ConfigurationParameters options) {\n         this.store = store;\n@@ -65,15 +83,40 @@ private void init() {\n         existingNames.clear();\n         for (String name : principalNames) {\n             long n = cache.getNumEntries(store, name, maxSize);\n-            cnt+= n;\n+            /*\n+            if cache.getNumEntries (n) returns a number bigger than 0, we\n+            remember this principal name int the 'existingNames' set\n+            */\n             if (n > 0) {\n                 existingNames.add(name);\n             }\n+            /*\n+            Calculate the total number of permission entries (cnt) defined for the\n+            given set of principals in order to be able to determine if the cache\n+            should be loaded upfront.\n+            Note however that cache.getNumEntries (n) may return Long.MAX_VALUE\n+            if the underlying implementation does not know the exact value, and\n+            the child node count is higher than maxSize (see OAK-2465).\n+            */                        \n+            if (cnt < Long.MAX_VALUE) {\n+                if (Long.MAX_VALUE == n) {\n+                    cnt = Long.MAX_VALUE;\n+                } else {\n+                    try {\n+                        cnt = LongMath.checkedAdd(cnt, n);\n+                    } catch (ArithmeticException ae) {\n+                        log.warn(\"Long overflow while calculate the total number of permission entries\");\n+                        cnt = Long.MAX_VALUE;\n+                    }\n                 }\n-        if (cnt < maxSize) {\n-            // cache all entries of all principals\n+            }\n+        }\n+\n+        if (cnt > 0 && cnt < maxSize) {\n+            // the total number of entries is smaller that maxSize, so we can\n+            // cache all entries for all principals having any entries right away\n             pathEntryMap = new HashMap<String, Collection<PermissionEntry>>();\n-            for (String name: principalNames) {\n+            for (String name : existingNames) {\n                 cache.load(store, pathEntryMap, name);\n             }\n         } else {\n", "nb_test": 1890, "linesAdd": 31, "jira_id": "2465", "singleLine": false, "nb_skipped": 9, "commit": "60186813", "nb_failure": 3, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testGetAllIdentifiers(org.apache.jackrabbit.oak.plugins.blob.datastore.OakFileDataStoreTest): expected:<[cdefgh, bcdefg, abcdef]> but was:<[cdefgh, c, abcdef, bcdefg]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/OakFileDataStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/OakFileDataStore.java\nindex a55d100..5e86881 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/OakFileDataStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/OakFileDataStore.java\n@@ -38,7 +38,6 @@\n import com.google.common.io.Closeables;\n import com.google.common.io.Files;\n \n-import org.apache.commons.io.FilenameUtils;\n import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.filefilter.FileFilterUtils;\n import org.apache.jackrabbit.core.data.DataIdentifier;\n@@ -50,6 +49,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.commons.io.FilenameUtils.normalizeNoEndSeparator;\n+\n /**\n  *  Oak specific extension of JR2 FileDataStore which enables\n  *  provisioning the signing key via OSGi config\n@@ -67,12 +68,13 @@ public OakFileDataStore() {\n \n     @Override\n     public Iterator<DataIdentifier> getAllIdentifiers() {\n-        final String path = FilenameUtils.normalizeNoEndSeparator(getPath());\n+        final String path = normalizeNoEndSeparator(getPath());\n         return Files.fileTreeTraverser().postOrderTraversal(new File(getPath()))\n                 .filter(new Predicate<File>() {\n                     @Override\n                     public boolean apply(File input) {\n-                        return input.isFile() && !input.getParent().equals(path);\n+                        return input.isFile() &&\n+                            !normalizeNoEndSeparator(input.getParent()).equals(path);\n                     }\n                 })\n                 .transform(new Function<File, DataIdentifier>() {\n", "nb_test": 2887, "linesAdd": 5, "jira_id": "4432", "singleLine": false, "nb_skipped": 1, "commit": "c9765c21", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAuthenticatePasswordExpiredAndInHistory(org.apache.jackrabbit.oak.security.user.PasswordExpiryHistoryTest): credentials should contain pw change failure reason expected:<New password was found in password history.> but was:<null>", "testAuthenticatePasswordExpiredAndSame(org.apache.jackrabbit.oak.security.user.PasswordExpiryHistoryTest): credentials should contain pw change failure reason expected:<New password is identical to the current password.> but was:<null>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserAuthentication.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserAuthentication.java\nindex f7b3b69..95fd76a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserAuthentication.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserAuthentication.java\n@@ -169,7 +169,7 @@ private boolean changePassword(User user, SimpleCredentials credentials) {\n                 }\n             }\n         } catch (PasswordHistoryException e) {\n-            credentials.setAttribute(e.getClass().getName(), e.getMessage());\n+            credentials.setAttribute(e.getClass().getSimpleName(), e.getMessage());\n             log.error(\"Failed to change password for user \" + userId, e.getMessage());\n         } catch (RepositoryException e) {\n             log.error(\"Failed to change password for user \" + userId, e.getMessage());\n", "nb_test": 3065, "linesAdd": 1, "jira_id": "3792", "singleLine": false, "nb_skipped": 1, "commit": "94110f21", "nb_failure": 2, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testInvalidJcrPaths(org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest): foo:bar]baz"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\nindex a257e69..9108966 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n@@ -256,6 +256,9 @@ private boolean needsFullMapping(String path) {\n             switch (path.charAt(i)) {\n                 case '{': // possibly an expanded name\n                 case '[': // possibly an index\n+                case ']': // illegal character if not part of index\n+                case '|': // illegal character\n+                case '*': // illegal character\n                     return true;\n                 case '.':\n                     if (i == slash + 1) {\n", "nb_test": 1720, "linesAdd": 3, "jira_id": "1168", "singleLine": false, "nb_skipped": 8, "commit": "c05cec12", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testListWithLotsOfReferences(org.apache.jackrabbit.oak.plugins.segment.RecordTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\nindex cc59163..fd6e50b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\n@@ -21,7 +21,7 @@\n \r\n class ListRecord extends Record {\r\n \r\n-    static final int LEVEL_SIZE = 1 << 8; // 256\r\n+    static final int LEVEL_SIZE = Segment.SEGMENT_REFERENCE_LIMIT;\r\n \r\n     private final int size;\r\n \r\n", "nb_test": 1444, "linesAdd": 1, "jira_id": "1184", "singleLine": false, "nb_skipped": 6, "commit": "f72dd8d1", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["simpleMove(org.apache.jackrabbit.oak.spi.state.MoveDetectorTest): Unexpected move. Expected: None Found: >/test/x:/test/x expected:<null> but was:</test/x>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex 75d6c45..31f6236 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -374,11 +374,9 @@ protected static void annotateSourcePath(NodeBuilder builder, String path) {\n         PropertyState base = builder.getBaseState().getProperty(MoveDetector.SOURCE_PATH);\n         PropertyState head = builder.getNodeState().getProperty(MoveDetector.SOURCE_PATH);\n         if (Objects.equal(base, head)) {\n-            if (!builder.hasProperty(MoveDetector.SOURCE_PATH)) {\n             builder.setProperty(MoveDetector.SOURCE_PATH, path);\n         }\n     }\n-    }\n \n     @Override\n     public boolean copyTo(NodeBuilder newParent, String newName) {\n", "nb_test": 1506, "linesAdd": 0, "jira_id": "1297", "singleLine": false, "nb_skipped": 6, "commit": "73cc2442", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["mergeInternalDocAcrossCluster(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): OakMerge0004: The node 1:/:dynHidden was changed in revision(..)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 2317b57..1004e06 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -37,6 +37,7 @@\n import com.google.common.base.Function;\n import com.google.common.base.Predicate;\n import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterators;\n import com.google.common.collect.Queues;\n import org.apache.jackrabbit.oak.cache.CacheValue;\n@@ -57,7 +58,6 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.transform;\n-import static java.util.Collections.reverseOrder;\n import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;\n import static org.apache.jackrabbit.oak.plugins.document.StableRevisionComparator.REVERSE;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;\n@@ -737,11 +737,11 @@ public boolean apply(Revision input) {\n \n         Revision newestRev = null;\n         // check local commits first\n-        Comparator<Revision> comp = reverseOrder(context.getRevisionComparator());\n-        SortedSet<Revision> revisions = Sets.newTreeSet(comp);\n-        revisions.addAll(getLocalRevisions().keySet());\n-        revisions.addAll(getLocalCommitRoot().keySet());\n-        Iterator<Revision> it = filter(revisions, predicate).iterator();\n+        SortedMap<Revision, String> revisions = getLocalRevisions();\n+        SortedMap<Revision, String> commitRoots = getLocalCommitRoot();\n+        Iterator<Revision> it = filter(Iterables.mergeSorted(\n+                ImmutableList.of(revisions.keySet(), commitRoots.keySet()),\n+                revisions.comparator()), predicate).iterator();\n         if (it.hasNext()) {\n             newestRev = it.next();\n         } else {\n", "nb_test": 2427, "linesAdd": 6, "jira_id": "3411", "singleLine": false, "nb_skipped": 1, "commit": "978c77ff", "nb_failure": 0, "linesRem": 6}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["verifyVersionHistory(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): OAK-1789 expected:<[e029df41-62f5-4ab8-9251-3288131460ce]> but was:<[ffec28b7-3e34-428e-8b30-6aea10b2a989/child]>"], "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\nindex 3752b91..fded86c 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n@@ -332,13 +332,15 @@ private void fixFrozenUuid() {\n             }\n \n             if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\n+                String parentFrozenUuid = parent.getString(JCR_FROZENUUID);\n+                if (parentFrozenUuid != null) {\n                     frozenUuid = PropertyStates.createProperty(\n-                        JCR_FROZENUUID,\n-                        parent.getString(JCR_FROZENUUID) + \"/\" + name);\n+                            JCR_FROZENUUID, parentFrozenUuid + \"/\" + name);\n                     properties.put(JCR_FROZENUUID, frozenUuid);\n                 }\n             }\n         }\n+    }\n \n     private org.apache.jackrabbit.oak.api.PropertyState createProperty(\n             String name, int type, InternalValue value)\ndiff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex 5dff050..ce8b019 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -238,7 +238,8 @@ public void copy(RepositoryInitializer initializer) throws RepositoryException {\n         logger.info(\n                 \"Copying repository content from {} to Oak\", config.getHomeDir());\n         try {\n-            NodeBuilder builder = target.getRoot().builder();\n+            NodeState base = target.getRoot();\n+            NodeBuilder builder = base.builder();\n \n             String workspace =\n                     source.getRepositoryConfig().getDefaultWorkspaceName();\n@@ -260,6 +261,11 @@ public void copy(RepositoryInitializer initializer) throws RepositoryException {\n             copyNodeTypes(builder, uriToPrefix.inverse());\n             copyPrivileges(builder);\n \n+            // Triggers compilation of type information, which we need for\n+            // the type predicates used by the bulk  copy operations below.\n+            new TypeEditorProvider(false).getRootEditor(\n+                    base, builder.getNodeState(), builder, null);\n+\n             NodeState root = builder.getNodeState();\n             copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\n             copyWorkspace(builder, root, workspace, uriToPrefix, idxToPrefix);\n", "nb_test": 14, "linesAdd": 9, "jira_id": "1789", "singleLine": false, "nb_skipped": 0, "commit": "07646fba", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["xpath(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/xpath.txt don't match expected results in src/test/resources/xpath.txt; compare the files for details", "xpath(org.apache.jackrabbit.oak.plugins.index.property.OrderedIndexQueryTest): Results in target/xpath.txt don't match expected results in src/test/resources/xpath.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\nindex af95c65..fb046c5 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n@@ -497,8 +497,14 @@ private Expression parseExpression() throws ParseException {\n         if (readIf(\"@\")) {\n             return readProperty();\n         } else if (readIf(\"true\")) {\n+            if (readIf(\"(\")) {\n+                read(\")\");\n+            }\n             return Expression.Literal.newBoolean(true);\n         } else if (readIf(\"false\")) {\n+            if (readIf(\"(\")) {\n+                read(\")\");\n+            }\n             return Expression.Literal.newBoolean(false);\n         } else if (currentTokenType == VALUE_NUMBER) {\n             Expression.Literal l = Expression.Literal.newNumber(currentToken);\n", "nb_test": 2233, "linesAdd": 6, "jira_id": "2864", "singleLine": false, "nb_skipped": 1, "commit": "f51ea2a2", "nb_failure": 0, "linesRem": 0}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["move2(org.apache.jackrabbit.oak.core.RootImplTest): expected:<[y]> but was:<[]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\nindex 9631cbe..d20d820 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n@@ -21,6 +21,7 @@\n import org.apache.jackrabbit.oak.api.CoreValue;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Tree;\n+import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n import org.apache.jackrabbit.oak.spi.state.NodeStateBuilder;\n@@ -29,8 +30,10 @@\n import org.apache.jackrabbit.oak.util.Function1;\n import org.apache.jackrabbit.oak.util.Iterators;\n \n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * Implementation of tree based on {@link NodeStateBuilder}s. Each subtree\n@@ -42,43 +45,46 @@\n     /** Underlying store */\n     private final NodeStore store;\n \n+    private final NodeStateBuilder rootBuilder;\n+\n     /**\n      * Underlying persistent state or {@code null} if this instance represents an\n      * added tree\n      */\n     private final NodeState baseState;\n \n-    private final NodeStateBuilder builder;\n-\n     /** Listener for changes on this tree */\n     private final Listener listener;\n \n+    /** Parent of this tree */\n+    private TreeImpl parent;\n+\n     /** Name of this tree */\n     private String name;\n \n-    /** Parent of this tree */\n-    private TreeImpl parent;\n+    // FIXME: should be synchronized, and weak refs\n+    private final Map<String, TreeImpl> children = new HashMap<String, TreeImpl>();\n \n-    private TreeImpl(NodeStore store, NodeState baseState, NodeStateBuilder builder,\n+    private TreeImpl(NodeStore store, NodeState baseState, NodeStateBuilder rootBuilder,\n             TreeImpl parent, String name, Listener listener) {\n \n         this.store = store;\n-        this.builder = builder;\n+        this.rootBuilder = rootBuilder;\n         this.baseState = baseState;\n         this.listener = listener;\n-        this.name = name;\n         this.parent = parent;\n+        this.name = name;\n     }\n \n     /**\n      * Create a new instance which represents the root of a tree.\n      * @param store  underlying store to the tree\n-     * @param nodeStateBuilder  builder for the root\n+     * @param rootBuilder  builder for the root\n      * @param listener  change listener for the tree. May be {@code null} if\n      *                  listening to changes is not needed.\n      */\n-    TreeImpl(NodeStore store, NodeStateBuilder nodeStateBuilder, Listener listener) {\n-        this(store, nodeStateBuilder.getNodeState(), nodeStateBuilder, null, \"\", listener);\n+    TreeImpl(NodeStore store, NodeStateBuilder rootBuilder, Listener listener) {\n+        this(store, rootBuilder.getNodeState(), rootBuilder, null, \"\", listener);\n     }\n \n     /**\n@@ -147,15 +153,14 @@ public String getName() {\n \n     @Override\n     public String getPath() {\n+        // Shortcut for root\n         if (parent == null) {\n-            return name;\n-        }\n-        else {\n-            String path = parent.getPath();\n-            return path.isEmpty()\n-                    ? name\n-                    : path + '/' + name;\n+            return \"\";\n         }\n+\n+        StringBuilder sb = new StringBuilder();\n+        buildPath(sb);\n+        return sb.toString();\n     }\n \n     @Override\n@@ -233,17 +238,22 @@ public long getPropertyCount() {\n \n     @Override\n     public TreeImpl getChild(String name) {\n-        NodeStateBuilder childBuilder = builder.getChildBuilder(name);\n-        if (childBuilder == null) {\n+        TreeImpl child = children.get(name);\n+        if (child != null) {\n+            return child;\n+        }\n+\n+        if (!hasChild(name)) {\n             return null;\n         }\n-        else {\n+\n         NodeState childBaseState = baseState == null\n                 ? null\n                 : baseState.getChildNode(name);\n \n-            return new TreeImpl(store, childBaseState, childBuilder, this, name, listener);\n-        }\n+        child = new TreeImpl(store, childBaseState, rootBuilder, this, name, listener);\n+        children.put(name, child);\n+        return child;\n     }\n \n     @Override\n@@ -307,14 +317,24 @@ public long getChildrenCount() {\n         return new Iterable<Tree>() {\n             @Override\n             public Iterator<Tree> iterator() {\n+                final NodeState nodeState = getNodeState();\n+\n                 Iterator<? extends ChildNodeEntry> childEntries =\n-                        getNodeState().getChildNodeEntries().iterator();\n+                        nodeState.getChildNodeEntries().iterator();\n \n                 return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {\n                     @Override\n                     public Tree apply(ChildNodeEntry entry) {\n-                        NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());\n-                        return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);\n+                        String childName = entry.getName();\n+                        TreeImpl child = children.get(entry.getName());\n+                        if (child != null) {\n+                            return child;\n+                        }\n+\n+                        NodeState childNodeState = nodeState.getChildNode(childName);\n+                        child = new TreeImpl(store, childNodeState, rootBuilder, TreeImpl.this, childName, listener);\n+                        children.put(childName, child);\n+                        return child;\n                     }\n                 });\n             }\n@@ -323,24 +343,27 @@ public Tree apply(ChildNodeEntry entry) {\n \n     @Override\n     public Tree addChild(String name) {\n-        if (builder.addNode(name) != null) {\n+        if (getBuilder().addNode(name) != null) {\n             listener.addChild(this, name);\n         }\n-        return getChild(name);\n+        TreeImpl child = getChild(name);\n+        children.put(name, child);\n+        return child;\n     }\n \n     @Override\n     public boolean removeChild(String name) {\n-        boolean result = builder.removeNode(name);\n+        boolean result = getBuilder().removeNode(name);\n         if (result) {\n             listener.removeChild(this, name);\n+            children.remove(name);\n         }\n         return result;\n     }\n \n     @Override\n     public PropertyState setProperty(String name, CoreValue value) {\n-        PropertyState property = builder.setProperty(name, value);\n+        PropertyState property = getBuilder().setProperty(name, value);\n         if (listener != null) {\n             listener.setProperty(this, name, value);\n         }\n@@ -349,7 +372,7 @@ public PropertyState setProperty(String name, CoreValue value) {\n \n     @Override\n     public PropertyState setProperty(String name, List<CoreValue> values) {\n-        PropertyState property = builder.setProperty(name, values);\n+        PropertyState property = getBuilder().setProperty(name, values);\n         if (listener != null) {\n             listener.setProperty(this, name, values);\n         }\n@@ -358,7 +381,7 @@ public PropertyState setProperty(String name, List<CoreValue> values) {\n \n     @Override\n     public void removeProperty(String name) {\n-        builder.removeProperty(name);\n+        getBuilder().removeProperty(name);\n         if (listener != null) {\n             listener.removeProperty(this, name);\n         }\n@@ -374,8 +397,13 @@ public void removeProperty(String name) {\n      * when {@code destName} already exists at {@code destParent}\n      */\n     public boolean move(TreeImpl destParent, String destName) {\n-        boolean result = builder.moveTo(destParent.builder, destName);\n+        NodeStateBuilder builder = getBuilder();\n+        NodeStateBuilder destParentBuilder = destParent.getBuilder();\n+        boolean result = builder.moveTo(destParentBuilder, destName);\n         if (result) {\n+            parent.children.remove(name);\n+            destParent.children.put(destName, this);\n+\n             TreeImpl oldParent = parent;\n             String oldName = name;\n \n@@ -398,7 +426,7 @@ public boolean move(TreeImpl destParent, String destName) {\n      * when {@code destName} already exists at {@code destParent}\n      */\n     public boolean copy(TreeImpl destParent, String destName) {\n-        boolean result = builder.copyTo(destParent.builder, destName);\n+        boolean result = getBuilder().copyTo(destParent.getBuilder(), destName);\n         if (result) {\n             if (listener != null) {\n                 listener.copy(parent, name, destParent.getChild(destName));\n@@ -410,8 +438,30 @@ public boolean copy(TreeImpl destParent, String destName) {\n \n     //------------------------------------------------------------< private >---\n \n+    private void buildPath(StringBuilder sb) {\n+        if (parent != null) {\n+            parent.buildPath(sb);\n+            if (sb.length() > 0) {\n+                sb.append('/');\n+            }\n+            sb.append(name);\n+        }\n+    }\n+\n+    private NodeStateBuilder getBuilder() {\n+        NodeStateBuilder builder = rootBuilder;\n+        for (String name : PathUtils.elements(getPath())) {\n+            builder = builder.getChildBuilder(name);\n+            if (builder == null) {\n+                throw new IllegalStateException(\"Stale NodeStateBuilder for \" + getPath());\n+            }\n+        }\n+\n+        return builder;\n+    }\n+\n     private NodeState getNodeState() {\n-        return builder.getNodeState();\n+        return getBuilder().getNodeState();\n     }\n \n     private boolean isSame(NodeState state1, NodeState state2) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStateBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStateBuilder.java\nindex d35d82e..5c477f8 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStateBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStateBuilder.java\n@@ -28,27 +28,28 @@\n public class KernelNodeStateBuilder implements NodeStateBuilder {\n     private final NodeStateBuilderContext context;\n \n-    private String path;\n+    private KernelNodeStateBuilder parent;\n+    private String name;\n \n-    private KernelNodeStateBuilder(NodeStateBuilderContext context, String path) {\n+    private KernelNodeStateBuilder(NodeStateBuilderContext context, KernelNodeStateBuilder parent, String name) {\n         this.context = context;\n-        this.path = path;\n+        this.parent = parent;\n+        this.name = name;\n     }\n \n     public static NodeStateBuilder create(NodeStateBuilderContext context) {\n-        return new KernelNodeStateBuilder(context, \"\");\n+        return new KernelNodeStateBuilder(context, null, \"\");\n     }\n \n-\n     @Override\n     public NodeState getNodeState() {\n-        return context.getNodeState(path);\n+        return context.getNodeState(getPath());\n     }\n \n     @Override\n     public NodeStateBuilder getChildBuilder(String name) {\n         return hasChild(name)\n-            ? new KernelNodeStateBuilder(context, PathUtils.concat(path, name))\n+            ? new KernelNodeStateBuilder(context, this, name)\n             : null;\n     }\n \n@@ -58,9 +59,9 @@ public NodeStateBuilder addNode(String name, NodeState nodeState) {\n             return null;\n         }\n         else {\n-            String targetPath = PathUtils.concat(path, name);\n+            String targetPath = PathUtils.concat(getPath(), name);\n             context.addNode(nodeState, targetPath);\n-            return new KernelNodeStateBuilder(context, targetPath);\n+            return new KernelNodeStateBuilder(context, this, name);\n         }\n     }\n \n@@ -70,16 +71,16 @@ public NodeStateBuilder addNode(String name) {\n             return null;\n         }\n         else {\n-            String targetPath = PathUtils.concat(path, name);\n+            String targetPath = PathUtils.concat(getPath(), name);\n             context.addNode(targetPath);\n-            return new KernelNodeStateBuilder(context, targetPath);\n+            return new KernelNodeStateBuilder(context, this, name);\n         }\n     }\n \n     @Override\n     public boolean removeNode(String name) {\n         if (hasChild(name)) {\n-            context.removeNode(PathUtils.concat(path, name));\n+            context.removeNode(PathUtils.concat(getPath(), name));\n             return true;\n         }\n         else {\n@@ -91,10 +92,10 @@ public boolean removeNode(String name) {\n     public PropertyState setProperty(String name, CoreValue value) {\n         PropertyState property = new PropertyStateImpl(name, value);\n         if (hasProperty(name)) {\n-            context.setProperty(property, path);\n+            context.setProperty(property, getPath());\n         }\n         else {\n-            context.addProperty(property, path);\n+            context.addProperty(property, getPath());\n         }\n         return property;\n     }\n@@ -103,10 +104,10 @@ public PropertyState setProperty(String name, CoreValue value) {\n     public PropertyState setProperty(String name, List<CoreValue> values) {\n         PropertyState property = new PropertyStateImpl(name, values);\n         if (hasProperty(name)) {\n-            context.setProperty(property, path);\n+            context.setProperty(property, getPath());\n         }\n         else {\n-            context.addProperty(property, path);\n+            context.addProperty(property, getPath());\n         }\n         return property;\n     }\n@@ -114,7 +115,7 @@ public PropertyState setProperty(String name, List<CoreValue> values) {\n     @Override\n     public void removeProperty(String name) {\n         if (hasProperty(name)) {\n-            context.removeProperty(PathUtils.concat(path, name));\n+            context.removeProperty(PathUtils.concat(getPath(), name));\n         }\n     }\n \n@@ -129,10 +130,13 @@ public boolean moveTo(NodeStateBuilder destParent, String destName) {\n         }\n \n         KernelNodeStateBuilder destParentBuilder = (KernelNodeStateBuilder) destParent;\n-        String destPath = PathUtils.concat(destParentBuilder.path, destName);\n+        String destPath = PathUtils.concat(destParentBuilder.getPath(), destName);\n+\n+        context.moveNode(getPath(), destPath);\n+\n+        name = destName;\n+        parent = destParentBuilder;\n \n-        context.moveNode(path, destPath);\n-        path = destPath;\n         return true;\n     }\n \n@@ -147,9 +151,9 @@ public boolean copyTo(NodeStateBuilder destParent, String destName) {\n         }\n \n         KernelNodeStateBuilder destParentBuilder = (KernelNodeStateBuilder) destParent;\n-        String destPath = PathUtils.concat(destParentBuilder.path, destName);\n+        String destPath = PathUtils.concat(destParentBuilder.getPath(), destName);\n \n-        context.copyNode(path, destPath);\n+        context.copyNode(getPath(), destPath);\n         return true;\n     }\n \n@@ -161,6 +165,27 @@ NodeStateBuilderContext getContext() {\n \n     //------------------------------------------------------------< private >---\n \n+    private String getPath() {\n+        // Shortcut for root\n+        if (parent == null) {\n+            return \"\";\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        buildPath(sb);\n+        return sb.toString();\n+    }\n+\n+    private void buildPath(StringBuilder sb) {\n+        if (parent != null) {\n+            parent.buildPath(sb);\n+            if (sb.length() > 0) {\n+                sb.append('/');\n+            }\n+            sb.append(name);\n+        }\n+    }\n+\n     private boolean hasChild(String name) {\n         return getNodeState().getChildNode(name) != null;\n     }\n", "nb_test": 151, "linesAdd": 126, "jira_id": "93", "singleLine": false, "nb_skipped": 1, "commit": "0be7e8f0", "nb_failure": 1, "linesRem": 54}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["keyEquals(org.apache.jackrabbit.oak.plugins.document.UpdateOpTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\nindex b957c37..707149d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n@@ -368,7 +368,7 @@ public boolean equals(Object obj) {\n             if (obj instanceof Key) {\n                 Key other = (Key) obj;\n                 return name.equals(other.name) &&\n-                        revision != null ? revision.equals(other.revision) : other.revision == null;\n+                        (revision != null ? revision.equals(other.revision) : other.revision == null);\n             }\n             return false;\n         }\n", "nb_test": 1868, "linesAdd": 1, "jira_id": "2435", "singleLine": false, "nb_skipped": 9, "commit": "7e250001", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["removeRecentKey[0](org.apache.jackrabbit.oak.plugins.segment.CompactionMapTest): Compaction map must not contain removed key"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/PersistedCompactionMap.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/PersistedCompactionMap.java\nindex ae5c14b..51a065b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/PersistedCompactionMap.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/PersistedCompactionMap.java\n@@ -229,9 +229,9 @@ private void compress(@Nonnull Set<UUID> removed) {\n                     \", baseId=\" + previousBaseId + '}';\n             writer.writeString(mapInfo);\n             writer.flush();\n-            recent.clear();\n         }\n \n+        recent.clear();\n         if (recordCount == 0) {\n             entries = null;\n         }\n", "nb_test": 2656, "linesAdd": 1, "jira_id": "3511", "singleLine": false, "nb_skipped": 1, "commit": "5138a1e2", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["deleteParentLast(org.apache.jackrabbit.oak.plugins.document.VersionGCDeletionTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\nindex 2f816d1..9b12714 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n@@ -20,6 +20,7 @@\n package org.apache.jackrabbit.oak.plugins.document;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.EnumSet;\n import java.util.List;\n import java.util.Set;\n@@ -109,6 +110,8 @@ private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision\n             Utils.closeIfCloseable(itr);\n         }\n \n+        Collections.sort(docIdsToDelete, PathComparator.INSTANCE);\n+\n         if(log.isDebugEnabled()) {\n             StringBuilder sb = new StringBuilder(\"Deleted document with following ids were deleted as part of GC \\n\");\n             Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);\n", "nb_test": 1999, "linesAdd": 3, "jira_id": "2603", "singleLine": false, "nb_skipped": 9, "commit": "77d2d3b0", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["removeNew(org.apache.jackrabbit.oak.core.TreeImplTest): expected:<DISCONNECTED> but was:<NEW>", "moveNew(org.apache.jackrabbit.oak.core.RootImplTest): expected:<DISCONNECTED> but was:<NEW>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\nindex 3cbd5b8..ac0353a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n@@ -58,6 +58,11 @@\n     private final RootImpl root;\n \n     /**\n+     * The {@code NodeBuilder} for the underlying node state\n+     */\n+    private final NodeBuilder nodeBuilder;\n+\n+    /**\n      * Parent of this tree. Null for the root.\n      */\n     private TreeImpl parent;\n@@ -67,32 +72,26 @@\n      */\n     private String name;\n \n-    /**\n-     * Lazily initialised {@code NodeBuilder} for the underlying node state\n-     */\n-    NodeBuilder nodeBuilder;\n+    private TreeImpl(RootImpl root) {\n+        this.root = checkNotNull(root);\n+        this.name = \"\";\n+        this.nodeBuilder = root.createRootBuilder();\n+    }\n \n     private TreeImpl(RootImpl root, TreeImpl parent, String name) {\n         this.root = checkNotNull(root);\n-        this.parent = parent;\n+        this.parent = checkNotNull(parent);\n         this.name = checkNotNull(name);\n+        this.nodeBuilder = parent.getNodeBuilder().child(name);\n     }\n \n     @Nonnull\n     static TreeImpl createRoot(final RootImpl root) {\n-        return new TreeImpl(root, null, \"\") {\n+        return new TreeImpl(root) {\n             @Override\n             protected NodeState getBaseState() {\n                 return root.getBaseState();\n             }\n-\n-            @Override\n-            protected synchronized NodeBuilder getNodeBuilder() {\n-                if (nodeBuilder == null) {\n-                    nodeBuilder = root.createRootBuilder();\n-                }\n-                return nodeBuilder;\n-            }\n         };\n     }\n \n@@ -189,7 +188,7 @@ public long getPropertyCount() {\n     @Override\n     public Iterable<? extends PropertyState> getProperties() {\n         root.checkLive();\n-        return Iterables.filter(getNodeBuilder().getProperties(),\n+        return Iterables.filter(nodeBuilder.getProperties(),\n                 new Predicate<PropertyState>() {\n                     @Override\n                     public boolean apply(PropertyState propertyState) {\n@@ -219,7 +218,7 @@ private boolean isDisconnected() {\n         if (!parent.nodeBuilder.isConnected()) {\n             return true;\n         }\n-        return !getNodeBuilder().isConnected();\n+        return !nodeBuilder.isConnected();\n     }\n \n     @Override\n@@ -230,7 +229,7 @@ public Status getStatus() {\n             return Status.DISCONNECTED;\n         }\n \n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         if (builder.isNew()) {\n             return Status.NEW;\n         } else if (builder.isModified()) {\n@@ -250,7 +249,7 @@ public boolean hasChild(String name) {\n     public long getChildrenCount() {\n         // TODO: make sure cnt respects access control\n         root.checkLive();\n-        return getNodeBuilder().getChildNodeCount();\n+        return nodeBuilder.getChildNodeCount();\n     }\n \n     @Override\n@@ -260,7 +259,7 @@ public long getChildrenCount() {\n         if (hasOrderableChildren()) {\n             childNames = getOrderedChildNames();\n         } else {\n-            childNames = getNodeBuilder().getChildNodeNames();\n+            childNames = nodeBuilder.getChildNodeNames();\n         }\n         return Iterables.filter(Iterables.transform(\n                 childNames,\n@@ -282,9 +281,9 @@ public boolean apply(Tree tree) {\n     public Tree addChild(String name) {\n         root.checkLive();\n         if (!hasChild(name)) {\n-            getNodeBuilder().child(name);\n+            nodeBuilder.child(name);\n             if (hasOrderableChildren()) {\n-                getNodeBuilder().setProperty(\n+                nodeBuilder.setProperty(\n                         MemoryPropertyBuilder.copy(Type.STRING, internalGetProperty(OAK_CHILD_ORDER))\n                                 .addValue(name)\n                                 .getPropertyState());\n@@ -292,8 +291,10 @@ public Tree addChild(String name) {\n             root.updated();\n         }\n \n-        TreeImpl child = getChild(name);\n-        assert child != null;\n+        TreeImpl child = new TreeImpl(root, this, name);\n+\n+        // Make sure to allocate the node builder for new nodes in order to correctly\n+        // track removes and moves. See OAK-621\n         return child;\n     }\n \n@@ -305,7 +306,7 @@ public boolean remove() {\n         }\n \n         if (!isRoot() && parent.hasChild(name)) {\n-            NodeBuilder builder = parent.getNodeBuilder();\n+            NodeBuilder builder = parent.nodeBuilder;\n             builder.removeNode(name);\n             if (parent.hasOrderableChildren()) {\n                 builder.setProperty(\n@@ -360,7 +361,7 @@ public boolean apply(@Nullable String input) {\n             tail = Iterables.skip(filtered, idx);\n         }\n         // concatenate head, this name and tail\n-        parent.getNodeBuilder().setProperty(MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, Iterables.concat(head, Collections.singleton(getName()), tail))\n+        parent.nodeBuilder.setProperty(MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, Iterables.concat(head, Collections.singleton(getName()), tail))\n         );\n         root.updated();\n         return true;\n@@ -369,7 +370,7 @@ public boolean apply(@Nullable String input) {\n     @Override\n     public void setProperty(PropertyState property) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.setProperty(property);\n         root.updated();\n     }\n@@ -377,7 +378,7 @@ public void setProperty(PropertyState property) {\n     @Override\n     public <T> void setProperty(String name, T value) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.setProperty(name, value);\n         root.updated();\n     }\n@@ -385,7 +386,7 @@ public void setProperty(PropertyState property) {\n     @Override\n     public <T> void setProperty(String name, T value, Type<T> type) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.setProperty(name, value, type);\n         root.updated();\n     }\n@@ -393,7 +394,7 @@ public void setProperty(PropertyState property) {\n     @Override\n     public void removeProperty(String name) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.removeProperty(name);\n         root.updated();\n     }\n@@ -418,16 +419,13 @@ protected NodeState getBaseState() {\n                 : parentBaseState.getChildNode(name);\n     }\n \n+    //-----------------------------------------------------------< internal >---\n+\n     @Nonnull\n-    protected synchronized NodeBuilder getNodeBuilder() {\n-        if (nodeBuilder == null) {\n-            nodeBuilder = parent.getNodeBuilder().child(name);\n-        }\n+    NodeBuilder getNodeBuilder() {\n         return nodeBuilder;\n     }\n \n-    //-----------------------------------------------------------< internal >---\n-\n     /**\n      * Move this tree to the parent at {@code destParent} with the new name\n      * {@code destName}.\n@@ -446,7 +444,7 @@ void moveTo(TreeImpl destParent, String destName) {\n \n     @Nonnull\n     NodeState getNodeState() {\n-        return getNodeBuilder().getNodeState();\n+        return nodeBuilder.getNodeState();\n     }\n \n     /**\n@@ -480,29 +478,29 @@ void updateChildOrder() {\n         }\n         Set<String> names = Sets.newLinkedHashSet();\n         for (String name : getOrderedChildNames()) {\n-            if (getNodeBuilder().hasChildNode(name)) {\n+            if (nodeBuilder.hasChildNode(name)) {\n                 names.add(name);\n             }\n         }\n-        for (String name : getNodeBuilder().getChildNodeNames()) {\n+        for (String name : nodeBuilder.getChildNodeNames()) {\n             names.add(name);\n         }\n         PropertyBuilder<String> builder = MemoryPropertyBuilder.array(\n                 Type.STRING, OAK_CHILD_ORDER);\n         builder.setValues(names);\n-        getNodeBuilder().setProperty(builder.getPropertyState());\n+        nodeBuilder.setProperty(builder.getPropertyState());\n     }\n \n     //------------------------------------------------------------< private >---\n \n     private TreeImpl internalGetChild(String childName) {\n-        return getNodeBuilder().hasChildNode(childName)\n+        return nodeBuilder.hasChildNode(childName)\n                 ? new TreeImpl(root, this, childName)\n                 : null;\n     }\n \n     private PropertyState internalGetProperty(String propertyName) {\n-        return getNodeBuilder().getProperty(propertyName);\n+        return nodeBuilder.getProperty(propertyName);\n     }\n \n     private void buildPath(StringBuilder sb) {\n@@ -574,10 +572,10 @@ public void remove() {\n      * of the children as returned by {@link NodeBuilder#getChildNodeNames()}.\n      */\n     public void ensureChildOrderProperty() {\n-        PropertyState childOrder = getNodeBuilder().getProperty(OAK_CHILD_ORDER);\n+        PropertyState childOrder = nodeBuilder.getProperty(OAK_CHILD_ORDER);\n         if (childOrder == null) {\n-            getNodeBuilder().setProperty(\n-                    MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, getNodeBuilder().getChildNodeNames()));\n+            nodeBuilder.setProperty(\n+                    MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, nodeBuilder.getChildNodeNames()));\n         }\n     }\n \n", "nb_test": 619, "linesAdd": 36, "jira_id": "621", "singleLine": false, "nb_skipped": 8, "commit": "00b4b8a0", "nb_failure": 2, "linesRem": 40}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["getNext(org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest): the highest available lane is expected expected:<[]> but was:<[d]>", "setNext(org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest): expected:<[foobar]> but was:<[foobar, , , ]>", "firstAndOnlyItem(org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest): n0 should point nowhere as it's the last (and only) element expected:<0> but was:<4>", "first2newKeysAlreadyOrdered(org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest): n0 should point nowhere at this stage expected:<0> but was:<4>", "fourShuffledElements(org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest): n0 should still be the last item of the list expected:<0> but was:<4>", "insertWithLanes1Item(org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest): :start's :next should always point to the first element expected:<[000]> but was:<[000, , , ]>", "laneInsert2ItemsAlreadyOrdere(org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest): expected:<[000]> but was:<[000, , , ]>", "insertShuffledItemsWithLanes(org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest): expected:<[006]> but was:<[006, , , ]>", "prune(org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest): expected:<[000]> but was:<[000, , , ]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java\nindex ba92511..96f4cd3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java\n@@ -136,12 +136,12 @@ public static boolean isAscending(NodeState indexMeta) {\n      *  <dt>lane 3:</dt> <dd>0.1%</dd>\n      * </dl>\n      */\n-    double DEFAULT_PROBABILITY = 0.1;\n+    double DEFAULT_PROBABILITY = Integer.getInteger(\"oak.orderedIndex.prob\", 3) / 10.0;\n     \n     /**\n      * the number of lanes used in the SkipList \n      */\n-    int LANES = 4;\n+    int LANES = Integer.getInteger(\"oak.orderedIndex.lanes\", 15);\n     \n     /**\n      * Convenience Predicate that will force the implementor to expose what we're searching for\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\nindex e039c0d..ce158a2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n@@ -23,6 +23,7 @@\n \n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Deque;\n import java.util.Iterator;\n@@ -51,7 +52,6 @@\n \n import com.google.common.base.Charsets;\n import com.google.common.base.Strings;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n \n@@ -867,10 +867,13 @@ String seek(@Nonnull final NodeBuilder index,\n             LOG.debug(\"seek() - plain case\");\n             \n             lane = OrderedIndex.LANES - 1;\n-            \n+            NodeBuilder currentNode = null;\n             do {\n                 stillLaning = lane > 0;\n-                nextkey = getPropertyNext(index.getChildNode(currentKey), lane);\n+                if (currentNode == null) {\n+                    currentNode = index.getChildNode(currentKey);\n+                }\n+                nextkey = getPropertyNext(currentNode, lane);\n                 if ((Strings.isNullOrEmpty(nextkey) || !walkingPredicate.apply(nextkey)) && lane > 0) {\n                     // if we're currently pointing to NIL or the next element does not fit the search\n                     // but we still have lanes left, let's lower the lane;\n@@ -880,6 +883,7 @@ String seek(@Nonnull final NodeBuilder index,\n                         found = nextkey;\n                     } else {\n                         currentKey = nextkey;\n+                        currentNode = null;\n                         if (keepWalked && !Strings.isNullOrEmpty(currentKey)) {\n                             for (int l = lane; l >= 0; l--) {\n                                 walkedLanes[l] = currentKey;\n@@ -1072,12 +1076,18 @@ public boolean hasNext() {\n      */\n     static void setPropertyNext(@Nonnull final NodeBuilder node, final String... next) {\n         if (node != null && next != null) {\n-            String n1 = (next.length > 0) ? next[0] : \"\";\n-            String n2 = (next.length > 1) ? next[1] : \"\";\n-            String n3 = (next.length > 2) ? next[2] : \"\";\n-            String n4 = (next.length > 3) ? next[3] : \"\";\n-            \n-            node.setProperty(NEXT, ImmutableList.of(n1, n2, n3, n4), Type.STRINGS);\n+            int len = next.length - 1;\n+            for (; len >= 0; len--) {\n+                if (next[len].length() != 0) {\n+               \t    break;\n+                }\n+            }\n+            len++;\n+            List<String> list = new ArrayList<String>(len);\n+            for (int i = 0; i < len; i++) {\n+                list.add(next[i]);\n+            }\n+            node.setProperty(NEXT, list, Type.STRINGS);\n         }\n     }\n     \n@@ -1102,7 +1112,7 @@ static void setPropertyNext(@Nonnull final NodeBuilder node,\n                         // content\n                         LOG.debug(\"topping-up the number of lanes.\");\n                         List<String> vv = Lists.newArrayList(values);\n-                        for (int i = vv.size(); i <= OrderedIndex.LANES; i++) {\n+                        for (int i = vv.size(); i < OrderedIndex.LANES; i++) {\n                             vv.add(\"\");\n                         }\n                         values = vv.toArray(new String[vv.size()]);\n@@ -1151,7 +1161,10 @@ static String getPropertyNext(@Nonnull final NodeBuilder node, final int lane) {\n         PropertyState ps = node.getProperty(NEXT);\n         if (ps != null) {\n             if (ps.isArray()) {\n-                next = ps.getValue(Type.STRING, Math.min(ps.count() - 1, lane));\n+                int count = ps.count();\n+                if (count > 0 && count > lane) {\n+                    next = ps.getValue(Type.STRING, lane);\n+                }\n             } else {\n                 next = ps.getValue(Type.STRING);\n             }\n", "nb_test": 1932, "linesAdd": 26, "jira_id": "2147", "singleLine": false, "nb_skipped": 1, "commit": "a1556c30", "nb_failure": 9, "linesRem": 13}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAddNode(org.apache.jackrabbit.oak.jcr.OrderableNodesTest): expected:<[a]> but was:<[b]>", "setPrimaryType(org.apache.jackrabbit.oak.jcr.OrderableNodesTest): expected:<[node-24, node-92, node-28, node-19, node-75, node-8, node-55, node-38, node-36]> but was:<[node-75, node-8, node-38, node-24, node-19, node-92, node-28, node-36, node-55]>", "orderableFolder(org.apache.jackrabbit.oak.jcr.OrderableNodesTest): expected:<[a]> but was:<[b]>", "testSimpleOrdering(org.apache.jackrabbit.oak.jcr.OrderableNodesTest): expected:<[a]> but was:<[b]>"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex 79e0eb3..c84f625 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -274,6 +274,10 @@ public Node perform() throws RepositoryException {\n                     throw new ItemExistsException();\n                 }\n \n+                if (getPrimaryNodeType().hasOrderableChildNodes()) {\n+                    dlg.orderBefore(oakName, null);\n+                }\n+\n                 NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\n                 childNode.internalSetPrimaryType(ntName);\n                 childNode.autoCreateItems();\n@@ -1431,6 +1435,18 @@ public Void perform() throws RepositoryException {\n                 String jcrPrimaryType = sessionDelegate.getOakPath(Property.JCR_PRIMARY_TYPE);\n                 Value value = sessionDelegate.getValueFactory().createValue(nodeTypeName, PropertyType.NAME);\n                 dlg.setProperty(jcrPrimaryType, value);\n+\n+                if (nt.hasOrderableChildNodes()) {\n+                    // freeze child order with a call to orderBefore()\n+                    // only makes sense with a least two child nodes\n+                    Iterator<NodeDelegate> children = dlg.getChildren();\n+                    NodeDelegate child1 = children.hasNext() ? children.next() : null;\n+                    NodeDelegate child2 = children.hasNext() ? children.next() : null;\n+                    if (child1 != null && child2 != null) {\n+                        dlg.orderBefore(child1.getName(), child2.getName());\n+                    }\n+                }\n+\n                 return null;\n             }\n         });\n", "nb_test": 395, "linesAdd": 14, "jira_id": "612", "singleLine": false, "nb_skipped": 1, "commit": "df9e6913", "nb_failure": 4, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["deletesMemoryNodeStore(org.apache.jackrabbit.oak.kernel.KernelNodeBuilderTest): child node x/y/z not should not be present", "deletesKernelNodeStore(org.apache.jackrabbit.oak.kernel.KernelNodeBuilderTest): child node x/y/z not should not be present"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex 0168d6e..3efa027 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -187,22 +187,11 @@ private MutableNodeState getWriteState(String name) {\n         }\n     }\n \n-    /**\n-     * Determine whether the named child has been removed. This is the\n-     * case when the write state has a corresponding {@code null} entry.\n-     * Assumes {@code read()}, {@code write()} needs not be called.\n-     * @param name  name of the child\n-     * @return  {@code true} iff a child with the given name has been removed\n-     */\n-    private boolean removed(String name) {\n-        return writeState != null && writeState.isRemoved(name);\n-    }\n-\n     @Nonnull\n     private NodeState read() {\n         if (revision != root.revision) {\n             assert(!isRoot()); // root never gets here since revision == root.revision\n-            checkState(!parent.removed(name), \"This node has already been removed\");\n+            checkState(!isRemoved(), \"This node has already been removed\");\n             parent.read();\n \n             // The builder could have been reset, need to re-get base state\n@@ -232,7 +221,7 @@ private MutableNodeState write() {\n     private MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\n         // make sure that all revision numbers up to the root gets updated\n         if (!isRoot()) {\n-            checkState(skipRemovedCheck || !parent.removed(name));\n+            checkState(skipRemovedCheck || !isRemoved());\n             parent.write(newRevision, skipRemovedCheck);\n         }\n \n@@ -244,7 +233,7 @@ private MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\n \n             writeState = parent.getWriteState(name);\n             if (writeState == null) {\n-                if (parent.removed(name)) {\n+                if (isRemoved()) {\n                     writeState = new MutableNodeState(null);\n                 }\n                 else {\n", "nb_test": 403, "linesAdd": 3, "jira_id": "531", "singleLine": false, "nb_skipped": 0, "commit": "90c45a02", "nb_failure": 2, "linesRem": 7}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["backgroundLeaseUpdateThread(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex ada87d0..8511e37 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -68,6 +68,8 @@\n \n import com.google.common.base.Function;\n import com.google.common.base.Predicates;\n+import com.google.common.base.Supplier;\n+import com.google.common.base.Suppliers;\n import com.google.common.cache.Cache;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n@@ -2561,18 +2563,35 @@ public long determineServerTimeDifferenceMillis() {\n     static abstract class NodeStoreTask implements Runnable {\n         final WeakReference<DocumentNodeStore> ref;\n         private final AtomicBoolean isDisposed;\n-        private int delay;\n+        private final Supplier<Integer> delaySupplier;\n \n-        NodeStoreTask(DocumentNodeStore nodeStore, AtomicBoolean isDisposed) {\n-            ref = new WeakReference<DocumentNodeStore>(nodeStore);\n-            delay = nodeStore.getAsyncDelay();\n+        NodeStoreTask(final DocumentNodeStore nodeStore,\n+                      final AtomicBoolean isDisposed,\n+                      Supplier<Integer> delay) {\n+            this.ref = new WeakReference<DocumentNodeStore>(nodeStore);\n             this.isDisposed = isDisposed;\n+            if (delay == null) {\n+                delay = new Supplier<Integer>() {\n+                    @Override\n+                    public Integer get() {\n+                        DocumentNodeStore ns = ref.get();\n+                        return ns != null ? ns.getAsyncDelay() : 0;\n+                    }\n+                };\n+            }\n+            this.delaySupplier = delay;\n+        }\n+\n+        NodeStoreTask(final DocumentNodeStore nodeStore,\n+                      final AtomicBoolean isDisposed) {\n+            this(nodeStore, isDisposed, null);\n         }\n \n         protected abstract void execute(@Nonnull DocumentNodeStore nodeStore);\n \n         @Override\n         public void run() {\n+            int delay = delaySupplier.get();\n             while (delay != 0 && !isDisposed.get()) {\n                 synchronized (isDisposed) {\n                     try {\n@@ -2588,7 +2607,7 @@ public void run() {\n                     } catch (Throwable t) {\n                         LOG.warn(\"Background operation failed: \" + t.toString(), t);\n                     }\n-                    delay = nodeStore.getAsyncDelay();\n+                    delay = delaySupplier.get();\n                 } else {\n                     // node store not in use anymore\n                     break;\n@@ -2633,7 +2652,7 @@ protected void execute(@Nonnull DocumentNodeStore nodeStore) {\n \n         BackgroundLeaseUpdate(DocumentNodeStore nodeStore,\n                               AtomicBoolean isDisposed) {\n-            super(nodeStore, isDisposed);\n+            super(nodeStore, isDisposed, Suppliers.ofInstance(1000));\n         }\n \n         @Override\n", "nb_test": 3025, "linesAdd": 25, "jira_id": "3579", "singleLine": false, "nb_skipped": 1, "commit": "2565d74a", "nb_failure": 1, "linesRem": 6}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testRemoveMissingProperty(org.apache.jackrabbit.oak.jcr.CRUDTest): missing not found on /", "testRemoveMissingMVProperty(org.apache.jackrabbit.oak.jcr.CRUDTest): missing not found on /"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex 2771c28..a3d9da9 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -1450,13 +1450,17 @@ private Property internalSetProperty(final String jcrName, final Value value,\n         return sessionDelegate.perform(new SessionOperation<Property>() {\n             @Override\n             public Property perform() throws RepositoryException {\n+                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n                 if (value == null) {\n+                    if (hasProperty(jcrName)) {\n                         Property property = getProperty(jcrName);\n                         property.remove();\n                         return property;\n                     } else {\n-                    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n-\n+                        return new PropertyImpl(new PropertyDelegate(\n+                                sessionDelegate, dlg.getLocation().getChild(oakName)));\n+                    }\n+                } else {\n                     PropertyDefinition definition;\n                     if (hasProperty(jcrName)) {\n                         definition = getProperty(jcrName).getDefinition();\n@@ -1485,13 +1489,17 @@ private Property internalSetProperty(final String jcrName, final Value[] values,\n         return sessionDelegate.perform(new SessionOperation<Property>() {\n             @Override\n             public Property perform() throws RepositoryException {\n+                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n                 if (values == null) {\n-                    Property p = getProperty(jcrName);\n-                    p.remove();\n-                    return p;\n+                    if (hasProperty(jcrName)) {\n+                        Property property = getProperty(jcrName);\n+                        property.remove();\n+                        return property;\n+                    } else {\n+                        return new PropertyImpl(new PropertyDelegate(\n+                                sessionDelegate, dlg.getLocation().getChild(oakName)));\n+                    }\n                 } else {\n-                    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n-\n                     PropertyDefinition definition;\n                     if (hasProperty(jcrName)) {\n                         definition = getProperty(jcrName).getDefinition();\n", "nb_test": 330, "linesAdd": 15, "jira_id": "395", "singleLine": false, "nb_skipped": 4, "commit": "e6c31270", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCloseOnOriginalIndexInput(org.apache.jackrabbit.oak.plugins.index.lucene.OakDirectoryTest): cannot use IndexInput once closed", "testCloseOnClonedIndexInputs(org.apache.jackrabbit.oak.plugins.index.lucene.OakDirectoryTest): cannot use IndexInput once closed"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\nindex 946d0c1..056ddf7 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n@@ -21,6 +21,7 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n \n@@ -33,6 +34,7 @@\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n import org.apache.jackrabbit.oak.util.PerfLogger;\n+import org.apache.lucene.store.AlreadyClosedException;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.store.IOContext;\n import org.apache.lucene.store.IndexInput;\n@@ -40,6 +42,7 @@\n import org.apache.lucene.store.Lock;\n import org.apache.lucene.store.LockFactory;\n import org.apache.lucene.store.NoLockFactory;\n+import org.apache.lucene.util.WeakIdentityMap;\n import org.slf4j.LoggerFactory;\n \n import static com.google.common.base.Preconditions.checkArgument;\n@@ -364,29 +367,41 @@ public String toString() {\n     private static class OakIndexInput extends IndexInput {\n \n         private final OakIndexFile file;\n+        private boolean isClone = false;\n+        private final WeakIdentityMap<OakIndexInput, Boolean> clones;\n \n         public OakIndexInput(String name, NodeBuilder file) {\n             super(name);\n             this.file = new OakIndexFile(name, file);\n+            clones = WeakIdentityMap.newConcurrentHashMap();\n         }\n \n         private OakIndexInput(OakIndexInput that) {\n             super(that.toString());\n             this.file = new OakIndexFile(that.file);\n+            clones = null;\n         }\n \n         @Override\n         public OakIndexInput clone() {\n-            return new OakIndexInput(this);\n+            // TODO : shouldn't we call super#clone ?\n+            OakIndexInput clonedIndexInput = new OakIndexInput(this);\n+            clonedIndexInput.isClone = true;\n+            if (clones != null) {\n+                clones.put(clonedIndexInput, Boolean.TRUE);\n+            }\n+            return clonedIndexInput;\n         }\n \n         @Override\n         public void readBytes(byte[] b, int o, int n) throws IOException {\n+            checkNotClosed();\n             file.readBytes(b, o, n);\n         }\n \n         @Override\n         public byte readByte() throws IOException {\n+            checkNotClosed();\n             byte[] b = new byte[1];\n             readBytes(b, 0, 1);\n             return b[0];\n@@ -394,16 +409,19 @@ public byte readByte() throws IOException {\n \n         @Override\n         public void seek(long pos) throws IOException {\n+            checkNotClosed();\n             file.seek(pos);\n         }\n \n         @Override\n         public long length() {\n+            checkNotClosed();\n             return file.length;\n         }\n \n         @Override\n         public long getFilePointer() {\n+            checkNotClosed();\n             return file.position;\n         }\n \n@@ -411,6 +429,20 @@ public long getFilePointer() {\n         public void close() {\n             file.blob = null;\n             file.data = null;\n+\n+            if (clones != null) {\n+                for (Iterator<OakIndexInput> it = clones.keyIterator(); it.hasNext();) {\n+                    final OakIndexInput clone = it.next();\n+                    assert clone.isClone;\n+                    clone.close();\n+                }\n+            }\n+        }\n+\n+        private void checkNotClosed() {\n+            if (file.blob == null && file.data == null) {\n+                throw new AlreadyClosedException(\"Already closed: \" + this);\n+            }\n         }\n \n     }\n", "nb_test": 453, "linesAdd": 32, "jira_id": "2799", "singleLine": false, "nb_skipped": 3, "commit": "3979fa8d", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["gcPrevWithMostRecentModification[0](org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollectorTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\nindex 885f721..74b4a84 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n@@ -20,7 +20,7 @@\n package org.apache.jackrabbit.oak.plugins.document;\n \n import java.util.ArrayList;\n-import java.util.EnumSet;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n@@ -43,11 +43,10 @@\n \n     /**\n      * Split document types which can be safely Garbage Collected\n+     * OAK-1793: SplitDocType.DEFAULT_NO_CHILD and SplitDocType.PROP_COMMIT_ONLY\n+     * have been removed, but should be added again when OAK-1794 is fixed.\n      */\n-    private static final Set<NodeDocument.SplitDocType> GC_TYPES = EnumSet.of(\n-            NodeDocument.SplitDocType.DEFAULT_NO_CHILD,\n-            NodeDocument.SplitDocType.PROP_COMMIT_ONLY);\n-\n+    private static final Set<NodeDocument.SplitDocType> GC_TYPES = Collections.emptySet();\n \n     VersionGarbageCollector(DocumentNodeStore nodeStore) {\n         this.nodeStore = nodeStore;\n", "nb_test": 1851, "linesAdd": 2, "jira_id": "1793", "singleLine": false, "nb_skipped": 9, "commit": "16225d51", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["oak4170(org.apache.jackrabbit.oak.query.FilterTest): expected:<...t:\"december\", path=*[])> but was:<...t:\"december\", path=*[, property=[jcr:content/metadata/comment=[is not null]]])>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\nindex 2e0505f..f3d11de 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n@@ -273,16 +273,6 @@ public void bindSelector(SourceImpl source) {\n \n     @Override\n     public void restrict(FilterImpl f) {\n-        if (propertyName != null) {\n-            if (f.getSelector().equals(selector)) {\n-                String p = propertyName;\n-                if (relativePath != null) {\n-                    p = PathUtils.concat(relativePath, p);\n-                }\n-                p = normalizePropertyName(p);\n-                restrictPropertyOnFilter(p, f);\n-            }\n-        }\n         f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\n     }\n \n", "nb_test": 2894, "linesAdd": 0, "jira_id": "4170", "singleLine": false, "nb_skipped": 1, "commit": "2a489d05", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testNullBlobId(org.apache.jackrabbit.oak.plugins.segment.ExternalBlobTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\nindex 0552b33..16c3f83 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n@@ -219,7 +219,7 @@ public synchronized void flush() {\n                 data.put(buffer, buffer.length - length, length);\n                 data.rewind();\n             } else {\n-                data = ByteBuffer.wrap(buffer);\n+                data = ByteBuffer.wrap(buffer, buffer.length - length, length);\n             }\n             tracker.setSegment(id, new Segment(tracker, id, data));\n \n", "nb_test": 1870, "linesAdd": 1, "jira_id": "1817", "singleLine": false, "nb_skipped": 9, "commit": "78c37386", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["cacheConsistency[0](org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollectorTest): java.lang.NullPointerException: Document /test-7 not found"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex d57f875..35a5f77 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -589,6 +589,10 @@ public CacheStats getDocChildrenCacheStats() {\n         return docChildrenCacheStats;\n     }\n \n+    void invalidateDocChildrenCache() {\n+        docChildrenCache.invalidateAll();\n+    }\n+\n     public int getPendingWriteCount() {\n         return unsavedLastRevisions.getPaths().size();\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\nindex e671b66..885f721 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n@@ -121,6 +121,7 @@ private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision\n             log.debug(sb.toString());\n         }\n         nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);\n+        nodeStore.invalidateDocChildrenCache();\n         stats.deletedDocGCCount += docIdsToDelete.size();\n     }\n \n", "nb_test": 1847, "linesAdd": 5, "jira_id": "1779", "singleLine": false, "nb_skipped": 9, "commit": "9d36bede", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTrailingSlash(org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest): expected:</a/b/c[]> but was:</a/b/c[/]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\nindex 7bce77d..65639f1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n@@ -151,9 +151,6 @@ public boolean name(String name, int index) {\n     }\n \n     private String getOakPath(String jcrPath, final boolean keepIndex) {\n-        final List<String> elements = new ArrayList<String>();\n-        final StringBuilder parseErrors = new StringBuilder();\n-\n         if (\"/\".equals(jcrPath)) {\n             // avoid the need to special case the root path later on\n             return \"/\";\n@@ -180,6 +177,7 @@ private String getOakPath(String jcrPath, final boolean keepIndex) {\n         boolean hasIndexBrackets = false;\n         boolean hasColon = false;\n         boolean hasNameStartingWithDot = false;\n+        boolean hasTrailingSlash = false;\n \n         char prev = 0;\n         for (int i = 0; i < length; i++) {\n@@ -193,6 +191,8 @@ private String getOakPath(String jcrPath, final boolean keepIndex) {\n                 hasColon = true;\n             } else if (c == '.' && (prev == 0 || prev == '/')) {\n                 hasNameStartingWithDot = true;\n+            } else if(c == '/' && i == (length - 1)){\n+                hasTrailingSlash = true;\n             }\n \n             prev = c;\n@@ -202,6 +202,9 @@ private String getOakPath(String jcrPath, final boolean keepIndex) {\n         if (!hasNameStartingWithDot && !hasClarkBrackets && !hasIndexBrackets) {\n             if (!hasColon || !hasSessionLocalMappings()) {\n                 if (JcrPathParser.validate(jcrPath)) {\n+                    if(hasTrailingSlash){\n+                        return jcrPath.substring(0, length - 1);\n+                    }\n                     return jcrPath;\n                 }\n                 else {\n@@ -211,6 +214,9 @@ private String getOakPath(String jcrPath, final boolean keepIndex) {\n             }\n         }\n \n+        final List<String> elements = new ArrayList<String>();\n+        final StringBuilder parseErrors = new StringBuilder();\n+\n         JcrPathParser.Listener listener = new JcrPathParser.Listener() {\n \n             @Override\n", "nb_test": 229, "linesAdd": 9, "jira_id": "313", "singleLine": false, "nb_skipped": 1, "commit": "e115fd90", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReadOnRemoveNode(org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest)", "testWriteOnRemoveNode(org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex e514790..fac27d2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -188,20 +188,19 @@ private MutableNodeState getWriteState(String name) {\n     }\n \n     /**\n-     * Determine whether this child has been removed.\n+     * Determine whether this child exists.\n      * Assumes {@code read()}, {@code write()} needs not be called.\n-     * @return  {@code true} iff this child has been removed\n+     * @return  {@code true} iff this child exists\n      */\n-    private boolean removed() {\n-        return !isRoot() && parent.writeState != null &&\n-                parent.hasBaseState(name) && !parent.writeState.hasChildNode(name);\n+    private boolean exists() {\n+        return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);\n     }\n \n     @Nonnull\n     private NodeState read() {\n         if (revision != root.revision) {\n             assert(!isRoot()); // root never gets here since revision == root.revision\n-            checkState(!removed(), \"This node has already been removed\");\n+            checkState(exists(), \"This node has already been removed\");\n             parent.read();\n \n             // The builder could have been reset, need to re-get base state\n@@ -231,7 +230,7 @@ private MutableNodeState write() {\n     private MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\n         // make sure that all revision numbers up to the root gets updated\n         if (!isRoot()) {\n-            checkState(skipRemovedCheck || !removed());\n+            checkState(skipRemovedCheck || exists());\n             parent.write(newRevision, skipRemovedCheck);\n         }\n \n@@ -243,7 +242,7 @@ private MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\n \n             writeState = parent.getWriteState(name);\n             if (writeState == null) {\n-                if (removed()) {\n+                if (!exists()) {\n                     writeState = new MutableNodeState(null);\n                 }\n                 else {\n@@ -385,7 +384,7 @@ public NodeBuilder setNode(String name, NodeState state) {\n         MutableNodeState childState = getWriteState(name);\n         if (childState == null) {\n             writeState.nodes.remove(name);\n-            childState = createChildBuilder(name).write();\n+            childState = createChildBuilder(name).write(root.revision + 1, true);\n         }\n         childState.reset(state);\n \n", "nb_test": 581, "linesAdd": 6, "jira_id": "614", "singleLine": false, "nb_skipped": 8, "commit": "6feacf6b", "nb_failure": 2, "linesRem": 7}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["list(org.apache.jackrabbit.oak.plugins.document.blob.ds.MongoDataStoreBlobStoreTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\nindex 3ad49ad..0880a19 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\n@@ -267,7 +267,8 @@ public long getBlockSizeMin() {\n             public boolean apply(DataIdentifier input) {\n                 try {\n                     DataRecord dr = delegate.getRecord(input);\n-                    if(dr != null && dr.getLastModified() < maxLastModifiedTime){\n+                    if(dr != null && (maxLastModifiedTime <=0\n+                            || dr.getLastModified() < maxLastModifiedTime)){\n                         return true;\n                     }\n                 } catch (DataStoreException e) {\n", "nb_test": 1768, "linesAdd": 2, "jira_id": "1655", "singleLine": false, "nb_skipped": 8, "commit": "c91bfa54", "nb_failure": 1, "linesRem": 1}, {"files": 9, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["pathBasedCostEstimation(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexTest): cost: 12.0", "testPathAwarePropertyLookup(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexTest): expected:<[a]> but was:<[b, a]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\nindex 74cfd81..0574916 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\n@@ -44,6 +44,7 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(OrderedPropertyIndex.class);\n \n+    @Override\n     public String getIndexName() {\n         return TYPE;\n     }\n@@ -57,6 +58,7 @@ OrderedPropertyIndexLookup getLookup(NodeState root) {\n      * \n      * !!! for now we want to skip the use-case of NON range-queries !!!\n      */\n+    @Override\n     public double getCost(Filter filter, NodeState root) {\n         throw new UnsupportedOperationException(\"Not supported as implementing AdvancedQueryIndex\");\n     }\n@@ -181,6 +183,7 @@ public Cursor query(IndexPlan plan, NodeState root) {\n \n         Filter filter = plan.getFilter();\n         List<OrderEntry> sortOrder = plan.getSortOrder();\n+        String pathPrefix = plan.getPathPrefix();\n         Iterable<String> paths = null;\n         OrderedContentMirrorStoreStrategy strategy\n                 = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());\n@@ -190,7 +193,7 @@ public Cursor query(IndexPlan plan, NodeState root) {\n             String propertyName = PathUtils.getName(pr.propertyName);\n             depth = PathUtils.getDepth(propertyName);\n             paths = strategy.query(plan.getFilter(), propertyName,\n-                    plan.getDefinition(), pr);\n+                    plan.getDefinition(), pr, pathPrefix);\n         }\n         if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {\n             // we could be here if we have a query where the ORDER BY makes us play it.\n@@ -198,7 +201,7 @@ public Cursor query(IndexPlan plan, NodeState root) {\n                 String propertyName = PathUtils.getName(oe.getPropertyName());\n                 depth = PathUtils.getDepth(oe.getPropertyName());\n                 paths = strategy.query(plan.getFilter(), propertyName,\n-                        plan.getDefinition(), new PropertyRestriction());\n+                        plan.getDefinition(), new PropertyRestriction(), pathPrefix);\n             }\n         }\n \n@@ -209,7 +212,6 @@ public Cursor query(IndexPlan plan, NodeState root) {\n                             + filter);\n         }\n         Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());\n-        cursor = Cursors.newPrefixCursor(cursor, plan.getPathPrefix());\n         if (depth > 1) {\n             cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java\nindex df94011..dc35da4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java\n@@ -203,7 +203,8 @@ public double getCost(Filter filter, String propertyName, PropertyValue value) {\n         if (indexMeta == null) {\n             throw new IllegalArgumentException(\"No index for \" + propertyName);\n         }\n-        return getStrategy(indexMeta).query(filter, propertyName, indexMeta, pr);\n+        return getStrategy(indexMeta).query(\n+                filter, propertyName, indexMeta, pr, \"\");\n     }\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java\nindex ae18d9b..cfd96e2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java\n@@ -129,7 +129,7 @@ public double getCost(Filter filter, String propertyName, PropertyValue value) {\n             return Double.POSITIVE_INFINITY;\n         }\n         return COST_OVERHEAD +\n-                getStrategy(indexMeta).count(indexMeta, encode(value), MAX_COST);\n+                getStrategy(indexMeta).count(filter, indexMeta, encode(value), MAX_COST);\n     }\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\nindex 5cc398d..8ace776 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n@@ -135,7 +135,7 @@\n \n                 if (restriction != null) {\n                     Set<String> values = getValues(restriction);\n-                    double cost = strategy.count(definition, values, MAX_COST);\n+                    double cost = strategy.count(filter, definition, values, MAX_COST);\n                     if (cost < bestCost) {\n                         bestDepth = depth;\n                         bestValues = values;\n@@ -152,7 +152,7 @@\n                 if (constraint instanceof OrImpl) {\n                     Set<String> values = findMultiProperty((OrImpl) constraint);\n                     if (values != null) {\n-                        double cost = strategy.count(definition, values, MAX_COST);\n+                        double cost = strategy.count(filter, definition, values, MAX_COST);\n                         if (cost < bestCost) {\n                             bestDepth = 1;\n                             bestValues = values;\n@@ -208,7 +208,7 @@ private boolean isIndexed(DynamicOperandImpl operand) {\n         }\n     }\n \n-    private Set<String> getValues(PropertyRestriction restriction) {\n+    private static Set<String> getValues(PropertyRestriction restriction) {\n         if (restriction.firstIncluding\n                 && restriction.lastIncluding\n                 && restriction.first != null\n@@ -249,6 +249,7 @@ Cursor execute() {\n \n     //------------------------------------------------------------< Object >--\n \n+    @Override\n     public String toString() {\n         StringBuilder buffer = new StringBuilder(\"property \");\n         buffer.append(name);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\nindex be32205..26eed1e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n@@ -121,7 +121,7 @@ private void insert(NodeBuilder index, String key, String value) {\n         return new Iterable<String>() {\n             @Override\n             public Iterator<String> iterator() {\n-                PathIterator it = new PathIterator(filter, indexName);\n+                PathIterator it = new PathIterator(filter, indexName, \"\");\n                 if (values == null) {\n                     it.setPathContainsValue(true);\n                     it.enqueue(getChildNodeEntries(index).iterator());\n@@ -157,8 +157,18 @@ public long count(NodeState indexMeta, Set<String> values, int max) {\n         return count(indexMeta, INDEX_CONTENT_NODE_NAME, values, max);\n     }\n \n+    @Override\n+    public long count(final Filter filter, NodeState indexMeta, Set<String> values, int max) {\n+        return count(filter, indexMeta, INDEX_CONTENT_NODE_NAME, values, max);\n+    }\n+\n     public long count(NodeState indexMeta, final String indexStorageNodeName,\n             Set<String> values, int max) {\n+        return count(null, indexMeta, indexStorageNodeName, values, max);\n+    }\n+\n+    public long count(Filter filter, NodeState indexMeta, final String indexStorageNodeName,\n+            Set<String> values, int max) {\n         NodeState index = indexMeta.getChildNode(indexStorageNodeName);\n         int count = 0;\n         if (values == null) {\n@@ -196,6 +206,11 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n             }\n             max = Math.max(10, max / size);\n             int i = 0;\n+            String filterRootPath = null;\n+            if (filter != null &&\n+                    filter.getPathRestriction().equals(Filter.PathRestriction.ALL_CHILDREN)) {\n+                filterRootPath = filter.getPath();\n+            }\n             for (String p : values) {\n                 if (count > max && i > 3) {\n                     // the total count is extrapolated from the the number \n@@ -204,6 +219,16 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n                     break;\n                 }\n                 NodeState s = index.getChildNode(p);\n+                if (filterRootPath != null && s.exists()) {\n+                    // Descend directly to path restriction inside index tree\n+                    for (String pathFragment : PathUtils\n+                            .elements(filterRootPath)) {\n+                        s = s.getChildNode(pathFragment);\n+                        if (!s.exists()) {\n+                            break;\n+                        }\n+                    }\n+                }\n                 if (s.exists()) {\n                     CountingNodeVisitor v = new CountingNodeVisitor(max);\n                     v.visit(s);\n@@ -227,6 +252,8 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n         private int readCount;\n         private boolean init;\n         private boolean closed;\n+        private String filterPath;\n+        private String pathPrefix;\n         private String parentPath;\n         private String currentPath;\n         private boolean pathContainsValue;\n@@ -237,9 +264,19 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n         private final Set<String> knownPaths = Sets.newHashSet();\n         private final long maxMemoryEntries;\n \n-        PathIterator(Filter filter, String indexName) {\n+        PathIterator(Filter filter, String indexName, String pathPrefix) {\n             this.filter = filter;\n+            this.pathPrefix = pathPrefix;\n             this.indexName = indexName;\n+            boolean shouldDescendDirectly = filter.getPathRestriction().equals(Filter.PathRestriction.ALL_CHILDREN);\n+            if (shouldDescendDirectly) {            \n+                filterPath = filter.getPath();\n+                if (PathUtils.denotesRoot(filterPath)) {\n+                    filterPath = \"\";\n+                }\n+            } else {\n+                filterPath = \"\";\n+            }            \n             parentPath = \"\";\n             currentPath = \"/\";\n             this.maxMemoryEntries = filter.getQueryEngineSettings().getLimitInMemory();\n@@ -305,6 +342,25 @@ private void fetchNextPossiblyDuplicate() {\n                     }\n                     currentPath = PathUtils.concat(parentPath, name);\n \n+                    if (!\"\".equals(filterPath)) {\n+                        String p = currentPath;\n+                        if (pathContainsValue) {\n+                            String value = PathUtils.elements(p).iterator().next();\n+                            p = PathUtils.relativize(value, p);                        \n+                        }\n+                        if (\"\".equals(pathPrefix)) {\n+                            p = PathUtils.concat(\"/\", p);\n+                        } else {\n+                            p = PathUtils.concat(pathPrefix, p);\n+                        }\n+                        if (!\"\".equals(p) && \n+                                !p.equals(filterPath) && \n+                                !PathUtils.isAncestor(p, filterPath) && \n+                                !PathUtils.isAncestor(filterPath, p)) {\n+                            continue;\n+                        }\n+                    }\n+\n                     nodeIterators.addLast(node.getChildNodeEntries().iterator());\n                     parentPath = currentPath;\n \n@@ -330,7 +386,7 @@ public String next() {\n                 fetchNext();\n                 init = true;\n             }\n-            String result = currentPath;\n+            String result = PathUtils.concat(pathPrefix, currentPath);\n             fetchNext();\n             return result;\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java\nindex 5864eef..6438fc0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java\n@@ -43,7 +43,7 @@ void update(\n     /**\n      * Search for a given set of values.\n      * \n-     * @param filter the filter (used for logging)\n+     * @param filter the filter (can optionally be used for optimized query execution)\n      * @param indexName the name of the index (for logging)\n      * @param indexMeta the index metadata node (may not be null)\n      * @param values values to look for (null to check for property existence)\n@@ -62,4 +62,16 @@ void update(\n      */\n     long count(NodeState indexMeta, Set<String> values, int max);\n \n+    /**\n+     * Count the occurrence of a given set of values. Used in calculating the\n+     * cost of an index.\n+     *\n+     * @param filter the filter which can be used to estimate better cost\n+     * @param indexMeta the index metadata node (may not be null)\n+     * @param values values to look for (null to check for property existence)\n+     * @param max the maximum value to return\n+     * @return the aggregated count of occurrences for each provided value\n+     */\n+    long count(Filter filter, NodeState indexMeta, Set<String> values, int max);\n+\n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\nindex 2445869..411f734 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n@@ -265,6 +265,11 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n         return cne;\n     }\n     \n+    public Iterable<String> query(final Filter filter, final String indexName,\n+            final NodeState indexMeta, final PropertyRestriction pr) {\n+        return query(filter, indexName, indexMeta, pr, \"\");\n+    }\n+\n     /**\n      * search the index for the provided PropertyRestriction\n      * \n@@ -275,8 +280,9 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n      * @return the iterable\n      */\n     public Iterable<String> query(final Filter filter, final String indexName,\n-                                  final NodeState indexMeta, final PropertyRestriction pr) {\n-        return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr);\n+                                  final NodeState indexMeta, final PropertyRestriction pr,\n+                                  String pathPrefix) {\n+        return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr, pathPrefix);\n     }\n \n     /**\n@@ -292,7 +298,7 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n      */\n     public Iterable<String> query(final Filter filter, final String indexName,\n                                   final NodeState indexMeta, final String indexStorageNodeName,\n-                                  final PropertyRestriction pr) {\n+                                  final PropertyRestriction pr, String pathPrefix) {\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"query() - filter: {}\", filter);            \n             LOG.debug(\"query() - indexName: {}\", indexName);            \n@@ -325,11 +331,14 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n                         indexState.getChildNode(firstValuableItemKey));\n                     if (direction.isAscending()) {\n                         childrenIterable = new SeekedIterable(indexState, firstValueableItem);\n-                        it = new QueryResultsWrapper(filter, indexName, childrenIterable);\n+                        it = new QueryResultsWrapper(filter, indexName, \n+                                childrenIterable, pathPrefix);\n                     } else {\n-                        it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(\n+                        it = new QueryResultsWrapper(filter, indexName, \n+                                new BetweenIterable(\n                                         indexState, firstValueableItem, firstEncoded,\n-                            pr.firstIncluding, direction));\n+                                        pr.firstIncluding, direction),\n+                                pathPrefix);\n                     }\n                 }\n             } else {\n@@ -362,7 +371,8 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n                         indexState.getChildNode(firstValuableItemKey));\n                     childrenIterable = new BetweenIterable(indexState, firstValueableItem, last,\n                         includeLast, direction);\n-                    it = new QueryResultsWrapper(filter, indexName, childrenIterable);\n+                    it = new QueryResultsWrapper(filter, indexName, \n+                            childrenIterable, pathPrefix);\n                 }\n             }\n \n@@ -387,18 +397,21 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n                 firstValueableItem = new OrderedChildNodeEntry(firstValueableItemKey,\n                     indexState.getChildNode(firstValueableItemKey));\n                 if (direction.isAscending()) {\n-                    it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(indexState,\n-                        firstValueableItem, searchfor, include, direction));\n+                    it = new QueryResultsWrapper(filter, indexName, \n+                            new BetweenIterable(indexState, firstValueableItem, searchfor, include, direction),\n+                            pathPrefix);\n                 } else {\n-                    it = new QueryResultsWrapper(filter, indexName, new SeekedIterable(indexState,\n-                        firstValueableItem));\n+                    it = new QueryResultsWrapper(filter, indexName, \n+                            new SeekedIterable(indexState, firstValueableItem),\n+                            pathPrefix);\n                 }\n             }\n             return it;\n         } else {\n             // property is not null. AKA \"open query\"\n             LOG.debug(\"property is not null. AKA 'open query'. FullIterable\");\n-            return new QueryResultsWrapper(filter, indexName, new FullIterable(indexState, false));\n+            return new QueryResultsWrapper(filter, indexName, \n+                    new FullIterable(indexState, false), pathPrefix);\n         }\n     }\n     \n@@ -602,17 +615,20 @@ public String getSearchFor() {\n         private Iterable<ChildNodeEntry> children;\n         private String indexName;\n         private Filter filter;\n+        private String pathPrefix;\n \n         public QueryResultsWrapper(Filter filter, String indexName,\n-                                   Iterable<ChildNodeEntry> children) {\n+                                   Iterable<ChildNodeEntry> children,\n+                                   String pathPrefix) {\n             this.children = children;\n             this.indexName = indexName;\n             this.filter = filter;\n+            this.pathPrefix = pathPrefix;\n         }\n \n         @Override\n         public Iterator<String> iterator() {\n-            PathIterator pi = new PathIterator(filter, indexName);\n+            PathIterator pi = new PathIterator(filter, indexName, pathPrefix);\n             pi.setPathContainsValue(true);\n             pi.enqueue(children.iterator());\n             return pi;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java\nindex 15111ec..ca80c7e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java\n@@ -166,4 +166,8 @@ public long count(NodeState indexMeta, Set<String> values, int max) {\n         return count;\n     }\n \n+    @Override\n+    public long count(final Filter filter, NodeState indexMeta, Set<String> values, int max) {\n+        return count(indexMeta, values, max);\n+    }\n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\nindex 4d85191..ff4a1ab 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\n@@ -24,7 +24,6 @@\n \n import javax.annotation.Nullable;\n \n-import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.memory.MemoryChildNodeEntry;\n import org.apache.jackrabbit.oak.query.FilterIterators;\n@@ -74,23 +73,6 @@ public static Cursor newPathCursor(Iterable<String> paths, QueryEngineSettings s\n     }\n \n     /**\n-     * Creates a cursor which wraps another cursor and adds a path prefix to\n-     * each of row of the wrapped cursor. This method will return the passed\n-     * cursor as is if {@code path} is the empty string or the root path (\"/\").\n-     *\n-     * @param c    the cursor to wrap.\n-     * @param path the path prefix.\n-     * @return the cursor.\n-     */\n-    public static Cursor newPrefixCursor(Cursor c, String path) {\n-        if (path.isEmpty() || PathUtils.denotesRoot(path)) {\n-            // no need to wrap\n-            return c;\n-        }\n-        return new PrefixCursor(c, path);\n-    }\n-    \n-    /**\n      * Creates a {@link Cursor} over paths, and make the result distinct.\n      * The iterator might return duplicate paths\n      * \n@@ -220,48 +202,6 @@ public boolean hasNext() {\n     }\n \n     /**\n-     * A cursor which wraps another cursor and adds a path prefix to each of\n-     * row of the wrapped cursor.\n-     */\n-    private static final class PrefixCursor extends AbstractCursor {\n-\n-        private final Cursor c;\n-        private final String path;\n-\n-        PrefixCursor(Cursor c, String prefix) {\n-            this.c = c;\n-            this.path = prefix;\n-        }\n-\n-        @Override\n-        public IndexRow next() {\n-            final IndexRow r = c.next();\n-            return new IndexRow() {\n-\n-                @Override\n-                public String getPath() {\n-                    String sub = r.getPath();\n-                    if (PathUtils.isAbsolute(sub)) {\n-                        return path + sub;\n-                    } else {\n-                        return PathUtils.concat(path, r.getPath());\n-                    }\n-                }\n-\n-                @Override\n-                public PropertyValue getValue(String columnName) {\n-                    return r.getValue(columnName);\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public boolean hasNext() {\n-            return c.hasNext();\n-        }\n-    }\n-\n-    /**\n      * A cursor that reads all nodes in a given subtree.\n      */\n     private static class TraversingCursor extends AbstractCursor {\n", "nb_test": 1899, "linesAdd": 106, "jira_id": "1977", "singleLine": false, "nb_skipped": 9, "commit": "4bfbfcdd", "nb_failure": 2, "linesRem": 71}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["and(org.apache.jackrabbit.oak.query.ast.FullTextTest): FullText expression: hello  (*)world; expected: term"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextParser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextParser.java\nindex 8217960..1827d72 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextParser.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextParser.java\n@@ -163,7 +163,14 @@ FullTextExpression parseTerm() throws ParseException {\n                 } else if (c == '^') {\n                     boost = \"\";\n                     break;\n-                } else if (c == ' ') {\n+                } else if (c <= ' ') {\n+                    while (parseIndex < text.length()) {\n+                        c = text.charAt(parseIndex);\n+                        if (c > ' ') {\n+                            break;\n+                        }\n+                        parseIndex++;\n+                    }\n                     break;\n                 } else {\n                     buff.append(c);\n", "nb_test": 2421, "linesAdd": 8, "jira_id": "3377", "singleLine": false, "nb_skipped": 1, "commit": "00b9bc52", "nb_failure": 0, "linesRem": 1}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReaggregateMixin(org.apache.jackrabbit.oak.plugins.index.lucene.AggregateTest): expected:<4> but was:<0>", "oneLevelTypedMixin(org.apache.jackrabbit.oak.plugins.index.lucene.AggregateTest): expected:<1> but was:<0>", "indexingBasedOnMixinAndRelativeProps(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): Expected path /test/a not found, got []"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\nindex e9f7dd2..fa5728b 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\n@@ -30,7 +30,6 @@\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n-import org.apache.jackrabbit.oak.api.CommitFailedException;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.index.lucene.util.ConfigUtil;\n@@ -79,7 +78,7 @@\n     }\n \n     public void collectAggregates(NodeState root, ResultCollector collector) {\n-        if (nodeTypeName.equals(ConfigUtil.getPrimaryTypeName(root))) {\n+        if (matchingType(nodeTypeName, root)) {\n             List<Matcher> matchers = createMatchers();\n             collectAggregates(root, matchers, collector);\n         }\n@@ -111,6 +110,19 @@ public String toString() {\n         return nodeTypeName;\n     }\n \n+    private static boolean matchingType(String nodeTypeName, NodeState nodeState) {\n+        if (nodeTypeName.equals(ConfigUtil.getPrimaryTypeName(nodeState))) {\n+            return true;\n+        }\n+\n+        for (String mixin : ConfigUtil.getMixinNames(nodeState)) {\n+            if (nodeTypeName.equals(mixin)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     private static void collectAggregates(NodeState nodeState, List<Matcher> matchers,\n                                           ResultCollector collector) {\n         for (ChildNodeEntry cne : nodeState.getChildNodeEntries()) {\n@@ -231,7 +243,7 @@ public boolean match(String name, NodeState nodeState, int depth) {\n             //last segment -> add to collector if node type matches\n             if (depth == maxDepth() - 1\n                     && primaryType != null\n-                    && !primaryType.equals(ConfigUtil.getPrimaryTypeName(nodeState))) {\n+                    && !matchingType(primaryType, nodeState)) {\n                 return false;\n             }\n             return super.match(name, nodeState, depth);\n@@ -256,7 +268,19 @@ public boolean aggregatesProperty(String name) {\n \n         @Override\n         public Aggregate getAggregate(NodeState matchedNodeState) {\n-            return aggMapper.getAggregate(ConfigUtil.getPrimaryTypeName(matchedNodeState));\n+            //Check agg defn for primaryType first\n+            Aggregate agg = aggMapper.getAggregate(ConfigUtil.getPrimaryTypeName(matchedNodeState));\n+\n+            //If not found then look for defn for mixins\n+            if (agg == null) {\n+                for (String mixin : ConfigUtil.getMixinNames(matchedNodeState)) {\n+                    agg = aggMapper.getAggregate(mixin);\n+                    if (agg != null) {\n+                        break;\n+                    }\n+                }\n+            }\n+            return agg;\n         }\n \n         @Override\ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/ConfigUtil.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/ConfigUtil.java\nindex 476f7e1..73287a0 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/ConfigUtil.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/ConfigUtil.java\n@@ -19,6 +19,8 @@\n \n package org.apache.jackrabbit.oak.plugins.index.lucene.util;\n \n+import java.util.Collections;\n+\n import com.google.common.primitives.Ints;\n import org.apache.jackrabbit.JcrConstants;\n import org.apache.jackrabbit.oak.api.Blob;\n@@ -60,6 +62,11 @@ public static String getPrimaryTypeName(NodeState nodeState) {\n         return (ps == null) ? JcrConstants.NT_BASE : ps.getValue(Type.NAME);\n     }\n \n+    public static Iterable<String> getMixinNames(NodeState nodeState) {\n+        PropertyState ps = nodeState.getProperty(JcrConstants.JCR_MIXINTYPES);\n+        return (ps == null) ? Collections.<String>emptyList() : ps.getValue(Type.NAMES);\n+    }\n+\n     /**\n      * Assumes that given state is of type nt:file and then reads\n      * the jcr:content/@jcr:data property to get the binary content\ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/package-info.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/package-info.java\nindex 0761902..b1049b9 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/package-info.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/package-info.java\n@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-@Version(\"1.1.0\")\n+@Version(\"1.2.0\")\n @Export(optional = \"provide:=true\")\n package org.apache.jackrabbit.oak.plugins.index.lucene.util;\n \n", "nb_test": 278, "linesAdd": 34, "jira_id": "3630", "singleLine": false, "nb_skipped": 3, "commit": "fcd64766", "nb_failure": 3, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testIndexPruning(org.apache.jackrabbit.oak.plugins.index.p2.strategy.ContentMirrorStoreStrategyTest): Missing child node e on path key/d/e/f"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\nindex 36c1dee..9792b65 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\n@@ -16,11 +16,12 @@\n  */\n package org.apache.jackrabbit.oak.plugins.index.p2.strategy;\n \n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.Queue;\n+import java.util.Map;\n import java.util.Set;\n+import java.util.TreeMap;\n \n import org.apache.jackrabbit.oak.api.CommitFailedException;\n import org.apache.jackrabbit.oak.api.PropertyState;\n@@ -38,46 +39,66 @@ public void remove(NodeBuilder index, String key, Iterable<String> values) {\n             return;\n         }\n         NodeBuilder child = index.child(key);\n-        Queue<NodeBuilder> parentQueue = new LinkedList<NodeBuilder>();\n+        Map<String, NodeBuilder> parents = new TreeMap<String, NodeBuilder>(Collections.reverseOrder());\n+\n         for (String rm : values) {\n             if (PathUtils.denotesRoot(rm)) {\n                 child.removeProperty(\"match\");\n             } else {\n-                NodeBuilder indexEntry = child;\n-                Iterator<String> segments = PathUtils.elements(rm).iterator();\n+                String parentPath = PathUtils.getParentPath(rm);\n+                String name = PathUtils.getName(rm);\n+                NodeBuilder indexEntry = parents.get(parentPath);\n+                if (indexEntry == null) {\n+                    indexEntry = child;\n+                    String segmentPath = \"\";\n+                    Iterator<String> segments = PathUtils.elements(parentPath)\n+                            .iterator();\n                     while (segments.hasNext()) {\n                         String segment = segments.next();\n-                    if (segments.hasNext()) {\n-                        parentQueue.add(indexEntry);\n+                        segmentPath = PathUtils.concat(segmentPath, segment);\n                         indexEntry = indexEntry.child(segment);\n-                    } else {\n-                        // last segment\n-                        if (indexEntry.hasChildNode(segment)) {\n-                            indexEntry.removeNode(segment);\n+                        parents.put(segmentPath, indexEntry);\n+                    }\n                 }\n+                if (indexEntry.hasChildNode(name)) {\n+                    NodeBuilder childEntry = indexEntry.child(name);\n+                    childEntry.removeProperty(\"match\");\n+                    if (childEntry.getChildNodeCount() == 0) {\n+                        indexEntry.removeNode(name);\n                     }\n                 }\n             }\n         }\n         // prune the index: remove all children that have no children\n         // and no \"match\" property progressing bottom up\n-        // see OAK-520\n-        // while (!parentQueue.isEmpty()) {\n-        // NodeBuilder node = parentQueue.poll();\n-        // for (String name : node.getChildNodeNames()) {\n-        // NodeBuilder segment = node.child(name);\n-        // if (segment.getChildNodeCount() == 0\n-        // && segment.getProperty(\"match\") == null) {\n-        // segment.removeNode(name);\n-        // }\n-        // }\n-        // }\n-        // finally remove the index node if empty\n-        if (child.getChildNodeCount() == 0) {\n+        Iterator<String> it = parents.keySet().iterator();\n+        while (it.hasNext()) {\n+            String path = it.next();\n+            NodeBuilder parent = parents.get(path);\n+            pruneNode(parent);\n+        }\n+\n+        // finally prune the index node\n+        pruneNode(child);\n+        if (child.getChildNodeCount() == 0\n+                && child.getProperty(\"match\") == null) {\n             index.removeNode(key);\n         }\n     }\n \n+    private void pruneNode(NodeBuilder parent) {\n+        if (parent.isRemoved()) {\n+            return;\n+        }\n+        for (String name : parent.getChildNodeNames()) {\n+            NodeBuilder segment = parent.child(name);\n+            if (segment.getChildNodeCount() == 0\n+                    && segment.getProperty(\"match\") == null) {\n+                parent.removeNode(name);\n+            }\n+        }\n+    }\n+\n     @Override\n     public void insert(NodeBuilder index, String key, boolean unique,\n             Iterable<String> values) throws CommitFailedException {\n@@ -85,9 +106,7 @@ public void insert(NodeBuilder index, String key, boolean unique,\n \n         for (String add : values) {\n             NodeBuilder indexEntry = child;\n-            Iterator<String> segments = PathUtils.elements(add).iterator();\n-            while (segments.hasNext()) {\n-                String segment = segments.next();\n+            for(String segment: PathUtils.elements(add)){\n                 indexEntry = indexEntry.child(segment);\n             }\n             indexEntry.setProperty(\"match\", true);\n", "nb_test": 404, "linesAdd": 45, "jira_id": "520", "singleLine": false, "nb_skipped": 0, "commit": "ec961a38", "nb_failure": 1, "linesRem": 14}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testUpgrade(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content"], "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/PersistenceCopier.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/PersistenceCopier.java\nindex 23c905e..88030fe 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/PersistenceCopier.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/PersistenceCopier.java\n@@ -292,7 +292,7 @@ private void copy(NodeState sourceNode, NodeBuilder builder)\n                     name, value.getBoolean(), Type.BOOLEAN);\n         case PropertyType.DATE:\n             return PropertyStates.createProperty(\n-                    name, value.getCalendar().getTimeInMillis(), Type.DATE);\n+                    name, value.getString(), Type.DATE);\n         case PropertyType.DECIMAL:\n             return PropertyStates.createProperty(\n                     name, value.getDecimal(), Type.DECIMAL);\n", "nb_test": 1, "linesAdd": 1, "jira_id": "1111", "singleLine": false, "nb_skipped": 0, "commit": "459bd065", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["xpath(org.apache.jackrabbit.oak.query.QueryTest): Results in target/queryXpathTest.txt don't match expected results in src/test/resources/queryXpathTest.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java\nindex 6a5f5a9..8103898 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java\n@@ -381,10 +381,20 @@ private Expression parseFunction(String functionName) throws ParseException {\n             Cast c = new Cast(expr, \"date\");\n             read(\")\");\n             return c;\n+        } else if (\"fn:lower-case\".equals(functionName)) {\n+            Function f = new Function(\"lower\");\n+            f.params.add(parseExpression());\n+            read(\")\");\n+            return f;\n+        } else if (\"fn:upper-case\".equals(functionName)) {\n+            Function f = new Function(\"upper\");\n+            f.params.add(parseExpression());\n+            read(\")\");\n+            return f;\n         // } else if (\"jcr:deref\".equals(functionName)) {\n             // TODO support jcr:deref?\n         } else {\n-            throw getSyntaxError(\"jcr:like | jcr:contains | jcr:score | jcr:deref\");\n+            throw getSyntaxError(\"jcr:like | jcr:contains | jcr:score | jcr:deref | fn:lower-case | fn:upper-case\");\n         }\n     }\n \n@@ -537,7 +547,9 @@ private void read() throws ParseException {\n         case CHAR_NAME:\n             while (true) {\n                 type = types[i];\n-                if (type != CHAR_NAME && type != CHAR_VALUE) {\n+                // the '-' can be part of a name, \n+                // for example in \"fn:lower-case\"\n+                if (type != CHAR_NAME && type != CHAR_VALUE && chars[i] != '-') {\n                     c = chars[i];\n                     break;\n                 }\n", "nb_test": 212, "linesAdd": 12, "jira_id": "225", "singleLine": false, "nb_skipped": 0, "commit": "e33328e0", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["splitCommitRoot(org.apache.jackrabbit.oak.plugins.mongomk.DocumentSplitTest): expected:<1> but was:<1001>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\nindex 9b6835f..dfe473d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\n@@ -118,6 +118,11 @@\n \n     final DocumentStore store;\n \n+    /**\n+     * Parsed and sorted set of previous revisions.\n+     */\n+    private SortedMap<Revision, Range> previous;\n+\n     private final long time = System.currentTimeMillis();\n \n     NodeDocument(@Nonnull DocumentStore store) {\n@@ -151,19 +156,23 @@ public final long getCreated() {\n \n     /**\n      * Returns <code>true</code> if the given <code>revision</code> is marked\n-     * committed in <strong>this</strong> document including previous documents.\n+     * committed.\n      *\n      * @param revision the revision.\n      * @return <code>true</code> if committed; <code>false</code> otherwise.\n      */\n     public boolean isCommitted(@Nonnull Revision revision) {\n+        NodeDocument commitRootDoc = getCommitRoot(checkNotNull(revision));\n+        if (commitRootDoc == null) {\n+            return false;\n+        }\n         String rev = checkNotNull(revision).toString();\n-        String value = getLocalRevisions().get(rev);\n+        String value = commitRootDoc.getLocalRevisions().get(rev);\n         if (value != null) {\n             return Utils.isCommitted(value);\n         }\n         // check previous docs\n-        for (NodeDocument prev : getPreviousDocs(revision, REVISIONS)) {\n+        for (NodeDocument prev : commitRootDoc.getPreviousDocs(revision, REVISIONS)) {\n             if (prev.containsRevision(revision)) {\n                 return prev.isCommitted(revision);\n             }\n@@ -659,20 +668,26 @@ public boolean isConflicting(@Nonnull UpdateOp op,\n                     main.removeMapEntry(property, r);\n                     old.setMapEntry(property, r, entry.getValue());\n                 }\n+            }\n             splitOps.add(old);\n             splitOps.add(main);\n         }\n-        }\n         return splitOps;\n     }\n \n-    @Override\n+    /**\n+     * Returns previous revision ranges for this document. The revision keys are\n+     * sorted descending, newest first!\n+     *\n+     * @return the previous ranges for this document.\n+     */\n     @Nonnull\n-    protected Map<?, ?> transformAndSeal(@Nonnull Map<Object, Object> map,\n-                                         @Nullable String key,\n-                                         int level) {\n-        if (level == 1) {\n-            if (PREVIOUS.equals(key)) {\n+    SortedMap<Revision, Range> getPreviousRanges() {\n+        if (previous == null) {\n+            Map<String, String> map = getLocalMap(PREVIOUS);\n+            if (map.isEmpty()) {\n+                previous = EMPTY_RANGE_MAP;\n+            } else {\n                 SortedMap<Revision, Range> transformed = new TreeMap<Revision, Range>(\n                         new Comparator<Revision>() {\n                             @Override\n@@ -687,29 +702,13 @@ public int compare(Revision o1, Revision o2) {\n                                 return c;\n                             }\n                         });\n-                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n-                    Revision high = Revision.fromString(entry.getKey().toString());\n-                    Revision low = Revision.fromString(entry.getValue().toString());\n+                for (Map.Entry<String, String> entry : map.entrySet()) {\n+                    Revision high = Revision.fromString(entry.getKey());\n+                    Revision low = Revision.fromString(entry.getValue());\n                     transformed.put(high, new Range(high, low));\n                 }\n-                return Collections.unmodifiableSortedMap(transformed);\n-            }\n-        }\n-        return super.transformAndSeal(map, key, level);\n+                previous = Collections.unmodifiableSortedMap(transformed);\n             }\n-\n-    /**\n-     * Returns previous revision ranges for this document. The revision keys are\n-     * sorted descending, newest first!\n-     *\n-     * @return the previous ranges for this document.\n-     */\n-    @Nonnull\n-    SortedMap<Revision, Range> getPreviousRanges() {\n-        @SuppressWarnings(\"unchecked\")\n-        SortedMap<Revision, Range> previous = (SortedMap<Revision, Range>) get(PREVIOUS);\n-        if (previous == null) {\n-            previous = EMPTY_RANGE_MAP;\n         }\n         return previous;\n     }\n", "nb_test": 1253, "linesAdd": 19, "jira_id": "926", "singleLine": false, "nb_skipped": 8, "commit": "e1ae968c", "nb_failure": 1, "linesRem": 23}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["setNodeTest(org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex 3854466..9faa23f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -254,7 +254,9 @@ private MutableNodeState write(long newRevision, boolean reconnect) {\n             writeState = parent.getWriteState(name);\n             if (writeState == null) {\n                 if (exists()) {\n-                    writeState = new MutableNodeState(baseState);\n+                    NodeState writeBase =\n+                            parent.writeState.base.getChildNode(name);\n+                    writeState = new MutableNodeState(writeBase);\n                 }\n                 else {\n                     writeState = new MutableNodeState(null);\n", "nb_test": 637, "linesAdd": 3, "jira_id": "782", "singleLine": false, "nb_skipped": 2, "commit": "45b110e1", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["indexNodeLockHandling(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexTest): attempt to unlock read lock, not locked by current thread"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex b01ff99..1c84164 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -206,8 +206,8 @@ public String getIndexName() {\n     public List<IndexPlan> getPlans(Filter filter, List<OrderEntry> sortOrder, NodeState rootState) {\n         Collection<String> indexPaths = new LuceneIndexLookup(rootState).collectIndexNodePaths(filter);\n         List<IndexPlan> plans = Lists.newArrayListWithCapacity(indexPaths.size());\n-        IndexNode indexNode = null;\n         for (String path : indexPaths) {\n+            IndexNode indexNode = null;\n             try {\n                 indexNode = tracker.acquireIndexNode(path);\n \n", "nb_test": 262, "linesAdd": 1, "jira_id": "3442", "singleLine": false, "nb_skipped": 4, "commit": "17032c50", "nb_failure": 0, "linesRem": 1}, {"files": 4, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["query(org.apache.jackrabbit.oak.plugins.index.property.MultiPropertyOrTest): [nt:base] as [nt:base] /* property xyz IN (foo, bar)(..)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\nindex 40eca04..3ec211f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n@@ -192,7 +192,7 @@ public double getCost(Filter filter, NodeState root) {\n             // not an appropriate index for native search\n             return Double.POSITIVE_INFINITY;\n         }\n-        if (filter.getPropertyRestrictions().isEmpty() && filter.getSelector().getSelectorConstraints().isEmpty()) {\n+        if (filter.getPropertyRestrictions().isEmpty()) {\n             // not an appropriate index for no property restrictions & selector constraints\n             return Double.POSITIVE_INFINITY;\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\nindex b1123a0..d15c273 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n@@ -35,14 +35,6 @@\n import org.apache.jackrabbit.oak.plugins.index.property.strategy.IndexStoreStrategy;\n import org.apache.jackrabbit.oak.plugins.index.property.strategy.UniqueEntryStoreStrategy;\n import org.apache.jackrabbit.oak.query.QueryEngineSettings;\n-import org.apache.jackrabbit.oak.query.ast.ComparisonImpl;\n-import org.apache.jackrabbit.oak.query.ast.ConstraintImpl;\n-import org.apache.jackrabbit.oak.query.ast.DynamicOperandImpl;\n-import org.apache.jackrabbit.oak.query.ast.InImpl;\n-import org.apache.jackrabbit.oak.query.ast.Operator;\n-import org.apache.jackrabbit.oak.query.ast.OrImpl;\n-import org.apache.jackrabbit.oak.query.ast.PropertyValueImpl;\n-import org.apache.jackrabbit.oak.query.ast.StaticOperandImpl;\n import org.apache.jackrabbit.oak.spi.query.Cursor;\n import org.apache.jackrabbit.oak.spi.query.Cursors;\n import org.apache.jackrabbit.oak.spi.query.Filter;\n@@ -72,8 +64,6 @@\n     private static final IndexStoreStrategy UNIQUE =\n             new UniqueEntryStoreStrategy();\n \n-    private final NodeState root;\n-\n     private final NodeState definition;\n \n     private final String name;\n@@ -98,7 +88,6 @@\n \n     PropertyIndexPlan(String name, NodeState root, NodeState definition, Filter filter) {\n         this.name = name;\n-        this.root = root;\n         this.definition = definition;\n         this.properties = newHashSet(definition.getNames(PROPERTY_NAMES));\n         pathFilter = PathFilter.from(definition.builder());\n@@ -162,24 +151,6 @@\n                     }\n                 }\n             }\n-\n-            // OAK-1965: let's see if we can find a (x='...' OR y='...')\n-            // constraint where both x and y are covered by this index\n-            // TODO: avoid repeated scans through the constraints\n-            for (ConstraintImpl constraint\n-                    : filter.getSelector().getSelectorConstraints()) {\n-                if (constraint instanceof OrImpl) {\n-                    Set<String> values = findMultiProperty((OrImpl) constraint);\n-                    if (values != null) {\n-                        double cost = strategy.count(filter, root, definition, values, MAX_COST);\n-                        if (cost < bestCost) {\n-                            bestDepth = 1;\n-                            bestValues = values;\n-                            bestCost = cost;\n-                        }\n-                    }\n-                }\n-            }\n         }\n \n         this.depth = bestDepth;\n@@ -187,46 +158,6 @@\n         this.cost = COST_OVERHEAD + bestCost;\n     }\n \n-    private Set<String> findMultiProperty(OrImpl or) {\n-        Set<String> values = newLinkedHashSet();\n-        for (ConstraintImpl constraint : or.getConstraints()) {\n-            if (constraint instanceof ComparisonImpl) {\n-                ComparisonImpl comparison = (ComparisonImpl) constraint;\n-                if (isIndexed(comparison.getOperand1())\n-                        && comparison.getOperator() == Operator.EQUAL) {\n-                    values.addAll(encode(comparison.getOperand2().currentValue()));\n-                } else {\n-                    return null;\n-                }\n-            } else if (constraint instanceof InImpl) {\n-                InImpl in = (InImpl) constraint;\n-                if (isIndexed(in.getOperand1())) {\n-                    for (StaticOperandImpl operand : in.getOperand2()) {\n-                        values.addAll(encode(operand.currentValue()));\n-                    }\n-                } else {\n-                    return null;\n-                }\n-            } else {\n-                return null;\n-            }\n-        }\n-        return values;\n-    }\n-\n-    /**\n-     * Checks whether the given dynamic operand is a property\n-     * covered by this index.\n-     */\n-    private boolean isIndexed(DynamicOperandImpl operand) {\n-        if (operand instanceof PropertyValueImpl) {\n-            PropertyValueImpl property = (PropertyValueImpl) operand;\n-            return properties.contains(property.getPropertyName());\n-        } else {\n-            return false;\n-        }\n-    }\n-\n     private static Set<String> getValues(PropertyRestriction restriction) {\n         if (restriction.firstIncluding\n                 && restriction.lastIncluding\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\nindex 6908950..0f851b1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n@@ -218,7 +218,6 @@ public boolean isAlwaysFalse() {\n         return alwaysFalse;\n     }\n \n-    @Override\n     public SelectorImpl getSelector() {\n         return selector;\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java\nindex f2e55fd..9aabf1a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java\n@@ -28,7 +28,6 @@\n \n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.query.QueryEngineSettings;\n-import org.apache.jackrabbit.oak.query.ast.SelectorImpl;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextExpression;\n \n /**\n@@ -45,13 +44,6 @@\n public interface Filter {\n \n     /**\n-     * Get the selector associated with this filter.\n-     *\n-     * @return selector\n-     */\n-    SelectorImpl getSelector();\n-\n-    /**\n      * Get the list of property restrictions, if any. Each property may contain\n      * multiple restrictions, for example x=1 and x=2. For this case, only\n      * multi-valued properties match that contain both 1 and 2.\n", "nb_test": 2801, "linesAdd": 1, "jira_id": "4038", "singleLine": false, "nb_skipped": 1, "commit": "557eec4f", "nb_failure": 1, "linesRem": 67}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["checkGetIdWhenNotRegistered(org.apache.jackrabbit.oak.plugins.blob.ClusterRepositoryInfoTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/ClusterRepositoryInfo.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/ClusterRepositoryInfo.java\nindex 7b5f4da..d2755eb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/ClusterRepositoryInfo.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/ClusterRepositoryInfo.java\n@@ -23,8 +23,11 @@\n import org.apache.jackrabbit.oak.spi.commit.CommitInfo;\n import org.apache.jackrabbit.oak.spi.commit.EmptyHook;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n+import org.apache.jackrabbit.oak.spi.state.NodeState;\n import org.apache.jackrabbit.oak.spi.state.NodeStore;\n \n+import javax.annotation.CheckForNull;\n+\n /**\n  * Utility class to manage a unique cluster/repository id for the cluster.\n  */\n@@ -57,8 +60,13 @@ public static String createId(NodeStore store) throws CommitFailedException {\n      * @param store the NodeStore instance\n      * @return the repository id\n      */\n+    @CheckForNull\n     public static String getId(NodeStore store) {\n-        return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);\n+        NodeState state = store.getRoot().getChildNode(CLUSTER_CONFIG_NODE);\n+        if (state.hasProperty(CLUSTER_ID_PROP)) {\n+            return state.getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);\n+        }\n+        return null;\n     }\n }\n \n", "nb_test": 2012, "linesAdd": 9, "jira_id": "2691", "singleLine": false, "nb_skipped": 9, "commit": "d2da7499", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOrderLimitOffset(org.apache.jackrabbit.oak.query.UnionQueryTest): expected:<3> but was:<1>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java\nindex 90cb3ff..2f9bf8d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java\n@@ -91,13 +91,19 @@ public void setOrderings(OrderingImpl[] orderings) {\n     @Override\n     public void setLimit(long limit) {\n         this.limit = limit;\n-        left.setLimit(limit);\n-        right.setLimit(limit);\n+        applyLimitOffset();\n     }\n \n     @Override\n     public void setOffset(long offset) {\n         this.offset = offset;\n+        applyLimitOffset();\n+    }\n+\n+    private void applyLimitOffset() {\n+        long subqueryLimit = QueryImpl.saturatedAdd(limit, offset);\n+        left.setLimit(subqueryLimit);\n+        right.setLimit(subqueryLimit);\n     }\n \n     @Override\n", "nb_test": 2184, "linesAdd": 8, "jira_id": "3013", "singleLine": false, "nb_skipped": 9, "commit": "eabb4066", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRemoveMissingProperty(org.apache.jackrabbit.oak.jcr.CRUDTest): removing a missing property should fail", "testRemoveBySetProperty(org.apache.jackrabbit.oak.jcr.CRUDTest)"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex c3ff7d6..c1114a7 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -302,19 +302,20 @@ public Property setProperty(String name, Value value) throws RepositoryException\n      * @see Node#setProperty(String, javax.jcr.Value, int)\n      */\n     @Override\n-    @CheckForNull\n+    @Nonnull\n     public Property setProperty(final String jcrName, final Value value, final int type)\n             throws RepositoryException {\n         checkStatus();\n \n-        return sessionDelegate.perform(new SessionOperation<PropertyImpl>() {\n+        return sessionDelegate.perform(new SessionOperation<Property>() {\n             @Override\n-            public PropertyImpl perform() throws RepositoryException {\n-                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n+            public Property perform() throws RepositoryException {\n                 if (value == null) {\n-                    dlg.removeProperty(oakName);\n-                    return null;\n+                    Property property = getProperty(jcrName);\n+                    property.remove();\n+                    return property;\n                 } else {\n+                    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n                     int targetType = getTargetType(value, type);\n                     Value targetValue =\n                             ValueHelper.convert(value, targetType, getValueFactory());\n", "nb_test": 331, "linesAdd": 7, "jira_id": "395", "singleLine": false, "nb_skipped": 4, "commit": "4ed7bc8e", "nb_failure": 2, "linesRem": 6}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBinaryPropertyFromExternalSegmentStore(org.apache.jackrabbit.oak.segment.RecordTest): OAK-4307 SegmentWriter saves references to external blobs"], "patch": "diff --git a/oak-segment-next/src/main/java/org/apache/jackrabbit/oak/segment/SegmentWriter.java b/oak-segment-next/src/main/java/org/apache/jackrabbit/oak/segment/SegmentWriter.java\nindex b2f44f2..ee320ed 100644\n--- a/oak-segment-next/src/main/java/org/apache/jackrabbit/oak/segment/SegmentWriter.java\n+++ b/oak-segment-next/src/main/java/org/apache/jackrabbit/oak/segment/SegmentWriter.java\n@@ -608,8 +608,20 @@ private RecordId writeStream(InputStream stream) throws IOException {\n             boolean threw = true;\n             try {\n                 RecordId id = SegmentStream.getRecordIdIfAvailable(stream, store);\n-                if (id == null || isOldGen(id)) {\n+                if (id == null) {\n+                    // This is either not a segment stream or a one from another store:\n+                    // fully serialise the stream.\n                     id = internalWriteStream(stream);\n+                } else if (isOldGen(id)) {\n+                    // This is a segment stream from this store but from an old generation:\n+                    // try to link to the blocks if there are any.\n+                    SegmentStream segmentStream = (SegmentStream) stream;\n+                    List<RecordId> blockIds = segmentStream.getBlockIds();\n+                    if (blockIds == null) {\n+                        return internalWriteStream(stream);\n+                    } else {\n+                        return writeValueRecord(segmentStream.getLength(), writeList(blockIds));\n+                    }\n                 }\n                 threw = false;\n                 return id;\n@@ -619,14 +631,6 @@ private RecordId writeStream(InputStream stream) throws IOException {\n         }\n \n         private RecordId internalWriteStream(InputStream stream) throws IOException {\n-            if (stream instanceof SegmentStream) {\n-                SegmentStream segmentStream = (SegmentStream) stream;\n-                List<RecordId> blockIds = segmentStream.getBlockIds();\n-                if (blockIds != null) {\n-                    return writeValueRecord(segmentStream.getLength(), writeList(blockIds));\n-                }\n-            }\n-\n             // Special case for short binaries (up to about 16kB):\n             // store them directly as small- or medium-sized value records\n             byte[] data = new byte[Segment.MEDIUM_LIMIT];\n", "nb_test": 136, "linesAdd": 9, "jira_id": "4307", "singleLine": false, "nb_skipped": 2, "commit": "f303c916", "nb_failure": 1, "linesRem": 9}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMembershipForExistingForeignGroup(org.apache.jackrabbit.oak.spi.security.authentication.external.basic.DefaultSyncContextTest)"], "patch": "diff --git a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/basic/DefaultSyncContext.java b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/basic/DefaultSyncContext.java\nindex 7d78159..1218fb7 100644\n--- a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/basic/DefaultSyncContext.java\n+++ b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/basic/DefaultSyncContext.java\n@@ -531,10 +531,10 @@ protected void syncMembership(@Nonnull ExternalIdentity external, @Nonnull Autho\n             if (a == null) {\n                 grp = createGroup(extGroup);\n                 log.debug(\"- created new group\");\n-            } else if (a.isGroup()) {\n+            } else if (a.isGroup() && isSameIDP(a)) {\n                 grp = (Group) a;\n             } else {\n-                log.warn(\"Authorizable '{}' is not a group, but should be one.\", extGroup.getId());\n+                log.warn(\"Existing authorizable '{}' is not a group from this IDP '{}'.\", extGroup.getId(), idp.getName());\n                 continue;\n             }\n             log.debug(\"- user manager returned '{}'\", grp);\n", "nb_test": 271, "linesAdd": 2, "jira_id": "4397", "singleLine": false, "nb_skipped": 2, "commit": "e33516d5", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["costPerEntryForOlderVersion(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest): expected:<1.5> but was:<1.0>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\nindex 99018c5..ed96808 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n@@ -270,7 +270,7 @@ public IndexDefinition(NodeState root, NodeState defn, @Nullable NodeBuilder def\n         }\n \n         this.maxFieldLength = getOptionalValue(defn, LuceneIndexConstants.MAX_FIELD_LENGTH, DEFAULT_MAX_FIELD_LENGTH);\n-        this.costPerEntry = getOptionalValue(defn, LuceneIndexConstants.COST_PER_ENTRY, 1.0);\n+        this.costPerEntry = getOptionalValue(defn, LuceneIndexConstants.COST_PER_ENTRY, getDefaultCostPerEntry(version));\n         this.costPerExecution = getOptionalValue(defn, LuceneIndexConstants.COST_PER_EXECUTION, 1.0);\n         this.indexesAllTypes = areAllTypesIndexed();\n         this.analyzers = collectAnalyzers(defn);\n@@ -1512,4 +1512,10 @@ public boolean getActiveDeleteEnabled() {\n         return activeDelete >= 0;\n     }\n \n+    private static double getDefaultCostPerEntry(IndexFormatVersion version) {\n+        //For older format cost per entry would be higher as it does a runtime\n+        //aggregation\n+        return version == IndexFormatVersion.V1 ?  1.5 : 1.0;\n+    }\n+\n }\n", "nb_test": 359, "linesAdd": 5, "jira_id": "4300", "singleLine": false, "nb_skipped": 6, "commit": "06c367af", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["getNext(org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest): the highest available lane is expected expected:<[d]> but was:<[]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\nindex 0fd121c..3f78b78 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n@@ -1021,8 +1021,11 @@ static String getPropertyNext(@Nonnull final NodeState state, final int lane) {\n         String next = \"\";\n         PropertyState ps = state.getProperty(NEXT);\n         if (ps != null) {\n-            next = (lane < OrderedIndex.LANES) ? ps.getValue(Type.STRING, lane)\n-                                               : \"\";\n+            if (ps.isArray()) {\n+                next = ps.getValue(Type.STRING, Math.min(ps.count() - 1, lane));\n+            } else {\n+                next = ps.getValue(Type.STRING);\n+            }\n         }\n         return next;\n     }\n", "nb_test": 1809, "linesAdd": 5, "jira_id": "1899", "singleLine": false, "nb_skipped": 9, "commit": "b6f89048", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testStringPrimaryType(org.apache.jackrabbit.oak.plugins.segment.RecordTest)", "testStringMixinTypes(org.apache.jackrabbit.oak.plugins.segment.RecordTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\nindex fe5221b..9eb6cd9 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\n@@ -116,10 +116,14 @@ public boolean hasProperty(String name) {\n     public PropertyState getProperty(String name) {\n         checkNotNull(name);\n         Template template = getTemplate();\n+        PropertyState property = null;\n         if (JCR_PRIMARYTYPE.equals(name)) {\n-            return template.getPrimaryType();\n+            property = template.getPrimaryType();\n         } else if (JCR_MIXINTYPES.equals(name)) {\n-            return template.getMixinTypes();\n+            property = template.getMixinTypes();\n+        }\n+        if (property != null) {\n+            return property;\n         }\n \n         PropertyTemplate propertyTemplate =\n", "nb_test": 1811, "linesAdd": 6, "jira_id": "1916", "singleLine": false, "nb_skipped": 9, "commit": "705ce1d1", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["xpath(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/xpath.txt don't match expected results in src/test/resources/xpath.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\nindex 91a257b..3cf0717 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n@@ -516,7 +516,7 @@ private Expression parsePropertyOrFunction() throws ParseException {\n         boolean isPath = false;\n         while (true) {\n             if (currentTokenType == IDENTIFIER) {\n-                String name = readIdentifier();\n+                String name = readPathSegment();\n                 buff.append(name);\n             } else if (readIf(\"*\")) {\n                 // any node\n@@ -533,7 +533,7 @@ private Expression parsePropertyOrFunction() throws ParseException {\n                     // xpath supports @*, even thought jackrabbit may not\n                     buff.append('*');\n                 } else {\n-                    buff.append(readIdentifier());\n+                    buff.append(readPathSegment());\n                 }\n                 return new Expression.Property(currentSelector, buff.toString());\n             } else {\n@@ -649,7 +649,7 @@ private void read(String expected) throws ParseException {\n         if (readIf(\"*\")) {\n             return new Expression.Property(currentSelector, \"*\");\n         }\n-        return new Expression.Property(currentSelector, readIdentifier());\n+        return new Expression.Property(currentSelector, readPathSegment());\n     }\n     \n     private void readExcerpt() throws ParseException {\n", "nb_test": 1517, "linesAdd": 3, "jira_id": "1308", "singleLine": false, "nb_skipped": 6, "commit": "69ba2a54", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBlobSerialization(org.apache.jackrabbit.oak.plugins.document.BlobTest): expected:<0> but was:<1>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 36b242a..cc5ea66 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -280,7 +280,17 @@ public String serialize(Blob blob) {\n             if (blob instanceof BlobStoreBlob) {\n                 return ((BlobStoreBlob) blob).getBlobId();\n             }\n+\n             String id;\n+\n+            String reference = blob.getReference();\n+            if(reference != null){\n+                id = blobStore.getBlobId(reference);\n+                if(id != null){\n+                    return id;\n+                }\n+            }\n+\n             try {\n                 id = createBlob(blob.getNewStream()).getBlobId();\n             } catch (IOException e) {\n", "nb_test": 1844, "linesAdd": 10, "jira_id": "1761", "singleLine": false, "nb_skipped": 9, "commit": "f37ce716", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFlushBlocks(org.apache.jackrabbit.oak.segment.SegmentBufferWriterPoolTest): expected:<fcbb243d-00b9-4678-aa83-e97c9740d410.ffea> but was:<null>"], "patch": "diff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java\nindex c035323..610b3ca 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java\n@@ -34,6 +34,8 @@\n import javax.annotation.Nonnull;\n \n import com.google.common.base.Supplier;\n+import com.google.common.util.concurrent.Monitor;\n+import com.google.common.util.concurrent.Monitor.Guard;\n \n /**\n  * This {@link WriteOperationHandler} uses a pool of {@link SegmentBufferWriter}s,\n@@ -43,8 +45,27 @@\n  * {@link SegmentWriter}.\n  */\n public class SegmentBufferWriterPool implements WriteOperationHandler {\n+\n+    /**\n+     * Monitor protecting the state of this pool. Neither of {@link #writers},\n+     * {@link #borrowed} and {@link #disposed} must be modified without owning\n+     * this monitor.\n+     */\n+    private final Monitor poolMonitor = new Monitor(true);\n+\n+    /**\n+     * Pool of current writers that are not in use\n+     */\n     private final Map<Object, SegmentBufferWriter> writers = newHashMap();\n+\n+    /**\n+     * Writers that are currently in use\n+     */\n     private final Set<SegmentBufferWriter> borrowed = newHashSet();\n+\n+    /**\n+     * Retired writers that have not yet been flushed\n+     */\n     private final Set<SegmentBufferWriter> disposed = newHashSet();\n \n     @Nonnull\n@@ -95,21 +116,82 @@ public RecordId execute(WriteOperation writeOperation) throws IOException {\n     @Override\n     public void flush() throws IOException {\n         List<SegmentBufferWriter> toFlush = newArrayList();\n-        synchronized (this) {\n+        List<SegmentBufferWriter> toReturn = newArrayList();\n+\n+        poolMonitor.enter();\n+        try {\n+            // Collect all writers that are not currently in use and clear\n+            // the list so they won't get re-used anymore.\n             toFlush.addAll(writers.values());\n-            toFlush.addAll(disposed);\n             writers.clear();\n-            disposed.clear();\n+\n+            // Collect all borrowed writers, which we need to wait for.\n+            // Clear the list so they will get disposed once returned.\n+            toReturn.addAll(borrowed);\n             borrowed.clear();\n+        } finally {\n+            poolMonitor.leave();\n+        }\n+\n+        // Wait for the return of the borrowed writers. This is the\n+        // case once all of them appear in the disposed set.\n+        if (safeEnterWhen(poolMonitor, allReturned(toReturn))) {\n+            try {\n+                // Collect all disposed writers and clear the list to mark them\n+                // as flushed.\n+                toFlush.addAll(toReturn);\n+                disposed.removeAll(toReturn);\n+            } finally {\n+                poolMonitor.leave();\n+            }\n         }\n-        // Call flush from outside a synchronized context to avoid\n+\n+        // Call flush from outside the pool monitor to avoid potential\n         // deadlocks of that method calling SegmentStore.writeSegment\n         for (SegmentBufferWriter writer : toFlush) {\n             writer.flush();\n         }\n     }\n \n-    private synchronized SegmentBufferWriter borrowWriter(Object key) {\n+    /**\n+     * Create a {@code Guard} that is satisfied if and only if {@link #disposed}\n+     * contains all items in {@code toReturn}\n+     */\n+    @Nonnull\n+    private Guard allReturned(final List<SegmentBufferWriter> toReturn) {\n+        return new Guard(poolMonitor) {\n+\n+            @Override\n+            public boolean isSatisfied() {\n+                return disposed.containsAll(toReturn);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Same as {@code monitor.enterWhen(guard)} but copes with that pesky {@code\n+     * InterruptedException} by catching it and setting this thread's\n+     * interrupted flag.\n+     */\n+    private static boolean safeEnterWhen(Monitor monitor, Guard guard) {\n+        try {\n+            monitor.enterWhen(guard);\n+            return true;\n+        } catch (InterruptedException ignore) {\n+            Thread.currentThread().interrupt();\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Return a writer from the pool by its {@code key}. This method may return\n+     * a fresh writer at any time. Callers need to return a writer before\n+     * borrowing it again. Failing to do so leads to undefined behaviour.\n+     */\n+    private SegmentBufferWriter borrowWriter(Object key) {\n+        poolMonitor.enter();\n+        try {\n             SegmentBufferWriter writer = writers.remove(key);\n             if (writer == null) {\n                 writer = new SegmentBufferWriter(store, tracker, reader, version, getWriterId(wid), gcGeneration.get());\n@@ -119,15 +201,27 @@ private synchronized SegmentBufferWriter borrowWriter(Object key) {\n             }\n             borrowed.add(writer);\n             return writer;\n+        } finally {\n+            poolMonitor.leave();\n+        }\n     }\n \n-    private synchronized void returnWriter(Object key, SegmentBufferWriter writer) {\n+    /**\n+     * Return a writer to the pool using the {@code key} that was used to borrow\n+     * it.\n+     */\n+    private void returnWriter(Object key, SegmentBufferWriter writer) {\n+        poolMonitor.enter();\n+        try {\n             if (borrowed.remove(writer)) {\n                 checkState(writers.put(key, writer) == null);\n             } else {\n                 // Defer flush this writer as it was borrowed while flush() was called.\n                 disposed.add(writer);\n             }\n+        } finally {\n+            poolMonitor.leave();\n+        }\n     }\n \n     private String getWriterId(String wid) {\ndiff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java\nindex 1a585c0..b122a0a 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java\n@@ -58,9 +58,6 @@\n \n     /**\n      * Flush any pending changes on any {@link SegmentBufferWriter} managed by this instance.\n-     * This method <em>does not block</em> to wait for concurrent write operations. However, if\n-     * a write operation is currently in progress a call to this method ensures the respective\n-     * changes are properly flushed at the end of that call.\n      * @throws IOException\n      */\n     void flush() throws IOException;\n", "nb_test": 144, "linesAdd": 59, "jira_id": "4291", "singleLine": false, "nb_skipped": 1, "commit": "cdb34ffc", "nb_failure": 1, "linesRem": 5}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["journalEntryKey(org.apache.jackrabbit.oak.plugins.document.JournalTest): Background update did not create a journal entry with id 2-0000015633e073f8-00000006"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex b4aae75..2c72ff4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -2084,9 +2084,9 @@ private void backgroundSplit() {\n     BackgroundWriteStats backgroundWrite() {\n         return unsavedLastRevisions.persist(this, new UnsavedModifications.Snapshot() {\n             @Override\n-            public void acquiring() {\n+            public void acquiring(Revision mostRecent) {\n                 if (store.create(JOURNAL,\n-                        singletonList(changes.asUpdateOp(getHeadRevision())))) {\n+                        singletonList(changes.asUpdateOp(mostRecent)))) {\n                     changes = JOURNAL.newDocument(getDocumentStore());\n                 }\n             }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\nindex 69e8fe7..25f0390 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n@@ -235,7 +235,7 @@ public int recover(Iterator<NodeDocument> suspects,\n             unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {\n \n                 @Override\n-                public void acquiring() {\n+                public void acquiring(Revision mostRecent) {\n                     if (lastRootRev == null) {\n                         // this should never happen - when unsaved has no changes\n                         // that is reflected in the 'map' to be empty - in that\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java\nindex d5f6c1e..1d06fa7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java\n@@ -159,7 +159,7 @@ public BackgroundWriteStats persist(@Nonnull DocumentNodeStore store,\n         time = clock.getTime();\n         Map<String, Revision> pending;\n         try {\n-            snapshot.acquiring();\n+            snapshot.acquiring(getMostRecentRevision());\n             pending = Maps.newTreeMap(PathComparator.INSTANCE);\n             pending.putAll(map);\n         } finally {\n@@ -234,14 +234,26 @@ public String toString() {\n         return map.toString();\n     }\n \n+    private Revision getMostRecentRevision() {\n+        // use revision of root document\n+        Revision rev = map.get(\"/\");\n+        // otherwise find most recent\n+        if (rev == null) {\n+            for (Revision r : map.values()) {\n+                rev = Utils.max(rev, r);\n+            }\n+        }\n+        return rev;\n+    }\n+\n     public interface Snapshot {\n \n         Snapshot IGNORE = new Snapshot() {\n             @Override\n-            public void acquiring() {\n+            public void acquiring(Revision mostRecent) {\n             }\n         };\n \n-        void acquiring();\n+        void acquiring(Revision mostRecent);\n     }\n }\n", "nb_test": 2438, "linesAdd": 16, "jira_id": "3433", "singleLine": false, "nb_skipped": 1, "commit": "b76b31f7", "nb_failure": 1, "linesRem": 6}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 4, "classification": {"singleLine": false}, "failing_tests": ["getNodeSNS[0](org.apache.jackrabbit.oak.jcr.RepositoryTest): Invalid name or path: /foo[1]/bar[2]", "getNodeSNS[3](org.apache.jackrabbit.oak.jcr.RepositoryTest): Invalid name or path: /foo[1]/bar[2]", "getNodeSNS[2](org.apache.jackrabbit.oak.jcr.RepositoryTest): Invalid name or path: /foo[1]/bar[2]", "getNodeSNS[1](org.apache.jackrabbit.oak.jcr.RepositoryTest): Invalid name or path: /foo[1]/bar[2]"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionContext.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionContext.java\nindex dff9421..86ca4bd 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionContext.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionContext.java\n@@ -328,8 +328,14 @@ public String getOakPathOrThrow(String jcrPath) throws RepositoryException {\n         if (oakPath != null) {\n             return oakPath;\n         } else {\n+            // check if the path is an SNS path with an index > 1 and throw a PathNotFoundException instead (see OAK-1216)\n+            if (getOakPathKeepIndex(jcrPath) != null) {\n+                throw new PathNotFoundException(jcrPath);\n+            } else {\n                 throw new RepositoryException(\"Invalid name or path: \" + jcrPath);\n             }\n+\n+        }\n     }\n \n     /**\n", "nb_test": 1963, "linesAdd": 5, "jira_id": "1216", "singleLine": false, "nb_skipped": 5, "commit": "e403e003", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["versionablePathHook(org.apache.jackrabbit.oak.plugins.document.VisibleChangesTest): Must not query for hidden paths: [2:/:hidden/] expected:<0> but was:<1>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionablePathHook.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionablePathHook.java\nindex 9369dde..132296a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionablePathHook.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionablePathHook.java\n@@ -37,6 +37,7 @@\n import org.apache.jackrabbit.oak.spi.state.DefaultNodeStateDiff;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.apache.jackrabbit.oak.spi.state.NodeStateUtils;\n \n import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.EMPTY_NODE;\n \n@@ -108,6 +109,10 @@ public boolean childNodeAdded(String name, NodeState after) {\n         @Override\n         public boolean childNodeChanged(\n                 String name, NodeState before, NodeState after) {\n+            if (NodeStateUtils.isHidden(name)) {\n+                // stop comparison\n+                return false;\n+            }\n             Node node = new Node(nodeAfter, name);\n             return after.compareAgainstBaseState(\n                     before, new Diff(versionManager, node, exceptions));\n@@ -117,7 +122,8 @@ private boolean setVersionablePath(PropertyState after) {\n             if (JcrConstants.JCR_VERSIONHISTORY.equals(after.getName()) && nodeAfter.isVersionable(versionManager)) {\n                 NodeBuilder vhBuilder;\n                 try {\n-                    vhBuilder = versionManager.getOrCreateVersionHistory(nodeAfter.builder, Collections.EMPTY_MAP);\n+                    vhBuilder = versionManager.getOrCreateVersionHistory(\n+                            nodeAfter.builder, Collections.<String, Object>emptyMap());\n                 } catch (CommitFailedException e) {\n                     exceptions.add(e);\n                     // stop further comparison\n", "nb_test": 2166, "linesAdd": 6, "jira_id": "3019", "singleLine": false, "nb_skipped": 9, "commit": "5135cf4b", "nb_failure": 1, "linesRem": 1}, {"files": 4, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["resetMultipleCommits(org.apache.jackrabbit.oak.plugins.document.DocumentMKResetTest): expected:<0> but was:<1>", "resetToBaseOfBranch(org.apache.jackrabbit.oak.plugins.document.DocumentMKResetTest): org.apache.jackrabbit.oak.plugins.document.DocumentStoreException: br156331b8f5e-1-1 is not an ancestor revision of br156331b8f5f-0-1", "resetRemovesCommitRootOnParent(org.apache.jackrabbit.oak.plugins.document.DocumentMKResetTest): org.apache.jackrabbit.oak.plugins.document.DocumentStoreException: br156331b8f70-1-1 is not an ancestor revision of br156331b8f71-0-1"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\nindex 8643bf7..7fb76bb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n@@ -335,7 +335,7 @@ public String reset(@Nonnull String branchRevisionId,\n             throw new DocumentStoreException(\"Not a branch revision: \" + ancestorRevisionId);\n         }\n         try {\n-            return nodeStore.reset(branch, ancestor, null).toString();\n+            return nodeStore.reset(branch, ancestor).toString();\n         } catch (DocumentStoreException e) {\n             throw new DocumentStoreException(e);\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex fcc6bf9..14e608f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -22,6 +22,8 @@\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.toArray;\n import static com.google.common.collect.Iterables.transform;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static com.google.common.collect.Lists.reverse;\n import static java.util.Collections.singletonList;\n import static org.apache.jackrabbit.oak.commons.PathUtils.concat;\n import static org.apache.jackrabbit.oak.plugins.document.Collection.JOURNAL;\n@@ -81,6 +83,7 @@\n import org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob;\n import org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector;\n import org.apache.jackrabbit.oak.plugins.blob.ReferencedBlob;\n+import org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit;\n import org.apache.jackrabbit.oak.plugins.document.cache.CacheInvalidationStats;\n import org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache;\n import org.apache.jackrabbit.oak.plugins.document.persistentCache.broadcast.DynamicBroadcastConfig;\n@@ -1249,8 +1252,7 @@ RevisionVector rebase(@Nonnull RevisionVector branchHead,\n \n     @Nonnull\n     RevisionVector reset(@Nonnull RevisionVector branchHead,\n-                         @Nonnull RevisionVector ancestor,\n-                         @Nullable DocumentNodeStoreBranch branch) {\n+                         @Nonnull RevisionVector ancestor) {\n         checkNotNull(branchHead);\n         checkNotNull(ancestor);\n         Branch b = getBranches().getBranch(branchHead);\n@@ -1261,61 +1263,44 @@ RevisionVector reset(@Nonnull RevisionVector branchHead,\n             throw new DocumentStoreException(branchHead + \" is not the head \" +\n                     \"of a branch\");\n         }\n-        if (!b.containsCommit(ancestor.getBranchRevision())) {\n+        if (!b.containsCommit(ancestor.getBranchRevision())\n+                && !b.getBase().asBranchRevision(getClusterId()).equals(ancestor)) {\n             throw new DocumentStoreException(ancestor + \" is not \" +\n                     \"an ancestor revision of \" + branchHead);\n         }\n-        if (branchHead.equals(ancestor)) {\n+        // tailSet is inclusive -> use an ancestorRev with a\n+        // counter incremented by one to make the call exclusive\n+        Revision ancestorRev = ancestor.getBranchRevision();\n+        ancestorRev = new Revision(ancestorRev.getTimestamp(),\n+                ancestorRev.getCounter() + 1, ancestorRev.getClusterId(), true);\n+        List<Revision> revs = newArrayList(b.getCommits().tailSet(ancestorRev));\n+        if (revs.isEmpty()) {\n             // trivial\n             return branchHead;\n         }\n-        boolean success = false;\n-        Commit commit = newCommit(branchHead, branch);\n-        try {\n-            Iterator<Revision> it = b.getCommits().tailSet(ancestor.getBranchRevision()).iterator();\n-            // first revision is the ancestor (tailSet is inclusive)\n-            // do not undo changes for this revision\n-            it.next();\n+        UpdateOp rootOp = new UpdateOp(Utils.getIdFromPath(\"/\"), false);\n+        // reset each branch commit in reverse order\n         Map<String, UpdateOp> operations = Maps.newHashMap();\n-            if (it.hasNext()) {\n-                Revision reset = it.next();\n-                // TODO: correct?\n-                getRoot(b.getCommit(reset).getBase().update(reset))\n-                        .compareAgainstBaseState(getRoot(ancestor),\n-                                new ResetDiff(reset.asTrunkRevision(), operations));\n-                UpdateOp rootOp = operations.get(\"/\");\n-                if (rootOp == null) {\n-                    rootOp = new UpdateOp(Utils.getIdFromPath(\"/\"), false);\n-                    NodeDocument.setModified(rootOp, commit.getRevision());\n-                    operations.put(\"/\", rootOp);\n-                }\n-                NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());\n-                NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());\n-            }\n-            // update root document first\n-            if (store.findAndUpdate(Collection.NODES, operations.get(\"/\")) != null) {\n-                // clean up in-memory branch data\n-                // first revision is the ancestor (tailSet is inclusive)\n-                List<Revision> revs = Lists.newArrayList(b.getCommits().tailSet(ancestor.getBranchRevision()));\n-                for (Revision r : revs.subList(1, revs.size())) {\n-                    b.removeCommit(r);\n-                }\n-                // successfully updating the root document can be considered\n-                // as success because the changes are not marked as committed\n-                // anymore\n-                success = true;\n+        for (Revision r : reverse(revs)) {\n+            NodeDocument.removeCollision(rootOp, r.asTrunkRevision());\n+            NodeDocument.removeRevision(rootOp, r.asTrunkRevision());\n+            operations.clear();\n+            BranchCommit bc = b.getCommit(r);\n+            if (bc.isRebase()) {\n+                continue;\n             }\n-            operations.remove(\"/\");\n-            // update remaining documents\n+            getRoot(bc.getBase().update(r))\n+                    .compareAgainstBaseState(getRoot(bc.getBase()),\n+                            new ResetDiff(r.asTrunkRevision(), operations));\n+            // apply reset operations\n             for (UpdateOp op : operations.values()) {\n                 store.findAndUpdate(Collection.NODES, op);\n             }\n-        } finally {\n-            if (!success) {\n-                canceled(commit);\n-            } else {\n-                done(commit, true, null);\n         }\n+        store.findAndUpdate(Collection.NODES, rootOp);\n+        // clean up in-memory branch data\n+        for (Revision r : revs) {\n+            b.removeCommit(r);\n         }\n         return ancestor;\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java\nindex 4a02213..6e99422 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java\n@@ -620,8 +620,7 @@ private void resetBranch(DocumentNodeState branchHead, DocumentNodeState ancesto\n             try {\n                 head = store.getRoot(\n                         store.reset(branchHead.getRevision(), \n-                                ancestor.getRevision(), \n-                                DocumentNodeStoreBranch.this));\n+                                ancestor.getRevision()));\n             } catch (Exception e) {\n                 CommitFailedException ex = new CommitFailedException(\n                         OAK, 100, \"Branch reset failed\", e);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java\nindex 239928f..cc08635 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java\n@@ -74,6 +74,7 @@ public boolean propertyDeleted(PropertyState before) {\n \n     @Override\n     public boolean childNodeAdded(String name, NodeState after) {\n+        NodeDocument.removeCommitRoot(getUpdateOp(), revision);\n         String p = PathUtils.concat(path, name);\n         ResetDiff diff = new ResetDiff(revision, p, operations);\n         UpdateOp op = diff.getUpdateOp();\n", "nb_test": 3065, "linesAdd": 28, "jira_id": "3897", "singleLine": false, "nb_skipped": 1, "commit": "94c6c575", "nb_failure": 1, "linesRem": 38}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["emptyIndex(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): (..)"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\nindex 5277652..e13e7ef 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n@@ -38,6 +38,7 @@\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.plugins.index.IndexEditor;\n import org.apache.jackrabbit.oak.plugins.index.IndexUpdateCallback;\n+import org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState;\n import org.apache.jackrabbit.oak.plugins.nodetype.TypePredicate;\n import org.apache.jackrabbit.oak.spi.commit.Editor;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n@@ -122,6 +123,9 @@ public String getPath() {\n     @Override\n     public void enter(NodeState before, NodeState after)\n             throws CommitFailedException {\n+        if (EmptyNodeState.MISSING_NODE == before && parent == null){\n+            context.enableReindexMode();\n+        }\n     }\n \n     @Override\ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\nindex 686db73..a25bc41 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n@@ -101,6 +101,8 @@ private static Directory newIndexDirectory(NodeBuilder definition)\n \n     private final IndexUpdateCallback updateCallback;\n \n+    private boolean reindex;\n+\n     LuceneIndexEditorContext(NodeBuilder definition, Analyzer analyzer, IndexUpdateCallback updateCallback) {\n         this.definitionBuilder = definition;\n         this.definition = new IndexDefinition(definitionBuilder);\n@@ -132,6 +134,14 @@ IndexWriter getWriter() throws IOException {\n      * close writer if it's not null\n      */\n     void closeWriter() throws IOException {\n+        //If reindex or fresh index and write is null on close\n+        //it indicates that the index is empty. In such a case trigger\n+        //creation of write such that an empty Lucene index state is persisted\n+        //in directory\n+        if (reindex && writer == null){\n+            getWriter();\n+        }\n+\n         if (writer != null) {\n             writer.close();\n \n@@ -144,6 +154,10 @@ void closeWriter() throws IOException {\n         }\n     }\n \n+    public void enableReindexMode(){\n+        reindex = true;\n+    }\n+\n     public long incIndexedNodes() {\n         indexedNodes++;\n         return indexedNodes;\n", "nb_test": 301, "linesAdd": 14, "jira_id": "2235", "singleLine": false, "nb_skipped": 1, "commit": "29d3d8f1", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ignoreByType(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexExclusionQueryTest): Result set size is different expected:<1> but was:<0>", "ignoreByName(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexExclusionQueryTest): Result set size is different expected:<1> but was:<0>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex 6d8e111..c589260 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -28,6 +28,8 @@\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.TYPE_PROPERTY_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.PATH;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.PATH_SELECTOR;\n+import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.EXCLUDE_PROPERTY_NAMES;\n+import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.INCLUDE_PROPERTY_TYPES;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.INDEX_DATA_CHILD_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.PERSISTENCE_FILE;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.PERSISTENCE_NAME;\n@@ -56,6 +58,8 @@\n import java.util.Set;\n import java.util.concurrent.atomic.AtomicReference;\n \n+import javax.jcr.PropertyType;\n+\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.plugins.index.aggregate.NodeAggregator;\n import org.apache.jackrabbit.oak.plugins.index.lucene.util.MoreLikeThisHelper;\n@@ -67,11 +71,11 @@\n import org.apache.jackrabbit.oak.query.fulltext.FullTextTerm;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextVisitor;\n import org.apache.jackrabbit.oak.spi.query.Cursor;\n-import org.apache.jackrabbit.oak.spi.query.Filter;\n-import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n import org.apache.jackrabbit.oak.spi.query.Cursors.PathCursor;\n+import org.apache.jackrabbit.oak.spi.query.Filter;\n import org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction;\n import org.apache.jackrabbit.oak.spi.query.IndexRow;\n+import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n import org.apache.jackrabbit.oak.spi.query.QueryIndex;\n import org.apache.jackrabbit.oak.spi.query.QueryIndex.FulltextQueryIndex;\n import org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;\n@@ -329,7 +333,7 @@ public String getPlan(Filter filter, NodeState root) {\n         // we only restrict non-full-text conditions if there is\n         // no relative property in the full-text constraint\n         boolean nonFullTextConstraints = parent.isEmpty();\n-        String plan = getQuery(filter, null, nonFullTextConstraints, analyzer) + \" ft:(\" + ft + \")\";\n+        String plan = getQuery(filter, null, nonFullTextConstraints, analyzer, getIndexDef(root)) + \" ft:(\" + ft + \")\";\n         if (!parent.isEmpty()) {\n             plan += \" parent:\" + parent;\n         }\n@@ -363,7 +367,7 @@ public Cursor query(Filter filter, NodeState root) {\n                     IndexSearcher searcher = new IndexSearcher(reader);\n                     List<LuceneResultRow> rows = new ArrayList<LuceneResultRow>();\n                     Query query = getQuery(filter, reader,\n-                            nonFullTextConstraints, analyzer);\n+                            nonFullTextConstraints, analyzer, getIndexDef(root));\n \n                     // TODO OAK-828\n                     HashSet<String> seenPaths = new HashSet<String>();\n@@ -428,10 +432,11 @@ public Cursor query(Filter filter, NodeState root) {\n      *            path, node type, and so on) should be added to the Lucene\n      *            query\n      * @param analyzer the Lucene analyzer used for building the fulltext query\n+     * @param indexDefinition nodestate that contains the index definition\n      * @return the Lucene query\n      */\n     private static Query getQuery(Filter filter, IndexReader reader,\n-            boolean nonFullTextConstraints, Analyzer analyzer) {\n+            boolean nonFullTextConstraints, Analyzer analyzer, NodeState indexDefinition) {\n         List<Query> qs = new ArrayList<Query>();\n         FullTextExpression ft = filter.getFullTextConstraint();\n         if (ft == null) {\n@@ -461,9 +466,9 @@ private static Query getQuery(Filter filter, IndexReader reader,\n                     throw new RuntimeException(e);\n                 }\n             }\n-        }\n-        else if (nonFullTextConstraints) {\n-            addNonFullTextConstraints(qs, filter, reader, analyzer);\n+        } else if (nonFullTextConstraints) {\n+            addNonFullTextConstraints(qs, filter, reader, analyzer,\n+                    indexDefinition);\n         }\n         if (qs.size() == 0) {\n             return new MatchAllDocsQuery();\n@@ -479,7 +484,7 @@ else if (nonFullTextConstraints) {\n     }\n \n     private static void addNonFullTextConstraints(List<Query> qs,\n-            Filter filter, IndexReader reader, Analyzer analyzer) {\n+            Filter filter, IndexReader reader, Analyzer analyzer, NodeState indexDefinition) {\n         if (!filter.matchesAllTypes()) {\n             addNodeTypeConstraints(qs, filter);\n         }\n@@ -526,11 +531,12 @@ private static void addNonFullTextConstraints(List<Query> qs,\n                 continue;\n             }\n \n-            String name = pr.propertyName;\n-            if (name.contains(\"/\")) {\n-                // lucene cannot handle child-level property restrictions\n+            // check excluded properties and types\n+            if (isExcludedProperty(pr, indexDefinition)) {\n                 continue;\n             }\n+\n+            String name = pr.propertyName;\n             if (\"rep:excerpt\".equals(name)) {\n                 continue;\n             }\n@@ -617,6 +623,44 @@ private static String tokenizeAndPoll(String token, Analyzer analyzer){\n         return token;\n     }\n \n+    private static boolean isExcludedProperty(PropertyRestriction pr,\n+            NodeState definition) {\n+        String name = pr.propertyName;\n+        if (name.contains(\"/\")) {\n+            // lucene cannot handle child-level property restrictions\n+            return true;\n+        }\n+\n+        // check name\n+        for (String e : definition.getStrings(EXCLUDE_PROPERTY_NAMES)) {\n+            if (e.equalsIgnoreCase(name)) {\n+                return true;\n+            }\n+        }\n+\n+        // check type\n+        Integer type = null;\n+        if (pr.first != null) {\n+            type = pr.first.getType().tag();\n+        } else if (pr.last != null) {\n+            type = pr.last.getType().tag();\n+        } else if (pr.list != null && !pr.list.isEmpty()) {\n+            type = pr.list.get(0).getType().tag();\n+        }\n+        if (type != null) {\n+            boolean isIn = false;\n+            for (String e : definition.getStrings(INCLUDE_PROPERTY_TYPES)) {\n+                if (PropertyType.valueFromName(e) == type) {\n+                    isIn = true;\n+                }\n+            }\n+            if (!isIn) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     private static void addReferenceConstraint(String uuid, List<Query> qs,\n             IndexReader reader) {\n         if (reader == null) {\n", "nb_test": 257, "linesAdd": 51, "jira_id": "1668", "singleLine": false, "nb_skipped": 0, "commit": "63070cf9", "nb_failure": 2, "linesRem": 11}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["sql2(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest)", "sql2(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java\nindex d0b9245..090c265 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java\n@@ -110,7 +110,13 @@ public FullTextExpression getFullTextConstraint(SelectorImpl s) {\n         for (Entry<DynamicOperandImpl, Set<StaticOperandImpl>> e2 : m2.entrySet()) {\n             Set<StaticOperandImpl> s = result.get(e2.getKey());\n             if (s != null) {\n-                s.retainAll(e2.getValue());\n+                // OAK-1933\n+                // a property can have multiple values at the same time,\n+                // so that \"where a=1 and a=2\" needs to be kept and can not\n+                // be reduced to \"where false\" - in fact, we could \n+                // extend it to \"where a in (1, 2)\" so that an index can be used,\n+                // but we might as well keep it at \"where a = 1\" as that would\n+                // also use an index\n             } else {\n                 result.put(e2.getKey(), e2.getValue());\n             }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java\nindex a5cfe10..f3cf5ef 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java\n@@ -194,8 +194,8 @@\n         double getCostPerEntry();\n \n         /**\n-         * The estimated number of entries. This value does not have to be\n-         * accurate.\n+         * The estimated number of entries in the cursor that is returned by the query method,\n+         * when using this plan. This value does not have to be accurate.\n          * \n          * @return the estimated number of entries\n          */\n", "nb_test": 1841, "linesAdd": 0, "jira_id": "1933", "singleLine": true, "nb_skipped": 9, "commit": "2e16a983", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testChildNodesWithAccessCheck(org.apache.jackrabbit.oak.jcr.security.authorization.ReadTest)"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\nindex 16c3150..9cbfaf0 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\n@@ -338,7 +338,7 @@ public NodeDelegate getChild(String relPath) throws RepositoryException {\n                 filter(iterator, new Predicate<Tree>() {\n                     @Override\n                     public boolean apply(Tree tree) {\n-                        return !tree.getName().startsWith(\":\");\n+                        return tree.exists();\n                     }\n                 }),\n                 new Function<Tree, NodeDelegate>() {\n@@ -447,7 +447,6 @@ public void removeMixin(String typeName) throws RepositoryException {\n     /**\n      * Set a property\n      *\n-     * @param propertyState\n      * @return the set property\n      */\n     @Nonnull\n@@ -824,7 +823,7 @@ private Tree internalAddChild(\n     @Nonnull // FIXME this should be package private. OAK-672\n     public Tree getTree() throws InvalidItemStateException {\n         if (!tree.exists()) {\n-            throw new InvalidItemStateException(\"Item is stale\");\n+            throw new InvalidItemStateException(\"Item is stale \" + tree.getPath());\n         }\n         return tree;\n     }\n", "nb_test": 1589, "linesAdd": 2, "jira_id": "1081", "singleLine": false, "nb_skipped": 3, "commit": "4ce4e3c9", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testRandomOperations(org.apache.jackrabbit.oak.cache.ConcurrentTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\nindex 8392b7f..34ca662 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n@@ -619,7 +619,9 @@ public CacheStats stats() {\n         int queue2Size;\n \n         /**\n-         * The map array. The size is always a power of 2.\n+         * The map array. The size is always a power of 2. The bit mask that is\n+         * applied to the key hash code to get the index in the map array. The\n+         * mask is the length of the array minus one.\n          */\n         Entry<K, V>[] entries;\n \n@@ -657,12 +659,6 @@ public CacheStats stats() {\n         private int averageMemory;\n \n         /**\n-         * The bit mask that is applied to the key hash code to get the index in the\n-         * map array. The mask is the length of the array minus one.\n-         */\n-        private int mask;\n-\n-        /**\n          * The LIRS stack size.\n          */\n         private int stackSize;\n@@ -722,8 +718,6 @@ synchronized void clear() {\n             }\n             // the array size is at most 2^31 elements\n             int len = (int) Math.min(1L << 31, l);\n-            // the bit mask has all bits set\n-            mask = len - 1;\n \n             // initialize the stack and queue heads\n             stack = new Entry<K, V>();\n@@ -733,8 +727,10 @@ synchronized void clear() {\n             queue2 = new Entry<K, V>();\n             queue2.queuePrev = queue2.queueNext = queue2;\n \n-            // first set to null - avoiding out of memory\n-            entries = null;\n+            // first set to a small array, to avoiding out of memory\n+            @SuppressWarnings(\"unchecked\")\n+            Entry<K, V>[] small = new Entry[1];\n+            entries = small;\n             @SuppressWarnings(\"unchecked\")\n             Entry<K, V>[] e = new Entry[len];\n             entries = e;\n@@ -920,6 +916,10 @@ synchronized V putIfAbsent(K key, int hash, V value, int memory) {\n         }\n \n         synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\n+            if (loader == null) {\n+                // no loader - no refresh\n+                return;\n+            }            \n             V value;\n             V old = get(key, hash);\n             long start = System.nanoTime();\n@@ -968,9 +968,11 @@ synchronized V put(K key, int hash, V value, int memory) {\n             e.key = key;\n             e.value = value;\n             e.memory = memory;\n+            Entry<K, V>[] array = entries;\n+            int mask = array.length - 1;\n             int index = hash & mask;\n-            e.mapNext = entries[index];\n-            entries[index] = e;\n+            e.mapNext = array[index];\n+            array[index] = e;\n             usedMemory += memory;\n             if (usedMemory > maxMemory && mapSize > 0) {\n                 // an old entry needs to be removed\n@@ -990,13 +992,15 @@ synchronized V put(K key, int hash, V value, int memory) {\n          * @param hash the hash\n          */\n         synchronized void invalidate(Object key, int hash) {\n+            Entry<K, V>[] array = entries;\n+            int mask = array.length - 1;            \n             int index = hash & mask;\n-            Entry<K, V> e = entries[index];\n+            Entry<K, V> e = array[index];\n             if (e == null) {\n                 return;\n             }\n             if (e.key.equals(key)) {\n-                entries[index] = e.mapNext;\n+                array[index] = e.mapNext;\n             } else {\n                 Entry<K, V> last;\n                 do {\n@@ -1107,8 +1111,10 @@ private void pruneStack() {\n          * @return the entry (might be a non-resident)\n          */\n         Entry<K, V> find(Object key, int hash) {\n+            Entry<K, V>[] array = entries;\n+            int mask = array.length - 1;                \n             int index = hash & mask;\n-            Entry<K, V> e = entries[index];\n+            Entry<K, V> e = array[index];\n             while (e != null && !e.key.equals(key)) {\n                 e = e.mapNext;\n             }\n", "nb_test": 1564, "linesAdd": 17, "jira_id": "1364", "singleLine": false, "nb_skipped": 6, "commit": "b481a14c", "nb_failure": 0, "linesRem": 9}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testRandomOperations(org.apache.jackrabbit.oak.cache.ConcurrentTest): java.util.concurrent.ExecutionException: java.lang.NullPointerException"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\nindex 3356131..431d1f3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n@@ -154,11 +154,6 @@ public void invalidateAll() {\n         }\n     }\n \n-    private Entry<K, V> find(Object key) {\n-        int hash = getHash(key);\n-        return getSegment(hash).find(key, hash);\n-    }\n-\n     /**\n      * Check whether there is a resident entry for the given key. This\n      * method does not adjust the internal state of the cache.\n@@ -179,7 +174,8 @@ public boolean containsKey(Object key) {\n      * @return the value, or null if there is no resident entry\n      */\n     public V peek(K key) {\n-        Entry<K, V> e = find(key);\n+        int hash = getHash(key);\n+        Entry<K, V> e = getSegment(hash).find(key, hash);\n         return e == null ? null : e.value;\n     }\n \n@@ -459,7 +455,10 @@ public long getMaxMemory() {\n     public synchronized Set<Map.Entry<K, V>> entrySet() {\n         HashMap<K, V> map = new HashMap<K, V>();\n         for (K k : keySet()) {\n-            map.put(k,  find(k).value);\n+            V v = peek(k);\n+            if (v != null) {\n+                map.put(k,  v);\n+            }\n         }\n         return map.entrySet();\n     }\n@@ -467,7 +466,7 @@ public long getMaxMemory() {\n     protected Collection<V> values() {\n         ArrayList<V> list = new ArrayList<V>();\n         for (K k : keySet()) {\n-            V v = find(k).value;\n+            V v = peek(k);\n             if (v != null) {\n                 list.add(v);\n             }\n@@ -478,7 +477,7 @@ public long getMaxMemory() {\n     boolean containsValue(Object value) {\n         for (Segment<K, V> s : segments) {\n             for (K k : s.keySet()) {\n-                V v = find(k).value;\n+                V v = peek(k);\n                 if (v != null && v.equals(value)) {\n                     return true;\n                 }\n@@ -860,6 +859,9 @@ synchronized V get(K key, int hash, Callable<? extends V> valueLoader) throws Ex\n         synchronized V get(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\n             V value = get(key, hash);\n             if (value == null) {\n+                if (loader == null) {\n+                    return null;\n+                }\n                 long start = System.nanoTime();\n                 try {\n                     value = loader.load(key);\n@@ -1394,7 +1396,7 @@ public boolean containsValue(Object value) {\n             @SuppressWarnings(\"unchecked\")\n             @Override\n             public V get(Object key) {\n-                return CacheLIRS.this.getUnchecked((K) key);\n+                return CacheLIRS.this.peek((K) key);\n             }\n \n             @Override\n", "nb_test": 1562, "linesAdd": 12, "jira_id": "1364", "singleLine": false, "nb_skipped": 6, "commit": "05c89637", "nb_failure": 0, "linesRem": 10}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testPropertyCountSQL(org.apache.jackrabbit.core.query.SelectClauseTest)", "testPropertyCountSQL(org.apache.jackrabbit.core.query.SelectClauseTest)"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\nindex e337f39..e50d30d 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\n@@ -100,7 +100,7 @@ public Value getValue(String columnName) throws RepositoryException {\n         int len = values.length;\n         Value[] v2 = new Value[values.length];\n         for (int i = 0; i < len; i++) {\n-            if(values[i].isArray()){\n+            if (values[i] != null && values[i].isArray()) {\n                 v2[i] = result.createValue(mvpToString(values[i]));\n             } else {\n                 v2[i] = result.createValue(values[i]);\n", "nb_test": 1596, "linesAdd": 1, "jira_id": "1093", "singleLine": false, "nb_skipped": 3, "commit": "531aca78", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["verifyGroupNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberSplitUpgradeTest): Migrated group needs to be new node type", "verifyReplacedBuiltinNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Migrated repository must have new nodetype definitions", "verifyMemberOf(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberUpgradeTest): user TestUser-0 must be member of all groups expected:<0> but was:<2>", "verifyGroupNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberUpgradeTest): Migrated group needs to be new node type"], "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex 2734f3b..d29b8f5 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -22,6 +22,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Properties;\n+import java.util.Set;\n \n import javax.jcr.NamespaceException;\n import javax.jcr.NamespaceRegistry;\n@@ -38,8 +39,10 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.plugins.index.reference.ReferenceEditorProvider;\n+import org.apache.jackrabbit.oak.plugins.name.NamespaceConstants;\n import org.apache.jackrabbit.oak.plugins.name.Namespaces;\n import org.apache.jackrabbit.oak.plugins.nodetype.RegistrationEditorProvider;\n+import org.apache.jackrabbit.oak.plugins.nodetype.write.InitialContent;\n import org.apache.jackrabbit.oak.spi.commit.CommitHook;\n import org.apache.jackrabbit.oak.spi.commit.CompositeHook;\n import org.apache.jackrabbit.oak.spi.commit.EditorHook;\n@@ -58,6 +61,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.ImmutableSet;\n+\n import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.Lists.newArrayListWithCapacity;\n import static com.google.common.collect.Maps.newHashMap;\n@@ -119,6 +124,85 @@\n     private final NodeStore target;\n \n     /**\n+     * the set of oak built-in nodetypes\n+     * todo: load from file or from repo\n+     */\n+    private static final Set<String> BUILT_IN_NODE_TYPES = ImmutableSet.of(\n+            \"mix:created\",\n+            \"mix:etag\",\n+            \"mix:language\",\n+            \"mix:lastModified\",\n+            \"mix:lifecycle\",\n+            \"mix:lockable\",\n+            \"mix:mimeType\",\n+            \"mix:referenceable\",\n+            \"mix:shareable\",\n+            \"mix:simpleVersionable\",\n+            \"mix:title\",\n+            \"mix:versionable\",\n+            \"nt:activity\",\n+            \"nt:address\",\n+            \"nt:base\",\n+            \"nt:childNodeDefinition\",\n+            \"nt:configuration\",\n+            \"nt:file\",\n+            \"nt:folder\",\n+            \"nt:frozenNode\",\n+            \"nt:hierarchyNode\",\n+            \"nt:linkedFile\",\n+            \"nt:nodeType\",\n+            \"nt:propertyDefinition\",\n+            \"nt:query\",\n+            \"nt:resource\",\n+            \"nt:unstructured\",\n+            \"nt:version\",\n+            \"nt:versionHistory\",\n+            \"nt:versionLabels\",\n+            \"nt:versionedChild\",\n+            \"oak:childNodeDefinition\",\n+            \"oak:childNodeDefinitions\",\n+            \"oak:namedChildNodeDefinitions\",\n+            \"oak:namedPropertyDefinitions\",\n+            \"oak:nodeType\",\n+            \"oak:propertyDefinition\",\n+            \"oak:propertyDefinitions\",\n+            \"oak:queryIndexDefinition\",\n+            \"oak:unstructured\",\n+            \"rep:ACE\",\n+            \"rep:ACL\",\n+            \"rep:AccessControl\",\n+            \"rep:AccessControllable\",\n+            \"rep:Activities\",\n+            \"rep:Authorizable\",\n+            \"rep:AuthorizableFolder\",\n+            \"rep:Configurations\",\n+            \"rep:DenyACE\",\n+            \"rep:GrantACE\",\n+            \"rep:Group\",\n+            \"rep:Impersonatable\",\n+            \"rep:MemberReferences\",\n+            \"rep:MemberReferencesList\",\n+            \"rep:Members\",\n+            \"rep:MergeConflict\",\n+            \"rep:PermissionStore\",\n+            \"rep:Permissions\",\n+            \"rep:Policy\",\n+            \"rep:PrincipalAccessControl\",\n+            \"rep:Privilege\",\n+            \"rep:Privileges\",\n+            \"rep:RepoAccessControllable\",\n+            \"rep:Restrictions\",\n+            \"rep:RetentionManageable\",\n+            \"rep:Token\",\n+            \"rep:User\",\n+            \"rep:VersionReference\",\n+            \"rep:nodeTypes\",\n+            \"rep:root\",\n+            \"rep:system\",\n+            \"rep:versionStorage\"\n+    );\n+\n+    /**\n      * Copies the contents of the repository in the given source directory\n      * to the given target node store.\n      *\n@@ -183,6 +267,9 @@ public void copy() throws RepositoryException {\n         try {\n             NodeBuilder builder = target.getRoot().builder();\n \n+            // init target repository first\n+            new InitialContent().initialize(builder);\n+\n             Map<Integer, String> idxToPrefix = copyNamespaces(builder);\n             copyNodeTypes(builder);\n             copyVersionStore(builder, idxToPrefix);\n@@ -223,7 +310,7 @@ private String getOakName(Name name) throws NamespaceException {\n         Map<Integer, String> idxToPrefix = newHashMap();\n \n         NodeBuilder system = root.child(JCR_SYSTEM);\n-        NodeBuilder namespaces = Namespaces.createStandardMappings(system);\n+        NodeBuilder namespaces = system.child(NamespaceConstants.REP_NAMESPACES);\n \n         Properties registry = loadProperties(\"/namespaces/ns_reg.properties\");\n         Properties indexes  = loadProperties(\"/namespaces/ns_idx.properties\");\n@@ -292,8 +379,14 @@ private void copyNodeTypes(NodeBuilder root) throws RepositoryException {\n \n         logger.info(\"Copying registered node types\");\n         for (Name name : sourceRegistry.getRegisteredNodeTypes()) {\n+            // skip built-in nodetypes (OAK-1235)\n+            String oakName = getOakName(name);\n+            if (BUILT_IN_NODE_TYPES.contains(oakName)) {\n+                logger.info(\"skipping built-on nodetype: {}\", name);\n+                continue;\n+            }\n             QNodeTypeDefinition def = sourceRegistry.getNodeTypeDef(name);\n-            NodeBuilder type = types.child(getOakName(name));\n+            NodeBuilder type = types.child(oakName);\n             copyNodeType(def, type);\n         }\n     }\n", "nb_test": 12, "linesAdd": 89, "jira_id": "1235", "singleLine": false, "nb_skipped": 1, "commit": "1beb2a50", "nb_failure": 4, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testAddNodeWithRelativePath(org.apache.jackrabbit.oak.jcr.security.authorization.WriteTest): Access denied."], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\nindex 07e0ae3..2e1733d 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n@@ -290,7 +290,7 @@ public Node perform() throws RepositoryException {\n                 // modification of that property in the PermissionValidator\n                 if (oakTypeName != null) {\n                     PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);\n-                    sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\n+                    sessionContext.getAccessManager().checkPermissions(parent.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\n                 }\n \n                 NodeDelegate added = parent.addChild(oakName, oakTypeName);\n", "nb_test": 1198, "linesAdd": 1, "jira_id": "3517", "singleLine": false, "nb_skipped": 1, "commit": "24f7f60a", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["gcLongPathSplitDocs[0](org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollectorTest): 4:h5915dedbd67b1256ded019e82c382f9e81fc7c9827110e6ddf9a089117734f44", "gcLongPathSplitDocs[1](org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollectorTest): 4:h998f0bf03224e9ab74fdb910712b0ba30ed8b58f37c2d5f6cd9cab120e106951"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitDocumentCleanUp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitDocumentCleanUp.java\nindex 081a422..7cdaebc 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitDocumentCleanUp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitDocumentCleanUp.java\n@@ -79,14 +79,16 @@ private void disconnect(NodeDocument splitDoc) {\n                     mainId, splitId);\n             return;\n         }\n-        int slashIdx = splitId.lastIndexOf('/');\n-        int height = Integer.parseInt(splitId.substring(slashIdx + 1));\n+        \n+        String splitDocPath = splitDoc.getPath();\n+        int slashIdx = splitDocPath.lastIndexOf('/');\n+        int height = Integer.parseInt(splitDocPath.substring(slashIdx + 1));\n         Revision rev = Revision.fromString(\n-                splitId.substring(splitId.lastIndexOf('/', slashIdx - 1) + 1, slashIdx));\n+                splitDocPath.substring(splitDocPath.lastIndexOf('/', slashIdx - 1) + 1, slashIdx));\n         doc = doc.findPrevReferencingDoc(rev, height);\n         if (doc == null) {\n-            LOG.warn(\"Split document {} not referenced anymore. Main document is {}\",\n-                    splitId, mainId);\n+            LOG.warn(\"Split document {} for path {} not referenced anymore. Main document is {}\",\n+                    splitId, splitDocPath, mainId);\n             return;\n         }\n         // remove reference\n", "nb_test": 2215, "linesAdd": 7, "jira_id": "3099", "singleLine": false, "nb_skipped": 1, "commit": "25850476", "nb_failure": 0, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["containsDash(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest): Result set size is different expected:<2> but was:<0>", "testTokens(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexTest): expected:<[*llo, world]> but was:<[*lloworld]>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex 8889094..0e24834 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -73,10 +73,13 @@\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.index.MultiFields;\n import org.apache.lucene.index.Term;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.index.TermsEnum;\n import org.apache.lucene.search.BooleanClause;\n import org.apache.lucene.search.BooleanQuery;\n import org.apache.lucene.search.IndexSearcher;\n import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.search.MultiPhraseQuery;\n import org.apache.lucene.search.PhraseQuery;\n import org.apache.lucene.search.PrefixQuery;\n import org.apache.lucene.search.Query;\n@@ -87,6 +90,9 @@\n import org.apache.lucene.search.WildcardQuery;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.store.FSDirectory;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.automaton.Automaton;\n+import org.apache.lucene.util.automaton.CompiledAutomaton;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -416,7 +422,7 @@ private static Query getQuery(Filter filter, IndexReader reader,\n             // when using the LowCostLuceneIndexProvider\n             // which is used for testing\n         } else {\n-            qs.add(getFullTextQuery(ft, analyzer));\n+            qs.add(getFullTextQuery(ft, analyzer, reader));\n         }\n         if (nonFullTextConstraints) {\n             addNonFullTextConstraints(qs, filter, reader);\n@@ -582,7 +588,7 @@ private static void addNodeTypeConstraints(List<Query> qs, Filter filter) {\n         qs.add(bq);\n     }\n \n-    static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer) {\n+    static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer, final IndexReader reader) {\n         // a reference to the query, so it can be set in the visitor\n         // (a \"non-local return\")\n         final AtomicReference<Query> result = new AtomicReference<Query>();\n@@ -592,7 +598,7 @@ static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer) {\n             public boolean visit(FullTextOr or) {\n                 BooleanQuery q = new BooleanQuery();\n                 for (FullTextExpression e : or.list) {\n-                    Query x = getFullTextQuery(e, analyzer);\n+                    Query x = getFullTextQuery(e, analyzer, reader);\n                     q.add(x, SHOULD);\n                 }\n                 result.set(q);\n@@ -603,7 +609,7 @@ public boolean visit(FullTextOr or) {\n             public boolean visit(FullTextAnd and) {\n                 BooleanQuery q = new BooleanQuery();\n                 for (FullTextExpression e : and.list) {\n-                    Query x = getFullTextQuery(e, analyzer);\n+                    Query x = getFullTextQuery(e, analyzer, reader);\n                     // Lucene can't deal with \"must(must_not(x))\"\n                     if (x instanceof BooleanQuery) {\n                         BooleanQuery bq = (BooleanQuery) x;\n@@ -625,7 +631,7 @@ public boolean visit(FullTextTerm term) {\n                     // do not add constraints on child nodes properties\n                     p = \"*\";\n                 }\n-                Query q = tokenToQuery(term.getText(), analyzer);\n+                Query q = tokenToQuery(term.getText(), analyzer, reader);\n                 if (q == null) {\n                     return false;\n                 }\n@@ -646,7 +652,7 @@ public boolean visit(FullTextTerm term) {\n         return result.get();\n     }\n \n-    static Query tokenToQuery(String text, Analyzer analyzer) {\n+    static Query tokenToQuery(String text, Analyzer analyzer, IndexReader reader) {\n         if (analyzer == null) {\n             return null;\n         }\n@@ -657,22 +663,27 @@ static Query tokenToQuery(String text, Analyzer analyzer) {\n             // TODO what should be returned in the case there are no tokens?\n             return new BooleanQuery();\n         }\n-\n         if (tokens.size() == 1) {\n-            text = tokens.iterator().next();\n-            boolean hasFulltextToken = false;\n-            for (char c : fulltextTokens) {\n-                if (text.indexOf(c) != -1) {\n-                    hasFulltextToken = true;\n-                    break;\n+            String token = tokens.iterator().next();\n+            if (hasFulltextToken(token)) {\n+                return new WildcardQuery(newFulltextTerm(token));\n+            } else {\n+                return new TermQuery(newFulltextTerm(token));\n             }\n+        } else {\n+            if (hasFulltextToken(tokens)) {\n+                MultiPhraseQuery mpq = new MultiPhraseQuery();\n+                for(String token: tokens){\n+                    if (hasFulltextToken(token)) {\n+                        Term[] terms = extractMatchingTokens(reader, token);\n+                        if (terms != null && terms.length > 0) {\n+                            mpq.add(terms);\n                         }\n-\n-            if (hasFulltextToken) {\n-                return new WildcardQuery(newFulltextTerm(text));\n                     } else {\n-                return new TermQuery(newFulltextTerm(text));\n+                        mpq.add(newFulltextTerm(token));\n                     }\n+                }\n+                return mpq;\n             } else {\n                 PhraseQuery pq = new PhraseQuery();\n                 for (String t : tokens) {\n@@ -681,6 +692,48 @@ static Query tokenToQuery(String text, Analyzer analyzer) {\n                 return pq;\n             }\n         }\n+    }\n+\n+    private static Term[] extractMatchingTokens(IndexReader reader, String token) {\n+        if (reader == null) {\n+            // getPlan call\n+            return null;\n+        }\n+\n+        try {\n+            List<Term> terms = new ArrayList<Term>();\n+            Terms t = MultiFields.getTerms(reader, FieldNames.FULLTEXT);\n+            Automaton a = WildcardQuery.toAutomaton(newFulltextTerm(token));\n+            CompiledAutomaton ca = new CompiledAutomaton(a);\n+            TermsEnum te = ca.getTermsEnum(t);\n+            BytesRef text;\n+            while ((text = te.next()) != null) {\n+                terms.add(newFulltextTerm(text.utf8ToString()));\n+            }\n+            return terms.toArray(new Term[terms.size()]);\n+        } catch (IOException e) {\n+            LOG.error(\"Building fulltext query failed\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    private static boolean hasFulltextToken(List<String> tokens) {\n+        for (String token : tokens) {\n+            if (hasFulltextToken(token)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean hasFulltextToken(String token) {\n+        for (char c : fulltextTokens) {\n+            if (token.indexOf(c) != -1) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n \n     private static char[] fulltextTokens = new char[] { '*', '?' };\n \n@@ -727,6 +780,7 @@ static Query tokenToQuery(String text, Analyzer analyzer) {\n                 poz = end;\n                 if (hasFulltextToken) {\n                     token.append(term);\n+                    hasFulltextToken = false;\n                 } else {\n                     if (token.length() > 0) {\n                         tokens.add(token.toString());\n", "nb_test": 246, "linesAdd": 70, "jira_id": "1270", "singleLine": false, "nb_skipped": 1, "commit": "70564c7c", "nb_failure": 2, "linesRem": 17}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["rebasePreservesNew(org.apache.jackrabbit.oak.kernel.KernelNodeBuilderTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex c3b3885..00136aa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -260,7 +260,7 @@ public boolean exists() {\n \n     @Override\n     public boolean isNew() {\n-        return !isRoot() && !parent.base().hasChildNode(name) && parent.hasChildNode(name);\n+        return exists() && !base.exists();\n     }\n \n     @Override\n", "nb_test": 1423, "linesAdd": 1, "jira_id": "1178", "singleLine": false, "nb_skipped": 6, "commit": "84fb6b29", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTokenValidationIsCaseInsensitive(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest): expected:<[admin]> but was:<[ADMIN]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\nindex 0709960..83a0e22 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\n@@ -207,9 +207,11 @@ public TokenInfo createToken(Credentials credentials) {\n     @Override\n     public TokenInfo createToken(String userId, Map<String, ?> attributes) {\n         String error = \"Failed to create login token. \";\n-        NodeUtil tokenParent = getTokenParent(userId);\n+        User user = getUser(userId);\n+        NodeUtil tokenParent = getTokenParent(user);\n         if (tokenParent != null) {\n             try {\n+                String id = user.getID();\n                 long creationTime = new Date().getTime();\n                 NodeUtil tokenNode = createTokenNode(tokenParent, creationTime);\n                 tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());\n@@ -218,7 +220,7 @@ public TokenInfo createToken(String userId, Map<String, ?> attributes) {\n                 String nodeId = getIdentifier(tokenNode.getTree());\n                 String token = new StringBuilder(nodeId).append(DELIM).append(key).toString();\n \n-                String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, userId), options);\n+                String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, id), options);\n                 tokenNode.setString(TOKEN_ATTRIBUTE_KEY, keyHash);\n \n                 long exp;\n@@ -237,7 +239,7 @@ public TokenInfo createToken(String userId, Map<String, ?> attributes) {\n                     }\n                 }\n                 root.commit();\n-                return new TokenInfoImpl(tokenNode, token, userId);\n+                return new TokenInfoImpl(tokenNode, token, id);\n             } catch (NoSuchAlgorithmException e) {\n                 // error while generating login token\n                 log.error(error, e.getMessage());\n@@ -247,7 +249,7 @@ public TokenInfo createToken(String userId, Map<String, ?> attributes) {\n             } catch (CommitFailedException e) {\n                 // conflict while committing changes\n                 log.warn(error, e.getMessage());\n-            } catch (AccessDeniedException e) {\n+            } catch (RepositoryException e) {\n                 log.warn(error, e.getMessage());\n             }\n         } else {\n@@ -320,7 +322,7 @@ private static String generateKey(int size) {\n     }\n \n     @Nonnull\n-    private static String getKeyValue(String key, String userId) {\n+    private static String getKeyValue(@Nonnull String key, @Nonnull String userId) {\n         return key + userId;\n     }\n \n@@ -359,12 +361,29 @@ private String getUserId(Tree tokenTree) {\n     }\n \n     @CheckForNull\n-    private NodeUtil getTokenParent(String userId) {\n-        NodeUtil tokenParent = null;\n-        String parentPath = null;\n+    private User getUser(String userId) {\n         try {\n             Authorizable user = userManager.getAuthorizable(userId);\n             if (user != null && !user.isGroup()) {\n+                return (User) user;\n+            } else {\n+                log.debug(\"Cannot create login token: No corresponding node for User \" + userId + '.');\n+            }\n+        } catch (RepositoryException e) {\n+            // error while accessing user.\n+            log.debug(\"Error while accessing user \" + userId + '.', e);\n+        }\n+        return null;\n+    }\n+\n+    @CheckForNull\n+    private NodeUtil getTokenParent(@CheckForNull User user) {\n+        if (user == null) {\n+            return null;\n+        }\n+        NodeUtil tokenParent = null;\n+        String parentPath = null;\n+        try {\n             String userPath = user.getPath();\n             NodeUtil userNode = new NodeUtil(root.getTree(userPath));\n             tokenParent = userNode.getChild(TOKENS_NODE_NAME);\n@@ -373,12 +392,9 @@ private NodeUtil getTokenParent(String userId) {\n                 parentPath = userPath + '/' + TOKENS_NODE_NAME;\n                 root.commit();\n             }\n-            } else {\n-                log.debug(\"Cannot create login token: No corresponding node for User \" + userId + '.');\n-            }\n         } catch (RepositoryException e) {\n-            // error while accessing user.\n-            log.debug(\"Error while accessing user \" + userId + '.', e);\n+            // error while creating token node.\n+            log.debug(\"Error while creating token node \", e.getMessage());\n         } catch (CommitFailedException e) {\n             // conflict while creating token store for this user -> refresh and\n             // try to get the tree from the updated root.\n", "nb_test": 1859, "linesAdd": 27, "jira_id": "1985", "singleLine": false, "nb_skipped": 9, "commit": "f620b79b", "nb_failure": 1, "linesRem": 12}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testItemDefinitionsDefinesContextRoot(org.apache.jackrabbit.oak.security.authorization.AuthorizationContextTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AuthorizationContext.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AuthorizationContext.java\nindex 953d00b..49bfe47 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AuthorizationContext.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AuthorizationContext.java\n@@ -47,7 +47,11 @@ public boolean definesProperty(@Nonnull Tree parent, @Nonnull PropertyState prop\n     @Override\n     public boolean definesContextRoot(@Nonnull Tree tree) {\n         String name = tree.getName();\n-        return POLICY_NODE_NAMES.contains(name) || REP_PERMISSION_STORE.equals(name);\n+        if (POLICY_NODE_NAMES.contains(name)) {\n+            return NT_REP_ACL.equals(TreeUtil.getPrimaryTypeName(tree));\n+        } else {\n+            return REP_PERMISSION_STORE.equals(name);\n+        }\n     }\n \n     @Override\n", "nb_test": 2029, "linesAdd": 5, "jira_id": "2740", "singleLine": false, "nb_skipped": 9, "commit": "429baf4d", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["multipleCheckpointOnSameRevision(org.apache.jackrabbit.oak.plugins.document.CheckpointsTest): expected:<r15637bccb12-0-1> but was:<null>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Checkpoints.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Checkpoints.java\nindex e1d712d..8a6a98c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Checkpoints.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Checkpoints.java\n@@ -26,6 +26,7 @@\n import java.util.concurrent.atomic.AtomicInteger;\n \n import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n \n import org.apache.jackrabbit.oak.commons.json.JsopBuilder;\n import org.apache.jackrabbit.oak.commons.json.JsopReader;\n@@ -73,7 +74,14 @@\n     }\n \n     public Revision create(long lifetimeInMillis, Map<String, String> info) {\n-        Revision r = nodeStore.getHeadRevision();\n+        // create a unique dummy commit we can use as checkpoint revision\n+        Revision r = nodeStore.commitQueue.createRevision();\n+        nodeStore.commitQueue.done(r, new CommitQueue.Callback() {\n+            @Override\n+            public void headOfQueue(@Nonnull Revision revision) {\n+                // do nothing\n+            }\n+        });\n         createCounter.getAndIncrement();\n         performCleanupIfRequired();\n         UpdateOp op = new UpdateOp(ID, false);\n", "nb_test": 2654, "linesAdd": 7, "jira_id": "1648", "singleLine": false, "nb_skipped": 1, "commit": "fdc54465", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["readBranchCommit(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): must not access previous document: 3:p/test/r156362bd41c-4-1/0"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex e617e17..1134673 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -775,7 +775,7 @@ public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore,\n             // check if there may be more recent values in a previous document\n             if (value != null && !getPreviousRanges().isEmpty()) {\n                 Revision newest = getLocalMap(key).firstKey();\n-                if (!value.revision.equals(newest)) {\n+                if (isRevisionNewer(nodeStore, newest, value.revision)) {\n                     // not reading the most recent value, we may need to\n                     // consider previous documents as well\n                     Revision newestPrev = getPreviousRanges().firstKey();\n", "nb_test": 2023, "linesAdd": 1, "jira_id": "2336", "singleLine": false, "nb_skipped": 9, "commit": "d0f6715d", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReindexAuto(org.apache.jackrabbit.oak.plugins.index.IndexUpdateTest): expected:<[testRoot]> but was:<[]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\nindex 2116cee..75f0f31 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n@@ -19,6 +19,7 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.collect.Lists.newArrayList;\n import static com.google.common.collect.Lists.newArrayListWithCapacity;\n+import static org.apache.jackrabbit.oak.api.Type.BOOLEAN;\n import static org.apache.jackrabbit.oak.commons.PathUtils.concat;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.ASYNC_PROPERTY_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.ASYNC_REINDEX_VALUE;\n@@ -108,7 +109,7 @@ private IndexUpdate(IndexUpdate parent, String name) {\n     @Override\n     public void enter(NodeState before, NodeState after)\n             throws CommitFailedException {\n-        collectIndexEditors(builder.getChildNode(INDEX_DEFINITIONS_NAME));\n+        collectIndexEditors(builder.getChildNode(INDEX_DEFINITIONS_NAME), before);\n \n         // no-op when reindex is empty\n         CommitFailedException exception = EditorDiff.process(\n@@ -122,17 +123,30 @@ public void enter(NodeState before, NodeState after)\n         }\n     }\n \n-    private void collectIndexEditors(NodeBuilder definitions)\n-            throws CommitFailedException {\n+    private boolean shouldReindex(NodeBuilder definition, NodeState before,\n+            String name) {\n+        PropertyState ps = definition.getProperty(REINDEX_PROPERTY_NAME);\n+        if (ps != null && ps.getValue(BOOLEAN)) {\n+            return true;\n+        }\n+        // reindex in the case this is a new node, even though the reindex flag\n+        // might be set to 'false' (possible via content import)\n+        return !before.getChildNode(INDEX_DEFINITIONS_NAME).hasChildNode(name);\n+    }\n+\n+    private void collectIndexEditors(NodeBuilder definitions,\n+            NodeState before) throws CommitFailedException {\n         for (String name : definitions.getChildNodeNames()) {\n             NodeBuilder definition = definitions.getChildNode(name);\n             if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {\n                 String type = definition.getString(TYPE_PROPERTY_NAME);\n+                boolean shouldReindex = shouldReindex(definition,\n+                        before, name);\n                 Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);\n                 if (editor == null) {\n                     // trigger reindexing when an indexer becomes available\n                     definition.setProperty(REINDEX_PROPERTY_NAME, true);\n-                } else if (definition.getBoolean(REINDEX_PROPERTY_NAME)) {\n+                } else if (shouldReindex) {\n                     if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME)\n                             && definition.getString(ASYNC_PROPERTY_NAME) == null) {\n                         // switch index to an async update mode\n", "nb_test": 1803, "linesAdd": 16, "jira_id": "1874", "singleLine": false, "nb_skipped": 9, "commit": "3ae276c1", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testChildNodeDeletedAndMultipleAdded(org.apache.jackrabbit.oak.plugins.segment.CompareAgainstBaseStateTest): (..)"], "patch": "diff --git a/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java b/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\nindex cb42af2..6df8c38 100644\n--- a/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\n+++ b/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\n@@ -555,9 +555,11 @@ public boolean compareAgainstBaseState(NodeState base, NodeStateDiff diff) {\n                 }\n             }\n         } else if (beforeChildName != Template.MANY_CHILD_NODES) {\n+            boolean beforeChildStillExists = false;\n             for (ChildNodeEntry entry\n                     : afterTemplate.getChildNodeEntries(afterId)) {\n                 String childName = entry.getName();\n+                beforeChildStillExists |= childName.equals(beforeChildName);\n                 NodeState afterChild = entry.getNodeState();\n                 if (beforeChildName.equals(childName)) {\n                     NodeState beforeChild =\n@@ -577,6 +579,13 @@ public boolean compareAgainstBaseState(NodeState base, NodeStateDiff diff) {\n                     return false;\n                 }\n             }\n+            if (!beforeChildStillExists) {\n+                NodeState beforeChild =\n+                        beforeTemplate.getChildNode(beforeChildName, beforeId);\n+                if (!diff.childNodeDeleted(beforeChildName, beforeChild)) {\n+                    return false;\n+                }\n+            }\n         } else {\n             MapRecord afterMap = afterTemplate.getChildNodeMap(afterId);\n             MapRecord beforeMap = beforeTemplate.getChildNodeMap(beforeId);\n", "nb_test": 204, "linesAdd": 9, "jira_id": "4153", "singleLine": false, "nb_skipped": 7, "commit": "9120fd1b", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 4, "classification": {"singleLine": false}, "failing_tests": ["getNodeSNS[0](org.apache.jackrabbit.oak.jcr.RepositoryTest): /foo[1]/bar[2]", "getNodeSNS[3](org.apache.jackrabbit.oak.jcr.RepositoryTest): /foo[1]/bar[2]", "getNodeSNS[2](org.apache.jackrabbit.oak.jcr.RepositoryTest): /foo[1]/bar[2]", "getNodeSNS[1](org.apache.jackrabbit.oak.jcr.RepositoryTest): /foo[1]/bar[2]"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionImpl.java\nindex 13ade55..7d6e5d2 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionImpl.java\n@@ -161,7 +161,11 @@ public Node getNodeOrNull(final String absPath) throws RepositoryException {\n         return perform(new ReadOperation<Node>() {\n             @Override\n             public Node perform() throws RepositoryException {\n+                try {\n                     return NodeImpl.createNodeOrNull(sd.getNode(getOakPathOrThrow(absPath)), sessionContext);\n+                } catch (PathNotFoundException e) {\n+                    return null;\n+                }\n             }\n         });\n     }\n@@ -179,7 +183,12 @@ public Property getPropertyOrNull(final String absPath) throws RepositoryExcepti\n         if (absPath.equals(\"/\")) {\n             return null;\n         } else {\n-            final String oakPath = getOakPathOrThrow(absPath);\n+            final String oakPath;\n+            try {\n+                oakPath = getOakPathOrThrow(absPath);\n+            } catch (PathNotFoundException e) {\n+                return null;\n+            }\n             return perform(new ReadOperation<Property>() {\n                 @Override\n                 public Property perform() throws RepositoryException {\n", "nb_test": 1963, "linesAdd": 10, "jira_id": "1225", "singleLine": false, "nb_skipped": 5, "commit": "3535afe2", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["propertyDefinitionWithExcludes(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest)"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\nindex 9dd4b00..a89b6ae 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n@@ -285,7 +285,8 @@ boolean hasRelativeProperty(String name) {\n     private Map<String, PropertyDefinition> collectPropertyDefns(NodeBuilder defn) {\n         Map<String, PropertyDefinition> propDefns = newHashMap();\n         NodeBuilder propNode = defn.getChildNode(LuceneIndexConstants.PROP_NODE);\n-        for (String propName : Iterables.concat(includes, orderedProps)) {\n+        //Include all immediate child nodes to 'properties' node by default\n+        for (String propName : Iterables.concat(includes, orderedProps, propNode.getChildNodeNames())) {\n             NodeBuilder propDefnNode;\n             if (relativeProps.containsKey(propName)) {\n                 propDefnNode = relativeProps.get(propName).getPropDefnNode(propNode);\n@@ -293,7 +294,7 @@ boolean hasRelativeProperty(String name) {\n                 propDefnNode = propNode.getChildNode(propName);\n             }\n \n-            if (propDefnNode.exists()) {\n+            if (propDefnNode.exists() && !propDefns.containsKey(propName)) {\n                 propDefns.put(propName, new PropertyDefinition(this, propName, propDefnNode));\n             }\n         }\n", "nb_test": 315, "linesAdd": 2, "jira_id": "2250", "singleLine": false, "nb_skipped": 2, "commit": "08b25cb0", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["rollback(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): document with id 2:/foo/node does not exist"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex 75510da..93b4bd0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -408,7 +408,9 @@ private void rollback(List<UpdateOp> newDocuments,\n             store.createOrUpdate(NODES, reverse);\n         }\n         for (UpdateOp op : newDocuments) {\n-            store.remove(NODES, op.id);\n+            UpdateOp reverse = op.getReverseOperation();\n+            NodeDocument.unsetLastRev(reverse, revision.getClusterId());\n+            store.createOrUpdate(NODES, reverse);\n         }\n         UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);\n         NodeDocument.removeCollision(removeCollision, revision);\n", "nb_test": 1579, "linesAdd": 3, "jira_id": "1467", "singleLine": false, "nb_skipped": 7, "commit": "dde7de85", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["luceneBooleanComplexOrQueries(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): Result set size is different expected:<2> but was:<3>", "lucenPropertyBooleanComplexOrQueries(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): Result set size is different expected:<2> but was:<3>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex d35915c..7b0934e 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -724,16 +724,8 @@ public boolean visit(FullTextAnd and) {\n                 BooleanQuery q = new BooleanQuery();\n                 for (FullTextExpression e : and.list) {\n                     Query x = getFullTextQuery(e, analyzer, reader);\n-                    // Lucene can't deal with \"must(must_not(x))\"\n-                    if (x instanceof BooleanQuery) {\n-                        BooleanQuery bq = (BooleanQuery) x;\n-                        for (BooleanClause c : bq.clauses()) {\n-                            q.add(c);\n-                        }\n-                    } else {\n                     q.add(x, MUST);\n                 }\n-                }\n                 result.set(q);\n                 return true;\n             }\ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex 136f973..e0bbf79 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -836,16 +836,8 @@ public boolean visit(FullTextAnd and) {\n                 BooleanQuery q = new BooleanQuery();\n                 for (FullTextExpression e : and.list) {\n                     Query x = getFullTextQuery(plan, e, analyzer);\n-                    // Lucene can't deal with \"must(must_not(x))\"\n-                    if (x instanceof BooleanQuery) {\n-                        BooleanQuery bq = (BooleanQuery) x;\n-                        for (BooleanClause c : bq.clauses()) {\n-                            q.add(c);\n-                        }\n-                    } else {\n                     q.add(x, MUST);\n                 }\n-                }\n                 result.set(q);\n                 return true;\n             }\n", "nb_test": 380, "linesAdd": 0, "jira_id": "2434", "singleLine": false, "nb_skipped": 2, "commit": "8159fc21", "nb_failure": 2, "linesRem": 14}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReset2(org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex e96c9f3..1facf64 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -265,7 +265,7 @@ public void reset(NodeState newBase) {\n         if (this == root) {\n             baseState = checkNotNull(newBase);\n             writeState = new MutableNodeState(baseState);\n-            revision++;\n+            revision = 0;\n         } else {\n             throw new IllegalStateException(\"Cannot reset a non-root builder\");\n         }\n", "nb_test": 377, "linesAdd": 1, "jira_id": "421", "singleLine": false, "nb_skipped": 3, "commit": "36e70bd7", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["commit(org.apache.jackrabbit.oak.plugins.document.SimpleTest): expected:<[[]test]> but was:<[[/]test]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\nindex 4e14f42..7c70035 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n@@ -214,7 +214,7 @@ public String getNodes(String path, String revisionId, int depth,\n             if (maxChildNodes-- <= 0) {\n                 break;\n             }\n-            String name = PathUtils.getName(c.children.get((int) i));\n+            String name = c.children.get((int) i);\n             json.key(name).object().endObject();\n         }\n         if (c.hasMore) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\nindex 64a1eb8..7396f4e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\n@@ -381,28 +381,25 @@ private boolean dispatch(@Nonnull String jsonDiff,\n             }\n             switch (r) {\n                 case '+': {\n-                    String path = t.readString();\n+                    String name = t.readString();\n                     t.read(':');\n                     t.read('{');\n                     while (t.read() != '}') {\n                         // skip properties\n                     }\n-                    String name = PathUtils.getName(path);\n                     continueComparison = diff.childNodeAdded(name, getChildNode(name));\n                     break;\n                 }\n                 case '-': {\n-                    String path = t.readString();\n-                    String name = PathUtils.getName(path);\n+                    String name = t.readString();\n                     continueComparison = diff.childNodeDeleted(name, base.getChildNode(name));\n                     break;\n                 }\n                 case '^': {\n-                    String path = t.readString();\n+                    String name = t.readString();\n                     t.read(':');\n                     if (t.matches('{')) {\n                         t.read('}');\n-                        String name = PathUtils.getName(path);\n                         continueComparison = diff.childNodeChanged(name,\n                                 base.getChildNode(name), getChildNode(name));\n                     } else if (t.matches('[')) {\n@@ -416,21 +413,6 @@ private boolean dispatch(@Nonnull String jsonDiff,\n                     }\n                     break;\n                 }\n-                case '>': {\n-                    String from = t.readString();\n-                    t.read(':');\n-                    String to = t.readString();\n-                    String fromName = PathUtils.getName(from);\n-                    continueComparison = diff.childNodeDeleted(\n-                            fromName, base.getChildNode(fromName));\n-                    if (!continueComparison) {\n-                        break;\n-                    }\n-                    String toName = PathUtils.getName(to);\n-                    continueComparison = diff.childNodeAdded(\n-                            toName, getChildNode(toName));\n-                    break;\n-                }\n                 default:\n                     throw new IllegalArgumentException(\"jsonDiff: illegal token '\"\n                             + t.getToken() + \"' at pos: \" + t.getLastPos() + ' ' + jsonDiff);\n@@ -478,6 +460,9 @@ public NodeState getNodeState() {\n      */\n     public static class Children implements CacheValue {\n \n+        /**\n+         * Ascending sorted list of names of child nodes.\n+         */\n         final ArrayList<String> children = new ArrayList<String>();\n         boolean hasMore;\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 3a520e0..26bb4b4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -56,6 +56,8 @@\n \n import org.apache.jackrabbit.mk.api.MicroKernelException;\n import org.apache.jackrabbit.oak.api.PropertyState;\n+import org.apache.jackrabbit.oak.commons.json.JsopReader;\n+import org.apache.jackrabbit.oak.commons.json.JsopTokenizer;\n import org.apache.jackrabbit.oak.spi.blob.BlobStore;\n import org.apache.jackrabbit.oak.commons.json.JsopStream;\n import org.apache.jackrabbit.oak.commons.json.JsopWriter;\n@@ -665,7 +667,7 @@ public DocumentNodeState call() throws Exception {\n                 }\n                 if (c.children.size() < limit) {\n                     // add to children until limit is reached\n-                    c.children.add(p);\n+                    c.children.add(Utils.unshareString(PathUtils.getName(p)));\n                 } else {\n                     // enough collected and we know there are more\n                     c.hasMore = true;\n@@ -785,7 +787,8 @@ public NodeDocument apply(String name) {\n                 new Function<String, DocumentNodeState>() {\n             @Override\n             public DocumentNodeState apply(String input) {\n-                return getNode(input, readRevision);\n+                String p = PathUtils.concat(parent.getPath(), input);\n+                return getNode(p, readRevision);\n             }\n         });\n     }\n@@ -832,10 +835,9 @@ public void applyChanges(Revision rev, Revision before, String path,\n         if (isNew) {\n             CacheValue key = childNodeCacheKey(path, rev, null);\n             DocumentNodeState.Children c = new DocumentNodeState.Children();\n-            Set<String> set = Sets.newTreeSet(added);\n-            set.removeAll(removed);\n+            Set<String> set = Sets.newTreeSet();\n             for (String p : added) {\n-                set.add(Utils.unshareString(p));\n+                set.add(Utils.unshareString(PathUtils.getName(p)));\n             }\n             c.children.addAll(set);\n             nodeChildrenCache.put(key, c);\n@@ -844,13 +846,13 @@ public void applyChanges(Revision rev, Revision before, String path,\n             PathRev key = diffCacheKey(path, before, rev);\n             JsopWriter w = new JsopStream();\n             for (String p : added) {\n-                w.tag('+').key(p).object().endObject().newline();\n+                w.tag('+').key(PathUtils.getName(p)).object().endObject().newline();\n             }\n             for (String p : removed) {\n-                w.tag('-').value(p).newline();\n+                w.tag('-').value(PathUtils.getName(p)).newline();\n             }\n             for (String p : changed) {\n-                w.tag('^').key(p).object().endObject().newline();\n+                w.tag('^').key(PathUtils.getName(p)).object().endObject().newline();\n             }\n             diffCache.put(key, new StringValue(w.toString()));\n         }\n@@ -1148,12 +1150,35 @@ String diff(@Nonnull final String fromRevisionId,\n         try {\n             JsopWriter writer = new JsopStream();\n             diffProperties(from, to, writer);\n-            return writer.toString() + diffCache.get(key, new Callable<StringValue>() {\n+            String compactDiff = diffCache.get(key, new Callable<StringValue>() {\n                 @Override\n                 public StringValue call() throws Exception {\n                     return new StringValue(diffImpl(from, to));\n                 }\n-            });\n+            }).toString();\n+            JsopTokenizer t = new JsopTokenizer(compactDiff);\n+            int r;\n+            do {\n+                r = t.read();\n+                switch (r) {\n+                    case '+':\n+                    case '^': {\n+                        String name = t.readString();\n+                        t.read(':');\n+                        t.read('{');\n+                        t.read('}');\n+                        writer.tag((char) r).key(PathUtils.concat(path, name));\n+                        writer.object().endObject().newline();\n+                        break;\n+                    }\n+                    case '-': {\n+                        String name = t.readString();\n+                        writer.tag('-').value(PathUtils.concat(path, name));\n+                        writer.newline();\n+                    }\n+                }\n+            } while (r != JsopReader.END);\n+            return writer.toString();\n         } catch (ExecutionException e) {\n             if (e.getCause() instanceof MicroKernelException) {\n                 throw (MicroKernelException) e.getCause();\n@@ -1414,7 +1439,6 @@ private static void diffProperties(DocumentNodeState from,\n     private String diffImpl(DocumentNodeState from, DocumentNodeState to)\n             throws MicroKernelException {\n         JsopWriter w = new JsopStream();\n-        diffProperties(from, to, w);\n         // TODO this does not work well for large child node lists\n         // use a document store index instead\n         int max = MANY_CHILDREN_THRESHOLD;\n@@ -1422,8 +1446,8 @@ private String diffImpl(DocumentNodeState from, DocumentNodeState to)\n         fromChildren = getChildren(from, null, max);\n         toChildren = getChildren(to, null, max);\n         if (!fromChildren.hasMore && !toChildren.hasMore) {\n-            diffFewChildren(w, fromChildren, from.getLastRevision(),\n-                    toChildren, to.getLastRevision());\n+            diffFewChildren(w, from.getPath(), fromChildren,\n+                    from.getLastRevision(), toChildren, to.getLastRevision());\n         } else {\n             if (FAST_DIFF) {\n                 diffManyChildren(w, from.getPath(),\n@@ -1432,8 +1456,8 @@ private String diffImpl(DocumentNodeState from, DocumentNodeState to)\n                 max = Integer.MAX_VALUE;\n                 fromChildren = getChildren(from, null, max);\n                 toChildren = getChildren(to, null, max);\n-                diffFewChildren(w, fromChildren, from.getLastRevision(),\n-                        toChildren, to.getLastRevision());\n+                diffFewChildren(w, from.getPath(), fromChildren,\n+                        from.getLastRevision(), toChildren, to.getLastRevision());\n             }\n         }\n         return w.toString();\n@@ -1463,23 +1487,24 @@ private void diffManyChildren(JsopWriter w, String path, Revision fromRev, Revis\n         for (String p : paths) {\n             DocumentNodeState fromNode = getNode(p, fromRev);\n             DocumentNodeState toNode = getNode(p, toRev);\n+            String name = PathUtils.getName(p);\n             if (fromNode != null) {\n                 // exists in fromRev\n                 if (toNode != null) {\n                     // exists in both revisions\n                     // check if different\n                     if (!fromNode.getLastRevision().equals(toNode.getLastRevision())) {\n-                        w.tag('^').key(p).object().endObject().newline();\n+                        w.tag('^').key(name).object().endObject().newline();\n                     }\n                 } else {\n                     // does not exist in toRev -> was removed\n-                    w.tag('-').value(p).newline();\n+                    w.tag('-').value(name).newline();\n                 }\n             } else {\n                 // does not exist in fromRev\n                 if (toNode != null) {\n                     // exists in toRev\n-                    w.tag('+').key(p).object().endObject().newline();\n+                    w.tag('+').key(name).object().endObject().newline();\n                 } else {\n                     // does not exist in either revisions\n                     // -> do nothing\n@@ -1503,21 +1528,22 @@ private static void addPathsForDiff(String path,\n         }\n     }\n \n-    private void diffFewChildren(JsopWriter w, DocumentNodeState.Children fromChildren, Revision fromRev, DocumentNodeState.Children toChildren, Revision toRev) {\n+    private void diffFewChildren(JsopWriter w, String parentPath, DocumentNodeState.Children fromChildren, Revision fromRev, DocumentNodeState.Children toChildren, Revision toRev) {\n         Set<String> childrenSet = Sets.newHashSet(toChildren.children);\n         for (String n : fromChildren.children) {\n             if (!childrenSet.contains(n)) {\n                 w.tag('-').value(n).newline();\n             } else {\n-                DocumentNodeState n1 = getNode(n, fromRev);\n-                DocumentNodeState n2 = getNode(n, toRev);\n+                String path = PathUtils.concat(parentPath, n);\n+                DocumentNodeState n1 = getNode(path, fromRev);\n+                DocumentNodeState n2 = getNode(path, toRev);\n                 // this is not fully correct:\n                 // a change is detected if the node changed recently,\n                 // even if the revisions are well in the past\n                 // if this is a problem it would need to be changed\n-                checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", n, fromRev);\n-                checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", n, toRev);\n-                if (!n1.getId().equals(n2.getId())) {\n+                checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", path, fromRev);\n+                checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", path, toRev);\n+                if (!n1.getLastRevision().equals(n2.getLastRevision())) {\n                     w.tag('^').key(n).object().endObject().newline();\n                 }\n             }\n", "nb_test": 1580, "linesAdd": 54, "jira_id": "1429", "singleLine": false, "nb_skipped": 6, "commit": "c2f5ca6c", "nb_failure": 1, "linesRem": 46}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["failOnConflict(org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdateTest): conflict marker detected", "concurrentUpdates(org.apache.jackrabbit.oak.plugins.document.ConcurrentConflictTest): expected:<1000> but was:<1020>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\nindex c7538f7..9ce60a3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n@@ -41,10 +41,15 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean;\n+import org.apache.jackrabbit.oak.plugins.commit.AnnotatingConflictHandler;\n+import org.apache.jackrabbit.oak.plugins.commit.ConflictHook;\n+import org.apache.jackrabbit.oak.plugins.commit.ConflictValidatorProvider;\n import org.apache.jackrabbit.oak.plugins.value.Conversions;\n import org.apache.jackrabbit.oak.spi.commit.CommitHook;\n import org.apache.jackrabbit.oak.spi.commit.CommitInfo;\n+import org.apache.jackrabbit.oak.spi.commit.CompositeHook;\n import org.apache.jackrabbit.oak.spi.commit.EditorDiff;\n+import org.apache.jackrabbit.oak.spi.commit.EditorHook;\n import org.apache.jackrabbit.oak.spi.commit.EmptyHook;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n@@ -226,7 +231,10 @@ public synchronized void run() {\n \n     private static CommitHook newCommitHook(final String name,\n             final PropertyState state) throws CommitFailedException {\n-        return new CommitHook() {\n+        return new CompositeHook(\n+                new ConflictHook(new AnnotatingConflictHandler()),\n+                new EditorHook(new ConflictValidatorProvider()),\n+                new CommitHook() {\n             @Override\n             @Nonnull\n             public NodeState processCommit(NodeState before, NodeState after,\n@@ -241,7 +249,7 @@ public NodeState processCommit(NodeState before, NodeState after,\n                     throw CONCURRENT_UPDATE;\n                 }\n             }\n-        };\n+        });\n     }\n \n     private static void preAsyncRun(NodeStore store, String name) throws CommitFailedException {\n", "nb_test": 1849, "linesAdd": 10, "jira_id": "1784", "singleLine": false, "nb_skipped": 9, "commit": "2426deae", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFullTextTerm(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Result set size is different expected:<1> but was:<0>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\nindex 2d33a29..78a672f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\n@@ -67,7 +67,7 @@ public FullTextTerm(String propertyName, String text, boolean not, boolean escap\n                 } else if (c == '_') {\n                     buff.append(\"\\\\_\");\n                     pattern = true;\n-                } else if (Character.isLetterOrDigit(c) || \" +-:&\".indexOf(c) >= 0) {\n+                } else if (Character.isLetterOrDigit(c) || \" +-:&/\".indexOf(c) >= 0) {\n                     buff.append(c);\n                 }\n             }\n", "nb_test": 1257, "linesAdd": 1, "jira_id": "1024", "singleLine": false, "nb_skipped": 8, "commit": "2b5d3afb", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["removeMoved(org.apache.jackrabbit.oak.core.RootImplTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java\nindex abda5d2..a868959 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java\n@@ -225,9 +225,7 @@ void purge() {\n      * All registered {@link PurgeListener}s are notified.\n      */\n     private void purgePendingChanges() {\n-        if (hasPendingChanges()) {\n         branch.setRoot(rootTree.getNodeState());\n-        }\n         notifyListeners();\n     }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStoreBranch.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStoreBranch.java\nindex 79ffaff..63b1ec5 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStoreBranch.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStoreBranch.java\n@@ -80,9 +80,11 @@ public NodeState getBase() {\n \n     @Override\n     public void setRoot(NodeState newRoot) {\n+        if (!currentRoot.equals(newRoot)) {\n             currentRoot = newRoot;\n             commit(buildJsop());\n         }\n+    }\n \n     @Override\n     public boolean move(String source, String target) {\n", "nb_test": 203, "linesAdd": 2, "jira_id": "208", "singleLine": false, "nb_skipped": 0, "commit": "daf9a4ef", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["indexRuleMixin(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest)", "indexRuleMixinInheritance(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest)", "indexingBasedOnMixin(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): Expected path /test/a not found, got []"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\nindex 465ff12..8642545 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n@@ -748,6 +748,12 @@ public boolean isAggregated(String nodePath) {\n          *         <code>false</code> otherwise.\n          */\n         public boolean appliesTo(Tree state) {\n+            for (String mixinName : getMixinTypeNames(state)){\n+                if (nodeTypeName.equals(mixinName)){\n+                    return true;\n+                }\n+            }\n+\n             if (!nodeTypeName.equals(getPrimaryTypeName(state))) {\n                 return false;\n             }\n@@ -1242,7 +1248,7 @@ private static String getPrimaryTypeName(Tree state) {\n     }\n \n     private static Iterable<String> getMixinTypeNames(Tree tree) {\n-        PropertyState property = tree.getProperty(JcrConstants.JCR_MIMETYPE);\n+        PropertyState property = tree.getProperty(JcrConstants.JCR_MIXINTYPES);\n         return property != null ? property.getValue(Type.NAMES) : Collections.<String>emptyList();\n     }\n \n", "nb_test": 261, "linesAdd": 7, "jira_id": "3318", "singleLine": false, "nb_skipped": 4, "commit": "e12e2052", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["propertyConfigCaseInsensitive(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest)", "formatUpdate(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest)"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\nindex fcd547c..69d3431 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n@@ -23,6 +23,7 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n@@ -559,6 +560,9 @@ private boolean areAllTypesIndexed() {\n     public class IndexingRule {\n         private final String baseNodeType;\n         private final String nodeTypeName;\n+        /**\n+         * Case insensitive map of lower cased propertyName to propertyConfigs\n+         */\n         private final Map<String, PropertyDefinition> propConfigs;\n         private final List<NamePattern> namePatterns;\n         private final List<PropertyDefinition> nullCheckEnabledProperties;\n@@ -697,7 +701,7 @@ public boolean isFulltextEnabled() {\n          */\n         @CheckForNull\n         public PropertyDefinition getConfig(String propertyName) {\n-            PropertyDefinition config = propConfigs.get(propertyName);\n+            PropertyDefinition config = propConfigs.get(propertyName.toLowerCase(Locale.ENGLISH));\n             if (config != null) {\n                 return config;\n             } else if (namePatterns.size() > 0) {\n@@ -761,7 +765,7 @@ public boolean isBasedOnNtBase(){\n                     if(pd.isRegexp){\n                         patterns.add(new NamePattern(pd.name, pd));\n                     } else {\n-                        propDefns.put(pd.name, pd);\n+                        propDefns.put(pd.name.toLowerCase(Locale.ENGLISH), pd);\n                     }\n \n                     if (pd.relative){\n", "nb_test": 408, "linesAdd": 3, "jira_id": "2559", "singleLine": false, "nb_skipped": 2, "commit": "dfa87520", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFullTextTermName(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Result set size is different expected:<1> but was:<0>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\nindex 78a672f..cd974c2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\n@@ -67,7 +67,7 @@ public FullTextTerm(String propertyName, String text, boolean not, boolean escap\n                 } else if (c == '_') {\n                     buff.append(\"\\\\_\");\n                     pattern = true;\n-                } else if (Character.isLetterOrDigit(c) || \" +-:&/\".indexOf(c) >= 0) {\n+                } else if (Character.isLetterOrDigit(c) || \" +-:&/.\".indexOf(c) >= 0) {\n                     buff.append(c);\n                 }\n             }\n", "nb_test": 1275, "linesAdd": 1, "jira_id": "1024", "singleLine": false, "nb_skipped": 8, "commit": "e39b4d96", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["purgeAllButMostRecentCommittedCommitRoot(org.apache.jackrabbit.oak.plugins.document.DocumentSplitTest): merge must fail with CommitFailedException"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\nindex dc3eb5e..75853ce 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n@@ -240,10 +240,10 @@ private void collectRevisionsAndCommitRoot() {\n             } else if (r.getClusterId() == context.getClusterId() \n                     && !changes.contains(r)) {\n                 // OAK-2528: _commitRoot entry without associated change\n-                // consider all but most recent as garbage (OAK-3333)\n-                if (mostRecent) {\n+                // consider all but most recent as garbage (OAK-3333, OAK-4050)\n+                if (mostRecent && doc.isCommitted(r)) {\n                     mostRecent = false;\n-                } else {\n+                } else if (isGarbage(r)) {\n                     addGarbage(r, COMMIT_ROOT);\n                 }\n             }\n", "nb_test": 2801, "linesAdd": 2, "jira_id": "4050", "singleLine": false, "nb_skipped": 1, "commit": "52ca008c", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["indexDefinitionBelowRoot3(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): Invalid path [/test/]"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex 42a7804..5079088 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -1528,6 +1528,8 @@ public String getPath() {\n                     String sub = pathRow.getPath();\n                     if (isVirtualRow()) {\n                         return sub;\n+                    } else if (!\"\".equals(pathPrefix) && PathUtils.denotesRoot(sub)) {\n+                        return pathPrefix;\n                     } else if (PathUtils.isAbsolute(sub)) {\n                         return pathPrefix + sub;\n                     } else {\n", "nb_test": 360, "linesAdd": 2, "jira_id": "4351", "singleLine": false, "nb_skipped": 6, "commit": "59a83d23", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReferenceValue(org.apache.jackrabbit.oak.jcr.ValueFactoryTest): Conversion to REFERENCE value must validate identifier string", "testWeakReferenceValue(org.apache.jackrabbit.oak.jcr.ValueFactoryTest): Conversion to WEAK_REFERENCE value must validate identifier string"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/value/ValueFactoryImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/value/ValueFactoryImpl.java\nindex eb45232..a722509 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/value/ValueFactoryImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/value/ValueFactoryImpl.java\n@@ -37,6 +37,7 @@\n import java.io.UnsupportedEncodingException;\n import java.math.BigDecimal;\n import java.util.Calendar;\n+import java.util.UUID;\n \n /**\n  * Implementation of {@link ValueFactory} interface based on the\n@@ -185,6 +186,17 @@ public Value createValue(String value, int type) throws ValueFormatException {\n                     cv = factory.createValue(value, type);\n                     break;\n \n+                case PropertyType.REFERENCE:\n+                case PropertyType.WEAKREFERENCE:\n+                    // TODO: move to identifier/uuid management utility instead of relying on impl specific uuid-format here.\n+                    try {\n+                        UUID.fromString(value);\n+                    } catch (IllegalArgumentException e) {\n+                        throw new ValueFormatException(e);\n+                    }\n+                    cv = factory.createValue(value, type);\n+                    break;\n+\n                 case PropertyType.BINARY:\n                     cv = factory.createValue(new ByteArrayInputStream(value.getBytes(\"UTF-8\")));\n                     break;\n", "nb_test": 197, "linesAdd": 11, "jira_id": "238", "singleLine": false, "nb_skipped": 2, "commit": "24ce6788", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testMoveAndAddProperty2(org.apache.jackrabbit.oak.security.authorization.evaluation.MoveWithoutEntryCacheTest): OakAccess0000: Access denied", "testMoveAndRemoveProperty2(org.apache.jackrabbit.oak.security.authorization.evaluation.MoveWithoutEntryCacheTest): OakAccess0000: Access denied"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/MoveAwarePermissionValidator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/MoveAwarePermissionValidator.java\nindex 3f2382a..cee534a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/MoveAwarePermissionValidator.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/MoveAwarePermissionValidator.java\n@@ -75,10 +75,11 @@ PermissionValidator createValidator(@Nullable Tree parentBefore,\n     private Validator visibleValidator(@Nonnull Tree source,\n                                        @Nonnull Tree dest) {\n         // TODO improve: avoid calculating the 'before' permissions in case the current parent permissions already point to the correct tree.\n-        ImmutableTree parent = (ImmutableTree) moveCtx.rootBefore.getTree(\"/\");\n-        TreePermission tp = getPermissionProvider().getTreePermission(parent, TreePermission.EMPTY);\n+        ImmutableTree immutableTree = (ImmutableTree) moveCtx.rootBefore.getTree(\"/\");\n+        TreePermission tp = getPermissionProvider().getTreePermission(immutableTree, TreePermission.EMPTY);\n         for (String n : PathUtils.elements(source.getPath())) {\n-            tp = tp.getChildPermission(n, parent.getChild(n).getNodeState());\n+            immutableTree = immutableTree.getChild(n);\n+            tp = tp.getChildPermission(n, immutableTree.getNodeState());\n         }\n         Validator validator = createValidator(source, dest, tp, this);\n         return new VisibleValidator(validator, true, false);\n", "nb_test": 2101, "linesAdd": 4, "jira_id": "2933", "singleLine": false, "nb_skipped": 9, "commit": "44585b0c", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 9, "classification": {"singleLine": false}, "failing_tests": ["preExtractedProviderBindBeforeActivate(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexProviderServiceTest)", "testScore(org.apache.jackrabbit.oak.jcr.query.QueryFulltextTest): Failed to get Repository instance.", "testSurrogateFulltext(org.apache.jackrabbit.oak.jcr.query.QueryFulltextTest): Failed to get Repository instance.", "testFulltextRelativeProperty(org.apache.jackrabbit.oak.jcr.query.QueryFulltextTest): Failed to get Repository instance.", "testScoreWithOr(org.apache.jackrabbit.oak.jcr.query.QueryFulltextTest): Failed to get Repository instance.", "testFulltext(org.apache.jackrabbit.oak.jcr.query.QueryFulltextTest): Failed to get Repository instance.", "testFileContains(org.apache.jackrabbit.oak.jcr.query.TextExtractionQueryTest): Failed to get Repository instance.", "testNtFile(org.apache.jackrabbit.oak.jcr.query.TextExtractionQueryTest): Failed to get Repository instance.", "testScoreWithoutFulltext(org.apache.jackrabbit.oak.jcr.query.TextExtractionQueryTest): Failed to get Repository instance.", "testConcurrent(org.apache.jackrabbit.oak.jcr.query.MultiSessionQueryTest): GC overhead limit exceeded"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexProviderService.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexProviderService.java\nindex c8f0cfe..29a893a 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexProviderService.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexProviderService.java\n@@ -190,7 +190,7 @@\n     private IndexAugmentorFactory augmentorFactory;\n \n     @Reference(policy = ReferencePolicy.DYNAMIC,\n-            cardinality = ReferenceCardinality.OPTIONAL_MULTIPLE,\n+            cardinality = ReferenceCardinality.OPTIONAL_UNARY,\n             policyOption = ReferencePolicyOption.GREEDY\n     )\n     private volatile PreExtractedTextProvider extractedTextProvider;\n@@ -441,7 +441,9 @@ private void initializeExtractedTextCache(BundleContext bundleContext, Map<Strin\n                 PROP_EXTRACTED_TEXT_CACHE_EXPIRY_DEFAULT);\n \n         extractedTextCache = new ExtractedTextCache(cacheSizeInMB * ONE_MB, cacheExpiryInSecs);\n-\n+        if (extractedTextProvider != null){\n+            registerExtractedTextProvider(extractedTextProvider);\n+        }\n         CacheStats stats = extractedTextCache.getCacheStats();\n         if (stats != null){\n             oakRegs.add(registerMBean(whiteboard,\n", "nb_test": 328, "linesAdd": 4, "jira_id": "4036", "singleLine": false, "nb_skipped": 5, "commit": "f4324736", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["sql2Index(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/sql2_index.txt don't match expected results in src/test/resources/sql2_index.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\nindex 914881c..443f0cb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n@@ -30,6 +30,8 @@\n import org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction;\n import org.apache.jackrabbit.oak.spi.query.QueryIndex;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.google.common.base.Charsets;\n import com.google.common.collect.Iterables;\n@@ -90,6 +92,8 @@\n      */\n     private static final String EMPTY_TOKEN = \":\";\n \n+    private static final Logger LOG = LoggerFactory.getLogger(PropertyIndex.class);\n+\n     static Set<String> encode(PropertyValue value) {\n         if (value == null) {\n             return null;\n@@ -113,6 +117,37 @@\n         return values;\n     }\n \n+    private Cheapest findCheapestProperty(Filter filter, PropertyIndexLookup lookup) {\n+        Cheapest cost = new Cheapest();\n+        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n+            String propertyName = PathUtils.getName(pr.propertyName);\n+            double propertyCost = Double.POSITIVE_INFINITY;\n+            // TODO support indexes on a path\n+            // currently, only indexes on the root node are supported\n+            if (lookup.isIndexed(propertyName, \"/\", filter)) {\n+                if (pr.firstIncluding && pr.lastIncluding\n+                    && pr.first != null && pr.first.equals(pr.last)) {\n+                    // \"[property] = $value\"\n+                    propertyCost = lookup.getCost(filter, propertyName, pr.first);\n+                } else if (pr.list != null) {\n+                    propertyCost = 0;\n+                    for (PropertyValue p : pr.list) {\n+                        propertyCost += lookup.getCost(filter, propertyName, p);\n+                    }\n+                } else {\n+                    // processed as \"[property] is not null\"\n+                    propertyCost = lookup.getCost(filter, propertyName, null);\n+                }\n+            }\n+            LOG.debug(\"property cost for {} is {}\", propertyName, propertyCost);\n+            if (propertyCost < cost.cost) {\n+                cost.cost = propertyCost;\n+                cost.propertyRestriction = pr;\n+            }\n+        }\n+        return cost;\n+    }\n+\n     //--------------------------------------------------------< QueryIndex >--\n \n     @Override\n@@ -142,29 +177,9 @@ public double getCost(Filter filter, NodeState root) {\n         }\n \n         PropertyIndexLookup lookup = getLookup(root);\n-        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n-            String propertyName = PathUtils.getName(pr.propertyName);\n-            // TODO support indexes on a path\n-            // currently, only indexes on the root node are supported\n-            if (lookup.isIndexed(propertyName, \"/\", filter)) {\n-                if (pr.firstIncluding && pr.lastIncluding\n-                    && pr.first != null && pr.first.equals(pr.last)) {\n-                    // \"[property] = $value\"\n-                    return lookup.getCost(filter, propertyName, pr.first);\n-                } else if (pr.list != null) {\n-                    double cost = 0;\n-                    for (PropertyValue p : pr.list) {\n-                        cost += lookup.getCost(filter, propertyName, p);\n-                    }\n-                    return cost;\n-                } else {\n-                    // processed as \"[property] is not null\"\n-                    return lookup.getCost(filter, propertyName, null);\n-                }\n-            }\n-        }\n-        // not an appropriate index\n-        return Double.POSITIVE_INFINITY;\n+        Cheapest cheapest = findCheapestProperty(filter, lookup);\n+        LOG.debug(\"Cheapest property cost is {} for property {}\", cheapest.cost, cheapest.propertyRestriction != null ? cheapest.propertyRestriction.propertyName : null);\n+        return cheapest.cost;\n     }\n \n     @Override\n@@ -173,7 +188,11 @@ public Cursor query(Filter filter, NodeState root) {\n \n         PropertyIndexLookup lookup = getLookup(root);\n         int depth = 1;\n-        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n+\n+        Cheapest cheapest = findCheapestProperty(filter, lookup);\n+        PropertyRestriction pr = cheapest.propertyRestriction;\n+\n+        if (pr != null) {\n             String propertyName = PathUtils.getName(pr.propertyName);\n             depth = PathUtils.getDepth(pr.propertyName);\n             // TODO support indexes on a path\n@@ -184,7 +203,6 @@ public Cursor query(Filter filter, NodeState root) {\n                     && pr.first != null && pr.first.equals(pr.last)) {\n                     // \"[property] = $value\"\n                     paths = lookup.query(filter, propertyName, pr.first);\n-                    break;\n                 } else if (pr.list != null) {\n                     for (PropertyValue pv : pr.list) {\n                         Iterable<String> p = lookup.query(filter, propertyName, pv);\n@@ -194,11 +212,9 @@ public Cursor query(Filter filter, NodeState root) {\n                             paths = Iterables.concat(paths, p);\n                         }\n                     }\n-                    break;\n                 } else {\n                     // processed as \"[property] is not null\"\n                     paths = lookup.query(filter, propertyName, null);\n-                    break;\n                 }\n             }\n         }\n@@ -217,7 +233,10 @@ public String getPlan(Filter filter, NodeState root) {\n         StringBuilder buff = new StringBuilder(\"property\");\n         StringBuilder notIndexed = new StringBuilder();\n         PropertyIndexLookup lookup = getLookup(root);\n-        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n+        Cheapest cheapest = findCheapestProperty(filter, lookup);\n+        PropertyRestriction pr = cheapest.propertyRestriction;\n+\n+        if (pr != null) {\n             String propertyName = PathUtils.getName(pr.propertyName);\n             // TODO support indexes on a path\n             // currently, only indexes on the root node are supported\n@@ -251,4 +270,9 @@ public String getPlan(Filter filter, NodeState root) {\n         return buff.toString();\n     }\n \n+    private static class Cheapest {\n+        private double cost = Double.POSITIVE_INFINITY;\n+        private PropertyRestriction propertyRestriction;\n+    }\n+\n }\n\\ No newline at end of file\n", "nb_test": 1809, "linesAdd": 48, "jira_id": "1894", "singleLine": false, "nb_skipped": 9, "commit": "35562cce", "nb_failure": 0, "linesRem": 23}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test(org.apache.jackrabbit.oak.commons.PathTest)"], "patch": "diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\nindex 6201804..883f197 100644\n--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\n+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\n@@ -16,10 +16,11 @@\n  */\n package org.apache.jackrabbit.oak.commons;\n \n-import javax.annotation.Nonnull;\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n \n+import javax.annotation.Nonnull;\n+\n /**\n  * Utility methods to parse a path.\n  * <p/>\n@@ -288,7 +289,12 @@ public static boolean isAncestor(String ancestor, String path) {\n         if (ancestor.isEmpty() || path.isEmpty()) {\n             return false;\n         }\n-        if (!denotesRoot(ancestor)) {\n+        if (denotesRoot(ancestor)) {\n+            if (denotesRoot(path)) {\n+                return false;\n+            }\n+        }\n+        else {\n             ancestor += \"/\";\n         }\n         return path.startsWith(ancestor);\n", "nb_test": 6, "linesAdd": 8, "jira_id": "296", "singleLine": false, "nb_skipped": 0, "commit": "5449bf39", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["testRepeatedRecovery[0](org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgentTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java\nindex eef7c82..7659ec4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java\n@@ -94,6 +94,7 @@ public boolean acquireRecoveryLock(int clusterId){\n     public void releaseRecoveryLock(int clusterId){\n         UpdateOp update = new UpdateOp(Integer.toString(clusterId), true);\n         update.set(ClusterNodeInfo.REV_RECOVERY_LOCK, null);\n+        update.set(ClusterNodeInfo.STATE, null);\n         store.createOrUpdate(Collection.CLUSTER_NODES, update);\n     }\n \n", "nb_test": 1802, "linesAdd": 1, "jira_id": "1883", "singleLine": true, "nb_skipped": 9, "commit": "9c2421ed", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testZeroSizeCache(org.apache.jackrabbit.oak.cache.CacheTest): Max memory must be larger than 0"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\nindex 6eb74dc..26e44e7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n@@ -409,8 +409,8 @@ public long getUsedMemory() {\n      * @param maxMemory the maximum size (1 or larger)\n      */\n     public void setMaxMemory(long maxMemory) {\n-        if (maxMemory <= 0) {\n-            throw new IllegalArgumentException(\"Max memory must be larger than 0\");\n+        if (maxMemory < 0) {\n+            throw new IllegalArgumentException(\"Max memory must not be negative\");\n         }\n         this.maxMemory = maxMemory;\n         if (segments != null) {\n", "nb_test": 2201, "linesAdd": 2, "jira_id": "3089", "singleLine": false, "nb_skipped": 1, "commit": "ba38c380", "nb_failure": 0, "rtElixir": true, "linesRem": 2}, {"files": 11, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["sql2Index(org.apache.jackrabbit.oak.plugins.index.p2.Property2IndexQueryTest): Results in target/sql2_index.txt don't match expected results in src/test/resources/sql2_index.txt; compare the files for details", "sql2Explain(org.apache.jackrabbit.oak.plugins.index.old.QueryTest): Results in target/sql2_explain.txt don't match expected results in src/test/resources/sql2_explain.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java\nindex 57bf0d1..002bad8 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java\n@@ -308,7 +308,7 @@ public ResultImpl executeQuery() {\n         prepare();\n         Iterator<ResultRowImpl> it;\n         if (explain) {\n-            String plan = source.getPlan(rootState);\n+            String plan = getPlan();\n             columns = new ColumnImpl[] { new ColumnImpl(\"explain\", \"plan\", \"plan\")};\n             ResultRowImpl r = new ResultRowImpl(this,\n                     new String[0], \n@@ -317,7 +317,7 @@ public ResultImpl executeQuery() {\n             it = Arrays.asList(r).iterator();\n         } else {\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"plan: \" + source.getPlan(rootState));\n+                LOG.debug(\"plan: \" + getPlan());\n             }\n             if (orderings == null) {\n                 // can apply limit and offset directly\n@@ -438,6 +438,15 @@ public int compareRows(PropertyValue[] orderValues,\n         return comp;\n     }\n     \n+    /**\n+     * Get the query plan. The query must already be prepared.\n+     * \n+     * @return the query plan\n+     */\n+    private String getPlan() {\n+        return source.getPlan(rootState);\n+    }\n+\n     void prepare() {\n         if (prepared) {\n             return;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\nindex a7569bc..2a79d67 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\n@@ -176,11 +176,14 @@ public QueryIndex getBestIndex(Query query, NodeState rootState, Filter filter)\n                 best = index;\n             }\n         }\n-        if (best == null) {\n+        QueryIndex index = new TraversingIndex();\n+        double cost = index.getCost(filter, rootState);\n         if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"no indexes found - using TraversingIndex; indexProvider: \" + indexProvider);\n+            LOG.debug(\"cost for \" + index.getIndexName() + \" is \" + cost);\n         }\n-            best = new TraversingIndex();\n+        if (cost < bestCost) {\n+            bestCost = cost;\n+            best = index;\n         }\n         return best;\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java\nindex 829196a..6213557 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java\n@@ -66,12 +66,22 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == parentSelector) {\n             String c = childSelector.currentPath();\n+            if (c == null && f.isPreparing() && childSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                c = KNOWN_PATH;\n+            }\n             if (c != null) {\n                 f.restrictPath(PathUtils.getParentPath(c), Filter.PathRestriction.EXACT);\n             }\n         }\n         if (f.getSelector() == childSelector) {\n             String p = parentSelector.currentPath();\n+            if (p == null && f.isPreparing() && parentSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p = KNOWN_PATH;\n+            }\n             if (p != null) {\n                 f.restrictPath(p, Filter.PathRestriction.DIRECT_CHILDREN);\n             }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java\nindex 1552155..8e5f945 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java\n@@ -66,12 +66,22 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == ancestorSelector) {\n             String d = descendantSelector.currentPath();\n+            if (d == null && f.isPreparing() && descendantSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                d = KNOWN_PATH;\n+            }\n             if (d != null) {\n                 f.restrictPath(PathUtils.getParentPath(d), Filter.PathRestriction.PARENT);\n             }\n         }\n         if (f.getSelector() == descendantSelector) {\n             String a = ancestorSelector.currentPath();\n+            if (a == null && f.isPreparing() && ancestorSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                a = KNOWN_PATH;\n+            }\n             if (a != null) {\n                 f.restrictPath(a, Filter.PathRestriction.DIRECT_CHILDREN);\n             }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java\nindex dae131d..01d1ce2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java\n@@ -97,21 +97,35 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == selector1) {\n             PropertyValue p2 = selector2.currentProperty(property2Name);\n+            if (p2 == null && f.isPreparing() && selector2.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p2 = PropertyValues.newString(KNOWN_VALUE);\n+            }\n             if (p2 != null) {\n-                if (!p2.isArray()) {\n+                if (p2.isArray()) {\n                     // TODO support join on multi-valued properties\n-                    f.restrictProperty(property1Name, Operator.EQUAL, p2);\n+                    p2 = null;\n                 }\n             }\n+            // always set the condition, even if unkown ( -> is not null)\n+            f.restrictProperty(property1Name, Operator.EQUAL, p2);\n         }\n         if (f.getSelector() == selector2) {\n             PropertyValue p1 = selector1.currentProperty(property1Name);\n+            if (p1 == null && f.isPreparing() && selector1.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p1 = PropertyValues.newString(KNOWN_VALUE);\n+            }\n             if (p1 != null) {\n-                if (!p1.isArray()) {\n+                if (p1.isArray()) {\n                     // TODO support join on multi-valued properties\n-                    f.restrictProperty(property2Name, Operator.EQUAL, p1);\n+                    p1 = null;\n                 }\n             }\n+            // always set the condition, even if unkown ( -> is not null)\n+            f.restrictProperty(property2Name, Operator.EQUAL, p1);\n         }\n     }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java\nindex b3e2fd5..f5c8298 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java\n@@ -20,10 +20,35 @@\n  */\n public abstract class JoinConditionImpl extends AstElement {\n     \n+    /**\n+     * A path with 6 elements, which is the expected average for a join.\n+     */\n+    protected static final String KNOWN_PATH = \"/path/from/the/join/selector\";\n+\n+    protected static final String KNOWN_VALUE = \"valueFromTheJoinSelector\";\n+\n+    /**\n+     * Evaluate the result using the currently set values.\n+     * \n+     * @return true if the constraint matches\n+     */\n     public abstract boolean evaluate();\n     \n+    /**\n+     * Apply the condition to the filter, further restricting the filter if\n+     * possible. This may also verify the data types are compatible, and that\n+     * paths are valid.\n+     * \n+     * @param f the filter\n+     */\n     public abstract void restrict(FilterImpl f);\n \n-    public abstract void restrictPushDown(SelectorImpl selectorImpl);\n+    /**\n+     * Push as much of the condition down to this selector, further restricting\n+     * the selector condition if possible.\n+     * \n+     * @param s the selector\n+     */\n+    public abstract void restrictPushDown(SelectorImpl s);\n \n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java\nindex 6e4e408..a5ab71f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java\n@@ -60,8 +60,15 @@ boolean accept(AstVisitor v) {\n \n     @Override\n     public String getPlan(NodeState rootState) {\n-        return left.getPlan(rootState) + ' ' + joinType +\n-                \" \" + right.getPlan(rootState) + \" on \" + joinCondition;\n+        StringBuilder buff = new StringBuilder();\n+        buff.append(left.getPlan(rootState)).\n+            append(' ').\n+            append(joinType).\n+            append(' ').\n+            append(right.getPlan(rootState)).\n+            append(\" on \").\n+            append(joinCondition);\n+        return buff.toString();\n     }\n \n     @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java\nindex 187a795..7ab0cbe 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java\n@@ -81,6 +81,11 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == selector1) {\n             String p2 = selector2.currentPath();\n+            if (p2 == null && f.isPreparing() && selector2.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p2 = KNOWN_PATH;\n+            }\n             if (p2 != null) {\n                 if (selector2Path.equals(\".\")) {\n                     f.restrictPath(p2, Filter.PathRestriction.EXACT);\n@@ -93,6 +98,11 @@ public void restrict(FilterImpl f) {\n         }\n         if (f.getSelector() == selector2) {\n             String p1 = selector1.currentPath();\n+            if (p1 == null && f.isPreparing() && selector1.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p1 = KNOWN_PATH;\n+            }\n             if (p1 != null) {\n                 if (selector2Path.equals(\".\")) {\n                     f.restrictPath(p1, Filter.PathRestriction.EXACT);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\nindex ecf1e5b..3e779ff 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n@@ -95,6 +95,9 @@ public String toString() {\n         return quote(nodeTypeName) + \" as \" + quote(selectorName);\n     }\n \n+    public boolean isPrepared() {\n+        return index != null;\n+    }\n \n     @Override\n     public void prepare() {\n@@ -106,19 +109,19 @@ public void prepare() {\n                 c.restrictPushDown(this);\n             }\n         }\n-        index = query.getBestIndex(createFilter());\n+        index = query.getBestIndex(createFilter(true));\n     }\n \n     @Override\n     public void execute(NodeState rootState) {\n-        cursor = index.query(createFilter(), rootState);\n+        cursor = index.query(createFilter(false), rootState);\n     }\n \n     @Override\n     public String getPlan(NodeState rootState) {\n         StringBuilder buff = new StringBuilder();\n         buff.append(toString());\n-        buff.append(\" /* \").append(index.getPlan(createFilter(), rootState));\n+        buff.append(\" /* \").append(index.getPlan(createFilter(true), rootState));\n         if (selectorCondition != null) {\n             buff.append(\" where \").append(selectorCondition);\n         }\n@@ -126,8 +129,15 @@ public String getPlan(NodeState rootState) {\n         return buff.toString();\n     }\n \n-    private Filter createFilter() {\n+    /**\n+     * Create the filter condition for planning or execution.\n+     * \n+     * @param preparing whether a filter for the prepare phase should be made \n+     * @return the filter\n+     */\n+    private Filter createFilter(boolean preparing) {\n         FilterImpl f = new FilterImpl(this, query.getStatement());\n+        f.setPreparing(preparing);\n         validateNodeType(nodeTypeName);\n         f.setNodeType(nodeTypeName);\n         if (joinCondition != null) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\nindex 9bf1ef2..dc1d8e9 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n@@ -141,8 +141,8 @@ public SelectorImpl getExistingSelector(String selectorName) {\n     public abstract String getPlan(NodeState rootState);\n \n     /**\n-     * Prepare executing the query. This method will decide which index to use.\n-     *\n+     * Prepare executing the query (recursively). This method will decide which\n+     * index to use.\n      */\n     public abstract void prepare();\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\nindex f540e18..767ea3e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n@@ -76,6 +76,11 @@\n      */\n     private boolean distinct;\n     \n+    /**\n+     * Set during the prepare phase of a query.\n+     */\n+    private boolean preparing;\n+\n     // TODO support \"order by\"\n \n     public FilterImpl(SelectorImpl selector, String queryStatement) {\n@@ -83,6 +88,14 @@ public FilterImpl(SelectorImpl selector, String queryStatement) {\n         this.queryStatement = queryStatement;\n     }\n     \n+    public void setPreparing(boolean preparing) {\n+        this.preparing = preparing;\n+    }\n+    \n+    public boolean isPreparing() {\n+        return preparing;\n+    }\n+\n     /**\n      * Get the path.\n      *\n", "nb_test": 542, "linesAdd": 74, "jira_id": "579", "singleLine": false, "nb_skipped": 6, "commit": "7d72e6ed", "nb_failure": 0, "linesRem": 16}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["commitRootInPrevious(org.apache.jackrabbit.oak.plugins.document.DocumentSplitTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 49c9d01..48f3bfb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -362,9 +362,7 @@ public boolean containsRevision(@Nonnull Revision revision) {\n      */\n     @CheckForNull\n     public String getCommitRootPath(Revision revision) {\n-        // check local map first\n-        Map<Revision, String> local = getLocalCommitRoot();\n-        String depth = local.get(revision);\n+        String depth = getCommitRootDepth(revision);\n         if (depth != null) {\n             if (depth.equals(\"0\")) {\n                 return \"/\";\n@@ -373,13 +371,6 @@ public String getCommitRootPath(Revision revision) {\n             return PathUtils.getAncestorPath(p,\n                     PathUtils.getDepth(p) - Integer.parseInt(depth));\n         }\n-        // check previous\n-        for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {\n-            String path = prev.getCommitRootPath(revision);\n-            if (path != null) {\n-                return path;\n-            }\n-        }\n         return null;\n     }\n \n@@ -968,6 +959,31 @@ private NodeDocument getCommitRoot(@Nonnull Revision rev) {\n     }\n \n     /**\n+     * Returns the commit root depth for the given revision. This method also\n+     * takes previous documents into account.\n+     *\n+     * @param revision get the commit root depth for this revision.\n+     * @return the depth or <code>null</code> if there is no commit root entry\n+     *         for the given revision on this document or previous documents.\n+     */\n+    @CheckForNull\n+    private String getCommitRootDepth(@Nonnull Revision revision) {\n+        // check local map first\n+        Map<Revision, String> local = getLocalCommitRoot();\n+        String depth = local.get(revision);\n+        if (depth == null) {\n+            // check previous\n+            for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {\n+                depth = prev.getCommitRootDepth(revision);\n+                if (depth != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        return depth;\n+    }\n+\n+    /**\n      * Checks that revision x is newer than another revision.\n      *\n      * @param x the revision to check\n", "nb_test": 1625, "linesAdd": 16, "jira_id": "1429", "singleLine": false, "nb_skipped": 7, "commit": "279bb3ce", "nb_failure": 1, "linesRem": 8}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["xpath(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/xpath.txt don't match expected results in src/test/resources/xpath.txt; compare the files for details", "xpath(org.apache.jackrabbit.oak.plugins.index.property.OrderedIndexQueryTest): Results in target/xpath.txt don't match expected results in src/test/resources/xpath.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\nindex f922007..f93ed0e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n@@ -251,8 +251,12 @@ public void bindSelector(SourceImpl source) {\n     public void restrict(FilterImpl f) {\n         if (propertyName != null) {\n             if (f.getSelector().equals(selector)) {\n-                String pn = normalizePropertyName(propertyName);\n-                f.restrictProperty(pn, Operator.NOT_EQUAL, null);\n+                String p = propertyName;\n+                if (relativePath != null) {\n+                    p = PathUtils.concat(p, relativePath);\n+                }                \n+                p = normalizePropertyName(p);\n+                f.restrictProperty(p, Operator.NOT_EQUAL, null);\n             }\n         }\n         f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\nindex 6113c0c..9763c13 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n@@ -83,9 +83,7 @@ public Statement optimize() {\n     }\n     \n     private static void addToUnionList(Expression condition,  ArrayList<Expression> unionList) {\n-        if (condition.containsFullTextCondition()) {\n-            // do not use union\n-        } else if (condition instanceof OrCondition) {\n+        if (condition instanceof OrCondition) {\n             OrCondition or = (OrCondition) condition;\n             // conditions of type                \n             // @x = 1 or @y = 2\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\nindex 74060a1..10a459e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\n@@ -439,8 +439,13 @@ private void markSeen(String path) {\n         ConcatCursor(List<Cursor> cursors, QueryEngineSettings settings) {\n             this.cursors = cursors;\n             this.settings = settings;\n+            if (cursors.size() == 0) {\n+                init = true;\n+                closed = true;\n+            } else {\n                 this.currentCursor = cursors.remove(0);\n             }\n+        }\n \n         @Override\n         public IndexRow next() {\n", "nb_test": 1963, "linesAdd": 12, "jira_id": "2249", "singleLine": false, "nb_skipped": 9, "commit": "6dde8e9d", "nb_failure": 0, "linesRem": 4}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["getNewestRevision2(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): expected:<r156334c6eb0-0-1> but was:<null>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex fbcb646..f4006d4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -757,6 +757,15 @@ Revision getNewestRevision(final RevisionContext context,\n                     clusterIds.add(prevRev.getClusterId());\n                 }\n             }\n+            if (!clusterIds.isEmpty()) {\n+                // add clusterIds of local changes as well\n+                for (Revision r : getLocalCommitRoot().keySet()) {\n+                    clusterIds.add(r.getClusterId());\n+                }\n+                for (Revision r : getLocalRevisions().keySet()) {\n+                    clusterIds.add(r.getClusterId());\n+                }\n+            }\n         }\n         // if we don't have clusterIds, we can use the local changes only\n         boolean fullScan = true;\n@@ -786,7 +795,8 @@ Revision getNewestRevision(final RevisionContext context,\n             }\n             if (!fullScan) {\n                 // check if we can stop going through changes\n-                if (clusterIds.contains(r.getClusterId())) {\n+                if (isRevisionNewer(context, lower, r)\n+                        && newestRevs.containsKey(r.getClusterId())) {\n                     if (isRevisionNewer(context, lower, r)) {\n                         clusterIds.remove(r.getClusterId());\n                         if (clusterIds.isEmpty()) {\n", "nb_test": 3096, "linesAdd": 10, "jira_id": "3798", "singleLine": false, "nb_skipped": 1, "commit": "2ac1dccd", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["rollback(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): document with id 1:/newConflictingNode should get _deletedOnce marked due to rollback"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex eec0609..5bd72a3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -448,10 +448,14 @@ private void rollback(List<UpdateOp> newDocuments,\n         DocumentStore store = nodeStore.getDocumentStore();\n         for (UpdateOp op : changed) {\n             UpdateOp reverse = op.getReverseOperation();\n+            if (op.isNew()) {\n+                NodeDocument.setDeletedOnce(reverse);\n+            }\n             store.findAndUpdate(NODES, reverse);\n         }\n         for (UpdateOp op : newDocuments) {\n             UpdateOp reverse = op.getReverseOperation();\n+            NodeDocument.setDeletedOnce(reverse);\n             store.findAndUpdate(NODES, reverse);\n         }\n         UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 8424663..c5dd0d3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -1372,10 +1372,13 @@ public static void setDeleted(@Nonnull UpdateOp op,\n         if(deleted) {\n             //DELETED_ONCE would be set upon every delete.\n             //possibly we can avoid that\n-            checkNotNull(op).set(DELETED_ONCE, Boolean.TRUE);\n+            setDeletedOnce(op);\n+        }\n+        checkNotNull(op).setMapEntry(DELETED, checkNotNull(revision), String.valueOf(deleted));\n     }\n-        checkNotNull(op).setMapEntry(DELETED, checkNotNull(revision),\n-                String.valueOf(deleted));\n+\n+    public static void setDeletedOnce(@Nonnull UpdateOp op) {\n+        checkNotNull(op).set(DELETED_ONCE, Boolean.TRUE);\n     }\n \n     public static void removeDeleted(@Nonnull UpdateOp op,\n", "nb_test": 2232, "linesAdd": 10, "jira_id": "3104", "singleLine": false, "nb_skipped": 1, "commit": "38f5ef13", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["isNew[0](org.apache.jackrabbit.oak.core.MutableTreeTest): expected:<NEW> but was:<UNCHANGED>", "isNew[1](org.apache.jackrabbit.oak.core.MutableTreeTest): expected:<NEW> but was:<UNCHANGED>", "isNew[2](org.apache.jackrabbit.oak.core.MutableTreeTest): expected:<NEW> but was:<UNCHANGED>", "isNew[3](org.apache.jackrabbit.oak.core.MutableTreeTest): expected:<NEW> but was:<UNCHANGED>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/tree/AbstractTree.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/tree/AbstractTree.java\nindex 51afd2e..30f70ad 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/tree/AbstractTree.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/tree/AbstractTree.java\n@@ -204,7 +204,7 @@ protected void buildPath(StringBuilder sb) {\n \n     @Override\n     public Status getStatus() {\n-        if (nodeBuilder.isNew()) {\n+        if (nodeBuilder.isNew() || nodeBuilder.isReplaced()) {\n             return NEW;\n         } else if (nodeBuilder.isModified()) {\n             return MODIFIED;\n", "nb_test": 1830, "linesAdd": 1, "jira_id": "1674", "singleLine": false, "nb_skipped": 8, "commit": "073b814c", "nb_failure": 4, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["emptyCommit(org.apache.jackrabbit.mk.MicroKernelImplTest): empty branch commit must return current head of branch revision expected:<000000000000000[3]> but was:<000000000000000[1]>"], "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\nindex 35126ae..05b6309 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\n@@ -411,7 +411,7 @@ public String commit(String path, String jsonDiff, String revisionId, String mes\n             throw new IllegalArgumentException(\"absolute path expected: \" + path);\n         }\n         if (jsonDiff == null || jsonDiff.length() == 0) {\n-            return getHeadRevision();\n+            return revisionId != null ? revisionId : getHeadRevision();\n         }\n \n         Id revId = revisionId == null ? getHeadRevisionId() : Id.fromString(revisionId);\n", "nb_test": 100, "linesAdd": 1, "jira_id": "1122", "singleLine": false, "nb_skipped": 3, "commit": "5286861d", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["fulltextQueryWithSpecialChars(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): Expected path /test3 not found, got []"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex 749756a..42a7804 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -1371,7 +1371,7 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer) {\n     /**\n      * Following chars are used as operators in Lucene Query and should be escaped\n      */\n-    private static final char[] LUCENE_QUERY_OPERATORS = {':' , '/', '!', '&', '|'};\n+    private static final char[] LUCENE_QUERY_OPERATORS = {':' , '/', '!', '&', '|', '='};\n \n     /**\n      * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n", "nb_test": 359, "linesAdd": 1, "jira_id": "4359", "singleLine": false, "nb_skipped": 6, "commit": "002c5845", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["backgroundRead(org.apache.jackrabbit.oak.plugins.mongomk.MongoNodeStoreTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\nindex ecd48c6..6fee0d6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\n@@ -1135,8 +1135,15 @@ void backgroundRead() {\n             Revision r = e.getValue();\n             Revision last = lastKnownRevision.get(machineId);\n             if (last == null || r.compareRevisionTime(last) > 0) {\n-                lastKnownRevision.put(machineId, r);\n+                if (!hasNewRevisions) {\n+                    // publish our revision once before any foreign revision\n+\n+                    // the latest revisions of the current cluster node\n+                    // happened before the latest revisions of other cluster nodes\n+                    revisionComparator.add(Revision.newRevision(clusterId), headSeen);\n+                }\n                 hasNewRevisions = true;\n+                lastKnownRevision.put(machineId, r);\n                 revisionComparator.add(r, otherSeen);\n             }\n         }\n@@ -1144,11 +1151,6 @@ void backgroundRead() {\n             store.invalidateCache();\n             // TODO only invalidate affected items\n             docChildrenCache.invalidateAll();\n-            // add a new revision, so that changes are visible\n-            Revision r = Revision.newRevision(clusterId);\n-            // the latest revisions of the current cluster node\n-            // happened before the latest revisions of other cluster nodes\n-            revisionComparator.add(r, headSeen);\n             // the head revision is after other revisions\n             setHeadRevision(Revision.newRevision(clusterId));\n         }\n", "nb_test": 1505, "linesAdd": 5, "jira_id": "1254", "singleLine": false, "nb_skipped": 6, "commit": "25a70439", "nb_failure": 1, "linesRem": 3}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testChangeVisibility[RDBFixture: RDB-H2(file)](org.apache.jackrabbit.oak.plugins.document.MultiDocumentStoreTest): _modCount needs to be > 2 but was 2", "concurrentUpdate[RDBFixture: RDB-H2(file)](org.apache.jackrabbit.oak.plugins.document.MultiDocumentStoreTest): expected:<{Thread-125=2}> but was:<{Thread-124=2}>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\nindex 63304e7..ced74db 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n@@ -21,7 +21,6 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Date;\n-import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n@@ -83,6 +82,8 @@\n import com.mongodb.WriteResult;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Predicates.notNull;\n+import static com.google.common.collect.Maps.filterValues;\n \n /**\n  * A document store that uses MongoDB as the backend.\n@@ -285,22 +286,9 @@ public CacheInvalidationStats invalidateCache(Iterable<String> keys) {\n                         ids.size(), size);\n             }\n \n-            QueryBuilder query = QueryBuilder.start(Document.ID).in(ids);\n-            // Fetch only the modCount and id\n-            final BasicDBObject fields = new BasicDBObject(Document.ID, 1);\n-            fields.put(Document.MOD_COUNT, 1);\n-            \n-            DBCursor cursor = nodes.find(query.get(), fields);\n-            cursor.setReadPreference(ReadPreference.primary());\n+            Map<String, Number> modCounts = getModCounts(ids);\n             result.queryCount++;\n \n-            Map<String, Number> modCounts = new HashMap<String, Number>();\n-            for (DBObject obj : cursor) {\n-                String id = (String) obj.get(Document.ID);\n-                Number modCount = (Number) obj.get(Document.MOD_COUNT);\n-                modCounts.put(id, modCount);\n-            }\n-\n             int invalidated = nodesCache.invalidateOutdated(modCounts);\n             result.cacheEntriesProcessedCount += modCounts.size();\n             result.invalidationCount += invalidated;\n@@ -906,18 +894,26 @@ boolean canUseModifiedTimeIdx(long modifiedTimeInSecs) {\n             try {\n                 dbCollection.update(query.get(), update, false, true);\n                 if (collection == Collection.NODES) {\n+                    Map<String, Number> modCounts = getModCounts(filterValues(cachedDocs, notNull()).keySet());\n                     // update cache\n                     for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {\n                         // the cachedDocs is not empty, so the collection = NODES\n                         Lock lock = nodeLocks.acquire(entry.getKey());\n                         try {\n-                            if (entry.getValue() == null || entry.getValue() == NodeDocument.NULL) {\n+                            Number postUpdateModCount = modCounts.get(entry.getKey());\n+                            if (postUpdateModCount != null\n+                                    && entry.getValue() != null\n+                                    && entry.getValue() != NodeDocument.NULL\n+                                    && (postUpdateModCount.longValue() - 1) == entry.getValue().getModCount()) {\n+                                // post update modCount is one higher than\n+                                // what we currently see in the cache. we can\n+                                // replace the cached document\n+                                NodeDocument newDoc = applyChanges(Collection.NODES, entry.getValue(), updateOp.shallowCopy(entry.getKey()));\n+                                nodesCache.replaceCachedDocument(entry.getValue(), newDoc);\n+                            } else {\n                                 // make sure concurrently loaded document is\n                                 // invalidated\n                                 nodesCache.invalidate(entry.getKey());\n-                            } else {\n-                                NodeDocument newDoc = applyChanges(Collection.NODES, entry.getValue(), updateOp.shallowCopy(entry.getKey()));\n-                                nodesCache.replaceCachedDocument(entry.getValue(), newDoc);\n                             }\n                         } finally {\n                             lock.unlock();\n@@ -925,6 +921,11 @@ boolean canUseModifiedTimeIdx(long modifiedTimeInSecs) {\n                     }\n                 }\n             } catch (MongoException e) {\n+                // some documents may still have been updated\n+                // invalidate all documents affected by this update call\n+                for (String k : keys) {\n+                    nodesCache.invalidate(k);\n+                }\n                 throw DocumentStoreException.convert(e);\n             }\n         } finally {\n@@ -932,6 +933,35 @@ boolean canUseModifiedTimeIdx(long modifiedTimeInSecs) {\n         }\n     }\n \n+    /**\n+     * Returns the {@link Document#MOD_COUNT} value of the documents with the\n+     * given {@code keys}. The returned map will only contain entries for\n+     * existing documents.\n+     *\n+     * @param keys the keys of the documents.\n+     * @return map with key to {@link Document#MOD_COUNT} value mapping.\n+     * @throws MongoException if the call fails\n+     */\n+    @Nonnull\n+    private Map<String, Number> getModCounts(Iterable<String> keys)\n+            throws MongoException {\n+        QueryBuilder query = QueryBuilder.start(Document.ID).in(keys);\n+        // Fetch only the modCount and id\n+        final BasicDBObject fields = new BasicDBObject(Document.ID, 1);\n+        fields.put(Document.MOD_COUNT, 1);\n+\n+        DBCursor cursor = nodes.find(query.get(), fields);\n+        cursor.setReadPreference(ReadPreference.primary());\n+\n+        Map<String, Number> modCounts = Maps.newHashMap();\n+        for (DBObject obj : cursor) {\n+            String id = (String) obj.get(Document.ID);\n+            Number modCount = (Number) obj.get(Document.MOD_COUNT);\n+            modCounts.put(id, modCount);\n+        }\n+        return modCounts;\n+    }\n+\n     DocumentReadPreference getReadPreference(int maxCacheAge){\n         if(maxCacheAge >= 0 && maxCacheAge < maxReplicationLagMillis) {\n             return DocumentReadPreference.PRIMARY;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java\nindex f81e155..f07a827 100755\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java\n@@ -1261,6 +1261,9 @@ private static void addUpdateCounters(UpdateOp update) {\n                         qc.addKeys(chunkedIds);\n                         seenQueryContext.add(qc);\n                     }\n+                    for (String id : chunkedIds) {\n+                        nodesCache.invalidate(id);\n+                    }\n                 }\n \n                 Connection connection = null;\n@@ -1285,23 +1288,8 @@ private static void addUpdateCounters(UpdateOp update) {\n                                 qc.addKeys(chunkedIds);\n                             }\n                         }\n-                    }\n-                    for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {\n-                        T oldDoc = castAsT(entry.getValue());\n-                        String id = entry.getKey();\n-                        Lock lock = locks.acquire(id);\n-                        try {\n-                            if (oldDoc == null) {\n-                                // make sure concurrently loaded document is\n-                                // invalidated\n+                        for (String id : chunkedIds) {\n                             nodesCache.invalidate(id);\n-                            } else {\n-                                addUpdateCounters(update);\n-                                T newDoc = createNewDocument(collection, oldDoc, update);\n-                                nodesCache.replaceCachedDocument((NodeDocument) oldDoc, (NodeDocument) newDoc);\n-                            }\n-                        } finally {\n-                            lock.unlock();\n                         }\n                     }\n                 } else {\n", "nb_test": 3014, "linesAdd": 38, "jira_id": "3634", "singleLine": false, "nb_skipped": 1, "commit": "90ad50da", "nb_failure": 1, "linesRem": 32}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["restart(org.apache.jackrabbit.oak.plugins.document.ClusterNodeRestartTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\nindex 49496ee..9e3eac2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n@@ -127,7 +127,7 @@ public void dispose() {\n     }\n \n     void backgroundRead() {\n-        nodeStore.backgroundRead(true);\n+        nodeStore.backgroundRead();\n     }\n \n     void backgroundWrite() {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 061a364..347d694 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -18,6 +18,7 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.toArray;\n import static com.google.common.collect.Iterables.transform;\n@@ -487,27 +488,29 @@ public int getMemory() {\n             setHeadRevision(commit.getRevision());\n             // make sure _lastRev is written back to store\n             backgroundWrite();\n-        } else {\n-            // initialize branchCommits\n-            branches.init(store, this);\n-            // initial reading of the revisions of other cluster nodes\n-            backgroundRead(false);\n-            if (headRevision == null) {\n-                // no revision read from other cluster nodes\n-                setHeadRevision(newRevision());\n+            rootDoc = store.find(NODES, Utils.getIdFromPath(\"/\"));\n+            // at this point the root document must exist\n+            if (rootDoc == null) {\n+                throw new IllegalStateException(\"Root document does not exist\");\n             }\n+        } else {\n+            checkLastRevRecovery();\n+            initializeHeadRevision(rootDoc);\n             // check if _lastRev for our clusterId exists\n             if (!rootDoc.getLastRev().containsKey(clusterId)) {\n                 unsavedLastRevisions.put(\"/\", headRevision);\n                 backgroundWrite();\n             }\n         }\n-        checkLastRevRecovery();\n+\n         // Renew the lease because it may have been stale\n         renewClusterIdLease();\n \n         getRevisionComparator().add(headRevision, Revision.newRevision(0));\n \n+        // initialize branchCommits\n+        branches.init(store, this);\n+\n         dispatcher = new ChangeDispatcher(getRoot());\n         commitQueue = new CommitQueue(this);\n         String threadNamePostfix = \"(\" + clusterId + \")\";\n@@ -1693,7 +1696,7 @@ private void internalRunBackgroundReadOperations() {\n         synchronized (backgroundReadMonitor) {\n             long start = clock.getTime();\n             // pull in changes from other cluster nodes\n-            BackgroundReadStats readStats = backgroundRead(true);\n+            BackgroundReadStats readStats = backgroundRead();\n             long readTime = clock.getTime() - start;\n             String msg = \"Background read operations stats (read:{} {})\";\n             if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {\n@@ -1762,11 +1765,8 @@ boolean updateClusterState() {\n \n     /**\n      * Perform a background read and make external changes visible.\n-     *\n-     * @param dispatchChange whether to dispatch external changes\n-     *                       to {@link #dispatcher}.\n      */\n-    BackgroundReadStats backgroundRead(boolean dispatchChange) {\n+    BackgroundReadStats backgroundRead() {\n         BackgroundReadStats stats = new BackgroundReadStats();\n         long time = clock.getTime();\n         String id = Utils.getIdFromPath(\"/\");\n@@ -1774,30 +1774,7 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n         if (doc == null) {\n             return stats;\n         }\n-        Map<Integer, Revision> lastRevMap = doc.getLastRev();\n-        try {\n-            long externalTime = Utils.getMaxExternalTimestamp(lastRevMap.values(), clusterId);\n-            long localTime = clock.getTime();\n-            if (localTime < externalTime) {\n-                LOG.warn(\"Detected clock differences. Local time is '{}', \" +\n-                                \"while most recent external time is '{}'. \" +\n-                                \"Current _lastRev entries: {}\",\n-                        new Date(localTime), new Date(externalTime), lastRevMap.values());\n-                double delay = ((double) externalTime - localTime) / 1000d;\n-                String msg = String.format(\"Background read will be delayed by %.1f seconds. \" +\n-                        \"Please check system time on cluster nodes.\", delay);\n-                LOG.warn(msg);\n-                clock.waitUntil(externalTime + 1);\n-            } else if (localTime == externalTime) {\n-                // make sure local time is past external time\n-                // but only log at debug\n-                LOG.debug(\"Local and external time are equal. Waiting until local\" +\n-                        \"time is more recent than external reported time.\");\n-                clock.waitUntil(externalTime + 1);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\"Background read interrupted\", e);\n-        }\n+        alignWithExternalRevisions(doc);\n \n         Revision.RevisionComparator revisionComparator = getRevisionComparator();\n         // the (old) head occurred first\n@@ -1807,6 +1784,7 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n \n         StringSort externalSort = JournalEntry.newSorter();\n \n+        Map<Integer, Revision> lastRevMap = doc.getLastRev();\n         try {\n             Map<Revision, Revision> externalChanges = Maps.newHashMap();\n             for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {\n@@ -1899,7 +1877,6 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n                     Revision oldHead = headRevision;\n                     // the new head revision is after other revisions\n                     setHeadRevision(newRevision());\n-                    if (dispatchChange) {\n                     commitQueue.headRevisionChanged();\n                     time = clock.getTime();\n                     if (externalSort != null) {\n@@ -1915,7 +1892,6 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n                     time = clock.getTime();\n \n                     dispatcher.contentChanged(getRoot().fromExternalChange(), null);\n-                    }\n                 } finally {\n                     backgroundOperationLock.writeLock().unlock();\n                 }\n@@ -2054,6 +2030,68 @@ public void acquiring(Revision mostRecent) {\n \n     //-----------------------------< internal >---------------------------------\n \n+    /**\n+     * Performs an initial read of the _lastRevs on the root document,\n+     * initializes the {@link #revisionComparator} and sets the head revision.\n+     *\n+     * @param rootDoc the current root document.\n+     */\n+    private void initializeHeadRevision(NodeDocument rootDoc) {\n+        checkState(headRevision == null);\n+\n+        alignWithExternalRevisions(rootDoc);\n+        Map<Integer, Revision> lastRevMap = rootDoc.getLastRev();\n+        Revision seenAt = Revision.newRevision(0);\n+        long purgeMillis = revisionPurgeMillis();\n+        for (Map.Entry<Integer, Revision> entry : lastRevMap.entrySet()) {\n+            Revision r = entry.getValue();\n+            if (r.getTimestamp() > purgeMillis) {\n+                revisionComparator.add(r, seenAt);\n+            }\n+            if (entry.getKey() == clusterId) {\n+                continue;\n+            }\n+            lastKnownRevision.put(entry.getKey(), entry.getValue());\n+        }\n+        revisionComparator.purge(purgeMillis);\n+        setHeadRevision(newRevision());\n+    }\n+\n+    /**\n+     * Makes sure the current time is after the most recent external revision\n+     * timestamp in the _lastRev map of the given root document. If necessary\n+     * the current thread waits until {@link #clock} is after the external\n+     * revision timestamp.\n+     *\n+     * @param rootDoc the root document.\n+     */\n+    private void alignWithExternalRevisions(@Nonnull NodeDocument rootDoc) {\n+        Map<Integer, Revision> lastRevMap = checkNotNull(rootDoc).getLastRev();\n+        try {\n+            long externalTime = Utils.getMaxExternalTimestamp(lastRevMap.values(), clusterId);\n+            long localTime = clock.getTime();\n+            if (localTime < externalTime) {\n+                LOG.warn(\"Detected clock differences. Local time is '{}', \" +\n+                                \"while most recent external time is '{}'. \" +\n+                                \"Current _lastRev entries: {}\",\n+                        new Date(localTime), new Date(externalTime), lastRevMap.values());\n+                double delay = ((double) externalTime - localTime) / 1000d;\n+                String msg = String.format(\"Background read will be delayed by %.1f seconds. \" +\n+                        \"Please check system time on cluster nodes.\", delay);\n+                LOG.warn(msg);\n+                clock.waitUntil(externalTime + 1);\n+            } else if (localTime == externalTime) {\n+                // make sure local time is past external time\n+                // but only log at debug\n+                LOG.debug(\"Local and external time are equal. Waiting until local\" +\n+                        \"time is more recent than external reported time.\");\n+                clock.waitUntil(externalTime + 1);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Background read interrupted\", e);\n+        }\n+    }\n+\n     @Nonnull\n     private Commit newTrunkCommit(@Nonnull Revision base) {\n         checkArgument(!checkNotNull(base).isBranch(),\n", "nb_test": 2968, "linesAdd": 61, "jira_id": "3549", "singleLine": false, "nb_skipped": 1, "commit": "9772f5b2", "nb_failure": 1, "linesRem": 33}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testRelativeProperties(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Result set size is different expected:<1> but was:<2>", "testMultipleRelativeProperties(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Result set size is different expected:<0> but was:<1>", "sql2Measure(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/sql2_measure.txt don't match expected results in src/test/resources/sql2_measure.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\nindex 7421870..8434fb2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n@@ -42,6 +42,7 @@\n import org.apache.jackrabbit.oak.api.Tree;\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n+import org.apache.jackrabbit.oak.plugins.memory.PropertyBuilder;\n import org.apache.jackrabbit.oak.query.QueryImpl;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextExpression;\n import org.apache.jackrabbit.oak.query.index.FilterImpl;\n@@ -533,13 +534,34 @@ private PropertyValue currentOakProperty(String oakPropertyName, Integer propert\n             readOakProperties(list, t, oakPropertyName, propertyType);\n             if (list.size() == 0) {\n                 return null;\n+            } else if (list.size() == 1) {\n+                return list.get(0);\n+            }\n+            Type<?> type = list.get(0).getType();\n+            for (int i = 1; i < list.size(); i++) {\n+                Type<?> t2 = list.get(i).getType();\n+                if (t2 != type) {\n+                    // types don't match\n+                    type = Type.STRING;\n+                    break;\n+                }\n             }\n+            if (type == Type.STRING) {\n                 ArrayList<String> strings = new ArrayList<String>();\n                 for (PropertyValue p : list) {\n                     Iterables.addAll(strings, p.getValue(Type.STRINGS));\n                 }\n                 return PropertyValues.newString(strings);\n             }\n+            @SuppressWarnings(\"unchecked\")\n+            PropertyBuilder<Object> builder = (PropertyBuilder<Object>) PropertyBuilder.array(type);\n+            builder.setName(\"\");\n+            for (PropertyValue v : list) {\n+                builder.addValue(v.getValue(type));\n+            }\n+            PropertyState s = builder.getPropertyState();\n+            return PropertyValues.create(s);\n+        }\n         boolean relative = oakPropertyName.indexOf('/') >= 0;\n         Tree t = currentTree();\n         if (relative) {\n@@ -590,6 +612,7 @@ private PropertyValue currentOakProperty(Tree t, String oakPropertyName, Integer\n     }\n     \n     private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\n+        boolean skipCurrentNode = false;\n         while (true) {\n             if (t == null || !t.exists()) {\n                 return;\n@@ -608,10 +631,14 @@ private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String o\n                 for (Tree child : t.getChildren()) {\n                     readOakProperties(target, child, oakPropertyName, propertyType);\n                 }\n+                skipCurrentNode = true;\n             } else {\n                 t = t.getChild(parent);\n             }\n         }\n+        if (skipCurrentNode) {\n+            return;\n+        }\n         if (!\"*\".equals(oakPropertyName)) {\n             PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\n             if (value != null) {\n", "nb_test": 1836, "linesAdd": 26, "jira_id": "1076", "singleLine": false, "nb_skipped": 8, "commit": "9238264d", "nb_failure": 2, "linesRem": 0}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testUnwrappedOr(org.apache.jackrabbit.oak.query.SQL2ParserTest)", "xpath(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/xpath.txt don't match expected results in src/test/resources/xpath.txt; compare the files for details", "xpath(org.apache.jackrabbit.oak.plugins.index.property.OrderedIndexQueryTest): Results in target/xpath.txt don't match expected results in src/test/resources/xpath.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\nindex 782a543..b34fb56 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n@@ -17,6 +17,8 @@\n package org.apache.jackrabbit.oak.query.xpath;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n \n import org.apache.jackrabbit.oak.query.SQL2Parser;\n import org.apache.jackrabbit.util.ISO9075;\n@@ -46,6 +48,15 @@ public static Expression and(Expression old, Expression add) {\n     }\n     \n     /**\n+     * Get the optimized expression.\n+     * \n+     * @return the optimized expression\n+     */\n+    Expression optimize() {\n+        return this;\n+    }\n+\n+    /**\n      * Whether this is a condition.\n      * \n      * @return true if it is \n@@ -55,6 +66,43 @@ boolean isCondition() {\n     }\n     \n     /**\n+     * Whether this is a or contains a full-text condition.\n+     * \n+     * @return true if it is\n+     */\n+    boolean containsFullTextCondition() {\n+        return false;\n+    }\n+    \n+    /**\n+     * Get the left-hand-side expression for equality conditions. \n+     * For example, for x=1, it is x. If it is not equality, return null.\n+     * \n+     * @return the left-hand-side expression, or null\n+     */        \n+    String getCommonLeftPart() {\n+        return null;\n+    }\n+    \n+    /**\n+     * Get the left hand side of an expression.\n+     * \n+     * @return the left hand side\n+     */\n+    Expression getLeft() {\n+        return null;\n+    }\n+    \n+    /**\n+     * Get the list of the right hand side of an expression.\n+     * \n+     * @return the list\n+     */\n+    List<Expression> getRight() {\n+        return null;\n+    }\n+\n+    /**\n      * Pull an OR condition up to the right hand side of an AND condition.\n      * \n      * @return the (possibly rotated) expression\n@@ -157,13 +205,8 @@ int getPrecedence() {\n             return precedence;\n         }\n              \n-        /**\n-         * Get the left-hand-side expression for equality conditions. \n-         * For example, for x=1, it is x. If it is not equality, return null.\n-         * \n-         * @return the left-hand-side expression, or null\n-         */        \n-        public String getCommonLeftPart() {\n+        @Override\n+        String getCommonLeftPart() {\n             if (!\"=\".equals(operator)) {\n                 return null;\n             }\n@@ -171,6 +214,16 @@ public String getCommonLeftPart() {\n         }\n         \n         @Override\n+        Expression getLeft() {\n+            return left;\n+        }\n+        \n+        @Override\n+        List<Expression> getRight() {\n+            return Collections.singletonList(right);\n+        }\n+    \n+        @Override\n         public String toString() {\n             String leftExpr;\n             boolean leftExprIsName;\n@@ -223,6 +276,11 @@ boolean isCondition() {\n             return true;\n         }\n         \n+        @Override\n+        Expression optimize() {\n+            return this;\n+        }\n+    \n     }\n     \n     /**\n@@ -243,16 +301,87 @@ boolean isCondition() {\n          */\n         @Override\n         public String getCommonLeftPart() {\n-            if (left instanceof Condition && right instanceof Condition) {\n-                String l = ((Condition) left).getCommonLeftPart();\n-                String r = ((Condition) right).getCommonLeftPart();\n+            String l = left.getCommonLeftPart();\n+            String r = right.getCommonLeftPart();\n             if (l != null && r != null && l.equals(r)) {\n                 return l;\n             }\n-            }\n             return null;\n         }\n         \n+        @Override\n+        Expression optimize() {\n+            Expression l = left.optimize();\n+            Expression r = right.optimize();\n+            if (l != left || r != right) {\n+                return new OrCondition(l, r).optimize();\n+            }\n+            String commonLeft = getCommonLeftPart();\n+            if (commonLeft == null) {\n+                return this;\n+            }\n+            // \"@x = 1 or @x = 2\" is converted to \"@x in (1, 2)\"\n+            ArrayList<Expression> list = new ArrayList<Expression>();\n+            list.addAll(left.getRight());\n+            list.addAll(right.getRight());\n+            Expression le = left.getLeft();\n+            InCondition in = new InCondition(le, list);\n+            return in.optimize();\n+        }\n+        \n+        @Override\n+        boolean containsFullTextCondition() {\n+            return left.containsFullTextCondition() || right.containsFullTextCondition();\n+        }\n+        \n+    }\n+    \n+    /**\n+     * An \"or\" condition.\n+     */\n+    static class InCondition extends Expression {\n+\n+        final Expression left;\n+        final List<Expression> list;\n+        \n+        InCondition(Expression left, List<Expression> list) {\n+            this.left = left;\n+            this.list = list;\n+        }\n+        \n+        @Override\n+        String getCommonLeftPart() {\n+            return left.toString();\n+        }\n+        \n+        @Override\n+        Expression getLeft() {\n+            return left;\n+        }\n+        \n+        @Override\n+        List<Expression> getRight() {\n+            return list;\n+        }\n+    \n+        @Override\n+        public String toString() {\n+            StringBuilder buff = new StringBuilder();\n+            buff.append(left).append(\" in(\");\n+            for (int i = 0; i < list.size(); i++) {\n+                if (i > 0) {\n+                    buff.append(\", \");\n+                }\n+                buff.append(list.get(i));\n+            }\n+            return buff.append(')').toString();\n+        }\n+    \n+        @Override\n+        boolean isCondition() {\n+            return true;\n+        }        \n+        \n     }\n     \n     /**\n@@ -265,6 +394,16 @@ public String getCommonLeftPart() {\n         }\n \n         @Override\n+        Expression optimize() {\n+            Expression l = left.optimize();\n+            Expression r = right.optimize();\n+            if (l != left || r != right) {\n+                return new AndCondition(l, r);\n+            }\n+            return this;\n+        }\n+        \n+        @Override\n         AndCondition pullOrRight() {\n             if (right instanceof OrCondition) {\n                 return this;\n@@ -285,6 +424,11 @@ AndCondition pullOrRight() {\n             return this;\n         }\n         \n+        @Override\n+        boolean containsFullTextCondition() {\n+            return left.containsFullTextCondition() || right.containsFullTextCondition();\n+        }\n+        \n     }\n     \n     /**\n@@ -320,6 +464,11 @@ boolean isCondition() {\n         }\n         \n         @Override\n+        boolean containsFullTextCondition() {\n+            return true;\n+        }\n+        \n+        @Override\n         boolean isName() {\n             return left.isName();\n         }\n@@ -354,6 +503,11 @@ boolean isCondition() {\n         }\n \n         @Override\n+        boolean containsFullTextCondition() {\n+            return true;\n+        }\n+        \n+        @Override\n         boolean isName() {\n             return false;\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\nindex 0504429..6113c0c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n@@ -20,7 +20,6 @@\n \n import org.apache.jackrabbit.oak.query.QueryImpl;\n import org.apache.jackrabbit.oak.query.xpath.Expression.AndCondition;\n-import org.apache.jackrabbit.oak.query.xpath.Expression.Contains;\n import org.apache.jackrabbit.oak.query.xpath.Expression.OrCondition;\n import org.apache.jackrabbit.oak.query.xpath.Expression.Property;\n \n@@ -29,8 +28,6 @@\n  */\n public class Statement {\n \n-    private String xpathQuery;\n-    \n     private boolean explain;\n     private boolean measure;\n     \n@@ -49,15 +46,18 @@\n     \n     private Expression where;\n \n-    private ArrayList<Order> orderList = new ArrayList<Order>();\n+    ArrayList<Order> orderList = new ArrayList<Order>();\n+    \n+    String xpathQuery;\n     \n     public Statement optimize() {\n-        if (explain || measure || orderList.size() > 0) {\n+        if (explain || measure) {\n             return this;\n         }\n         if (where == null) {\n             return this;\n         }\n+        where = where.optimize();\n         ArrayList<Expression> unionList = new ArrayList<Expression>();\n         addToUnionList(where, unionList);\n         if (unionList.size() == 1) {\n@@ -71,29 +71,22 @@ public Statement optimize() {\n             s.selectors = selectors;\n             s.columnList = columnList;\n             s.where = e;\n-            if (i == unionList.size() - 1) {\n-                s.xpathQuery = xpathQuery;\n-            }\n             if (union == null) {\n                 union = s;\n             } else {\n                 union = new UnionStatement(union.optimize(), s.optimize());\n             }\n         }\n+        union.orderList = orderList;\n+        union.xpathQuery = xpathQuery;\n         return union;\n     }\n     \n     private static void addToUnionList(Expression condition,  ArrayList<Expression> unionList) {\n-        if (condition instanceof OrCondition) {\n+        if (condition.containsFullTextCondition()) {\n+            // do not use union\n+        } else if (condition instanceof OrCondition) {\n             OrCondition or = (OrCondition) condition;\n-            if (or.getCommonLeftPart() != null) {\n-                // @x = 1 or @x = 2 \n-                // is automatically converted to \n-                // @x in (1, 2)\n-                // within the query engine\n-            } else if (or.left instanceof Contains && or.right instanceof Contains) {\n-                // do not optimize \"contains\"\n-            } else {\n             // conditions of type                \n             // @x = 1 or @y = 2\n             // or similar are converted to\n@@ -101,7 +94,6 @@ private static void addToUnionList(Expression condition,  ArrayList<Expression>\n             addToUnionList(or.left, unionList);\n             addToUnionList(or.right, unionList);\n             return;\n-            }\n         } else if (condition instanceof AndCondition) {\n             // conditions of type\n             // @a = 1 and (@x = 1 or @y = 2)\n@@ -111,21 +103,12 @@ private static void addToUnionList(Expression condition,  ArrayList<Expression>\n             and = and.pullOrRight();\n             if (and.right instanceof OrCondition) {\n                 OrCondition or = (OrCondition) and.right;\n-                if (or.getCommonLeftPart() != null) {\n-                    // @x = 1 or @x = 2 \n-                    // is automatically converted to \n-                    // @x in (1, 2)\n-                    // within the query engine                \n-                } else if (or.left instanceof Contains && or.right instanceof Contains) {\n-                    // do not optimize \"contains\"\n-                } else {\n                 // same as above, but with the added \"and\"\n                 addToUnionList(new AndCondition(and.left, or.left), unionList);\n                 addToUnionList(new AndCondition(and.left, or.right), unionList);\n                 return;\n             }\n         }\n-        }\n         unionList.add(condition);\n     }\n     \n@@ -255,7 +238,25 @@ public void setOriginalQuery(String xpathQuery) {\n         \n         @Override\n         public String toString() {\n-            return s1 + \" union \" + s2;\n+            StringBuilder buff = new StringBuilder();\n+            buff.append(s1).append(\" union \").append(s2);\n+            // order by ...\n+            if (orderList != null && !orderList.isEmpty()) {\n+                buff.append(\" order by \");\n+                for (int i = 0; i < orderList.size(); i++) {\n+                    if (i > 0) {\n+                        buff.append(\", \");\n+                    }\n+                    buff.append(orderList.get(i));\n+                }\n+            }\n+            // leave original xpath string as a comment\n+            if (xpathQuery != null) {\n+                buff.append(\" /* xpath: \");\n+                buff.append(xpathQuery);\n+                buff.append(\" */\");\n+            }\n+            return buff.toString();\n         }\n         \n     }\n", "nb_test": 1868, "linesAdd": 161, "jira_id": "2021", "singleLine": false, "nb_skipped": 9, "commit": "004db804", "nb_failure": 1, "linesRem": 23}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["retrieveAny[0](org.apache.jackrabbit.oak.kernel.CheckpointTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 4efc6cb..5c519c2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -39,6 +39,7 @@\n import java.util.Map;\n import java.util.NavigableSet;\n import java.util.Set;\n+import java.util.SortedMap;\n import java.util.TimeZone;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -70,6 +71,7 @@\n import org.apache.jackrabbit.oak.commons.json.JsopTokenizer;\n import org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob;\n import org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector;\n+import org.apache.jackrabbit.oak.plugins.document.Checkpoints.Info;\n import org.apache.jackrabbit.oak.plugins.document.mongo.MongoBlobReferenceIterator;\n import org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore;\n import org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache;\n@@ -1404,7 +1406,8 @@ public String checkpoint(long lifetime) {\n     @Override\n     public NodeState retrieve(@Nonnull String checkpoint) {\n         Revision r = Revision.fromString(checkpoint);\n-        if (checkpoints.getCheckpoints().containsKey(r)) {\n+        SortedMap<Revision, Info> checkpoints = this.checkpoints.getCheckpoints();\n+        if (checkpoints != null && checkpoints.containsKey(r)) {\n             return getRoot(r);\n         } else {\n             return null;\n", "nb_test": 2033, "linesAdd": 4, "jira_id": "2363", "singleLine": false, "nb_skipped": 9, "commit": "90ea7aa5", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 4, "classification": {"singleLine": false}, "failing_tests": ["getNodeSNS[0](org.apache.jackrabbit.oak.jcr.RepositoryTest): bar[2]", "getNodeSNS[3](org.apache.jackrabbit.oak.jcr.RepositoryTest): bar[2]", "getNodeSNS[2](org.apache.jackrabbit.oak.jcr.RepositoryTest): bar[2]", "getNodeSNS[1](org.apache.jackrabbit.oak.jcr.RepositoryTest): bar[2]"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\nindex 2dbd284..21a32d0 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n@@ -797,6 +797,7 @@ public PropertyIterator getWeakReferences(String name) throws RepositoryExceptio\n \n     @Override\n     public boolean hasNode(String relPath) throws RepositoryException {\n+        try {\n             final String oakPath = getOakPathOrThrow(relPath);\n             return perform(new NodeOperation<Boolean>(dlg) {\n                 @Override\n@@ -804,10 +805,14 @@ public Boolean perform() throws RepositoryException {\n                     return node.getChild(oakPath) != null;\n                 }\n             });\n+        } catch (PathNotFoundException e) {\n+            return false;\n+        }\n     }\n \n     @Override\n     public boolean hasProperty(String relPath) throws RepositoryException {\n+        try {\n             final String oakPath = getOakPathOrThrow(relPath);\n             return perform(new NodeOperation<Boolean>(dlg) {\n                 @Override\n@@ -815,6 +820,9 @@ public Boolean perform() throws RepositoryException {\n                     return node.getPropertyOrNull(oakPath) != null;\n                 }\n             });\n+        } catch (PathNotFoundException e) {\n+            return false;\n+        }\n     }\n \n     @Override\n", "nb_test": 1963, "linesAdd": 8, "jira_id": "1227", "singleLine": false, "nb_skipped": 5, "commit": "117b0a3d", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["verifyPrivileges(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Miss match in aggregate privilege jcr:all expected [rep:readNodes, rep:readProperties, rep:addProperties, rep:alterProperties, rep:removeProperties, jcr:addChildNodes, jcr:removeChildNodes, jcr:removeNode, jcr:readAccessControl, jcr:modifyAccessControl, jcr:nodeTypeManagement, jcr:versionManagement, jcr:lockManagement, jcr:lifecycleManagement, jcr:retentionManagement, jcr:workspaceManagement, jcr:nodeTypeDefinitionManagement, jcr:namespaceManagement, rep:privilegeManagement, rep:userManagement, rep:indexDefinitionManagement, jcr:read, jcr:modifyProperties, jcr:write, rep:write] actual [test:privilege, rep:alterProperties, jcr:read, jcr:addChildNodes, jcr:nodeTypeManagement, jcr:removeChildNodes, jcr:nodeTypeDefinitionManagement, jcr:removeNode, jcr:write, jcr:readAccessControl, rep:readProperties, test:aggregate, jcr:modifyAccessControl, jcr:lifecycleManagement, jcr:versionManagement, jcr:namespaceManagement, jcr:lockManagement, jcr:workspaceManagement, rep:readNodes, jcr:modifyProperties, jcr:retentionManagement, rep:removeProperties, rep:write, rep:addProperties, rep:privilegeManagement]"], "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex 27e82ab..40b709f 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -65,6 +65,7 @@\n import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERYABLE;\n import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERY_ORDERABLE;\n import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_NODE_TYPES;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.JCR_ALL;\n import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGE;\n import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGES;\n import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_AGGREGATES;\n@@ -267,7 +268,7 @@ public void copy(RepositoryInitializer initializer) throws RepositoryException {\n             Map<Integer, String> idxToPrefix = newHashMap();\n             copyNamespaces(builder, uriToPrefix, idxToPrefix);\n             copyNodeTypes(builder, uriToPrefix.inverse());\n-            copyPrivileges(builder);\n+            copyCustomPrivileges(builder);\n \n             // Triggers compilation of type information, which we need for\n             // the type predicates used by the bulk  copy operations below.\n@@ -466,7 +467,7 @@ private Properties loadProperties(String path) throws RepositoryException {\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private void copyPrivileges(NodeBuilder root) throws RepositoryException {\n+    private void copyCustomPrivileges(NodeBuilder root) {\n         PrivilegeRegistry registry = source.getPrivilegeRegistry();\n         NodeBuilder privileges = root.child(JCR_SYSTEM).child(REP_PRIVILEGES);\n         privileges.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, NAME);\n@@ -476,6 +477,12 @@ private void copyPrivileges(NodeBuilder root) throws RepositoryException {\n         logger.info(\"Copying registered privileges\");\n         for (Privilege privilege : registry.getRegisteredPrivileges()) {\n             String name = privilege.getName();\n+            if (PrivilegeBits.BUILT_IN.containsKey(name) || JCR_ALL.equals(name)) {\n+                // Ignore built in privileges as those have been installed by\n+                // the PrivilegesInitializer already\n+                continue;\n+            }\n+\n             NodeBuilder def = privileges.child(name);\n             def.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGE, NAME);\n \n@@ -510,7 +517,7 @@ private void copyPrivileges(NodeBuilder root) throws RepositoryException {\n         }\n     }\n \n-    private PrivilegeBits resolvePrivilegeBits(\n+    private static PrivilegeBits resolvePrivilegeBits(\n             NodeBuilder privileges, String name) {\n         NodeBuilder def = privileges.getChildNode(name);\n \n", "nb_test": 17, "linesAdd": 8, "jira_id": "2047", "singleLine": false, "nb_skipped": 0, "commit": "a0a495f0", "nb_failure": 1, "linesRem": 3}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["hiddenNodeAdded(org.apache.jackrabbit.oak.security.authorization.accesscontrol.AccessControlValidatorTest)", "hiddenNodeChanged(org.apache.jackrabbit.oak.security.authorization.accesscontrol.AccessControlValidatorTest)", "hiddenNodeChanged(org.apache.jackrabbit.oak.security.user.UserValidatorTest)", "hiddenNodeDeleted(org.apache.jackrabbit.oak.security.user.UserValidatorTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlValidator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlValidator.java\nindex 3aa11f9..0721f2b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlValidator.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlValidator.java\n@@ -42,6 +42,7 @@\n import org.apache.jackrabbit.oak.plugins.tree.impl.TreeConstants;\n import org.apache.jackrabbit.oak.spi.commit.DefaultValidator;\n import org.apache.jackrabbit.oak.spi.commit.Validator;\n+import org.apache.jackrabbit.oak.spi.commit.VisibleValidator;\n import org.apache.jackrabbit.oak.spi.security.authorization.accesscontrol.AccessControlConstants;\n import org.apache.jackrabbit.oak.spi.security.authorization.restriction.Restriction;\n import org.apache.jackrabbit.oak.spi.security.authorization.restriction.RestrictionProvider;\n@@ -122,7 +123,7 @@ public Validator childNodeAdded(String name, NodeState after) throws CommitFaile\n         Tree treeAfter = checkNotNull(parentAfter.getChild(name));\n \n         checkValidTree(parentAfter, treeAfter, after);\n-        return new AccessControlValidator(this, treeAfter);\n+        return newValidator(this, treeAfter);\n     }\n \n     @Override\n@@ -130,7 +131,7 @@ public Validator childNodeChanged(String name, NodeState before, NodeState after\n         Tree treeAfter = checkNotNull(parentAfter.getChild(name));\n \n         checkValidTree(parentAfter, treeAfter, after);\n-        return new AccessControlValidator(this, treeAfter);\n+        return newValidator(this, treeAfter);\n     }\n \n     @Override\n@@ -141,6 +142,14 @@ public Validator childNodeDeleted(String name, NodeState before) throws CommitFa\n \n     //------------------------------------------------------------< private >---\n \n+    private static Validator newValidator(AccessControlValidator parent,\n+                                          Tree parentAfter) {\n+        return new VisibleValidator(\n+                new AccessControlValidator(parent, parentAfter),\n+                true,\n+                true);\n+    }\n+\n     private void checkValidTree(Tree parentAfter, Tree treeAfter, NodeState nodeAfter) throws CommitFailedException {\n         if (isPolicy(treeAfter)) {\n             checkValidPolicy(parentAfter, treeAfter, nodeAfter);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\nindex 975f5eb..7d6a2e9 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\n@@ -139,12 +139,13 @@ public Validator childNodeAdded(String name, NodeState after) throws CommitFaile\n         Tree tree = checkNotNull(parentAfter.getChild(name));\n \n         validateAuthorizable(tree, UserUtil.getType(tree));\n-        return new VisibleValidator(new UserValidator(null, tree, provider), true, true);\n+        return newValidator(null, tree, provider);\n     }\n \n     @Override\n     public Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {\n-        return new UserValidator(parentBefore.getChild(name), parentAfter.getChild(name), provider);\n+        return newValidator(parentBefore.getChild(name),\n+                parentAfter.getChild(name), provider);\n     }\n \n     @Override\n@@ -158,12 +159,21 @@ public Validator childNodeDeleted(String name, NodeState before) throws CommitFa\n             }\n             return null;\n         } else {\n-            return new VisibleValidator(new UserValidator(tree, null, provider), true, true);\n+            return newValidator(tree, null, provider);\n         }\n     }\n \n     //------------------------------------------------------------< private >---\n \n+    private static Validator newValidator(Tree parentBefore,\n+                                          Tree parentAfter,\n+                                          UserValidatorProvider provider) {\n+        return new VisibleValidator(\n+                new UserValidator(parentBefore, parentAfter, provider),\n+                true,\n+                true);\n+    }\n+\n     private boolean isAdminUser(@Nonnull Tree userTree) {\n         if (userTree.exists() && isUser(userTree)) {\n             String id = UserUtil.getAuthorizableId(userTree);\n", "nb_test": 2196, "linesAdd": 24, "jira_id": "3021", "singleLine": false, "nb_skipped": 9, "commit": "494da6de", "nb_failure": 4, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["reindexAndIndexDefnChildRemoval_OAK_2117(org.apache.jackrabbit.oak.plugins.index.IndexUpdateTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\nindex f68c213..47cdfd1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n@@ -45,6 +45,7 @@\n import org.apache.jackrabbit.oak.spi.commit.Editor;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.apache.jackrabbit.oak.spi.state.NodeStateUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -170,8 +171,10 @@ private void collectIndexEditors(NodeBuilder definitions,\n                         // as we don't know the index content node name\n                         // beforehand, we'll remove all child nodes\n                         for (String rm : definition.getChildNodeNames()) {\n+                            if (NodeStateUtils.isHidden(rm)) {\n                                 definition.getChildNode(rm).remove();\n                             }\n+                        }\n                         reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), editor);\n                     }\n                 } else {\n", "nb_test": 1901, "linesAdd": 3, "jira_id": "2117", "singleLine": false, "nb_skipped": 9, "commit": "c7669f31", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReadOnRemovedNode(org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest): Expected exception: java.lang.IllegalStateException"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex d5712ba..411c5fc 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -193,10 +193,15 @@ private MutableNodeState getWriteState(String name) {\n      * @return {@code true} iff this child exists at its direct parent.\n      */\n     private boolean exists() {\n-        // No need to check the base state if write state is null. The fact that we have this\n-        // builder instance proofs that this child existed at some point as it must have been\n-        // retrieved from the base state.\n-        return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);\n+        if (isRoot()) {\n+            return true;\n+        }\n+        else if (parent.writeState == null) {\n+            return parent.baseState != null && parent.baseState.hasChildNode(name);\n+        }\n+        else {\n+            return parent.writeState.hasChildNode(name);\n+        }\n     }\n \n     /**\n@@ -206,11 +211,8 @@ private boolean exists() {\n     private boolean updateReadState() {\n         if (revision != root.revision) {\n             assert(!isRoot()); // root never gets here since revision == root.revision\n-            if (!exists()) {\n-                return false;\n-            }\n-            parent.updateReadState();\n \n+            if (parent.updateReadState() && exists()) {\n                 // The builder could have been reset, need to re-get base state\n                 baseState = parent.getBaseState(name);\n \n@@ -218,6 +220,10 @@ private boolean updateReadState() {\n                 writeState = parent.getWriteState(name);\n \n                 revision = root.revision;\n+                return true;\n+            }\n+\n+            return false;\n         }\n         return writeState != null || baseState != null;\n     }\n@@ -238,8 +244,8 @@ private MutableNodeState write() {\n     private MutableNodeState write(long newRevision, boolean reconnect) {\n         // make sure that all revision numbers up to the root gets updated\n         if (!isRoot()) {\n-            checkState(reconnect || exists(), \"This node has been removed\");\n             parent.write(newRevision, reconnect);\n+            checkState(reconnect || exists(), \"This node has been removed\");\n         }\n \n         if (writeState == null || revision != root.revision) {\n", "nb_test": 687, "linesAdd": 15, "jira_id": "678", "singleLine": false, "nb_skipped": 1, "commit": "6c54045d", "nb_failure": 1, "linesRem": 6}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["importUUIDCreateNew[3](org.apache.jackrabbit.oak.jcr.RepositoryTest)", "importUUIDCreateNew[0](org.apache.jackrabbit.oak.jcr.RepositoryTest)", "importUUIDCreateNew[2](org.apache.jackrabbit.oak.jcr.RepositoryTest)", "importUUIDCreateNew[1](org.apache.jackrabbit.oak.jcr.RepositoryTest)"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\nindex bc2eb6b..f6d2c44 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\n@@ -404,7 +404,12 @@ public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos)\n                     conflicting = currentStateIdManager.getTree(id);\n                 }\n \n-                if (conflicting != null && conflicting.exists()) {\n+                // resolve conflict if there is one or force\n+                // conflict resolution when behavior is IMPORT_UUID_CREATE_NEW.\n+                // the latter will always create a new UUID even if no\n+                // conflicting node exists. see OAK-1244\n+                if ((conflicting != null && conflicting.exists())\n+                        || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                     // resolve uuid conflict\n                     tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                     if (tree == null) {\n", "nb_test": 1795, "linesAdd": 2, "jira_id": "1244", "singleLine": false, "nb_skipped": 5, "commit": "b4a93c81", "nb_failure": 4, "linesRem": 1}, {"files": 0, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["validateMigration(org.apache.jackrabbit.oak.upgrade.cli.blob.FbsToFbsTest): expected:<123> but was:<null>", "validateMigration(org.apache.jackrabbit.oak.upgrade.cli.blob.CopyReferencesTest): expected:<123> but was:<null>", "validateMigration(org.apache.jackrabbit.oak.upgrade.cli.blob.FdsToFbsTest): expected:<123> but was:<null>", "validateMigration(org.apache.jackrabbit.oak.upgrade.cli.blob.FbsToFdsTest): expected:<123> but was:<null>", "validateMigration(org.apache.jackrabbit.oak.upgrade.cli.SegmentToSegmentTarTest): expected:<123> but was:<null>", "validateMigration(org.apache.jackrabbit.oak.upgrade.cli.SegmentTarToSegmentTest): expected:<123> but was:<null>", "validateMigration(org.apache.jackrabbit.oak.upgrade.cli.SegmentToSegmentTest): expected:<123> but was:<null>"], "patch": "", "nb_test": 128, "linesAdd": 0, "jira_id": "4420", "singleLine": false, "nb_skipped": 7, "commit": "d645112f", "nb_failure": 7, "linesRem": 0}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["query(org.apache.jackrabbit.oak.plugins.index.nodetype.NodeTypeIndexQueryTest): Result set size is different expected:<2> but was:<0>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java\nindex 8ffa57b..f4f8dfb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java\n@@ -48,7 +48,7 @@ public double getCost(Filter filter, NodeState root) {\n             return Double.POSITIVE_INFINITY;\n         }\n         NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\n-        if (lookup.isIndexed(filter.getPath())) {\n+        if (lookup.isIndexed(filter.getPath(), filter)) {\n             return lookup.getCost(filter);\n         } else {\n             return Double.POSITIVE_INFINITY;\n@@ -58,7 +58,7 @@ public double getCost(Filter filter, NodeState root) {\n     @Override\n     public Cursor query(Filter filter, NodeState root) {\n         NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\n-        if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath())) {\n+        if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath(), filter)) {\n             throw new IllegalStateException(\n                     \"NodeType index is used even when no index is available for filter \" + filter);\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java\nindex 9a9316b..e4a61bb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java\n@@ -45,10 +45,10 @@ public NodeTypeIndexLookup(NodeState root) {\n      * @return <code>true</code> if a node type index exists; <code>false</code>\n      *         otherwise.\n      */\n-    public boolean isIndexed(String path) {\n+    public boolean isIndexed(String path, Filter f) {\n         PropertyIndexLookup lookup = new PropertyIndexLookup(root);\n-        if (lookup.isIndexed(JCR_PRIMARYTYPE, path, null)\n-                && lookup.isIndexed(JCR_MIXINTYPES, path, null)) {\n+        if (lookup.isIndexed(JCR_PRIMARYTYPE, path, f)\n+                && lookup.isIndexed(JCR_MIXINTYPES, path, f)) {\n             return true;\n         }\n \n@@ -62,13 +62,13 @@ public boolean isIndexed(String path) {\n \n         NodeState child = root.getChildNode(path.substring(0, slash));\n         return new NodeTypeIndexLookup(child).isIndexed(\n-                path.substring(slash));\n+                path.substring(slash), f);\n     }\n \n     public double getCost(Filter filter) {\n         PropertyIndexLookup lookup = new PropertyIndexLookup(root);\n-        return lookup.getCost(null, JCR_PRIMARYTYPE, newName(filter.getPrimaryTypes()))\n-                + lookup.getCost(null, JCR_MIXINTYPES, newName(filter.getMixinTypes()));\n+        return lookup.getCost(filter, JCR_PRIMARYTYPE, newName(filter.getPrimaryTypes()))\n+                + lookup.getCost(filter, JCR_MIXINTYPES, newName(filter.getMixinTypes()));\n     }\n \n     /**\n", "nb_test": 1485, "linesAdd": 8, "jira_id": "1269", "singleLine": false, "nb_skipped": 6, "commit": "b8fe2ded", "nb_failure": 1, "linesRem": 8}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["fulltextQueryWithSpecialChars(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): INVALID_SYNTAX_CANNOT_PARSE: Syntax Error, cannot parse foo!:"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex cd4d2c3..fb69de7 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -39,6 +39,7 @@\n import com.google.common.collect.Lists;\n import com.google.common.collect.Queues;\n import com.google.common.collect.Sets;\n+import com.google.common.primitives.Chars;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.Result.SizePrecision;\n import org.apache.jackrabbit.oak.api.Type;\n@@ -1337,6 +1338,11 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer) {\n     }\n \n     /**\n+     * Following chars are used as operators in Lucene Query and should be escaped\n+     */\n+    private static final char[] LUCENE_QUERY_OPERATORS = {':' , '/', '!', '&', '|', '[', ']', '{', '}'};\n+\n+    /**\n      * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n      */\n     static String rewriteQueryText(String textsearch) {\n@@ -1361,10 +1367,7 @@ static String rewriteQueryText(String textsearch) {\n                     escaped = false;\n                 }\n                 rewritten.append(c);\n-            } else if (c == ':' || c == '/') {\n-                //TODO Some other chars are also considered special See OAK-3769 for details\n-                //':' fields as known in lucene are not supported\n-                //'/' its a special char used for regex search in Lucene\n+            } else if (Chars.contains(LUCENE_QUERY_OPERATORS, c)) {\n                 rewritten.append('\\\\').append(c);\n             } else {\n                 if (escaped) {\n", "nb_test": 326, "linesAdd": 4, "jira_id": "3879", "singleLine": false, "nb_skipped": 3, "commit": "4faf31e3", "nb_failure": 0, "linesRem": 1}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["shallowCopy(org.apache.jackrabbit.oak.plugins.document.UpdateOpTest): expected:<1> but was:<0>", "combine(org.apache.jackrabbit.oak.plugins.document.UpdateOpTest): expected:<1> but was:<0>", "copy(org.apache.jackrabbit.oak.plugins.document.UpdateOpTest): expected:<1> but was:<0>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex a764669..7f09df6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -383,7 +383,7 @@ private void applyToDocumentStore(Revision baseBranchRevision) {\n                     // to set isNew to false. If we get here the\n                     // commitRoot document already exists and\n                     // only needs an update\n-                    UpdateOp commit = commitRoot.shallowCopy(commitRoot.getId());\n+                    UpdateOp commit = commitRoot.copy();\n                     commit.setNew(false);\n                     // only set revision on commit root when there is\n                     // no collision for this commit revision\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 3455f4b..65f79f3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1170,13 +1170,11 @@ void revisionsMerged(@Nonnull Iterable<Revision> revisions) {\n     @CheckForNull\n     NodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\n         // use batch commit when there are only revision and modified updates\n-        // and collision checks\n         boolean batch = true;\n         for (Map.Entry<Key, Operation> op : commit.getChanges().entrySet()) {\n             String name = op.getKey().getName();\n             if (NodeDocument.isRevisionsEntry(name)\n-                    || NodeDocument.MODIFIED_IN_SECS.equals(name)\n-                    || NodeDocument.COLLISIONS.equals(name)) {\n+                    || NodeDocument.MODIFIED_IN_SECS.equals(name)) {\n                 continue;\n             }\n             batch = false;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\nindex f72a7ae..0196878 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n@@ -50,23 +50,32 @@\n      * @param isNew whether this is a new document\n      */\n     UpdateOp(String id, boolean isNew) {\n-        this(id, isNew, false, new HashMap<Key, Operation>());\n+        this(id, isNew, false, new HashMap<Key, Operation>(), null);\n     }\n \n-    private UpdateOp(String id, boolean isNew, boolean isDelete,\n-                     Map<Key, Operation> changes) {\n-        this.id = id;\n+    private UpdateOp(@Nonnull String id, boolean isNew, boolean isDelete,\n+                     @Nonnull Map<Key, Operation> changes,\n+                     @Nullable Map<Key, Condition> conditions) {\n+        this.id = checkNotNull(id);\n         this.isNew = isNew;\n         this.isDelete = isDelete;\n-        this.changes = changes;\n+        this.changes = checkNotNull(changes);\n+        this.conditions = conditions;\n     }\n \n     static UpdateOp combine(String id, Iterable<UpdateOp> ops) {\n         Map<Key, Operation> changes = Maps.newHashMap();\n+        Map<Key, Condition> conditions = Maps.newHashMap();\n         for (UpdateOp op : ops) {\n             changes.putAll(op.getChanges());\n+            if (op.conditions != null) {\n+                conditions.putAll(op.conditions);\n             }\n-        return new UpdateOp(id, false, false, changes);\n+        }\n+        if (conditions.isEmpty()) {\n+            conditions = null;\n+        }\n+        return new UpdateOp(id, false, false, changes, conditions);\n     }\n \n     /**\n@@ -76,7 +85,7 @@ static UpdateOp combine(String id, Iterable<UpdateOp> ops) {\n      * @param id the primary key.\n      */\n     public UpdateOp shallowCopy(String id) {\n-        return new UpdateOp(id, isNew, isDelete, changes);\n+        return new UpdateOp(id, isNew, isDelete, changes, conditions);\n     }\n \n     /**\n@@ -86,8 +95,12 @@ public UpdateOp shallowCopy(String id) {\n      * @return a copy of this operation.\n      */\n     public UpdateOp copy() {\n+        Map<Key, Condition> conditionMap = null;\n+        if (conditions != null) {\n+            conditionMap = new HashMap<Key, Condition>(conditions);\n+        }\n         return new UpdateOp(id, isNew, isDelete,\n-                new HashMap<Key, Operation>(changes));\n+                new HashMap<Key, Operation>(changes), conditionMap);\n     }\n \n     public String getId() {\n@@ -254,7 +267,11 @@ public UpdateOp getReverseOperation() {\n \n     @Override\n     public String toString() {\n-        return \"key: \" + id + \" \" + (isNew ? \"new\" : \"update\") + \" \" + changes;\n+        String s = \"key: \" + id + \" \" + (isNew ? \"new\" : \"update\") + \" \" + changes;\n+        if (conditions != null) {\n+            s += \" conditions \" + conditions;\n+        }\n+        return s;\n     }\n \n     private Map<Key, Condition> getOrCreateConditions() {\n", "nb_test": 2190, "linesAdd": 28, "jira_id": "3028", "singleLine": false, "nb_skipped": 9, "commit": "89317b28", "nb_failure": 3, "linesRem": 12}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["xpath(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/xpath.txt don't match expected results in src/test/resources/xpath.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\nindex 5c37162..5f79f71 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n@@ -42,7 +42,7 @@ public static Expression and(Expression old, Expression add) {\n         } else if (add == null) {\n             return old;\n         }\n-        return new Expression.Condition(old, \"and\", add, Expression.PRECEDENCE_AND);\n+        return new Expression.AndCondition(old, add);\n     }\n     \n     /**\n@@ -55,6 +55,15 @@ boolean isCondition() {\n     }\n     \n     /**\n+     * Pull an OR condition up to the right hand side of an AND condition.\n+     * \n+     * @return the (possibly rotated) expression\n+     */\n+    Expression pullOrRight() {\n+        return this;\n+    }\n+    \n+    /**\n      * Get the operator / operation precedence. The JCR specification uses:\n      * 1=OR, 2=AND, 3=condition, 4=operand  \n      * \n@@ -255,6 +264,27 @@ public String getCommonLeftPart() {\n             super(left, \"and\", right, Expression.PRECEDENCE_AND);\n         }\n         \n+        @Override\n+        AndCondition pullOrRight() {\n+            if (right instanceof OrCondition) {\n+                return this;\n+            } else if (left instanceof OrCondition) {\n+                return new AndCondition(right, left);\n+            }\n+            if (right instanceof AndCondition) {\n+                // pull up x:\n+                // a and (b and (x)) -> (a and b) and (x)\n+                AndCondition r2 = (AndCondition) right;\n+                r2 = r2.pullOrRight();\n+                AndCondition l2 = new AndCondition(left, r2.left);\n+                l2 = l2.pullOrRight();\n+                return new AndCondition(l2, r2.right);\n+            } else if (left instanceof AndCondition) {\n+                return new AndCondition(right, left).pullOrRight();\n+            }\n+            return this;\n+        }\n+        \n     }\n     \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\nindex 03a2438..0504429 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n@@ -58,8 +58,34 @@ public Statement optimize() {\n         if (where == null) {\n             return this;\n         }\n-        if (where instanceof OrCondition) {\n-            OrCondition or = (OrCondition) where;\n+        ArrayList<Expression> unionList = new ArrayList<Expression>();\n+        addToUnionList(where, unionList);\n+        if (unionList.size() == 1) {\n+            return this;\n+        }\n+        Statement union = null;\n+        for (int i = 0; i < unionList.size(); i++) {\n+            Expression e = unionList.get(i);\n+            Statement s = new Statement();\n+            s.columnSelector = columnSelector;\n+            s.selectors = selectors;\n+            s.columnList = columnList;\n+            s.where = e;\n+            if (i == unionList.size() - 1) {\n+                s.xpathQuery = xpathQuery;\n+            }\n+            if (union == null) {\n+                union = s;\n+            } else {\n+                union = new UnionStatement(union.optimize(), s.optimize());\n+            }\n+        }\n+        return union;\n+    }\n+    \n+    private static void addToUnionList(Expression condition,  ArrayList<Expression> unionList) {\n+        if (condition instanceof OrCondition) {\n+            OrCondition or = (OrCondition) condition;\n             if (or.getCommonLeftPart() != null) {\n                 // @x = 1 or @x = 2 \n                 // is automatically converted to \n@@ -72,29 +98,17 @@ public Statement optimize() {\n                 // @x = 1 or @y = 2\n                 // or similar are converted to\n                 // (@x = 1) union (@y = 2)\n-                Statement s1 = new Statement();\n-                s1.columnSelector = columnSelector;\n-                s1.selectors = selectors;\n-                s1.columnList = columnList;\n-                s1.where = or.left;\n-                Statement s2 = new Statement();\n-                s2.columnSelector = columnSelector;\n-                s2.selectors = selectors;\n-                s2.columnList = columnList;\n-                s2.where = or.right;\n-                s2.xpathQuery = xpathQuery;\n-                return new UnionStatement(s1.optimize(), s2.optimize());\n-            }\n-        } else if (where instanceof AndCondition) {\n+                addToUnionList(or.left, unionList);\n+                addToUnionList(or.right, unionList);\n+                return;\n+            }\n+        } else if (condition instanceof AndCondition) {\n             // conditions of type\n             // @a = 1 and (@x = 1 or @y = 2)\n             // are automatically converted to\n             // (@a = 1 and @x = 1) union (@a = 1 and @y = 2)\n-            AndCondition and = (AndCondition) where;\n-            if (and.left instanceof OrCondition && !(and.right instanceof OrCondition)) {\n-                // swap left and right\n-                and = new AndCondition(and.right, and.left);\n-            }\n+            AndCondition and = (AndCondition) condition;\n+            and = and.pullOrRight();\n             if (and.right instanceof OrCondition) {\n                 OrCondition or = (OrCondition) and.right;\n                 if (or.getCommonLeftPart() != null) {\n@@ -106,23 +120,13 @@ public Statement optimize() {\n                     // do not optimize \"contains\"\n                 } else {\n                     // same as above, but with the added \"and\"\n-                    // TODO avoid code duplication if possible\n-                    Statement s1 = new Statement();\n-                    s1.columnSelector = columnSelector;\n-                    s1.selectors = selectors;\n-                    s1.columnList = columnList;\n-                    s1.where = new AndCondition(and.left, or.left);\n-                    Statement s2 = new Statement();\n-                    s2.columnSelector = columnSelector;\n-                    s2.selectors = selectors;\n-                    s2.columnList = columnList;\n-                    s2.where = new AndCondition(and.left, or.right);\n-                    s2.xpathQuery = xpathQuery;\n-                    return new UnionStatement(s1.optimize(), s2.optimize());\n+                    addToUnionList(new AndCondition(and.left, or.left), unionList);\n+                    addToUnionList(new AndCondition(and.left, or.right), unionList);\n+                    return;\n                 }\n             }\n         }\n-        return this;\n+        unionList.add(condition);\n     }\n     \n     @Override\n", "nb_test": 1562, "linesAdd": 63, "jira_id": "1432", "singleLine": false, "nb_skipped": 7, "commit": "808ac9c0", "nb_failure": 0, "linesRem": 34}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["recoverFromMissingCpRef(org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdateTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\nindex 88eb0f7..6401f23 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n@@ -318,7 +318,7 @@ public NodeState processCommit(\n                     throws CommitFailedException {\n                 // check for concurrent updates by this async task\n                 NodeState async = before.getChildNode(ASYNC);\n-                if (Objects.equal(checkpoint, async.getString(name))\n+                if (checkpoint == null || Objects.equal(checkpoint, async.getString(name))\n                         && lease == async.getLong(name + \"-lease\")) {\n                     return after;\n                 } else {\n", "nb_test": 1843, "linesAdd": 1, "jira_id": "1959", "singleLine": false, "nb_skipped": 9, "commit": "93c1aa40", "nb_failure": 1, "linesRem": 1}, {"files": 5, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["sql2Measure(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/sql2_measure.txt don't match expected results in src/test/resources/sql2_measure.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java\nindex 40786b4..963865d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java\n@@ -52,9 +52,10 @@ public void setQuery(QueryImpl query) {\n     \n     /**\n      * Normalize the property name (including namespace remapping).\n+     * Asterisks are kept.\n      *\n      * @param propertyName the property name to normalize\n-     * @return the normalized property name\n+     * @return the normalized (oak-) property name\n      */\n     protected String normalizePropertyName(String propertyName) {\n         // TODO normalize the path (remove superfluous \"..\" and \".\" \n@@ -71,7 +72,23 @@ protected String normalizePropertyName(String propertyName) {\n         }\n         // relative properties\n         String relativePath = PathUtils.getParentPath(propertyName);\n+        if (relativePath.indexOf('*') >= 0) {\n+            StringBuilder buff = new StringBuilder();\n+            for (String p : PathUtils.elements(relativePath)) {\n+                if (!p.equals(\"*\")) {\n+                    p = query.getOakPath(p);\n+                }\n+                if (p.length() > 0) {\n+                    if (buff.length() > 0) {\n+                        buff.append('/');\n+                    }\n+                    buff.append(p);\n+                }\n+            }\n+            relativePath = buff.toString();\n+        } else {\n             relativePath = query.getOakPath(relativePath);\n+        }\n         propertyName = PathUtils.getName(propertyName);\n         propertyName = normalizeNonRelativePropertyName(propertyName);\n         return PathUtils.concat(relativePath, propertyName);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java\nindex f1eb907..88d5610 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java\n@@ -18,7 +18,6 @@\n  */\n package org.apache.jackrabbit.oak.query.ast;\n \n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n@@ -26,17 +25,10 @@\n \n import javax.jcr.PropertyType;\n \n-import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n-import org.apache.jackrabbit.oak.api.Tree;\n-import org.apache.jackrabbit.oak.api.Type;\n-import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.query.QueryImpl;\n import org.apache.jackrabbit.oak.query.SQL2Parser;\n import org.apache.jackrabbit.oak.query.index.FilterImpl;\n-import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n-\n-import com.google.common.collect.Iterables;\n \n /**\n  * A property expression.\n@@ -107,58 +99,13 @@ public PropertyExistenceImpl getPropertyExistence() {\n \n     @Override\n     public PropertyValue currentProperty() {\n-        boolean asterisk = PathUtils.getName(propertyName).equals(\"*\");\n-        if (!asterisk) {\n-            PropertyValue p = selector.currentProperty(propertyName);\n-            return matchesPropertyType(p) ? p : null;\n-        }\n-        Tree tree = selector.currentTree();\n-        if (tree == null || !tree.exists()) {\n-            return null;\n-        }\n-        if (!asterisk) {\n-            String name = PathUtils.getName(propertyName);\n-            name = normalizePropertyName(name);\n-            PropertyState p = tree.getProperty(name);\n-            if (p == null) {\n-                return null;\n-            }\n-            return matchesPropertyType(p) ? PropertyValues.create(p) : null;\n-        }\n-        // asterisk - create a multi-value property\n-        // warning: the returned property state may have a mixed type\n-        // (not all values may have the same type)\n-\n-        // TODO currently all property values are converted to strings - \n-        // this doesn't play well with the idea that the types may be different\n-        List<String> values = new ArrayList<String>();\n-        for (PropertyState p : tree.getProperties()) {\n-            if (matchesPropertyType(p)) {\n-                Iterables.addAll(values, p.getValue(Type.STRINGS));\n-            }\n-        }\n-        // \"*\"\n-        return PropertyValues.newString(values);\n-    }\n-\n-    private boolean matchesPropertyType(PropertyValue value) {\n-        if (value == null) {\n-            return false;\n-        }\n-        if (propertyType == PropertyType.UNDEFINED) {\n-            return true;\n-        }\n-        return value.getType().tag() == propertyType;\n-    }\n-\n-    private boolean matchesPropertyType(PropertyState state) {\n-        if (state == null) {\n-            return false;\n-        }\n+        PropertyValue p;\n         if (propertyType == PropertyType.UNDEFINED) {\n-            return true;\n+            p = selector.currentProperty(propertyName);\n+        } else {\n+            p = selector.currentProperty(propertyName, propertyType);\n         }\n-        return state.getType().tag() == propertyType;\n+        return p;        \n     }\n \n     public void bindSelector(SourceImpl source) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\nindex 4d99f0f..a9c22fd 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n@@ -40,6 +40,7 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.Tree;\n+import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.query.QueryImpl;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextExpression;\n@@ -53,6 +54,7 @@\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n \n /**\n  * A selector within a query.\n@@ -386,6 +388,19 @@ public PropertyValue currentProperty(String propertyName) {\n     }\n \n     /**\n+     * The value for the given selector for the current node, filtered by\n+     * property type.\n+     * \n+     * @param propertyName the JCR (not normalized) property name\n+     * @param propertyType only include properties of this type\n+     * @return the property value (possibly null)\n+     */\n+    public PropertyValue currentProperty(String propertyName, int propertyType) {\n+        String pn = normalizePropertyName(propertyName);\n+        return currentOakProperty(pn, propertyType);\n+    }\n+\n+    /**\n      * Get the property value. The property name may be relative. The special\n      * property names \"jcr:path\", \"jcr:score\" and \"rep:excerpt\" are supported.\n      * \n@@ -393,6 +408,24 @@ public PropertyValue currentProperty(String propertyName) {\n      * @return the property value or null if not found\n      */\n     public PropertyValue currentOakProperty(String oakPropertyName) {\n+        return currentOakProperty(oakPropertyName, null);\n+    }\n+\n+    private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {\n+        boolean asterisk = oakPropertyName.indexOf('*') >= 0;\n+        if (asterisk) {\n+            Tree t = currentTree();\n+            ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\n+            readOakProperties(list, t, oakPropertyName, propertyType);\n+            if (list.size() == 0) {\n+                return null;\n+            }\n+            ArrayList<String> strings = new ArrayList<String>();\n+            for (PropertyValue p : list) {\n+                Iterables.addAll(strings, p.getValue(Type.STRINGS));\n+            }\n+            return PropertyValues.newString(strings);                    \n+        }\n         boolean relative = oakPropertyName.indexOf('/') >= 0;\n         Tree t = currentTree();\n         if (relative) {\n@@ -410,6 +443,11 @@ public PropertyValue currentOakProperty(String oakPropertyName) {\n             }\n             oakPropertyName = PathUtils.getName(oakPropertyName);\n         }\n+        return currentOakProperty(t, oakPropertyName, propertyType);\n+    }\n+    \n+    private PropertyValue currentOakProperty(Tree t, String oakPropertyName, Integer propertyType) {\n+        PropertyValue result;\n         if (t == null || !t.exists()) {\n             return null;\n         }\n@@ -420,13 +458,59 @@ public PropertyValue currentOakProperty(String oakPropertyName) {\n                 // not a local path\n                 return null;\n             }\n-            return PropertyValues.newString(local);\n+            result = PropertyValues.newString(local);\n         } else if (oakPropertyName.equals(QueryImpl.JCR_SCORE)) {\n-            return currentRow.getValue(QueryImpl.JCR_SCORE);\n+            result = currentRow.getValue(QueryImpl.JCR_SCORE);\n         } else if (oakPropertyName.equals(QueryImpl.REP_EXCERPT)) {\n-            return currentRow.getValue(QueryImpl.REP_EXCERPT);\n+            result = currentRow.getValue(QueryImpl.REP_EXCERPT);\n+        } else {\n+            result = PropertyValues.create(t.getProperty(oakPropertyName));\n+        }\n+        if (result == null) {\n+            return null;\n+        }\n+        if (propertyType != null && result.getType().tag() != propertyType) {\n+            return null;\n+        }\n+        return result;\n+    }\n+    \n+    private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\n+        while (true) {\n+            if (t == null || !t.exists()) {\n+                return;\n+            }\n+            int slash = oakPropertyName.indexOf('/');\n+            if (slash < 0) {\n+                break;\n+            }\n+            String parent = oakPropertyName.substring(0, slash);\n+            oakPropertyName = oakPropertyName.substring(slash + 1);\n+            if (parent.equals(\"..\")) {\n+                t = t.isRoot() ? null : t.getParent();\n+            } else if (parent.equals(\".\")) {\n+                // same node\n+            } else if (parent.equals(\"*\")) {\n+                for (Tree child : t.getChildren()) {\n+                    readOakProperties(target, child, oakPropertyName, propertyType);\n+                }\n+            } else {\n+                t = t.getChild(parent);\n+            }\n+        }\n+        if (!\"*\".equals(oakPropertyName)) {\n+            PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\n+            if (value != null) {\n+                target.add(value);\n+            }\n+            return;\n+        }\n+          for (PropertyState p : t.getProperties()) {\n+              if (propertyType == null || p.getType().tag() == propertyType) {\n+                  PropertyValue v = PropertyValues.create(p);\n+                  target.add(v);\n+              }\n           }\n-        return PropertyValues.create(t.getProperty(oakPropertyName));\n     }\n \n     @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\nindex 7b95dec..a545ba8 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n@@ -176,7 +176,9 @@ public SelectorImpl getExistingSelector(String selectorName) {\n      * \n      * this creates a filter for the given query\n      * \n+     * @param preparing whether this this the prepare phase\n+     * @return a new filter\n      */\n-    abstract public Filter createFilter(boolean preparing);\n+    public abstract Filter createFilter(boolean preparing);\n \n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java\nindex aa56db0..e6ed3a9 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java\n@@ -35,6 +35,9 @@\n \n import com.google.common.collect.ImmutableSet;\n \n+/**\n+ * This class can extract excerpts from node.\n+ */\n public class SimpleExcerptProvider {\n \n     private static final String REP_EXCERPT_FN = \"rep:excerpt(.)\";\n", "nb_test": 1562, "linesAdd": 101, "jira_id": "1215", "singleLine": false, "nb_skipped": 6, "commit": "a9efe3c4", "nb_failure": 0, "linesRem": 57}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["readNullEntry(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): must not read previous document: 3:p/test/r156360f32c9-2-1/0 (all: [3:p/test/r156360f32c9-2-1/0, 3:p/test/r156360f332f-6-1/0, 3:p/test/r156360f3195-0-1/0, 3:p/test/r156360f33eb-2-1/0, 3:p/test/r156360f322b-8-1/0, 3:p/test/r156360f3353-3-1/0, 3:p/test/r156360f324a-8-1/0, 3:p/test/r156360f326a-3-1/0, 3:p/test/r156360f33bb-5-1/0, 3:p/test/r156360f31b4-2-1/0, 3:p/test/r156360f31d1-3-1/0, 3:p/test/r156360f31ee-5-1/0, 3:p/test/r156360f32e9-5-1/0, 0:/, 3:p/test/r156360f32a7-6-1/1, 3:p/test/r156360f339a-5-1/0, 3:p/test/r156360f33da-5-1/0, 3:p/test/r156360f32a7-6-1/0, 3:p/test/r156360f3309-5-1/0, 3:p/test/r156360f3377-3-1/0, 3:p/test/r156360f328a-0-1/0, 3:p/test/r156360f320d-2-1/0])"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 2f23838..8000126 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -798,7 +798,7 @@ public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore,\n                     min, readRevision, validRevisions, lastRevs);\n \n             // check if there may be more recent values in a previous document\n-            if (value != null && !getPreviousRanges().isEmpty()) {\n+            if (!getPreviousRanges().isEmpty()) {\n                 Revision newest = getLocalMap(key).firstKey();\n                 if (isRevisionNewer(nodeStore, newest, value.revision)) {\n                     // not reading the most recent value, we may need to\n@@ -894,13 +894,13 @@ public Revision getLiveRevision(RevisionContext context, Revision maxRev,\n         // check local deleted map first\n         Value value = getLatestValue(context, getLocalDeleted(),\n                 null, maxRev, validRevisions, lastRevs);\n-        if (value == null && !getPreviousRanges().isEmpty()) {\n+        if (value.value == null && !getPreviousRanges().isEmpty()) {\n             // need to check complete map\n             value = getLatestValue(context, getDeleted(),\n                     null, maxRev, validRevisions, lastRevs);\n         }\n \n-        return value != null && \"false\".equals(value.value) ? value.revision : null;\n+        return \"false\".equals(value.value) ? value.revision : null;\n     }\n \n     /**\n@@ -1435,10 +1435,12 @@ private static boolean includeRevision(RevisionContext context,\n \n     /**\n      * Get the latest property value that is larger or equal the min revision,\n-     * and smaller or equal the readRevision revision. A {@code null} return\n-     * value indicates that the property was not set or removed within the given\n-     * range. A non-null value means the the property was either set or removed\n-     * depending on {@link Value#value}.\n+     * and smaller or equal the readRevision revision. The returned value will\n+     * provide the revision when the value was set between the {@code min} and\n+     * {@code readRevision}. The returned value will have a {@code null} value\n+     * contained if there is no valid change within the given range. In this\n+     * case the associated revision is {@code min} or {@code readRevision} if\n+     * no {@code min} is provided.\n      *\n      * @param valueMap the sorted revision-value map\n      * @param min the minimum revision (null meaning unlimited)\n@@ -1446,9 +1448,9 @@ private static boolean includeRevision(RevisionContext context,\n      * @param validRevisions map of revision to commit value considered valid\n      *                       against the given readRevision.\n      * @param lastRevs to keep track of the most recent modification.\n-     * @return the value, or null if not found\n+     * @return the latest value from the {@code readRevision} point of view.\n      */\n-    @CheckForNull\n+    @Nonnull\n     private Value getLatestValue(@Nonnull RevisionContext context,\n                                  @Nonnull Map<Revision, String> valueMap,\n                                  @Nullable Revision min,\n@@ -1486,7 +1488,9 @@ private Value getLatestValue(@Nonnull RevisionContext context,\n                 return new Value(commitRev, entry.getValue());\n             }\n         }\n-        return null;\n+\n+        Revision r = min != null ? min : readRevision;\n+        return new Value(r, null);\n     }\n \n     @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\nindex 94d21d3..7b1bec6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\n@@ -120,27 +120,34 @@ public int size() {\n \n             @Override\n             public String get(Object key) {\n+                Revision r = (Revision) key;\n                 // first check values map of this document\n-                String value = map.get(key);\n-                if (value != null) {\n-                    return value;\n+                if (map.containsKey(r)) {\n+                    return map.get(r);\n                 }\n-                Revision r = (Revision) key;\n                 for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\n-                    value = prev.getValueMap(property).get(key);\n+                    String value = prev.getValueMap(property).get(r);\n                     if (value != null) {\n                         return value;\n                     }\n                 }\n-                // not found\n+                // not found or null\n                 return null;\n             }\n \n             @Override\n             public boolean containsKey(Object key) {\n-                // can use get()\n-                // the values map does not have null values\n-                return get(key) != null;\n+                // check local map first\n+                if (map.containsKey(key)) {\n+                    return true;\n+                }\n+                Revision r = (Revision) key;\n+                for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\n+                    if (prev.getValueMap(property).containsKey(key)) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n             }\n         };\n     }\n", "nb_test": 1818, "linesAdd": 21, "jira_id": "2359", "singleLine": false, "nb_skipped": 9, "commit": "b3071839", "nb_failure": 1, "linesRem": 11}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCompactor(org.apache.jackrabbit.oak.plugins.segment.CompactorTest): expected:<{ test0 : { }, child0 : { } }> but was:<{ }>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\nindex 14278ca..18cb068 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\n@@ -20,7 +20,6 @@\n import static com.google.common.collect.Maps.newHashMap;\n import static org.apache.jackrabbit.oak.api.Type.BINARIES;\n import static org.apache.jackrabbit.oak.api.Type.BINARY;\n-import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.EMPTY_NODE;\n \n import java.io.IOException;\n import java.io.InputStream;\n@@ -62,8 +61,6 @@\n \n     private final SegmentWriter writer;\n \n-    private final SegmentNodeBuilder builder;\n-\n     private CompactionMap map = new CompactionMap(100000);\n \n     /**\n@@ -75,11 +72,11 @@\n \n     public Compactor(SegmentWriter writer) {\n         this.writer = writer;\n-        this.builder =\n-                new SegmentNodeBuilder(writer.writeNode(EMPTY_NODE), writer);\n     }\n \n     public SegmentNodeState compact(NodeState before, NodeState after) {\n+        SegmentNodeBuilder builder = new SegmentNodeBuilder(\n+                writer.writeNode(before), writer);\n         after.compareAgainstBaseState(before, new CompactDiff(builder));\n         return builder.getNodeState();\n     }\n", "nb_test": 1819, "linesAdd": 2, "jira_id": "1932", "singleLine": false, "nb_skipped": 9, "commit": "c215b267", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOak1096[2](org.apache.jackrabbit.oak.jcr.query.QueryTest): False amount of hits expected:<1> but was:<0>", "testOak1096[0](org.apache.jackrabbit.oak.jcr.query.QueryTest): False amount of hits expected:<1> but was:<0>", "testOak1096[1](org.apache.jackrabbit.oak.jcr.query.QueryTest): False amount of hits expected:<1> but was:<0>"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/QueryImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/QueryImpl.java\nindex 0ee38df..acff663 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/QueryImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/QueryImpl.java\n@@ -34,9 +34,10 @@\n \n import org.apache.jackrabbit.JcrConstants;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n+import org.apache.jackrabbit.oak.jcr.delegate.NodeDelegate;\n import org.apache.jackrabbit.oak.jcr.session.NodeImpl;\n import org.apache.jackrabbit.oak.jcr.session.SessionContext;\n-import org.apache.jackrabbit.oak.jcr.delegate.NodeDelegate;\n+import org.apache.jackrabbit.oak.jcr.session.operation.SessionOperation;\n \n /**\n  * The implementation of the corresponding JCR interface.\n@@ -86,7 +87,14 @@ private void parse() throws InvalidQueryException {\n \n     @Override\n     public QueryResult execute() throws RepositoryException {\n-        return manager.executeQuery(statement, language, limit, offset, bindVariableMap);\n+        return sessionContext.getSessionDelegate().perform(\n+                new SessionOperation<QueryResult>() {\n+                    @Override\n+                    public QueryResult perform() throws RepositoryException {\n+                        return manager.executeQuery(statement, language, limit,\n+                                offset, bindVariableMap);\n+                    }\n+                });\n     }\n \n     @Override\n", "nb_test": 1607, "linesAdd": 10, "jira_id": "1096", "singleLine": false, "nb_skipped": 3, "commit": "be44b816", "nb_failure": 3, "linesRem": 2}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["mergeSorted(org.apache.jackrabbit.oak.plugins.document.ValueMapTest): Revisioned values for property 0://_revisions: First element of next iterator must be greater than previous iterator", "mergeSorted1(org.apache.jackrabbit.oak.plugins.document.ValueMapTest): Revisioned values for property 0://_revisions: First element of next iterator must be greater than previous iterator"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\nindex 7b1bec6..259474d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\n@@ -18,9 +18,12 @@\n \n import java.util.AbstractMap;\n import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.SortedMap;\n@@ -32,6 +35,7 @@\n \n import com.google.common.base.Objects;\n import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n \n /**\n  * A value map contains the versioned values of a property. The key into this\n@@ -61,9 +65,32 @@\n                 if (map.isEmpty()) {\n                     docs = doc.getPreviousDocs(property, null).iterator();\n                 } else {\n-                    docs = Iterators.concat(\n-                            Iterators.singletonIterator(doc),\n-                            doc.getPreviousDocs(property, null).iterator());\n+                    // merge sort local map into maps of previous documents\n+                    List<Iterator<NodeDocument>> iterators = \n+                            new ArrayList<Iterator<NodeDocument>>(2);\n+                    iterators.add(Iterators.singletonIterator(doc));\n+                    iterators.add(doc.getPreviousDocs(property, null).iterator());                            \n+                    docs = Iterators.mergeSorted(iterators, new Comparator<NodeDocument>() {\n+                                @Override\n+                                public int compare(NodeDocument o1,\n+                                                   NodeDocument o2) {\n+                                    Revision r1 = getFirstRevision(o1);\n+                                    Revision r2 = getFirstRevision(o2);\n+                                    return c.compare(r1, r2);\n+                                }\n+                            \n+                                private Revision getFirstRevision(NodeDocument d) {\n+                                    Map<Revision, String> values;\n+                                    if (Objects.equal(d.getId(), doc.getId())) {\n+                                        // return local map for main document\n+                                        values = d.getLocalMap(property);\n+                                    } else {\n+                                        values = d.getValueMap(property);\n+                                    }\n+                                    return values.keySet().iterator().next();\n+                                }\n+                        \n+                            });\n                 }\n \n                 return new MergeSortedIterators<Map.Entry<Revision, String>>(\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java\nindex 48bed08..3cb3dc5 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java\n@@ -100,7 +100,9 @@ private void fetchNextIterator() {\n             PeekingIterator<T> pIt = Iterators.peekingIterator(it);\n             if (!iterators.isEmpty()\n                     &&  comparator.compare(pIt.peek(), lastPeek) < 0) {\n-                throw new IllegalStateException(description() + \" First element of next iterator must be greater than previous iterator\");\n+                throw new IllegalStateException(description() + \n+                        \" First element of next iterator (\" + pIt.peek() + \")\" +\n+                        \" must be after previous iterator (\" + lastPeek + \")\");\n             }\n             lastPeek = pIt.peek();\n             iterators.add(pIt);\n", "nb_test": 1870, "linesAdd": 31, "jira_id": "2433", "singleLine": false, "nb_skipped": 9, "commit": "7fca85bf", "nb_failure": 0, "linesRem": 4}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["oak2219(org.apache.jackrabbit.oak.plugins.index.property.OrderedPropertyIndexQueryTest): Expected path /content/a not found", "oak2219(org.apache.jackrabbit.oak.plugins.index.property.OrderedPropertyIndexDescendingQueryTest): Expected path /content/a not found"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\nindex 0574916..b675324 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\n@@ -191,7 +191,7 @@ public Cursor query(IndexPlan plan, NodeState root) {\n         PropertyRestriction pr = plan.getPropertyRestriction();\n         if (pr != null) {\n             String propertyName = PathUtils.getName(pr.propertyName);\n-            depth = PathUtils.getDepth(propertyName);\n+            depth = PathUtils.getDepth(pr.propertyName);\n             paths = strategy.query(plan.getFilter(), propertyName,\n                     plan.getDefinition(), pr, pathPrefix);\n         }\n", "nb_test": 1946, "linesAdd": 1, "jira_id": "2219", "singleLine": false, "nb_skipped": 9, "commit": "f2740ce1", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["costMaxEstimation(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexTest): Estimated cost for 101 nodes should not be higher than traversal (6.7108864E7)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\nindex fa01dc5..3b0bf7b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n@@ -345,19 +345,6 @@ public void remove() {\n         int depth;\n \n         /**\n-         * The total number of child nodes per node, for those nodes that were\n-         * fully traversed and do have child nodes. This value is used to\n-         * calculate the average width.\n-         */\n-        long widthTotal;\n-        \n-        /**\n-         * The number of nodes that were fully traversed and do have child\n-         * nodes. This value is used to calculate the average width.\n-         */\n-        int widthCount;\n-        \n-        /**\n          * The sum of the depth of all matching nodes. This value is used to\n          * calculate the average depth.\n          */\n@@ -375,20 +362,12 @@ public void visit(NodeState state) {\n             }\n             if (count < maxCount) {\n                 depth++;\n-                int width = 0;\n-                boolean finished = true;\n                 for (ChildNodeEntry entry : state.getChildNodeEntries()) {\n                     if (count >= maxCount) {\n-                        finished = false;\n                         break;\n                     }\n-                    width++;\n                     visit(entry.getNodeState());\n                 }\n-                if (finished && width > 0) {\n-                    widthTotal += width;\n-                    widthCount++;\n-                }\n                 depth--;\n             }\n         }\n@@ -415,15 +394,9 @@ int getEstimatedCount() {\n                 return count;\n             }\n             double averageDepth = (int) (depthTotal / count);\n-            double averageWidth = 2;\n-            if (widthCount > 0) {\n-                averageWidth = (int) (widthTotal / widthCount);\n-            }\n-            // calculate with an average width of at least 2\n-            averageWidth = Math.max(2, averageWidth);\n-            // the number of estimated matches is calculated as the\n-            // of a estimated\n-            long estimatedNodes = (long) Math.pow(averageWidth, 2 * averageDepth);\n+            // the number of estimated matches is higher\n+            // the higher the average depth of the first hits\n+            long estimatedNodes = (long) (count * Math.pow(1.1, averageDepth));\n             estimatedNodes = Math.min(estimatedNodes, Integer.MAX_VALUE);\n             return Math.max(count, (int) estimatedNodes);\n         }\n", "nb_test": 1461, "linesAdd": 1, "jira_id": "1155", "singleLine": false, "nb_skipped": 6, "commit": "f64e8adc", "nb_failure": 1, "linesRem": 18}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testGetTypeWithDefaultParentType(org.apache.jackrabbit.oak.security.authorization.permission.TreeTypeProviderTest): /jcr:system/jcr:nodeTypes/rep:system/rep:namedChildNodeDefinitions/jcr:versionStorage expected:<1> but was:<2>", "testGetType(org.apache.jackrabbit.oak.security.authorization.permission.TreeTypeProviderTest): /jcr:system/jcr:nodeTypes/rep:system/rep:namedChildNodeDefinitions/jcr:versionStorage expected:<1> but was:<2>", "testGetTypeWithParentType(org.apache.jackrabbit.oak.security.authorization.permission.TreeTypeProviderTest): /jcr:system/jcr:nodeTypes/rep:system/rep:namedChildNodeDefinitions/jcr:versionStorage expected:<1> but was:<2>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/TreeTypeProvider.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/TreeTypeProvider.java\nindex 1b1c336..2aadfd8 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/TreeTypeProvider.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/TreeTypeProvider.java\n@@ -18,6 +18,7 @@\n \n import javax.annotation.Nonnull;\n \n+import org.apache.jackrabbit.JcrConstants;\n import org.apache.jackrabbit.oak.api.Tree;\n import org.apache.jackrabbit.oak.plugins.version.VersionConstants;\n import org.apache.jackrabbit.oak.spi.security.Context;\n@@ -26,9 +27,8 @@\n \n /**\n  * <h3>TreeTypeProvider</h3>\n-  * For optimization purpose an Immutable tree will be associated with a\n-  * {@code TreeTypeProvider} that allows for fast detection of the following types\n-  * of Trees:\n+ * Allows to distinguish different types of trees based on their name, ancestry\n+ * or primary type. Currently the following types are supported:\n  *\n  * <ul>\n  *     <li>{@link #TYPE_HIDDEN}: a hidden tree whose name starts with \":\".\n@@ -38,6 +38,7 @@\n  *     <li>{@link #TYPE_VERSION}: if a given tree is located within\n  *     any of the version related stores defined by JSR 283. Depending on the\n  *     permission evaluation implementation those items require special treatment.</li>\n+ *     <li>{@link #TYPE_INTERNAL}: repository internal content that is not hidden (e.g. permission store)</li>\n  *     <li>{@link #TYPE_DEFAULT}: the default type for trees that don't\n  *     match any of the upper types.</li>\n  * </ul>\n@@ -55,21 +56,30 @@\n     // hidden trees\n     public static final int TYPE_HIDDEN = 16;\n \n-    private final Context contextInfo;\n+    private final Context authorizationContext;\n \n-    public TreeTypeProvider(@Nonnull Context contextInfo) {\n-        this.contextInfo = contextInfo;\n+    public TreeTypeProvider(@Nonnull Context authorizationContext) {\n+        this.authorizationContext = authorizationContext;\n     }\n \n-    public int getType(Tree tree) {\n+    public int getType(@Nonnull Tree tree) {\n         if (tree.isRoot()) {\n             return TYPE_DEFAULT;\n         } else {\n-            return getType(tree, getType(tree.getParent()));\n+            Tree t = tree;\n+            while (!t.isRoot()) {\n+                int type = getType(t.getName(), t);\n+                // stop walking up the hierarchy as soon as a special type is found\n+                if (TYPE_DEFAULT != type) {\n+                    return type;\n+                }\n+                t = t.getParent();\n+            }\n+            return TYPE_DEFAULT;\n         }\n     }\n \n-    public int getType(Tree tree, int parentType) {\n+    public int getType(@Nonnull Tree tree, int parentType) {\n         if (tree.isRoot()) {\n             return TYPE_DEFAULT;\n         }\n@@ -89,19 +99,24 @@ public int getType(Tree tree, int parentType) {\n                 type = TYPE_AC;\n                 break;\n             default:\n-                    String name = tree.getName();\n+                type = getType(tree.getName(), tree);\n+        }\n+        return type;\n+    }\n+\n+    private int getType(@Nonnull String name, @Nonnull Tree tree) {\n+        int type;\n         if (NodeStateUtils.isHidden(name)) {\n             type = TYPE_HIDDEN;\n         } else if (VersionConstants.VERSION_STORE_ROOT_NAMES.contains(name)) {\n-                        type = TYPE_VERSION;\n+            type = (JcrConstants.JCR_SYSTEM.equals(tree.getParent().getName())) ?  TYPE_VERSION : TYPE_DEFAULT;\n         } else if (PermissionConstants.REP_PERMISSION_STORE.equals(name)) {\n             type = TYPE_INTERNAL;\n-                    } else if (contextInfo.definesContextRoot(tree)) {\n+        } else if (authorizationContext.definesContextRoot(tree)) {\n             type = TYPE_AC;\n         } else {\n             type = TYPE_DEFAULT;\n         }\n-            }\n         return type;\n     }\n }\n", "nb_test": 2895, "linesAdd": 24, "jira_id": "3530", "singleLine": false, "nb_skipped": 1, "commit": "4d231938", "nb_failure": 3, "linesRem": 10}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReadOnlyAfterCheckin(org.apache.jackrabbit.oak.jcr.version.VersionableTest): setProperty(..., null) must fail on a checked-in node"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\nindex 71f12f9..07e0ae3 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n@@ -1424,6 +1424,14 @@ private Property internalRemoveProperty(final String jcrName)\n             throws RepositoryException {\n         final String oakName = getOakName(checkNotNull(jcrName));\n         return perform(new ItemWriteOperation<Property>(\"internalRemoveProperty\") {\n+            @Override\n+            public void checkPreconditions() throws RepositoryException {\n+                super.checkPreconditions();\n+                if (!isCheckedOut()) {\n+                    throw new VersionException(\n+                            \"Cannot remove property. Node is checked in.\");\n+                }\n+            }\n             @Nonnull\n             @Override\n             public Property perform() throws RepositoryException {\ndiff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/PropertyImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/PropertyImpl.java\nindex 52ca344..7a54197 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/PropertyImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/PropertyImpl.java\n@@ -37,6 +37,7 @@\n import javax.jcr.ValueFactory;\n import javax.jcr.ValueFormatException;\n import javax.jcr.nodetype.PropertyDefinition;\n+import javax.jcr.version.VersionException;\n \n import org.apache.jackrabbit.oak.api.Tree.Status;\n import org.apache.jackrabbit.oak.api.Type;\n@@ -110,6 +111,15 @@ public Boolean perform() {\n     public void remove() throws RepositoryException {\n         sessionDelegate.performVoid(new ItemWriteOperation(\"remove\") {\n             @Override\n+            public void checkPreconditions() throws RepositoryException {\n+                super.checkPreconditions();\n+                if (!getParent().isCheckedOut()) {\n+                    throw new VersionException(\n+                            \"Cannot set property. Node is checked in.\");\n+                }\n+            }\n+\n+            @Override\n             public void performVoid() {\n                 dlg.remove();\n             }\n@@ -451,6 +461,15 @@ private void internalSetValue(@Nonnull final Value value)\n             throws RepositoryException {\n         sessionDelegate.performVoid(new ItemWriteOperation(\"internalSetValue\") {\n             @Override\n+            public void checkPreconditions() throws RepositoryException {\n+                super.checkPreconditions();\n+                if (!getParent().isCheckedOut()) {\n+                    throw new VersionException(\n+                            \"Cannot set property. Node is checked in.\");\n+                }\n+            }\n+\n+            @Override\n             public void performVoid() throws RepositoryException {\n                 Type<?> type = dlg.getPropertyState().getType();\n                 if (type.isArray()) {\n@@ -478,6 +497,15 @@ private void internalSetValue(@Nonnull final Value[] values)\n \n         sessionDelegate.performVoid(new ItemWriteOperation(\"internalSetValue\") {\n             @Override\n+            public void checkPreconditions() throws RepositoryException {\n+                super.checkPreconditions();\n+                if (!getParent().isCheckedOut()) {\n+                    throw new VersionException(\n+                            \"Cannot set property. Node is checked in.\");\n+                }\n+            }\n+\n+            @Override\n             public void performVoid() throws RepositoryException {\n                 Type<?> type = dlg.getPropertyState().getType();\n                 if (!type.isArray()) {\n", "nb_test": 1413, "linesAdd": 36, "jira_id": "3310", "singleLine": false, "nb_skipped": 1, "commit": "4416a9f8", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["xpath(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/xpath.txt don't match expected results in src/test/resources/xpath.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\nindex f6ad95a..5c37162 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n@@ -180,10 +180,6 @@ public String toString() {\n             if (right == null) {\n                 rightExpr = \"\";\n             } else {\n-                if (left != null && left instanceof Property && ((Property) left).implicitAsterisk) {\n-                    throw new IllegalArgumentException(\n-                            \"Missing @ in front of the property name: \" + left);\n-                }\n                 if (leftExprIsName && !\"like\".equals(operator)) {\n                     // need to de-escape _x0020_ and so on\n                     if (!(right instanceof Literal)) {\n@@ -275,8 +271,16 @@ public String getCommonLeftPart() {\n     \n         @Override\n         public String toString() {\n-            StringBuilder buff = new StringBuilder(\"contains\").\n-                    append('(').append(left).append(\", \").append(right).append(')');\n+            StringBuilder buff = new StringBuilder(\"contains(\");\n+            Expression l = left;\n+            if (l instanceof Property) {\n+                Property p = (Property) l;\n+                if (p.thereWasNoAt) {\n+                    l = new Property(p.selector, p.name + \"/*\", true);\n+                }\n+            }\n+            buff.append(l);\n+            buff.append(\", \").append(right).append(')');\n             return buff.toString();\n         }\n     \n@@ -386,12 +390,18 @@ public String toString() {\n     \n         final Selector selector;\n         final String name;\n-        final boolean implicitAsterisk;\n         \n-        Property(Selector selector, String name, boolean implicitAsterisk) {\n+        /**\n+         * If there was no \"@\" character in front of the property name. If that\n+         * was the case, then it is still considered a property, except for\n+         * \"contains(x, 'y')\", where \"x\" is considered to be a node.\n+         */\n+        final boolean thereWasNoAt;\n+    \n+        Property(Selector selector, String name, boolean thereWasNoAt) {\n             this.selector = selector;\n             this.name = name;\n-            this.implicitAsterisk = implicitAsterisk;\n+            this.thereWasNoAt = thereWasNoAt;\n         }\n     \n         @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\nindex 5ac0529..76955a0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n@@ -552,9 +552,7 @@ private Expression parsePropertyOrFunction() throws ParseException {\n             // path without all attributes, as in:\n             // jcr:contains(jcr:content, 'x')\n             if (buff.toString().equals(\".\")) {\n-                buff = new StringBuilder(\"*\");\n-            } else {\n-                buff.append(\"/*\");\n+                return new Expression.Property(currentSelector, \"*\", false);\n             }\n             return new Expression.Property(currentSelector, buff.toString(), true);\n         }\n", "nb_test": 1563, "linesAdd": 15, "jira_id": "1369", "singleLine": false, "nb_skipped": 6, "commit": "ce0b0955", "nb_failure": 0, "linesRem": 12}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["nodeType(org.apache.jackrabbit.oak.jcr.CRUDTest): Unexpected exception, expected<javax.jcr.nodetype.ConstraintViolationException> but was<java.lang.NullPointerException>"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex 2c8566b..7cb7e2c 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -250,11 +250,10 @@ public Node perform() throws RepositoryException {\n                 String ntName = primaryNodeTypeName;\n                 if (ntName == null) {\n                     DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\n-                    try {\n                     String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\n                     NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\n                     ntName = def.getDefaultPrimaryTypeName();\n-                    } catch (RepositoryException e) {\n+                    if (ntName == null) {\n                         throw new ConstraintViolationException(\n                                 \"no matching child node definition found for \" + relPath);\n                     }\n", "nb_test": 511, "linesAdd": 1, "jira_id": "642", "singleLine": false, "nb_skipped": 1, "commit": "7a84b3a8", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testSyncCreateUser(org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalLoginModuleTest)"], "patch": "diff --git a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/impl/DefaultSyncHandler.java b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/impl/DefaultSyncHandler.java\nindex 43afa31..be7be37 100644\n--- a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/impl/DefaultSyncHandler.java\n+++ b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/impl/DefaultSyncHandler.java\n@@ -644,7 +644,12 @@ private void syncProperties(ExternalIdentity ext, Authorizable auth, Map<String,\n                 String name = entry.getValue();\n                 Object obj = properties.get(name);\n                 if (obj == null) {\n+                    int nameLen = name.length();\n+                    if (nameLen > 1 && name.charAt(0) == '\"' && name.charAt(nameLen-1) == '\"') {\n+                        auth.setProperty(relPath, valueFactory.createValue(name.substring(1, nameLen - 1)));\n+                    } else {\n                         auth.removeProperty(relPath);\n+                    }\n                 } else {\n                     if (obj instanceof Collection) {\n                         auth.setProperty(relPath, createValues((Collection) obj));\n", "nb_test": 5, "linesAdd": 5, "jira_id": "1848", "singleLine": false, "nb_skipped": 0, "commit": "093b9128", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSurrogates(org.apache.jackrabbit.oak.commons.json.JsopTest): expected:<\"surrogate-broken: [\\ud800] \"> but was:<\"surrogate-broken: [?] \">"], "patch": "diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\nindex 8489197..bffa237 100644\n--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n@@ -254,7 +254,7 @@ public static String encode(String s) {\n         }\n         for (int i = 0; i < length; i++) {\n             char c = s.charAt(i);\n-            if (c == '\\\"' || c == '\\\\' || c < ' ') {\n+            if (c == '\\\"' || c == '\\\\' || c < ' ' || (c >= 0xd800 && c <= 0xdbff)) {\n                 StringBuilder buff = new StringBuilder(length + 2 + length / 8);\n                 buff.append('\\\"');\n                 escape(s, length, buff);\n@@ -285,7 +285,6 @@ public static void escape(String s, StringBuilder buff) {\n     private static void escape(String s, int length, StringBuilder buff) {\n         for (int i = 0; i < length; i++) {\n             char c = s.charAt(i);\n-            int ic = (int)c;\n             switch (c) {\n             case '\"':\n                 // quotation mark\n@@ -317,8 +316,8 @@ private static void escape(String s, int length, StringBuilder buff) {\n                 break;\n             default:\n                 if (c < ' ') {\n-                    buff.append(String.format(\"\\\\u%04x\", ic));\n-                } else if (ic >= 0xD800 && ic <= 0xDBFF) {\n+                    buff.append(String.format(\"\\\\u%04x\", (int) c));\n+                } else if (c >= 0xd800 && c <= 0xdbff) {\n                     // isSurrogate(), only available in Java 7\n                     if (i < length - 1 && Character.isSurrogatePair(c, s.charAt(i + 1))) {\n                         // ok surrogate\n@@ -327,7 +326,7 @@ private static void escape(String s, int length, StringBuilder buff) {\n                         i += 1;\n                     } else {\n                         // broken surrogate -> escape\n-                        buff.append(String.format(\"\\\\u%04x\", ic));\n+                        buff.append(String.format(\"\\\\u%04x\", (int) c));\n                     }\n                 } else {\n                     buff.append(c);\n", "nb_test": 53, "linesAdd": 4, "jira_id": "2389", "singleLine": false, "nb_skipped": 0, "commit": "0fa892b3", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["cowConcurrentAccess(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierTest): f2 should exist"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\nindex e1e8a53..bea03c6 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n@@ -75,6 +75,7 @@\n import static com.google.common.collect.Iterables.toArray;\n import static com.google.common.collect.Iterables.transform;\n import static com.google.common.collect.Maps.newConcurrentMap;\n+import static com.google.common.collect.Maps.newHashMap;\n import static org.apache.jackrabbit.oak.commons.IOUtils.humanReadableByteCount;\n \n public class IndexCopier implements CopyOnReadStatsMBean, Closeable {\n@@ -111,6 +112,7 @@\n \n \n     private final Map<String, String> indexPathMapping = newConcurrentMap();\n+    private final Map<String, Set<String>> sharedWorkingSetMap = newHashMap();\n     private final Map<String, String> indexPathVersionMapping = newConcurrentMap();\n     private final ConcurrentMap<String, LocalIndexFile> failedToDeleteFiles = newConcurrentMap();\n     private final Set<LocalIndexFile> copyInProgressFiles = Collections.newSetFromMap(new ConcurrentHashMap<LocalIndexFile, Boolean>());\n@@ -131,12 +133,13 @@ public IndexCopier(Executor executor, File indexRootDir, boolean prefetchEnabled\n     public Directory wrapForRead(String indexPath, IndexDefinition definition,\n             Directory remote) throws IOException {\n         Directory local = createLocalDirForIndexReader(indexPath, definition);\n-        return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath);\n+        return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition));\n     }\n \n     public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {\n         Directory local = createLocalDirForIndexWriter(definition);\n-        return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition));\n+        return new CopyOnWriteDirectory(remote, local, reindexMode,\n+                getIndexPathForLogging(definition), getSharedWorkingSet(definition));\n     }\n \n     @Override\n@@ -238,6 +241,34 @@ private void successfullyDeleted(LocalIndexFile file, boolean fileExisted){\n     }\n \n     /**\n+     * Provide the corresponding shared state to enable COW inform COR\n+     * about new files it is creating while indexing. This would allow COR to ignore\n+     * such files while determining the deletion candidates.\n+     *\n+     * @param defn index definition for which the directory is being created\n+     * @return a set to maintain the state of new files being created by the COW Directory\n+     */\n+    private Set<String> getSharedWorkingSet(IndexDefinition defn){\n+        String indexPath = defn.getIndexPathFromConfig();\n+\n+        if (indexPath == null){\n+            //With indexPath null the working directory would not\n+            //be shared between COR and COW. So just return a new set\n+            return new HashSet<String>();\n+        }\n+\n+        Set<String> sharedSet;\n+        synchronized (sharedWorkingSetMap){\n+            sharedSet = sharedWorkingSetMap.get(indexPath);\n+            if (sharedSet == null){\n+                sharedSet = Sets.newConcurrentHashSet();\n+                sharedWorkingSetMap.put(indexPath, sharedSet);\n+            }\n+        }\n+        return sharedSet;\n+    }\n+\n+    /**\n      * Creates the workDir. If it exists then it is cleaned\n      *\n      * @param indexRootDir root directory under which all indexing related files are managed\n@@ -274,12 +305,17 @@ private static String getIndexPathForLogging(IndexDefinition defn){\n          */\n         private final Set<String> localFileNames = Sets.newConcurrentHashSet();\n \n-        public CopyOnReadDirectory(Directory remote, Directory local, boolean prefetch, String indexPath) throws IOException {\n+        public CopyOnReadDirectory(Directory remote, Directory local, boolean prefetch,\n+                                   String indexPath, Set<String> sharedWorkingSet) throws IOException {\n             super(remote);\n             this.remote = remote;\n             this.local = local;\n             this.indexPath = indexPath;\n+\n             this.localFileNames.addAll(Arrays.asList(local.listAll()));\n+            //Remove files which are being worked upon by COW\n+            this.localFileNames.removeAll(sharedWorkingSet);\n+\n             if (prefetch) {\n                 prefetchIndexFiles();\n             }\n@@ -549,6 +585,7 @@ public Void call() throws Exception {\n         private final CountDownLatch copyDone = new CountDownLatch(1);\n         private final boolean reindexMode;\n         private final String indexPathForLogging;\n+        private final Set<String> sharedWorkingSet;\n \n         /**\n          * Current background task\n@@ -602,12 +639,13 @@ public void run() {\n         };\n \n         public CopyOnWriteDirectory(Directory remote, Directory local, boolean reindexMode,\n-                                    String indexPathForLogging) throws IOException {\n+                                    String indexPathForLogging, Set<String> sharedWorkingSet) throws IOException {\n             super(local);\n             this.remote = remote;\n             this.local = local;\n             this.indexPathForLogging = indexPathForLogging;\n             this.reindexMode = reindexMode;\n+            this.sharedWorkingSet = sharedWorkingSet;\n             initialize();\n         }\n \n@@ -647,6 +685,7 @@ public IndexOutput createOutput(String name, IOContext context) throws IOExcepti\n             }\n             ref = new COWLocalFileReference(name);\n             fileMap.put(name, ref);\n+            sharedWorkingSet.add(name);\n             return ref.createOutput(context);\n         }\n \n@@ -723,6 +762,7 @@ public void close() throws IOException {\n \n             local.close();\n             remote.close();\n+            sharedWorkingSet.clear();\n         }\n \n         @Override\n@@ -994,7 +1034,7 @@ private boolean deleteFile(Directory dir, String fileName, boolean copiedFromRem\n         } catch (IOException e) {\n             failedToDelete(file);\n             log.debug(\"Error occurred while removing deleted file {} from Local {}. \" +\n-                    \"Attempt would be maid to delete it on next run \", fileName, dir, e);\n+                    \"Attempt would be made to delete it on next run \", fileName, dir, e);\n         }\n         return successFullyDeleted;\n     }\n", "nb_test": 466, "linesAdd": 34, "jira_id": "3110", "singleLine": false, "nb_skipped": 3, "commit": "d10362c0", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMultipleRelativeProperties(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Result set size is different expected:<1> but was:<0>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\nindex a77a85c..585b44e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\n@@ -24,8 +24,10 @@\n \n import javax.jcr.PropertyType;\n \n+import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.Type;\n+import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;\n import org.apache.jackrabbit.oak.query.fulltext.LikePattern;\n import org.apache.jackrabbit.oak.query.index.FilterImpl;\n import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n@@ -101,8 +103,23 @@ public boolean evaluate() {\n             // unable to convert, just skip this node\n             return false;\n         }\n+        if (p1.isArray()) {\n+            // JCR 2.0 spec, 6.7.16 Comparison:\n+            // \"... constraint is satisfied as a whole if the comparison\n+            // against any element of the array is satisfied.\"\n+            Type<?> base = p1.getType().getBaseType();\n+            for (int i = 0; i < p1.count(); i++) {\n+                PropertyState value = PropertyStates.createProperty(\n+                        \"value\", p1.getValue(base, i), base);\n+                if (evaluate(PropertyValues.create(value), p2)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        } else {\n             return evaluate(p1, p2);\n         }\n+    }\n \n     /**\n      * \"operand2 always evaluates to a scalar value\"\n", "nb_test": 1836, "linesAdd": 14, "jira_id": "1739", "singleLine": false, "nb_skipped": 8, "commit": "8188ef54", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["diffWithDepth(org.apache.jackrabbit.mk.MicroKernelImplTest): expected:<+\"/b\":{\"l\":1[]}> but was:<+\"/b\":{\"l\":1[,\"x\":{\"l\":2,\"y\":{}}]}>"], "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/tree/DiffBuilder.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/tree/DiffBuilder.java\nindex f023fb3..d450b4f 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/tree/DiffBuilder.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/tree/DiffBuilder.java\n@@ -60,7 +60,7 @@ public String build() throws Exception {\n         if (before == null) {\n             if (after != null) {\n                 buff.tag('+').key(path).object();\n-                toJson(buff, after);\n+                toJson(buff, after, depth);\n                 return buff.endObject().newline().toString();\n             } else {\n                 // path doesn't exist in the specified revisions\n@@ -117,7 +117,7 @@ public void childNodeAdded(String name, NodeState after) {\n                     addedNodes.put(after, p);\n                     buff.tag('+').\n                             key(p).object();\n-                    toJson(buff, after);\n+                    toJson(buff, after, depth);\n                     buff.endObject().newline();\n                 }\n             }\n@@ -215,7 +215,7 @@ public void childNodeAdded(String name, NodeState after) {\n                     if (p.startsWith(pathFilter)) {\n                         buff.tag('+').\n                                 key(p).object();\n-                        toJson(buff, after);\n+                        toJson(buff, after, depth);\n                         buff.endObject().newline();\n                     }\n                 }\n@@ -267,14 +267,16 @@ public void childNodeChanged(String name, NodeState before, NodeState after) {\n         return buff.toString();\n     }\n \n-    private void toJson(JsopBuilder builder, NodeState node) {\n+    private void toJson(JsopBuilder builder, NodeState node, int depth) {\n         for (PropertyState property : node.getProperties()) {\n             builder.key(property.getName()).encodedValue(property.getEncodedValue());\n         }\n+        if (depth != 0) {\n             for (ChildNode entry : node.getChildNodeEntries(0, -1)) {\n                 builder.key(entry.getName()).object();\n-            toJson(builder, entry.getNode());\n+                toJson(builder, entry.getNode(), depth < 0 ? depth : depth - 1);\n                 builder.endObject();\n             }\n         }\n     }\n+}\n", "nb_test": 79, "linesAdd": 7, "jira_id": "548", "singleLine": false, "nb_skipped": 2, "commit": "717186d6", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 13, "classification": {"singleLine": false}, "failing_tests": ["verifyGroupNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberSplitUpgradeTest): Failed to copy content", "verifyMembers(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberSplitUpgradeTest): Failed to copy content", "verifyMemberOf(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberSplitUpgradeTest): Failed to copy content", "verifyNameSpaces(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyCustomPrivileges(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyCustomNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyNewBuiltinNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyReplacedBuiltinNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyGenericProperties(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyReferencePropertiesContent(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyGroupNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberUpgradeTest): Failed to copy content", "verifyMembers(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberUpgradeTest): Failed to copy content", "verifyMemberOf(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberUpgradeTest): Failed to copy content"], "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex e47aba3..9c24468 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -47,7 +46,6 @@\n import org.apache.jackrabbit.oak.plugins.name.Namespaces;\n import org.apache.jackrabbit.oak.plugins.nodetype.TypeEditorProvider;\n import org.apache.jackrabbit.oak.plugins.nodetype.write.InitialContent;\n-import org.apache.jackrabbit.oak.security.authorization.AuthorizationConfigurationImpl;\n import org.apache.jackrabbit.oak.spi.commit.CommitHook;\n import org.apache.jackrabbit.oak.spi.commit.CommitInfo;\n import org.apache.jackrabbit.oak.spi.commit.CompositeEditorProvider;\n@@ -71,7 +69,6 @@\n import org.slf4j.LoggerFactory;\n \n import static com.google.common.base.Preconditions.checkState;\n-import static com.google.common.collect.Lists.newArrayList;\n import static com.google.common.collect.Lists.newArrayListWithCapacity;\n import static com.google.common.collect.Maps.newHashMap;\n import static java.util.Arrays.asList;\n@@ -225,7 +222,6 @@ public void copy() throws RepositoryException {\n \n             NodeState root = builder.getNodeState();\n             copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\n-            String workspaceName =\n             copyWorkspaces(builder, root, uriToPrefix, idxToPrefix);\n \n             logger.info(\"Applying default commit hooks\");\n@@ -237,15 +233,14 @@ public void copy() throws RepositoryException {\n                 groupsPath = UserConstants.DEFAULT_GROUP_PATH;\n             }\n             // TODO: default hooks?\n-            List<CommitHook> hooks = newArrayList();\n-            hooks.add(new EditorHook(new CompositeEditorProvider(\n-                            new GroupEditorProvider(groupsPath),\n+            CommitHook hook = new CompositeHook(\n+                    new EditorHook(new GroupEditorProvider(groupsPath)),\n+                    new EditorHook(new CompositeEditorProvider(\n                             new TypeEditorProvider(false),\n                             new IndexUpdateProvider(new CompositeIndexEditorProvider(\n                                     new ReferenceEditorProvider(),\n                                     new PropertyIndexEditorProvider())))));\n-            hooks.addAll(new AuthorizationConfigurationImpl().getCommitHooks(workspaceName));\n-            target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\n+            target.merge(builder, hook, CommitInfo.EMPTY);\n         } catch (Exception e) {\n             throw new RepositoryException(\"Failed to copy content\", e);\n         }\n@@ -562,7 +557,7 @@ private void copyVersionStore(\n                 \"/jcr:system/jcr:activities\", copyBinariesByReference));\n     }   \n \n-    private String copyWorkspaces(\n+    private void copyWorkspaces(\n             NodeBuilder builder, NodeState root,\n             Map<String, String> uriToPrefix, Map<Integer, String> idxToPrefix)\n             throws RepositoryException, IOException {\n@@ -587,7 +582,7 @@ private String copyWorkspaces(\n             }\n         }\n \n-        return name;\n+        // TODO: Copy all the active open-scoped locks\n     }\n \n \n", "nb_test": 13, "linesAdd": 5, "jira_id": "1719", "singleLine": false, "nb_skipped": 0, "commit": "c3773d53", "nb_failure": 0, "linesRem": 10}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAddRemovedNodeAgain(org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex 6600cc7..68cc5f2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -422,7 +422,9 @@ public NodeBuilder child(String name) {\n         read(); // shortcut when dealing with a read-only child node\n         if (baseState != null\n                 && baseState.hasChildNode(name)\n-                && (writeState == null || !writeState.nodes.containsKey(name))) {\n+                && (writeState == null\n+                    || (writeState.base == baseState\n+                        && !writeState.nodes.containsKey(name)))) {\n             return createChildBuilder(name);\n         }\n \n", "nb_test": 399, "linesAdd": 3, "jira_id": "447", "singleLine": false, "nb_skipped": 0, "commit": "00df38d2", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["copyOnWriteAndLocks(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditorTest): OakLucene0003: Failed to index the node /test"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\nindex e17f580..ea6b0ed 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n@@ -56,7 +56,6 @@\n import com.google.common.collect.Sets;\n import com.google.common.hash.Hashing;\n import org.apache.commons.io.FileUtils;\n-import org.apache.jackrabbit.oak.commons.IOUtils;\n import org.apache.jackrabbit.oak.commons.concurrent.NotifyingFutureTask;\n import org.apache.jackrabbit.oak.util.PerfLogger;\n import org.apache.lucene.store.Directory;\n@@ -65,6 +64,7 @@\n import org.apache.lucene.store.IOContext;\n import org.apache.lucene.store.IndexInput;\n import org.apache.lucene.store.IndexOutput;\n+import org.apache.lucene.store.NoLockFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -147,7 +147,10 @@ protected Directory createLocalDirForIndexWriter(IndexDefinition definition) thr\n             String newVersion = String.valueOf(definition.getReindexCount());\n             indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);\n         }\n-        Directory dir = FSDirectory.open(indexWriterDir);\n+\n+        //By design indexing in Oak is single threaded so Lucene locking\n+        //can be disabled\n+        Directory dir = FSDirectory.open(indexWriterDir, NoLockFactory.getNoLockFactory());\n \n         log.debug(\"IndexWriter would use {}\", indexWriterDir);\n \n", "nb_test": 460, "linesAdd": 3, "jira_id": "3053", "singleLine": false, "nb_skipped": 3, "commit": "7552a10b", "nb_failure": 0, "linesRem": 2}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testGetTree2(org.apache.jackrabbit.oak.security.authorization.evaluation.RootTest): /a/b/c", "testGetNodeLocation2(org.apache.jackrabbit.oak.security.authorization.evaluation.RootTest): /a/b/c", "testGetPropertyLocation2(org.apache.jackrabbit.oak.security.authorization.evaluation.RootTest): /a/jcr:primaryType", "testGetPropertyLocation3(org.apache.jackrabbit.oak.security.authorization.evaluation.RootTest): /a/aProp"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractNodeLocation.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractNodeLocation.java\nindex e70a1b1..89df0ac 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractNodeLocation.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractNodeLocation.java\n@@ -57,15 +57,15 @@ public TreeLocation getParent() {\n \n     @Override\n     public TreeLocation getChild(String name) {\n-        T child = getChildTree(name);\n-        if (child != null) {\n-            return createNodeLocation(child);\n-        }\n-\n         PropertyState prop = getPropertyState(name);\n         if (prop != null) {\n             return createPropertyLocation(this, name);\n         }\n+\n+        T child = getChildTree(name);\n+        if (child != null) {\n+            return createNodeLocation(child);\n+        }\n         return new NullLocation(this, name);\n     }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\nindex 8bda9f2..efb5ec9 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n@@ -91,7 +91,7 @@ private TreeImpl(RootImpl root, TreeImpl parent, String name, Move pendingMoves)\n         this.root = checkNotNull(root);\n         this.parent = checkNotNull(parent);\n         this.name = checkNotNull(name);\n-        this.nodeBuilder = parent.nodeBuilder.child(name);\n+        this.nodeBuilder = parent.nodeBuilder.getChildNode(name);\n         this.pendingMoves = checkNotNull(pendingMoves);\n     }\n \n@@ -187,11 +187,7 @@ public TreeImpl getChild(@Nonnull String name) {\n         checkNotNull(name);\n         enter();\n         TreeImpl child = internalGetChild(name);\n-        if (child != null && canRead(child)) {\n-            return child;\n-        } else {\n-            return null;\n-        }\n+        return canRead(child) ? child : null;\n     }\n \n     @Override\n@@ -438,11 +434,8 @@ TreeImpl getTree(String path) {\n         TreeImpl child = this;\n         for (String name : elements(path)) {\n             child = child.internalGetChild(name);\n-            if (child == null) {\n-                return null;\n-            }\n         }\n-        return (canRead(child)) ? child : null;\n+        return canRead(child) ? child : null;\n     }\n \n     /**\n@@ -526,9 +519,7 @@ private void applyPendingMoves() {\n     }\n \n     private TreeImpl internalGetChild(String childName) {\n-        return nodeBuilder.hasChildNode(childName)\n-            ? new TreeImpl(root, this, childName, pendingMoves)\n-            : null;\n+        return new TreeImpl(root, this, childName, pendingMoves);\n     }\n \n     private PropertyState internalGetProperty(String propertyName) {\n", "nb_test": 684, "linesAdd": 9, "jira_id": "766", "singleLine": false, "nb_skipped": 1, "commit": "6fc5ea9d", "nb_failure": 4, "linesRem": 18}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["verifyVersionHistory(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): OAK-1789 expected:<[61400838-ec5e-48ac-a337-6e0c422d946b/child]> but was:<[37038439-e977-4e80-ae21-0f387aca3e66]>"], "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\nindex ffe9e8e..bc60aa8 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n@@ -18,16 +18,25 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Iterables.addAll;\n import static com.google.common.collect.Lists.newArrayList;\n import static com.google.common.collect.Lists.newArrayListWithCapacity;\n import static com.google.common.collect.Maps.newHashMap;\n import static com.google.common.collect.Maps.newLinkedHashMap;\n+import static com.google.common.collect.Sets.newHashSet;\n import static com.google.common.collect.Sets.newLinkedHashSet;\n+import static org.apache.jackrabbit.JcrConstants.JCR_FROZENMIXINTYPES;\n+import static org.apache.jackrabbit.JcrConstants.JCR_FROZENPRIMARYTYPE;\n+import static org.apache.jackrabbit.JcrConstants.JCR_FROZENUUID;\n import static org.apache.jackrabbit.JcrConstants.JCR_MIXINTYPES;\n import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;\n import static org.apache.jackrabbit.JcrConstants.JCR_UUID;\n import static org.apache.jackrabbit.JcrConstants.MIX_REFERENCEABLE;\n+import static org.apache.jackrabbit.JcrConstants.NT_FROZENNODE;\n import static org.apache.jackrabbit.JcrConstants.NT_UNSTRUCTURED;\n+import static org.apache.jackrabbit.oak.api.Type.NAME;\n+import static org.apache.jackrabbit.oak.api.Type.NAMES;\n+import static org.apache.jackrabbit.oak.api.Type.STRING;\n import static org.apache.jackrabbit.oak.plugins.tree.TreeConstants.OAK_CHILD_ORDER;\n \n import java.io.ByteArrayInputStream;\n@@ -97,6 +106,8 @@ private static void logNewNode(JackrabbitNodeState state) {\n \n     private final TypePredicate isOrderable;\n \n+    private final TypePredicate isFrozenNode;\n+\n     /**\n      * Source namespace mappings (URI -&lt; prefix).\n      */\n@@ -116,6 +127,7 @@ private JackrabbitNodeState(\n         this.loader = parent.loader;\n         this.isReferenceable = parent.isReferenceable;\n         this.isOrderable = parent.isOrderable;\n+        this.isFrozenNode = parent.isFrozenNode;\n         this.uriToPrefix = parent.uriToPrefix;\n         this.nodes = createNodes(bundle);\n         this.properties = createProperties(bundle);\n@@ -133,6 +145,7 @@ private JackrabbitNodeState(\n         this.loader = new BundleLoader(source);\n         this.isReferenceable = new TypePredicate(root, MIX_REFERENCEABLE);\n         this.isOrderable = TypePredicate.isOrderable(root);\n+        this.isFrozenNode = new TypePredicate(root, NT_FROZENNODE);\n         this.uriToPrefix = uriToPrefix;\n         try {\n             NodePropBundle bundle = loader.loadBundle(id);\n@@ -239,7 +252,7 @@ public NodeBuilder builder() {\n         return children;\n     }\n \n-    public Map<String, PropertyState> createProperties(NodePropBundle bundle) {\n+    private Map<String, PropertyState> createProperties(NodePropBundle bundle) {\n         Map<String, PropertyState> properties = newHashMap();\n \n         String primary;\n@@ -290,6 +303,32 @@ public NodeBuilder builder() {\n             }\n         }\n \n+        // OAK-1789: Convert the jcr:frozenUuid of a non-referenceable\n+        // frozen node from UUID to a path identifier\n+        PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\n+        if (frozenUuid != null\n+                && frozenUuid.getType() == STRING\n+                && isFrozenNode.apply(primary, mixins)) {\n+            String frozenPrimary = NT_UNSTRUCTURED;\n+            Set<String> frozenMixins = newHashSet();\n+\n+            PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\n+            if (property != null && property.getType() == NAME) {\n+                primary = property.getValue(NAME);\n+            }\n+            property = properties.get(JCR_FROZENMIXINTYPES);\n+            if (property != null && property.getType() == NAMES) {\n+                addAll(frozenMixins, property.getValue(NAMES));\n+            }\n+\n+            if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\n+                frozenUuid = PropertyStates.createProperty(\n+                        JCR_FROZENUUID,\n+                        parent.getString(JCR_FROZENUUID) + \"/\" + name);\n+                properties.put(JCR_FROZENUUID, frozenUuid);\n+            }\n+        }\n+\n         return properties;\n     }\n \n", "nb_test": 14, "linesAdd": 38, "jira_id": "1789", "singleLine": false, "nb_skipped": 0, "commit": "08ba79d4", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["getValuesOnMvp[2](org.apache.jackrabbit.oak.jcr.query.QueryTest)", "getValuesOnMvp[0](org.apache.jackrabbit.oak.jcr.query.QueryTest)", "getValuesOnMvp[1](org.apache.jackrabbit.oak.jcr.query.QueryTest)"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\nindex fd09cac..e337f39 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\n@@ -25,6 +25,10 @@\n \n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.ResultRow;\n+import org.apache.jackrabbit.oak.api.Type;\n+import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n+\n+import com.google.common.base.Joiner;\n \n /**\n  * The implementation of the corresponding JCR interface.\n@@ -96,9 +100,20 @@ public Value getValue(String columnName) throws RepositoryException {\n         int len = values.length;\n         Value[] v2 = new Value[values.length];\n         for (int i = 0; i < len; i++) {\n+            if(values[i].isArray()){\n+                v2[i] = result.createValue(mvpToString(values[i]));\n+            }else{\n                 v2[i] = result.createValue(values[i]);\n             }\n+        }\n         return v2;\n     }\n \n+    private static PropertyValue mvpToString(PropertyValue pv) {\n+        String v = Joiner.on(' ')\n+                .appendTo(new StringBuilder(), pv.getValue(Type.STRINGS))\n+                .toString();\n+        return PropertyValues.newString(v);\n+    }\n+\n }\n", "nb_test": 1156, "linesAdd": 15, "jira_id": "1093", "singleLine": false, "nb_skipped": 3, "commit": "d7f0f180", "nb_failure": 0, "linesRem": 0}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testRemoveMissingProperty(org.apache.jackrabbit.oak.jcr.CRUDTest): missing not found on /"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\nindex 351ae8b..bda7280 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\n@@ -291,6 +291,10 @@ public PropertyDelegate setProperty(String name, CoreValue value) throws Invalid\n         return new PropertyDelegate(sessionDelegate, getTree(), propertyState);\n     }\n \n+    public void removeProperty(String name) throws InvalidItemStateException {\n+        getTree().removeProperty(name);\n+    }\n+\n     /**\n      * Set a multi valued property\n      * @param name  oak name\ndiff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex 70d0494..fbb8b10 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -264,15 +264,16 @@ public Property setProperty(String jcrName, Value value, int type)\n             throws RepositoryException {\n         checkStatus();\n \n-        int targetType = getTargetType(value, type);\n-        Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\n+        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n         if (value == null) {\n-            Property p = getProperty(jcrName);\n-            p.remove();\n-            return p;\n+            dlg.removeProperty(oakName);\n+            return null;\n         } else {\n-            String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n-            CoreValue oakValue = ValueConverter.toCoreValue(targetValue, sessionDelegate);\n+            int targetType = getTargetType(value, type);\n+            Value targetValue =\n+                    ValueHelper.convert(value, targetType, getValueFactory());\n+            CoreValue oakValue =\n+                    ValueConverter.toCoreValue(targetValue, sessionDelegate);\n             return new PropertyImpl(dlg.setProperty(oakName, oakValue));\n         }\n     }\n", "nb_test": 195, "linesAdd": 12, "jira_id": "185", "singleLine": false, "nb_skipped": 9, "commit": "7fe28a0e", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["fulltextQueryWithSpecialChars(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): INVALID_SYNTAX_CANNOT_PARSE: Syntax Error, cannot parse stockphotography\\:business/business_abstract: Lexical error at line 1, column 45.  Encountered: <EOF> after : \"/business_abstract\""], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex e7cec26..e7f29cd 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -1337,7 +1337,7 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer) {\n     /**\n      * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n      */\n-    private static String rewriteQueryText(String textsearch) {\n+    static String rewriteQueryText(String textsearch) {\n         // replace escaped ' with just '\n         StringBuilder rewritten = new StringBuilder();\n         // the default lucene query parser recognizes 'AND' and 'NOT' as\n@@ -1346,27 +1346,30 @@ private static String rewriteQueryText(String textsearch) {\n         textsearch = textsearch.replaceAll(\"NOT\", \"not\");\n         boolean escaped = false;\n         for (int i = 0; i < textsearch.length(); i++) {\n-            if (textsearch.charAt(i) == '\\\\') {\n+            char c = textsearch.charAt(i);\n+            if (c == '\\\\') {\n                 if (escaped) {\n                     rewritten.append(\"\\\\\\\\\");\n                     escaped = false;\n                 } else {\n                     escaped = true;\n                 }\n-            } else if (textsearch.charAt(i) == '\\'') {\n+            } else if (c == '\\'') {\n                 if (escaped) {\n                     escaped = false;\n                 }\n-                rewritten.append(textsearch.charAt(i));\n-            } else if (textsearch.charAt(i) == ':') {\n-                // fields as known in lucene are not supported\n-                rewritten.append(\"\\\\:\");\n+                rewritten.append(c);\n+            } else if (c == ':' || c == '/') {\n+                //TODO Some other chars are also considered special See OAK-3769 for details\n+                //':' fields as known in lucene are not supported\n+                //'/' its a special char used for regex search in Lucene\n+                rewritten.append('\\\\').append(c);\n             } else {\n                 if (escaped) {\n                     rewritten.append('\\\\');\n                     escaped = false;\n                 }\n-                rewritten.append(textsearch.charAt(i));\n+                rewritten.append(c);\n             }\n         }\n         return rewritten.toString();\n", "nb_test": 315, "linesAdd": 8, "jira_id": "3769", "singleLine": false, "nb_skipped": 3, "commit": "306a9e00", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["nodeStatus(org.apache.jackrabbit.oak.core.TreeImplTest): Cannot get the base state of a removed tree", "propertyStatus(org.apache.jackrabbit.oak.core.TreeImplTest): Cannot build the path of a removed tree"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\nindex a3d3536..abc942a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n@@ -50,9 +50,12 @@\n     /** Underlying {@code Root} of this {@code Tree} instance */\n     private final RootImpl root;\n \n-    /** Parent of this tree. Null for the root and this for removed trees. */\n+    /** Parent of this tree. Null for the root. */\n     private TreeImpl parent;\n \n+    /** Marker for removed trees */\n+    private boolean removed;\n+\n     /** Name of this tree */\n     private String name;\n \n@@ -254,7 +257,7 @@ public boolean remove() {\n             NodeBuilder builder = parent.getNodeBuilder();\n             builder.removeNode(name);\n             parent.children.remove(name);\n-            parent = this;\n+            removed = true;\n             root.purge();\n             return true;\n         } else {\n@@ -390,6 +393,10 @@ private PropertyState internalGetProperty(String propertyName) {\n     }\n \n     private Status internalGetPropertyStatus(String name) {\n+        if (isRemoved()) {\n+            return Status.REMOVED;\n+        }\n+\n         NodeState baseState = getBaseState();\n         boolean exists = internalGetProperty(name) != null;\n         if (baseState == null) {\n@@ -433,14 +440,10 @@ private Status internalGetPropertyStatus(String name) {\n     }\n \n     private boolean isRemoved() {\n-        return parent == this;\n+        return removed || (parent != null && parent.isRemoved());\n     }\n \n     private void buildPath(StringBuilder sb) {\n-        if (isRemoved()) {\n-            throw new IllegalStateException(\"Cannot build the path of a removed tree\");\n-        }\n-\n         if (!isRoot()) {\n             parent.buildPath(sb);\n             sb.append('/').append(name);\n", "nb_test": 231, "linesAdd": 8, "jira_id": "278", "singleLine": false, "nb_skipped": 1, "commit": "db19e70f", "nb_failure": 0, "linesRem": 6}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testFailover(org.apache.jackrabbit.oak.plugins.segment.standby.FailoverTest)"], "patch": "diff --git a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/SegmentLoaderHandler.java b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/SegmentLoaderHandler.java\nindex ba7e775..633652c 100644\n--- a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/SegmentLoaderHandler.java\n+++ b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/SegmentLoaderHandler.java\n@@ -133,7 +133,7 @@ private void initSync() {\n     @Override\n     public Segment readSegment(final String id) {\n         ctx.writeAndFlush(newGetSegmentReq(this.clientID, id));\n-        return getSegment();\n+        return getSegment(id);\n     }\n \n     @Override\n@@ -145,15 +145,18 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)\n \n     // implementation of RemoteSegmentLoader\n \n-    public Segment getSegment() {\n+    public Segment getSegment(final String id) {\n         boolean interrupted = false;\n         try {\n             for (;;) {\n                 try {\n-                    // log.debug(\"polling segment\");\n                     Segment s = segment.poll(timeoutMs, TimeUnit.MILLISECONDS);\n-                    // log.debug(\"returning segment \" + s.getSegmentId());\n+                    if (s == null) {\n+                        return null;\n+                    }\n+                    if (s.getSegmentId().toString().equals(id)) {\n                         return s;\n+                    }\n                 } catch (InterruptedException ignore) {\n                     interrupted = true;\n                 }\n", "nb_test": 7, "linesAdd": 7, "jira_id": "2260", "singleLine": false, "nb_skipped": 0, "commit": "0ac7ff20", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testGetChildrenCountOnVersionStorage(org.apache.jackrabbit.oak.security.authorization.evaluation.VersionStorageTest)", "testGetChildrenCountOnVersionStorage2(org.apache.jackrabbit.oak.security.authorization.evaluation.VersionStorageTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\nindex dc1b9c2..c9d0fa0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\n@@ -157,7 +157,10 @@ public TreePermission getTreePermission(@Nonnull ImmutableTree tree, @Nonnull Tr\n                 // TODO: OAK-753 decide on where to filter out hidden items.\n                 return TreePermission.ALL;\n             case TreeTypeProvider.TYPE_VERSION:\n-                String ntName = checkNotNull(TreeUtil.getPrimaryTypeName(tree));\n+                String ntName = TreeUtil.getPrimaryTypeName(tree);\n+                if (ntName == null) {\n+                    return TreePermission.EMPTY;\n+                }\n                 if (VersionConstants.VERSION_STORE_NT_NAMES.contains(ntName) || VersionConstants.NT_ACTIVITY.equals(ntName)) {\n                     return new TreePermissionImpl(tree, TreeTypeProvider.TYPE_VERSION, parentPermission);\n                 } else {\n", "nb_test": 1422, "linesAdd": 4, "jira_id": "1173", "singleLine": false, "nb_skipped": 6, "commit": "61c877d8", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["conflictDetectionWithClockDifference(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): must fail with CommitFailedException", "parentWithUnseenChildrenMustNotBeDeleted(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): parent node of unseen children must not get deleted"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 420ba29..021cfa2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -37,7 +37,6 @@\n import com.google.common.base.Function;\n import com.google.common.base.Predicate;\n import com.google.common.collect.AbstractIterator;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterators;\n import com.google.common.collect.Queues;\n import org.apache.jackrabbit.oak.cache.CacheValue;\n@@ -58,6 +57,7 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.transform;\n+import static java.util.Collections.reverseOrder;\n import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;\n import static org.apache.jackrabbit.oak.plugins.document.StableRevisionComparator.REVERSE;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;\n@@ -740,11 +740,11 @@ public boolean apply(Revision input) {\n \n         Revision newestRev = null;\n         // check local commits first\n-        SortedMap<Revision, String> revisions = getLocalRevisions();\n-        SortedMap<Revision, String> commitRoots = getLocalCommitRoot();\n-        Iterator<Revision> it = filter(Iterables.mergeSorted(\n-                ImmutableList.of(revisions.keySet(), commitRoots.keySet()),\n-                revisions.comparator()), predicate).iterator();\n+        Comparator<Revision> comp = reverseOrder(context.getRevisionComparator());\n+        SortedSet<Revision> revisions = Sets.newTreeSet(comp);\n+        revisions.addAll(getLocalRevisions().keySet());\n+        revisions.addAll(getLocalCommitRoot().keySet());\n+        Iterator<Revision> it = filter(revisions, predicate).iterator();\n         if (it.hasNext()) {\n             newestRev = it.next();\n         } else {\n", "nb_test": 2421, "linesAdd": 6, "jira_id": "2929", "singleLine": false, "nb_skipped": 1, "commit": "a2950285", "nb_failure": 2, "linesRem": 6}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testListUsersWithMissingUid(org.apache.jackrabbit.oak.security.authentication.ldap.LdapProviderTest)"], "patch": "diff --git a/oak-auth-ldap/src/main/java/org/apache/jackrabbit/oak/security/authentication/ldap/impl/LdapIdentityProvider.java b/oak-auth-ldap/src/main/java/org/apache/jackrabbit/oak/security/authentication/ldap/impl/LdapIdentityProvider.java\nindex e6b2ba4..512a1bf 100644\n--- a/oak-auth-ldap/src/main/java/org/apache/jackrabbit/oak/security/authentication/ldap/impl/LdapIdentityProvider.java\n+++ b/oak-auth-ldap/src/main/java/org/apache/jackrabbit/oak/security/authentication/ldap/impl/LdapIdentityProvider.java\n@@ -702,7 +702,13 @@ private ExternalUser createUser(@Nonnull Entry entry, @CheckForNull String id)\n             throws LdapInvalidAttributeValueException {\n         ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());\n         if (id == null) {\n-            id = entry.get(config.getUserConfig().getIdAttribute()).getString();\n+            String idAttribute = config.getUserConfig().getIdAttribute();\n+            Attribute attr = entry.get(idAttribute);\n+            if (attr == null) {\n+                throw new LdapInvalidAttributeValueException(ResultCodeEnum.CONSTRAINT_VIOLATION,\n+                        \"no value found for attribute '\" + idAttribute + \"' for entry \" + entry);\n+            }\n+            id = attr.getString();\n         }\n         String path = config.getUserConfig().makeDnPath()\n                 ? createDNPath(entry.getDn())\n@@ -718,7 +724,13 @@ private ExternalGroup createGroup(@Nonnull Entry entry, @CheckForNull String nam\n             throws LdapInvalidAttributeValueException {\n         ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());\n         if (name == null) {\n-            name = entry.get(config.getGroupConfig().getIdAttribute()).getString();\n+            String idAttribute = config.getGroupConfig().getIdAttribute();\n+            Attribute attr = entry.get(idAttribute);\n+            if (attr == null) {\n+                throw new LdapInvalidAttributeValueException(ResultCodeEnum.CONSTRAINT_VIOLATION,\n+                        \"no value found for attribute '\" + idAttribute + \"' for entry \" + entry);\n+            }\n+            name = attr.getString();\n         }\n         String path = config.getGroupConfig().makeDnPath()\n                 ? createDNPath(entry.getDn())\n", "nb_test": 84, "linesAdd": 14, "jira_id": "3396", "singleLine": false, "nb_skipped": 1, "commit": "c83755c3", "nb_failure": 0, "linesRem": 2}, {"files": 6, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCompaction(org.apache.jackrabbit.oak.plugins.segment.file.FileStoreTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/CompactionMap.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/CompactionMap.java\nindex a33cba5..bbf5d30 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/CompactionMap.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/CompactionMap.java\n@@ -93,6 +93,19 @@ boolean wasCompactedTo(RecordId before, RecordId after) {\n         return after.equals(get(before));\n     }\n \n+    /**\n+     * Checks whether content in the segment with the given identifier was\n+     * compacted to new segments.\n+     *\n+     * @param id segment identifier\n+     * @return whether the identified segment was compacted\n+     */\n+    boolean wasCompacted(SegmentId id) {\n+        long msb = id.getMostSignificantBits();\n+        long lsb = id.getLeastSignificantBits();\n+        return findEntry(msb, lsb) != -1;\n+    }\n+\n     public RecordId get(RecordId before) {\n         RecordId after = recent.get(before);\n         if (after != null) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\nindex 45bbbcc..14278ca 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\n@@ -75,7 +75,8 @@\n \n     public Compactor(SegmentWriter writer) {\n         this.writer = writer;\n-        this.builder = writer.writeNode(EMPTY_NODE).builder();\n+        this.builder =\n+                new SegmentNodeBuilder(writer.writeNode(EMPTY_NODE), writer);\n     }\n \n     public SegmentNodeState compact(NodeState before, NodeState after) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Record.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Record.java\nindex f65a168..ec8fbfd 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Record.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Record.java\n@@ -65,6 +65,15 @@ protected boolean wasCompactedTo(Record after) {\n     }\n \n     /**\n+     * Returns the tracker of the segment that contains this record.\n+     *\n+     * @return segment tracker\n+     */\n+    protected SegmentTracker getTracker() {\n+        return segmentId.getTracker();\n+    }\n+\n+    /**\n      * Returns the segment that contains this record.\n      *\n      * @return segment that contains this record\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeBuilder.java\nindex 7fc474f..d532bdf 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeBuilder.java\n@@ -33,8 +33,12 @@\n     private long updateCount = 0;\n \n     SegmentNodeBuilder(SegmentNodeState base) {\n+        this(base, base.getTracker().getWriter());\n+    }\n+\n+    SegmentNodeBuilder(SegmentNodeState base, SegmentWriter writer) {\n         super(base);\n-        this.writer = base.getRecordId().getSegmentId().getTracker().getWriter();\n+        this.writer = writer;\n     }\n \n     //-------------------------------------------------< MemoryNodeBuilder >--\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\nindex 41fc1ef..a11b931 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n@@ -940,10 +940,22 @@ public synchronized RecordId writeTemplate(Template template) {\n         return id;\n     }\n \n+    private SegmentNodeState uncompact(SegmentNodeState state) {\n+        RecordId id = tracker.getCompactionMap().get(state.getRecordId());\n+        if (id != null) {\n+            return new SegmentNodeState(id);\n+        } else {\n+            return state;\n+        }\n+    }\n+\n     public SegmentNodeState writeNode(NodeState state) {\n-        if (state instanceof SegmentNodeState\n-                && store.containsSegment(((SegmentNodeState) state).getRecordId().getSegmentId())) {\n-            return (SegmentNodeState) state;\n+        if (state instanceof SegmentNodeState) {\n+            SegmentNodeState sns = uncompact((SegmentNodeState) state);\n+            if (sns != state || store.containsSegment(\n+                    sns.getRecordId().getSegmentId())) {\n+                return sns;\n+            }\n         }\n \n         SegmentNodeState before = null;\n@@ -952,12 +964,15 @@ public SegmentNodeState writeNode(NodeState state) {\n         if (state instanceof ModifiedNodeState) {\n             after = (ModifiedNodeState) state;\n             NodeState base = after.getBaseState();\n-            if (base instanceof SegmentNodeState\n-                    && store.containsSegment(((SegmentNodeState) base).getRecordId().getSegmentId())) {\n-                before = (SegmentNodeState) base;\n+            if (base instanceof SegmentNodeState) {\n+                SegmentNodeState sns = uncompact((SegmentNodeState) base);\n+                if (sns != base || store.containsSegment(\n+                        sns.getRecordId().getSegmentId())) {\n+                    before = sns;\n                     beforeTemplate = before.getTemplate();\n                 }\n             }\n+        }\n \n         Template template = new Template(state);\n         RecordId templateId;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java\nindex 3243572..f378247 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java\n@@ -415,6 +415,7 @@ public void compact() {\n \n         SegmentNodeState before = getHead();\n         SegmentNodeState after = compactor.compact(EMPTY_NODE, before);\n+        writer.flush();\n         while (!setHead(before, after)) {\n             // Some other concurrent changes have been made.\n             // Rebase (and compact) those changes on top of the\n@@ -422,9 +423,16 @@ public void compact() {\n             SegmentNodeState head = getHead();\n             after = compactor.compact(before, head);\n             before = head;\n+            writer.flush();\n         }\n         tracker.setCompactionMap(compactor.getCompactionMap());\n \n+        // Drop the SegmentWriter caches and flush any existing state\n+        // in an attempt to prevent new references to old pre-compacted\n+        // content. TODO: There should be a cleaner way to do this.\n+        tracker.getWriter().dropCache();\n+        tracker.getWriter().flush();\n+\n         log.info(\"TarMK compaction completed in {}ms\", MILLISECONDS\n                 .convert(System.nanoTime() - start, NANOSECONDS));\n         cleanupNeeded.set(true);\n", "nb_test": 1815, "linesAdd": 43, "jira_id": "1932", "singleLine": false, "nb_skipped": 9, "commit": "913c2f53", "nb_failure": 1, "linesRem": 8}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRemoveAdminUserFolder(org.apache.jackrabbit.oak.security.user.UserValidatorTest): Admin user cannot be removed"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\nindex c731481..f4c736c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\n@@ -56,7 +56,7 @@\n         this.parentAfter = parentAfter;\n         this.provider = provider;\n \n-        authorizableType = UserUtil.getType(parentAfter);\n+        authorizableType = (parentAfter == null) ? null : UserUtil.getType(parentAfter);\n     }\n \n     //----------------------------------------------------------< Validator >---\n@@ -149,12 +149,17 @@ public Validator childNodeChanged(String name, NodeState before, NodeState after\n \n     @Override\n     public Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {\n-        Tree node = parentBefore.getChild(name);\n-        if (isAdminUser(node)) {\n+        Tree tree = parentBefore.getChild(name);\n+        AuthorizableType type = UserUtil.getType(tree);\n+        if (type == AuthorizableType.USER || type == AuthorizableType.GROUP) {\n+            if (isAdminUser(tree)) {\n                 String msg = \"The admin user cannot be removed.\";\n                 throw constraintViolation(27, msg);\n             }\n             return null;\n+        } else {\n+            return new VisibleValidator(new UserValidator(tree, null, provider), true, true);\n+        }\n     }\n \n     //------------------------------------------------------------< private >---\n", "nb_test": 1276, "linesAdd": 8, "jira_id": "1054", "singleLine": false, "nb_skipped": 8, "commit": "0adf3a6e", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["useAbandoned(org.apache.jackrabbit.oak.plugins.document.ClusterInfoTest): should have re-used existing cluster id expected:<1> but was:<2>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java\nindex 92208a1..59d5f75 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java\n@@ -374,7 +374,7 @@ public static ClusterNodeInfo getInstance(DocumentStore store, String machineId,\n \n         int retries = 10;\n         for (int i = 0; i < retries; i++) {\n-            ClusterNodeInfo clusterNode = createInstance(store, machineId, instanceId, configuredClusterId);\n+            ClusterNodeInfo clusterNode = createInstance(store, machineId, instanceId, configuredClusterId, i == 0);\n             String key = String.valueOf(clusterNode.id);\n             UpdateOp update = new UpdateOp(key, true);\n             update.set(ID, key);\n@@ -409,7 +409,7 @@ public static ClusterNodeInfo getInstance(DocumentStore store, String machineId,\n     }\n \n     private static ClusterNodeInfo createInstance(DocumentStore store, String machineId,\n-            String instanceId, int configuredClusterId) {\n+            String instanceId, int configuredClusterId, boolean waitForLease) {\n \n         long now = getCurrentTime();\n         int clusterNodeId = 0;\n@@ -447,16 +447,25 @@ private static ClusterNodeInfo createInstance(DocumentStore store, String machin\n             }\n \n             Long leaseEnd = (Long) doc.get(LEASE_END_KEY);\n+            String mId = \"\" + doc.get(MACHINE_ID_KEY);\n+            String iId = \"\" + doc.get(INSTANCE_ID_KEY);\n \n             if (leaseEnd != null && leaseEnd > now) {\n-                // TODO wait for lease end, see OAK-3449\n+                // wait if (a) instructed to, and (b) also the remaining time\n+                // time is not much bigger than the lease interval (in which\n+                // case something is very very wrong anyway)\n+                if (waitForLease && (leaseEnd - now) < (DEFAULT_LEASE_DURATION_MILLIS + 5000) && mId.equals(machineId)\n+                        && iId.equals(instanceId)) {\n+                    boolean worthRetrying = waitForLeaseExpiry(store, doc, leaseEnd.longValue(), machineId, instanceId);\n+                    if (worthRetrying) {\n+                        return createInstance(store, machineId, instanceId, configuredClusterId, false);\n+                    }\n+                }\n+\n                 reuseFailureReason = \"leaseEnd \" + leaseEnd + \" > \" + now + \" - \" + (leaseEnd - now) + \"ms in the future\";\n                 continue;\n             }\n \n-            String mId = \"\" + doc.get(MACHINE_ID_KEY);\n-            String iId = \"\" + doc.get(INSTANCE_ID_KEY);\n-\n             // remove entries with \"random:\" keys if not in use (no lease at all) \n             if (mId.startsWith(RANDOM_PREFIX) && leaseEnd == null) {\n                 store.remove(Collection.CLUSTER_NODES, key);\n@@ -506,6 +515,51 @@ private static ClusterNodeInfo createInstance(DocumentStore store, String machin\n                 RecoverLockState.NONE, prevLeaseEnd, newEntry);\n     }\n \n+    private static boolean waitForLeaseExpiry(DocumentStore store, ClusterNodeInfoDocument cdoc, long leaseEnd, String machineId,\n+            String instanceId) {\n+        String key = cdoc.getId();\n+        LOG.info(\"Found an existing possibly active cluster node info (\" + key + \") for this instance: \" + machineId + \"/\"\n+                + instanceId + \", will try use it.\");\n+\n+        // wait until lease expiry plus 2s\n+        long waitUntil = leaseEnd + 2000;\n+\n+        while (getCurrentTime() < waitUntil) {\n+            LOG.info(\"Waiting for cluster node \" + key + \"'s lease to expire: \" + (waitUntil - getCurrentTime()) / 1000 + \"s left\");\n+\n+            try {\n+                Thread.sleep(5000);\n+            } catch (InterruptedException e) {\n+                // ignored\n+            }\n+\n+            try {\n+                // check state of cluster node info\n+                ClusterNodeInfoDocument reread = store.find(Collection.CLUSTER_NODES, key);\n+                if (reread == null) {\n+                    LOG.info(\"Cluster node info \" + key + \": gone; continueing.\");\n+                    return true;\n+                } else {\n+                    Long newLeaseEnd = (Long) reread.get(LEASE_END_KEY);\n+                    if (newLeaseEnd == null) {\n+                        LOG.info(\"Cluster node \" + key + \": lease end information missing, aborting.\");\n+                        return false;\n+                    } else {\n+                        if (newLeaseEnd.longValue() != leaseEnd) {\n+                            LOG.info(\"Cluster node \" + key + \" seems to be still active (lease end changed from \" + leaseEnd\n+                                    + \" to \" + newLeaseEnd + \", will not try to use it.\");\n+                            return false;\n+                        }\n+                    }\n+                }\n+            } catch (DocumentStoreException ex) {\n+                LOG.info(\"Error reading cluster node info for key \" + key, ex);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     public void performLeaseCheck() {\n         if (leaseCheckDisabled || !renewed) {\n             // if leaseCheckDisabled is set we never do the check, so return fast\n", "nb_test": 2982, "linesAdd": 54, "jira_id": "3424", "singleLine": false, "nb_skipped": 1, "commit": "f4349a96", "nb_failure": 1, "linesRem": 5}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["getNewestRevision(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): OakMerge0001: OakMerge0001: Failed to merge changes to the underlying store (retries 4, 3976 ms)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex 2e32b74..5d7b137 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -20,6 +20,7 @@\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n@@ -53,7 +54,7 @@\n     private final Revision revision;\n     private HashMap<String, UpdateOp> operations = new LinkedHashMap<String, UpdateOp>();\n     private JsopWriter diff = new JsopStream();\n-    private List<Revision> collisions = new ArrayList<Revision>();\n+    private Set<Revision> collisions = new LinkedHashSet<Revision>();\n \n     /**\n      * List of all node paths which have been modified in this commit. In addition to the nodes\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 770cc9c..8b4eb79 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1210,7 +1210,7 @@ public DocumentNodeState getRoot() {\n     @Override\n     public NodeState merge(@Nonnull NodeBuilder builder,\n                            @Nonnull CommitHook commitHook,\n-                           @Nullable CommitInfo info)\n+                           @Nonnull CommitInfo info)\n             throws CommitFailedException {\n         return asDocumentRootBuilder(builder).merge(commitHook, info);\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 35a2306..e685b36 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -581,29 +581,45 @@ public String getCommitRootPath(Revision revision) {\n      * @return the revision, or null if deleted\n      */\n     @CheckForNull\n-    public Revision getNewestRevision(RevisionContext context,\n-                                      Revision changeRev,\n-                                      CollisionHandler handler) {\n-        // no need to look at all commits. the primary document\n-        // always contains at least one commit, including all\n-        // branch commits which are not yet merged\n+    public Revision getNewestRevision(final RevisionContext context,\n+                                      final Revision changeRev,\n+                                      final CollisionHandler handler) {\n+        final Map<Revision, String> validRevisions = Maps.newHashMap();\n+        Predicate<Revision> predicate = new Predicate<Revision>() {\n+            @Override\n+            public boolean apply(Revision input) {\n+                if (input.equals(changeRev)) {\n+                    return false;\n+                }\n+                if (isValidRevision(context, input, null, changeRev, validRevisions)) {\n+                    return true;\n+                }\n+                handler.concurrentModification(input);\n+                return false;\n+            }\n+        };\n+\n+        Revision newestRev = null;\n+        // check local commits first\n         SortedMap<Revision, String> revisions = getLocalRevisions();\n         SortedMap<Revision, String> commitRoots = getLocalCommitRoot();\n-        Revision newestRev = null;\n-        for (Revision r : Iterables.mergeSorted(\n+        Iterator<Revision> it = filter(Iterables.mergeSorted(\n                 Arrays.asList(revisions.keySet(), commitRoots.keySet()),\n-                revisions.comparator())) {\n-            if (!r.equals(changeRev)) {\n-                if (isValidRevision(context, r, null, changeRev, new HashMap<Revision, String>())) {\n-                    newestRev = r;\n-                    // found newest revision, no need to check more revisions\n-                    // revisions are sorted newest first\n-                    break;\n+                revisions.comparator()), predicate).iterator();\n+        if (it.hasNext()) {\n+            newestRev = it.next();\n         } else {\n-                    handler.concurrentModification(r);\n-                }\n+            // check full history (only needed in rare cases)\n+            it = filter(Iterables.mergeSorted(\n+                    Arrays.asList(\n+                            getValueMap(REVISIONS).keySet(),\n+                            getValueMap(COMMIT_ROOT).keySet()),\n+                    revisions.comparator()), predicate).iterator();\n+            if (it.hasNext()) {\n+                newestRev = it.next();\n             }\n         }\n+\n         if (newestRev == null) {\n             return null;\n         }\n", "nb_test": 1776, "linesAdd": 34, "jira_id": "1662", "singleLine": false, "nb_skipped": 8, "commit": "3efb5cbf", "nb_failure": 0, "linesRem": 14}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["nodeStateAsMap(org.apache.jackrabbit.oak.plugins.index.lucene.NodeStateAnalyzerFactoryTest): expected null, but was:<hiddenValue>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\nindex 589fc63..a02983f 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\n@@ -41,6 +41,7 @@\n import org.apache.jackrabbit.oak.plugins.index.lucene.util.TokenizerChain;\n import org.apache.jackrabbit.oak.plugins.tree.TreeFactory;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.apache.jackrabbit.oak.spi.state.NodeStateUtils;\n import org.apache.lucene.analysis.Analyzer;\n import org.apache.lucene.analysis.util.AbstractAnalysisFactory;\n import org.apache.lucene.analysis.util.CharArraySet;\n@@ -201,6 +202,7 @@ private void init(AbstractAnalysisFactory o, NodeState state) {\n             String name = ps.getName();\n             if (ps.getType() != Type.BINARY\n                     && !ps.isArray()\n+                    && !(name != null && NodeStateUtils.isHidden(name))\n                     && !IGNORE_PROP_NAMES.contains(name)) {\n                 result.put(name, ps.getValue(Type.STRING));\n             }\n", "nb_test": 308, "linesAdd": 2, "jira_id": "3817", "singleLine": false, "nb_skipped": 3, "commit": "2a02a138", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["queryWhileDocsAreRemoved(org.apache.jackrabbit.oak.plugins.document.VersionGCDeletionTest): org.apache.jackrabbit.oak.plugins.document.DocumentStoreException: Error occurred while fetching children for path /node"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 03dd859..fe60e13 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -18,6 +18,7 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.toArray;\n import static com.google.common.collect.Iterables.transform;\n import static org.apache.jackrabbit.oak.api.CommitFailedException.MERGE;\n@@ -27,6 +28,7 @@\n import static org.apache.jackrabbit.oak.plugins.document.DocumentMK.MANY_CHILDREN_THRESHOLD;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation;\n+import static org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath;\n import static org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString;\n \n import java.io.Closeable;\n@@ -60,6 +62,7 @@\n import javax.management.NotCompliantMBeanException;\n \n import com.google.common.base.Function;\n+import com.google.common.base.Predicates;\n import com.google.common.cache.Cache;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n@@ -866,11 +869,11 @@ public DocumentNodeState call() throws Exception {\n      * @return the child documents.\n      */\n     @Nonnull\n-    Iterable<NodeDocument> readChildDocs(@Nonnull final String path,\n+    private Iterable<NodeDocument> readChildDocs(@Nonnull final String path,\n                                                  @Nullable String name,\n-                                         int limit) {\n-        String to = Utils.getKeyUpperLimit(checkNotNull(path));\n-        String from;\n+                                                 final int limit) {\n+        final String to = Utils.getKeyUpperLimit(checkNotNull(path));\n+        final String from;\n         if (name != null) {\n             from = Utils.getIdFromPath(concat(path, name));\n         } else {\n@@ -881,7 +884,7 @@ public DocumentNodeState call() throws Exception {\n             // or more than 16k child docs are requested\n             return store.query(Collection.NODES, from, to, limit);\n         }\n-        StringValue key = new StringValue(path);\n+        final StringValue key = new StringValue(path);\n         // check cache\n         NodeDocument.Children c = docChildrenCache.getIfPresent(key);\n         if (c == null) {\n@@ -898,10 +901,10 @@ public DocumentNodeState call() throws Exception {\n             // fetch more and update cache\n             String lastName = c.childNames.get(c.childNames.size() - 1);\n             String lastPath = concat(path, lastName);\n-            from = Utils.getIdFromPath(lastPath);\n+            String low = Utils.getIdFromPath(lastPath);\n             int remainingLimit = limit - c.childNames.size();\n             List<NodeDocument> docs = store.query(Collection.NODES,\n-                    from, to, remainingLimit);\n+                    low, to, remainingLimit);\n             NodeDocument.Children clone = c.clone();\n             for (NodeDocument doc : docs) {\n                 String p = doc.getPath();\n@@ -911,22 +914,36 @@ public DocumentNodeState call() throws Exception {\n             docChildrenCache.put(key, clone);\n             c = clone;\n         }\n-        Iterable<NodeDocument> it = transform(c.childNames, new Function<String, NodeDocument>() {\n+        Iterable<NodeDocument> head = filter(transform(c.childNames,\n+                new Function<String, NodeDocument>() {\n             @Override\n             public NodeDocument apply(String name) {\n                 String p = concat(path, name);\n                 NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(p));\n                 if (doc == null) {\n-                    docChildrenCache.invalidateAll();\n-                    throw new NullPointerException(\"Document \" + p + \" not found\");\n+                    docChildrenCache.invalidate(key);\n                 }\n                 return doc;\n             }\n-        });\n-        if (c.childNames.size() > limit * 2) {\n-            it = Iterables.limit(it, limit * 2);\n+        }), Predicates.notNull());\n+        Iterable<NodeDocument> it;\n+        if (c.isComplete) {\n+            it = head;\n+        } else {\n+            // OAK-2420: 'head' may have null documents when documents are\n+            // concurrently removed from the store. concat 'tail' to fetch\n+            // more documents if necessary\n+            final String last = getIdFromPath(concat(\n+                    path, c.childNames.get(c.childNames.size() - 1)));\n+            Iterable<NodeDocument> tail = new Iterable<NodeDocument>() {\n+                @Override\n+                public Iterator<NodeDocument> iterator() {\n+                    return store.query(NODES, last, to, limit).iterator();\n+                }\n+            };\n+            it = Iterables.concat(head, tail);\n         }\n-        return it;\n+        return Iterables.limit(it, limit);\n     }\n \n     /**\n", "nb_test": 2009, "linesAdd": 28, "jira_id": "2420", "singleLine": false, "nb_skipped": 9, "commit": "24cb1908", "nb_failure": 0, "linesRem": 14}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["removeUncommittedChange[0](org.apache.jackrabbit.oak.plugins.document.OrphanedBranchTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex aa67c4a..c5d5094 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -802,8 +802,13 @@ public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore,\n             if (!Utils.isPropertyName(key)) {\n                 continue;\n             }\n+            // ignore when local map is empty (OAK-2442)\n+            SortedMap<Revision, String> local = getLocalMap(key);\n+            if (local.isEmpty()) {\n+                continue;\n+            }\n             // first check local map, which contains most recent values\n-            Value value = getLatestValue(nodeStore, getLocalMap(key),\n+            Value value = getLatestValue(nodeStore, local,\n                     min, readRevision, validRevisions, lastRevs);\n \n             // check if there may be more recent values in a previous document\n", "nb_test": 1809, "linesAdd": 5, "jira_id": "2442", "singleLine": false, "nb_skipped": 9, "commit": "ea7a6199", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["xpath(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/oajopi.property.PropertyIndexQueryTest_xpath.txt don't match expected results in /home/ylyu/parallel/oak/oak9/dataset/oak/OAK-4387_ca05fd06f97e4ea2be08b58204c3be060d71e7f0/oak-core/target/test-classes/org/apache/jackrabbit/oak/query/xpath.txt; compare the files for details; got=(..)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\nindex d64d7cf..98bcc5e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n@@ -192,20 +192,23 @@ private Statement convertToStatement(String query) throws ParseException {\n                         currentSelector.path = \"/\";\n                     }\n                 }\n-            } else if (readIf(\"text\")) {\n+            } else if (currentTokenType == IDENTIFIER) {\n+                // probably a path restriction\n+                // String name = readPathSegment();\n+                String identifier = readIdentifier();\n+                if (readIf(\"(\")) {\n+                    if (\"text\".equals(identifier)) {\n                         // \"...text()\"\n                         currentSelector.isChild = false;\n                         pathPattern += \"jcr:xmltext\";\n-                read(\"(\");\n                         read(\")\");\n                         if (currentSelector.isDescendant) {\n                             currentSelector.nodeName = \"jcr:xmltext\";\n                         } else {\n                             currentSelector.path = PathUtils.concat(currentSelector.path, \"jcr:xmltext\");\n                         }                        \n-            } else if (readIf(\"element\")) {\n+                    } else if (\"element\".equals(identifier)) {\n                         // \"...element(...\"\n-                read(\"(\");\n                         if (readIf(\")\")) {\n                             // any\n                             pathPattern += \"%\";\n@@ -223,14 +226,22 @@ private Statement convertToStatement(String query) throws ParseException {\n                             }\n                             read(\")\");\n                         }\n-            } else if (readIf(\"@\")) {\n+                    } else if (\"rep:excerpt\".equals(identifier)) {\n+                        readOpenDotClose(false);\n                         rewindSelector();\n-                Expression.Property p = readProperty();\n+                        Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\n                         statement.addSelectColumn(p);\n-            } else if (readIf(\"rep:excerpt\")) {\n+                    } else {\n+                        throw getSyntaxError();\n+                    }\n+                } else {\n+                    String name = ISO9075.decode(identifier);\n+                    pathPattern += name;\n+                    appendNodeName(name);\n+                }\n+            } else if (readIf(\"@\")) {\n                 rewindSelector();\n-                readExcerpt();\n-                Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\n+                Expression.Property p = readProperty();\n                 statement.addSelectColumn(p);\n             } else if (readIf(\"(\")) {\n                 rewindSelector();\n@@ -239,7 +250,7 @@ private Statement convertToStatement(String query) throws ParseException {\n                         Expression.Property p = readProperty();\n                         statement.addSelectColumn(p);\n                     } else if (readIf(\"rep:excerpt\")) {\n-                        readExcerpt();\n+                        readOpenDotClose(true);\n                         Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\n                         statement.addSelectColumn(p);\n                     } else if (readIf(\"rep:spellcheck\")) {\n@@ -249,7 +260,7 @@ private Statement convertToStatement(String query) throws ParseException {\n                         Expression.Property p = new Expression.Property(currentSelector, \"rep:spellcheck()\", false);\n                         statement.addSelectColumn(p);\n                     } else if (readIf(\"rep:suggest\")) {\n-                        readExcerpt();\n+                        readOpenDotClose(true);\n                         Expression.Property p = new Expression.Property(currentSelector, \"rep:suggest()\", false);\n                         statement.addSelectColumn(p);\n                     }\n@@ -257,11 +268,6 @@ private Statement convertToStatement(String query) throws ParseException {\n                 if (!readIf(\")\")) {\n                     return convertToUnion(query, statement, startParseIndex - 1);\n                 }\n-            } else if (currentTokenType == IDENTIFIER) {\n-                // path restriction\n-                String name = readPathSegment();\n-                pathPattern += name;\n-                appendNodeName(name);\n             } else if (readIf(\".\")) {\n                 // just \".\" this is simply ignored, so that\n                 // \"a/./b\" is the same as \"a/b\"\n@@ -717,13 +723,19 @@ private void read(String expected) throws ParseException {\n         return new Expression.Property(currentSelector, readPathSegment(), false);\n     }\n     \n-    private void readExcerpt() throws ParseException {\n+    /**\n+     * Read open bracket (optional), and optional dot, and close bracket.\n+     * \n+     * @param readOpenBracket whether to read the open bracket (false if this\n+     *            was already read)\n+     * @throws ParseException if close bracket or the dot were not read\n+     */\n+    private void readOpenDotClose(boolean readOpenBracket) throws ParseException {\n+        if (readOpenBracket) {\n             read(\"(\");\n-        if (!readIf(\")\")) {\n-            // only rep:excerpt(.) and rep:excerpt() are currently supported\n-            read(\".\");\n-            read(\")\");\n         }\n+        readIf(\".\");\n+        read(\")\");\n     }\n \n     private String readPathSegment() throws ParseException {\n", "nb_test": 2884, "linesAdd": 24, "jira_id": "4387", "singleLine": false, "nb_skipped": 1, "commit": "ca05fd06", "nb_failure": 0, "linesRem": 19}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["mergedBranchVisibility(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 077d4b3..388cca2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -1330,9 +1330,6 @@ private boolean isCommitted(@Nonnull RevisionContext context,\n                                 @Nonnull Revision revision,\n                                 @Nullable String commitValue,\n                                 @Nonnull Revision readRevision) {\n-        if (revision.equalsIgnoreBranch(readRevision)) {\n-            return true;\n-        }\n         if (commitValue == null) {\n             commitValue = getCommitValue(revision);\n         }\n", "nb_test": 1964, "linesAdd": 0, "jira_id": "2288", "singleLine": false, "nb_skipped": 9, "commit": "57bd2dc5", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRelativeNodeInclude(org.apache.jackrabbit.oak.plugins.index.lucene.AggregateTest): expected:<2> but was:<1>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\nindex 1143b81..8c94e08 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\n@@ -242,7 +242,7 @@ public boolean match(String name, NodeState nodeState, int depth) {\n         public void collectResults(NodeInclude rootInclude, String rootIncludePath, String nodePath,\n                                    NodeState nodeState, ResultCollector results) throws CommitFailedException {\n             //For supporting jcr:contains(jcr:content, 'foo')\n-            if (rootInclude != this && rootInclude.relativeNode){\n+            if (rootInclude.relativeNode){\n                 results.onResult(new NodeIncludeResult(nodePath, rootIncludePath, nodeState));\n             }\n \n@@ -511,7 +511,10 @@ public Matcher match(String name, NodeState nodeState) {\n         public void collectResults(ResultCollector results)\n                 throws CommitFailedException {\n             checkArgument(status == Status.MATCH_FOUND);\n-            String rootIncludePath = aggregateStack.isEmpty() ?  null : aggregateStack.get(0);\n+\n+            //If result being collected as part of reaggregation then take path\n+            //from the stack otherwise its the current path\n+            String rootIncludePath = aggregateStack.isEmpty() ?  currentPath : aggregateStack.get(0);\n             currentInclude.collectResults(rootState.rootInclude, rootIncludePath,\n                     currentPath, matchedNodeState, results);\n         }\n", "nb_test": 375, "linesAdd": 3, "jira_id": "2426", "singleLine": false, "nb_skipped": 2, "commit": "920f32d0", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testUpdateAndDelete[MyFixture: RDB-H2(file)](org.apache.jackrabbit.oak.plugins.document.blob.RDBBlobStoreTest): Datastore block 1d8542ec7822132dbde1160d1e148a2de437e2f4e5891fd4c07226a8c32bf5d2 not found"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBBlobStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBBlobStore.java\nindex 530c877..2ae668b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBBlobStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBBlobStore.java\n@@ -506,8 +506,10 @@ public long countDeleteChunks(List<String> chunkIds, long maxLastModifiedTime) t\n                         .append(inClause.getStatementComponent());\n \n                 if (maxLastModifiedTime > 0) {\n+                    // delete only if the last modified is OLDER than x\n                     metaStatement.append(\" and LASTMOD <= ?\");\n-                    dataStatement.append(\" and not exists(select * from \" + this.tnMeta + \" m where ID = m.ID and m.LASTMOD <= ?)\");\n+                    // delete if there is NO entry where the last modified of the meta is YOUNGER than x\n+                    dataStatement.append(\" and not exists(select * from \" + this.tnMeta + \" m where ID = m.ID and m.LASTMOD > ?)\");\n                 }\n \n                 prepMeta = con.prepareStatement(metaStatement.toString());\n@@ -522,8 +524,17 @@ public long countDeleteChunks(List<String> chunkIds, long maxLastModifiedTime) t\n                     prepData.setLong(dindex, maxLastModifiedTime);\n                 }\n \n-                count += prepMeta.executeUpdate();\n-                prepData.execute();\n+                int deletedMeta = prepMeta.executeUpdate();\n+                int deletedData = prepData.executeUpdate();\n+\n+                if (deletedMeta != deletedData) {\n+                    String message = String.format(\n+                            \"chunk deletion affected different numbers of DATA records (%s) and META records (%s)\", deletedMeta,\n+                            deletedData);\n+                    LOG.info(message);\n+                }\n+\n+                count += deletedMeta;\n             } finally {\n                 closeStatement(prepMeta);\n                 closeStatement(prepData);\n", "nb_test": 3040, "linesAdd": 12, "jira_id": "3872", "singleLine": false, "nb_skipped": 1, "commit": "c13708e3", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["nodeStateAsMap(org.apache.jackrabbit.oak.plugins.index.lucene.NodeStateAnalyzerFactoryTest)", "analyzerByComposition_TokenFilter(org.apache.jackrabbit.oak.plugins.index.lucene.NodeStateAnalyzerFactoryTest): SPI class of type org.apache.lucene.analysis.util.TokenFilterFactory with name 'LowerCase' cannot be instantiated. This is likely due to a misconfiguration of the java class 'org.apache.lucene.analysis.core.LowerCaseFilterFactory':"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\nindex dce4d4f..589fc63 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\n@@ -32,6 +32,7 @@\n \n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Maps;\n+import org.apache.jackrabbit.JcrConstants;\n import org.apache.jackrabbit.oak.api.Blob;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Tree;\n@@ -67,7 +68,11 @@\n final class NodeStateAnalyzerFactory{\n     private static final AtomicBoolean versionWarningAlreadyLogged = new AtomicBoolean(false);\n \n-    private static final Set<String> IGNORE_PROP_NAMES = ImmutableSet.of(LuceneIndexConstants.ANL_CLASS, LuceneIndexConstants.ANL_NAME);\n+    private static final Set<String> IGNORE_PROP_NAMES = ImmutableSet.of(\n+            LuceneIndexConstants.ANL_CLASS,\n+            LuceneIndexConstants.ANL_NAME,\n+            JcrConstants.JCR_PRIMARYTYPE\n+    );\n \n     private static final Logger log = LoggerFactory.getLogger(NodeStateAnalyzerFactory.class);\n \n", "nb_test": 399, "linesAdd": 6, "jira_id": "2524", "singleLine": false, "nb_skipped": 2, "commit": "977a31d8", "nb_failure": 1, "linesRem": 1}, {"files": 0, "project": "jackrabbit-oak", "nb_error": 5, "classification": {"singleLine": false}, "failing_tests": ["referencedOlderThanOrphaned(org.apache.jackrabbit.oak.upgrade.CopyVersionHistoryTest): jcr:versionHistory not found on /versionables/mix:simpleVersionable/old", "copyAllVersions(org.apache.jackrabbit.oak.upgrade.CopyVersionHistoryTest): jcr:versionHistory not found on /versionables/mix:simpleVersionable/old", "onlyReferencedAfterDate(org.apache.jackrabbit.oak.upgrade.CopyVersionHistoryTest): jcr:versionHistory not found on /versionables/mix:simpleVersionable/young", "onlyReferenced(org.apache.jackrabbit.oak.upgrade.CopyVersionHistoryTest): jcr:versionHistory not found on /versionables/mix:simpleVersionable/old", "referencedSinceDate(org.apache.jackrabbit.oak.upgrade.CopyVersionHistoryTest): jcr:versionHistory not found on /versionables/mix:simpleVersionable/young"], "patch": "", "nb_test": 126, "linesAdd": 0, "jira_id": "4166", "singleLine": false, "nb_skipped": 7, "commit": "374e3f3d", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["concurrentAddChildMakeOrderable[0](org.apache.jackrabbit.oak.api.TreeTest): expected:<[node2, node1, node3[, node4]]> but was:<[node2, node1, node3[]]>", "concurrentAddChildMakeOrderable[1](org.apache.jackrabbit.oak.api.TreeTest): expected:<[node1, node2, node3[, node4]]> but was:<[node1, node2, node3[]]>", "concurrentAddChildMakeOrderable[2](org.apache.jackrabbit.oak.api.TreeTest): expected:<[node1, node2, node3[, node4]]> but was:<[node1, node2, node3[]]>", "concurrentAddChildMakeOrderable[3](org.apache.jackrabbit.oak.api.TreeTest): expected:<[node1, node2, node3[, node4]]> but was:<[node1, node2, node3[]]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java\nindex bf31922..c4ea380 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java\n@@ -45,7 +45,8 @@ public Resolution addExistingProperty(NodeBuilder parent,\n         if (isChildOrderProperty(ours)) {\n             // two sessions concurrently called orderBefore() on a Tree\n             // that was previously unordered.\n-            return Resolution.THEIRS;\n+            merge(parent, ours, theirs);\n+            return Resolution.MERGED;\n         } else {\n             return handler.addExistingProperty(parent, ours, theirs);\n         }\n@@ -75,11 +76,11 @@ public Resolution changeChangedProperty(NodeBuilder parent,\n     }\n \n     private static void merge(NodeBuilder parent, PropertyState ours, PropertyState theirs) {\n-        Set<String> theirOrder = Sets.newHashSet(theirs.getValue(Type.STRINGS));\n-        PropertyBuilder<String> merged = PropertyBuilder.array(Type.STRING).assignFrom(theirs);\n+        Set<String> theirOrder = Sets.newHashSet(theirs.getValue(Type.NAMES));\n+        PropertyBuilder<String> merged = PropertyBuilder.array(Type.NAME).assignFrom(theirs);\n \n         // Append child node names from ours that are not in theirs\n-        for (String ourChild : ours.getValue(Type.STRINGS)) {\n+        for (String ourChild : ours.getValue(Type.NAMES)) {\n             if (!theirOrder.contains(ourChild)) {\n                 merged.addValue(ourChild);\n             }\n", "nb_test": 1578, "linesAdd": 5, "jira_id": "1460", "singleLine": false, "nb_skipped": 7, "commit": "f1ba7a42", "nb_failure": 4, "linesRem": 4}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["missingEqualsModified(org.apache.jackrabbit.oak.plugins.memory.EmptyNodeStateTest)", "emptyEqualsMissing(org.apache.jackrabbit.oak.plugins.memory.EmptyNodeStateTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyNodeState.java\nindex 62c757d..54415d4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyNodeState.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyNodeState.java\n@@ -186,7 +186,8 @@ public boolean equals(Object object) {\n         } else if (object instanceof NodeState) {\n             NodeState that = (NodeState) object;\n             return that.getPropertyCount() == 0\n-                    && that.getChildNodeCount(1) == 0;\n+                    && that.getChildNodeCount(1) == 0\n+                    && (exists == that.exists());\n         } else {\n             return false;\n         }\n", "nb_test": 3093, "linesAdd": 2, "jira_id": "3763", "singleLine": false, "nb_skipped": 1, "commit": "ab1a0cc2", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEncode(org.apache.jackrabbit.oak.kernel.TypeCodesTest): expected:<[:blobId]:> but was:<[bin]:>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/TypeCodes.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/TypeCodes.java\nindex 48142ab..dd0580a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/TypeCodes.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/TypeCodes.java\n@@ -34,7 +34,9 @@\n \n     static {\n         for (int type = PropertyType.UNDEFINED; type <= PropertyType.DECIMAL; type++) {\n-            String code = PropertyType.nameFromValue(type).substring(0, 3).toLowerCase(Locale.ENGLISH);\n+            String code = type == PropertyType.BINARY\n+                    ? \":blobId\"  // See class comment for MicroKernel and OAK-428\n+                    : PropertyType.nameFromValue(type).substring(0, 3).toLowerCase(Locale.ENGLISH);\n             TYPE2CODE.put(type, code);\n             CODE2TYPE.put(code, type);\n         }\n@@ -61,7 +63,10 @@ public static String encode(int propertyType, String propertyName) {\n      * @return  the location where the prefix ends or -1 if no prefix is present\n      */\n     public static int split(String jsonString) {\n-        if (jsonString.length() >= 4 && jsonString.charAt(3) == ':') {\n+        if (jsonString.startsWith(\":blobId:\")) {  // See OAK-428\n+            return 7;\n+        }\n+        else if (jsonString.length() >= 4 && jsonString.charAt(3) == ':') {\n             return 3;\n         }\n         else {\n", "nb_test": 397, "linesAdd": 7, "jira_id": "428", "singleLine": false, "nb_skipped": 1, "commit": "916cd92f", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["detectConflict(org.apache.jackrabbit.oak.plugins.document.CommitTest): OakMerge0004: OakMerge0004: The node 1:/foo was already added in revision(..)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex fc7cd5a..d24876f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -523,7 +523,8 @@ private void checkConflicts(@Nonnull UpdateOp op,\n             String conflictMessage = null;\n             Revision conflictRevision = newestRev;\n             if (newestRev == null) {\n-                if ((op.isDelete() || !op.isNew()) && isConflicting(before, op)) {\n+                if ((op.isDelete() || !op.isNew())\n+                        && !allowConcurrentAddRemove(before, op)) {\n                     conflictMessage = \"The node \" +\n                             op.getId() + \" does not exist or is already deleted\";\n                     if (before != null && !before.getLocalDeleted().isEmpty()) {\n@@ -531,7 +532,7 @@ private void checkConflicts(@Nonnull UpdateOp op,\n                     }\n                 }\n             } else {\n-                if (op.isNew() && isConflicting(before, op)) {\n+                if (op.isNew() && !allowConcurrentAddRemove(before, op)) {\n                     conflictMessage = \"The node \" +\n                             op.getId() + \" was already added in revision\\n\" +\n                             formatConflictRevision(newestRev);\n@@ -616,6 +617,25 @@ private boolean isConflicting(@Nullable NodeDocument doc,\n     }\n \n     /**\n+     * Checks whether a concurrent add/remove operation is allowed with the\n+     * given before document and update operation. This method will first check\n+     * if the concurrent add/remove feature is enable and return {@code false}\n+     * immediately if it is disabled. Only when enabled will this method check\n+     * if there is a conflict based on the given document and update operation.\n+     * See also {@link #isConflicting(NodeDocument, UpdateOp)}.\n+     *\n+     * @param before the contents of the document before the update.\n+     * @param op the update to perform.\n+     * @return {@code true} is a concurrent add/remove update is allowed;\n+     *      {@code false} otherwise.\n+     */\n+    private boolean allowConcurrentAddRemove(@Nullable NodeDocument before,\n+                                             @Nonnull UpdateOp op) {\n+        return nodeStore.getEnableConcurrentAddRemove()\n+                && !isConflicting(before, op);\n+    }\n+\n+    /**\n      * @return the branch if this is a branch commit, otherwise {@code null}.\n      */\n     @CheckForNull\n", "nb_test": 3097, "linesAdd": 9, "jira_id": "3733", "singleLine": false, "nb_skipped": 1, "commit": "a5ff019e", "nb_failure": 0, "linesRem": 2}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testSetPolicy(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testSetPolicyWritesAcContent(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AccessControlConfigurationImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AccessControlConfigurationImpl.java\nindex aa7b8d8..7531580 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AccessControlConfigurationImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AccessControlConfigurationImpl.java\n@@ -70,7 +70,8 @@ public CommitHookProvider getSecurityHooks() {\n         return new CommitHookProvider() {\n             @Override\n             public CommitHook getCommitHook(String workspaceName) {\n-                return new CompositeHook(new PermissionHook(workspaceName), new VersionablePathHook(workspaceName));\n+                //FIXME return new CompositeHook(new PermissionHook(workspaceName), new VersionablePathHook(workspaceName));\n+                return new CompositeHook(new VersionablePathHook(workspaceName));\n             }\n         };\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/privilege/PrivilegeDefinitionStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/privilege/PrivilegeDefinitionStore.java\nindex 6ae510c..2fa44f7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/privilege/PrivilegeDefinitionStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/privilege/PrivilegeDefinitionStore.java\n@@ -38,6 +38,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n /**\n  * Reads and writes privilege definitions from and to the repository content\n  * without applying any validation.\n@@ -110,7 +112,7 @@ public PrivilegeBits getBits(@Nonnull String... privilegeNames) {\n         }\n         PrivilegeBits bits = PrivilegeBits.getInstance();\n         for (String privilegeName : privilegeNames) {\n-            Tree defTree = privilegesTree.getChild(privilegeName);\n+            Tree defTree = privilegesTree.getChild(checkNotNull(privilegeName));\n             if (defTree != null) {\n                 bits.add(PrivilegeBits.getInstance(defTree));\n             }\n", "nb_test": 649, "linesAdd": 4, "jira_id": "644", "singleLine": false, "nb_skipped": 1, "commit": "55a4f738", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["segmentOverflow(org.apache.jackrabbit.oak.plugins.segment.file.FileStoreTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\nindex 84ac11a..62811a0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n@@ -46,6 +46,7 @@\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -191,6 +192,8 @@ public synchronized void flush() {\n                     refcount * 16 + rootcount * 3 + blobrefcount * 2 + length,\n                     16);\n \n+            checkState(length <= buffer.length);\n+\n             int pos = refcount * 16;\n             if (pos + length <= buffer.length) {\n                 // the whole segment fits to the space *after* the referenced\n@@ -291,14 +294,23 @@ private RecordId prepare(\n             refcount -= idcount;\n \n             Set<SegmentId> segmentIds = newIdentityHashSet();\n+            \n+            // The set of old record ids in this segment\n+            // that were previously root record ids, but will no longer be,\n+            // because the record to be written references them.\n+            // This needs to be a set, because the list of ids can\n+            // potentially reference the same record multiple times\n+            Set<RecordId> notRoots = new HashSet<RecordId>();\n             for (RecordId recordId : ids) {\n                 SegmentId segmentId = recordId.getSegmentId();\n                 if (segmentId != segment.getSegmentId()) {\n                     segmentIds.add(segmentId);\n                 } else if (roots.containsKey(recordId)) {\n-                    rootcount--;\n+                    notRoots.add(recordId);\n                 }\n             }\n+            rootcount -= notRoots.size();\n+\n             if (!segmentIds.isEmpty()) {\n                 for (int refid = 1; refid < refcount; refid++) {\n                     segmentIds.remove(segment.getRefId(refid));\n", "nb_test": 1900, "linesAdd": 8, "jira_id": "2049", "singleLine": false, "nb_skipped": 9, "commit": "4af0d4ee", "nb_failure": 0, "linesRem": 1}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["copy[0](org.apache.jackrabbit.mk.index.IndexTest): token: \u0001", "copy[3](org.apache.jackrabbit.mk.index.IndexTest): token: \u0001"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Indexer.java b/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Indexer.java\nindex 6b2a935..be48a28 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Indexer.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Indexer.java\n@@ -299,6 +299,7 @@ public String updateEnd(String toRevision) {\n     /**\n      * Update the index with the given changes.\n      *\n+     * @param rootPath the root path\n      * @param t the changes\n      * @param lastRevision\n      */\n@@ -309,6 +310,7 @@ public void updateIndex(String rootPath, JsopReader t, String lastRevision) {\n                 break;\n             }\n             String path = PathUtils.concat(rootPath, t.readString());\n+            String target;\n             switch (r) {\n             case '+': {\n                 t.read(':');\n@@ -327,8 +329,16 @@ public void updateIndex(String rootPath, JsopReader t, String lastRevision) {\n                 }\n                 break;\n             }\n+            case '*':\n+                // TODO support and test copy operation (\"*\"),\n+                // specially in combination with other operations\n+                // possibly split up the commit in this case\n+                t.read(':');\n+                target = t.readString();\n+                moveOrCopyNode(path, false, target, lastRevision);\n+                break;\n             case '-':\n-                moveNode(path, null, lastRevision);\n+                moveOrCopyNode(path, true, null, lastRevision);\n                 break;\n             case '^': {\n                 removeProperty(path, lastRevision);\n@@ -342,9 +352,12 @@ public void updateIndex(String rootPath, JsopReader t, String lastRevision) {\n                 break;\n             }\n             case '>':\n+                // TODO does move work correctly\n+                // in combination with other operations?\n+                // possibly split up the commit in this case\n                 t.read(':');\n                 String name = PathUtils.getName(path);\n-                String target, position;\n+                String position;\n                 if (t.matches('{')) {\n                     position = t.readString();\n                     t.read(':');\n@@ -364,7 +377,7 @@ public void updateIndex(String rootPath, JsopReader t, String lastRevision) {\n                 } else {\n                     throw ExceptionFactory.get(\"position: \" + position);\n                 }\n-                moveNode(path, target, lastRevision);\n+                moveOrCopyNode(path, true, target, lastRevision);\n                 break;\n             default:\n                 throw new AssertionError(\"token: \" + (char) t.getTokenType());\n@@ -430,7 +443,7 @@ private void addProperty(String path, String value) {\n         }\n     }\n \n-    private void moveNode(String sourcePath, String targetPath, String lastRevision) {\n+    private void moveOrCopyNode(String sourcePath, boolean remove, String targetPath, String lastRevision) {\n         if (isInIndex(sourcePath)) {\n             // don't index the index\n             return;\n@@ -444,7 +457,9 @@ private void moveNode(String sourcePath, String targetPath, String lastRevision)\n         NodeMap map = new NodeMap();\n         t.read('{');\n         NodeImpl n = NodeImpl.parse(map, t, 0, sourcePath);\n+        if (remove) {\n             addOrRemoveRecursive(n, true, false);\n+        }\n         if (targetPath != null) {\n             t = new JsopTokenizer(node);\n             map = new NodeMap();\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/simple/SimpleKernelImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/mk/simple/SimpleKernelImpl.java\nindex 87c2a96..185731e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/simple/SimpleKernelImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/mk/simple/SimpleKernelImpl.java\n@@ -278,18 +278,20 @@ private String doCommit(String rootPath, JsopReader t, String revisionId, String\n                 break;\n             }\n             case '*': {\n-                // TODO is it really required?\n                 // TODO possibly support target position notation\n-                // TODO support copy in wrappers, index,...\n                 t.read(':');\n                 String target = t.readString();\n-                diff.tag('*').key(path).value(target);\n                 if (!PathUtils.isAbsolute(target)) {\n                     target = PathUtils.concat(rootPath, target);\n                 }\n-                NodeImpl node = data.getNode(from);\n+                diff.tag('*').key(path).value(target);\n                 String to = PathUtils.relativize(\"/\", target);\n-                data = data.cloneAndAddChildNode(to, false, null, node, rev);\n+                NodeImpl node = data.getNode(from);\n+                JsopStream json = new JsopStream();\n+                node.append(json, Integer.MAX_VALUE, 0, Integer.MAX_VALUE, false);\n+                json.read('{');\n+                NodeImpl n2 = NodeImpl.parse(nodeMap, json, rev);\n+                data = data.cloneAndAddChildNode(to, false, null, n2, rev);\n                 break;\n             }\n             default:\n@@ -555,6 +557,7 @@ public synchronized void dispose() {\n         }\n     }\n \n+    @Override\n     public String toString() {\n         return \"simple:\" + name;\n     }\n", "nb_test": 379, "linesAdd": 20, "jira_id": "47", "singleLine": false, "nb_skipped": 0, "commit": "b62f1c26", "nb_failure": 2, "linesRem": 7}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testGetAllChunks(org.apache.jackrabbit.oak.plugins.blob.datastore.DataStoreBlobStoreTest): expected:<[d-20, d-10]> but was:<[d-20, d-30, d-10]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\nindex b055278..3ad49ad 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\n@@ -32,6 +32,7 @@\n import javax.jcr.RepositoryException;\n \n import com.google.common.base.Function;\n+import com.google.common.base.Predicate;\n import com.google.common.collect.Iterators;\n import com.google.common.io.ByteStreams;\n import com.google.common.io.Closeables;\n@@ -47,6 +48,8 @@\n import org.slf4j.LoggerFactory;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Iterators.filter;\n+import static com.google.common.collect.Iterators.transform;\n \n /**\n  * BlobStore wrapper for DataStore. Wraps Jackrabbit 2 DataStore and expose them as BlobStores\n@@ -258,12 +261,23 @@ public long getBlockSizeMin() {\n     }\n \n     @Override\n-    public Iterator<String> getAllChunkIds(long maxLastModifiedTime) throws Exception {\n-        //TODO Ignores the maxLastModifiedTime currently.\n-        return Iterators.transform(delegate.getAllIdentifiers(), new Function<DataIdentifier, String>() {\n-            @Nullable\n+    public Iterator<String> getAllChunkIds(final long maxLastModifiedTime) throws Exception {\n+        return transform(filter(delegate.getAllIdentifiers(), new Predicate<DataIdentifier>() {\n             @Override\n-            public String apply(@Nullable DataIdentifier input) {\n+            public boolean apply(DataIdentifier input) {\n+                try {\n+                    DataRecord dr = delegate.getRecord(input);\n+                    if(dr != null && dr.getLastModified() < maxLastModifiedTime){\n+                        return true;\n+                    }\n+                } catch (DataStoreException e) {\n+                    log.warn(\"Error occurred while fetching DataRecord for identifier {}\",input, e);\n+                }\n+                return false;\n+            }\n+        }),new Function<DataIdentifier, String>() {\n+            @Override\n+            public String apply(DataIdentifier input) {\n                 return input.toString();\n             }\n         });\n", "nb_test": 1752, "linesAdd": 19, "jira_id": "1655", "singleLine": false, "nb_skipped": 8, "commit": "01a8b283", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMultiValuedPropUpdate(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest): Result set size is different expected:<0> but was:<1>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\nindex 2023f2d..0f96b8a 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n@@ -100,6 +100,8 @@\n \n     private boolean propertiesChanged = false;\n \n+    private List<PropertyState> propertiesModified = Lists.newArrayList();\n+\n     private final NodeState root;\n \n     /**\n@@ -222,12 +224,14 @@ public void propertyAdded(PropertyState after) {\n     @Override\n     public void propertyChanged(PropertyState before, PropertyState after) {\n         markPropertyChanged(before.getName());\n+        propertiesModified.add(before);\n         checkAggregates(before.getName());\n     }\n \n     @Override\n     public void propertyDeleted(PropertyState before) {\n         markPropertyChanged(before.getName());\n+        propertiesModified.add(before);\n         checkAggregates(before.getName());\n     }\n \n@@ -333,6 +337,11 @@ private Document makeDocument(String path, NodeState state, boolean isUpdate) {\n         dirty |= indexNullCheckEnabledProps(path, fields, state);\n         dirty |= indexNotNullCheckEnabledProps(path, fields, state);\n         \n+        // Check if a node having a single property was modified/deleted\n+        if (!dirty) {\n+            dirty = indexIfSinglePropertyRemoved();\n+        }\n+\n         if (isUpdate && !dirty) {\n             // updated the state but had no relevant changes\n             return null;\n@@ -579,6 +588,21 @@ private boolean indexNullCheckEnabledProps(String path, List<Field> fields, Node\n         return fieldAdded;\n     }\n     \n+    private boolean indexIfSinglePropertyRemoved() {\n+        boolean dirty = false;\n+        for (PropertyState ps : propertiesModified) {\n+            PropertyDefinition pd = indexingRule.getConfig(ps.getName());\n+            if (pd != null \n+                    && pd.index \n+                    && (pd.includePropertyType(ps.getType().tag()) \n+                            || indexingRule.includePropertyType(ps.getType().tag()))) {\n+                dirty = true;\n+                break;\n+            }\n+        }\n+        return dirty;\n+    }\n+    \n     /**\n      * Determine if the property as defined by PropertyDefinition exists or not.\n      *\n", "nb_test": 463, "linesAdd": 23, "jira_id": "2999", "singleLine": false, "nb_skipped": 3, "commit": "3bf07779", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTrailingWhitespace(org.apache.jackrabbit.oak.plugins.name.NameValidatorTest): Expected exception: org.apache.jackrabbit.oak.api.CommitFailedException", "testLeadingWhitespace(org.apache.jackrabbit.oak.plugins.name.NameValidatorTest): Expected exception: org.apache.jackrabbit.oak.api.CommitFailedException", "testOnlyWhitespace(org.apache.jackrabbit.oak.plugins.name.NameValidatorTest): Expected exception: org.apache.jackrabbit.oak.api.CommitFailedException"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\nindex 0ad6022..3b4219c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n@@ -244,8 +244,12 @@ public static boolean isValidLocalName(String local) {\n \n         for (int i = 0; i < local.length(); i++) {\n             char ch = local.charAt(i);\n-            if (\"/:[]|*\".indexOf(ch) != -1) { // TODO: XMLChar check\n-                return false;\n+            if (i == 0 && Character.isWhitespace(ch)) {\n+                return false; // leading whitespace\n+            } else if (i == local.length() - 1 && Character.isWhitespace(ch)) {\n+                return false; // trailing whitespace\n+            } else if (\"/:[]|*\".indexOf(ch) != -1) { // TODO: XMLChar check\n+                return false; // invalid name character\n             }\n         }\n \n", "nb_test": 1752, "linesAdd": 6, "jira_id": "1624", "singleLine": false, "nb_skipped": 8, "commit": "6d8146f8", "nb_failure": 3, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 4, "classification": {"singleLine": false}, "failing_tests": ["onlyReferenced(org.apache.jackrabbit.oak.upgrade.CopyVersionHistoryTest): Failed to copy content", "onlyReferenced(org.apache.jackrabbit.oak.upgrade.CopyVersionHistoryTest)", "onlyReferencedAfterDate(org.apache.jackrabbit.oak.upgrade.CopyVersionHistoryTest): Failed to copy content", "onlyReferencedAfterDate(org.apache.jackrabbit.oak.upgrade.CopyVersionHistoryTest)"], "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex f4684cc..93b5133 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -462,7 +462,7 @@ protected Root getWriteRoot() {\n                 createIndexEditorProvider()\n             )));\n \n-            target.merge(builder, new LoggingCompositeHook(hooks, source, earlyShutdown), CommitInfo.EMPTY);\n+            target.merge(builder, new LoggingCompositeHook(hooks, source, overrideEarlyShutdown()), CommitInfo.EMPTY);\n             logger.info(\"Processing commit hooks completed in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\n             logger.debug(\"Repository upgrade completed.\");\n         } catch (Exception e) {\n@@ -470,6 +470,24 @@ protected Root getWriteRoot() {\n         }\n     }\n \n+    private boolean overrideEarlyShutdown() {\n+        if (earlyShutdown == false) {\n+            return false;\n+        }\n+\n+        final VersionCopyConfiguration c = this.versionCopyConfiguration;\n+        if (c.isCopyVersions() && c.skipOrphanedVersionsCopy()) {\n+            logger.info(\"Overriding early shutdown to false because of the copy versions settings\");\n+            return false;\n+        }\n+        if (c.isCopyVersions() && !c.skipOrphanedVersionsCopy()\n+                && c.getOrphanedMinDate().after(c.getVersionsMinDate())) {\n+            logger.info(\"Overriding early shutdown to false because of the copy versions settings\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private static EditorProvider createTypeEditorProvider() {\n         return new EditorProvider() {\n             @Override\n", "nb_test": 99, "linesAdd": 19, "jira_id": "3249", "singleLine": false, "nb_skipped": 0, "commit": "64712735", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTokenizer(org.apache.jackrabbit.oak.commons.json.JsopTest): expected:<\"[\u0123]\"> but was:<\"[\\u0123]\">", "testBuilder(org.apache.jackrabbit.oak.commons.json.JsopTest): expected:<...\"arr\":[[1,\"\\u001f ~ [\u007f \u0080]\",\"42\"],[]]},\"some\":...> but was:<...\"arr\":[[1,\"\\u001f ~ [\\u007f \\u0080]\",\"42\"],[]]},\"some\":...>", "testBuilder(org.apache.jackrabbit.oak.commons.json.JsopStreamTest): expected:<...\"arr\":[[1,\"\\u001f ~ [\u007f \u0080]\",\"42\"],[]]},\"some\":...> but was:<...\"arr\":[[1,\"\\u001f ~ [\\u007f \\u0080]\",\"42\"],[]]},\"some\":...>"], "patch": "diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\nindex b42beff..a9a8b9a 100644\n--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n@@ -254,7 +254,7 @@ public static String encode(String s) {\n         }\n         for (int i = 0; i < length; i++) {\n             char c = s.charAt(i);\n-            if (c == '\\\"' || c == '\\\\' || c < ' ' || c >= 127) {\n+            if (c == '\\\"' || c == '\\\\' || c < ' ') {\n                 StringBuilder buff = new StringBuilder(length + 2 + length / 8);\n                 buff.append('\\\"');\n                 escape(s, length, buff);\n@@ -269,13 +269,20 @@ public static String encode(String s) {\n      * Escape a string into the target buffer.\n      *\n      * @param s      the string to escape\n+     * @param buff   the target buffer\n+     */\n+    public static void escape(String s, StringBuilder buff) {\n+        escape(s, s.length(), buff);\n+    }\n+\n+    /**\n+     * Escape a string into the target buffer.\n+     *\n+     * @param s      the string to escape\n      * @param length the number of characters.\n      * @param buff   the target buffer\n      */\n-    public static void escape(String s, int length, StringBuilder buff) {\n-        // TODO only backslashes, double quotes, and characters < 32 need to be\n-        // escaped - but currently all special characters are escaped, which\n-        // needs more time, memory, and storage space\n+    private static void escape(String s, int length, StringBuilder buff) {\n         for (int i = 0; i < length; i++) {\n             char c = s.charAt(i);\n             switch (c) {\n@@ -309,21 +316,10 @@ public static void escape(String s, int length, StringBuilder buff) {\n                 break;\n             default:\n                 if (c < ' ') {\n-                    // guaranteed to be 1 or 2 hex digits only\n                     buff.append(\"\\\\u00\");\n-                    String hex = Integer.toHexString(c);\n-                    if (hex.length() == 1) {\n-                        buff.append('0');\n-                    }\n-                    buff.append(hex);\n-                } else if (c >= 127) {\n-                    // ascii only mode\n-                    buff.append(\"\\\\u\");\n-                    String hex = Integer.toHexString(c);\n-                    for (int len = hex.length(); len < 4; len++) {\n-                        buff.append('0');\n-                    }\n-                    buff.append(hex);\n+                    // guaranteed to be 1 or 2 hex digits only\n+                    buff.append(Character.forDigit(c >>> 4, 16));\n+                    buff.append(Character.forDigit(c & 15, 16));\n                 } else {\n                     buff.append(c);\n                 }\n", "nb_test": 52, "linesAdd": 8, "jira_id": "2389", "singleLine": false, "nb_skipped": 0, "commit": "7c320b1e", "nb_failure": 3, "linesRem": 14}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["dispatch(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\nindex 4b83da9..9cf769b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\n@@ -168,18 +168,7 @@ public boolean hasChildNode(String name) {\n     @Nonnull\n     @Override\n     public NodeState getChildNode(@Nonnull String name) {\n-        if (!hasChildren) {\n-            checkValidName(name);\n-            return EmptyNodeState.MISSING_NODE;\n-        }\n-        String p = PathUtils.concat(getPath(), name);\n-        DocumentNodeState child = store.getNode(p, lastRevision);\n-        if (child == null) {\n-            checkValidName(name);\n-            return EmptyNodeState.MISSING_NODE;\n-        } else {\n-            return child;\n-        }\n+        return getChildNode(name, lastRevision);\n     }\n \n     @Override\n@@ -282,6 +271,23 @@ public boolean compareAgainstBaseState(NodeState base, NodeStateDiff diff) {\n         return super.compareAgainstBaseState(base, diff);\n     }\n \n+    @Nonnull\n+    NodeState getChildNode(@Nonnull String name,\n+                           @Nonnull Revision revision) {\n+        if (!hasChildren) {\n+            checkValidName(name);\n+            return EmptyNodeState.MISSING_NODE;\n+        }\n+        String p = PathUtils.concat(getPath(), name);\n+        DocumentNodeState child = store.getNode(p, checkNotNull(revision));\n+        if (child == null) {\n+            checkValidName(name);\n+            return EmptyNodeState.MISSING_NODE;\n+        } else {\n+            return child;\n+        }\n+    }\n+\n     void setProperty(String propertyName, String value) {\n         if (value == null) {\n             properties.remove(propertyName);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 1087f53..1ed7072 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1905,14 +1905,14 @@ private boolean dispatch(@Nonnull String jsonDiff,\n                     while (t.read() != '}') {\n                         // skip properties\n                     }\n-                    NodeState child = getNode(concat(node.getPath(), name), nodeRev);\n-                    continueComparison = diff.childNodeAdded(name, child);\n+                    continueComparison = diff.childNodeAdded(name,\n+                            node.getChildNode(name, nodeRev));\n                     break;\n                 }\n                 case '-': {\n                     String name = unshareString(t.readString());\n-                    NodeState child = getNode(concat(base.getPath(), name), baseRev);\n-                    continueComparison = diff.childNodeDeleted(name, child);\n+                    continueComparison = diff.childNodeDeleted(name,\n+                            base.getChildNode(name, baseRev));\n                     break;\n                 }\n                 case '^': {\n@@ -1920,10 +1920,9 @@ private boolean dispatch(@Nonnull String jsonDiff,\n                     t.read(':');\n                     if (t.matches('{')) {\n                         t.read('}');\n-                        NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);\n-                        NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);\n-                        continueComparison = diff.childNodeChanged(\n-                                name, baseChild, nodeChild);\n+                        continueComparison = diff.childNodeChanged(name,\n+                                base.getChildNode(name, baseRev),\n+                                node.getChildNode(name, nodeRev));\n                     } else if (t.matches('[')) {\n                         // ignore multi valued property\n                         while (t.read() != ']') {\n", "nb_test": 2013, "linesAdd": 25, "jira_id": "2695", "singleLine": false, "nb_skipped": 9, "commit": "0598498e", "nb_failure": 1, "linesRem": 20}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["branchBaseOnCheckpoint(org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdateTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\nindex b509e1e..ea8d927 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n@@ -148,7 +148,7 @@ public synchronized void run() {\n             return;\n         }\n \n-        NodeBuilder builder = store.getRoot().builder();\n+        NodeBuilder builder = after.builder();\n         NodeBuilder async = builder.child(ASYNC);\n \n         NodeState before = null;\n", "nb_test": 1839, "linesAdd": 1, "jira_id": "1749", "singleLine": false, "nb_skipped": 8, "commit": "591e4d4a", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["hasNodeDotDot(org.apache.jackrabbit.oak.jcr.RepositoryTest)", "testAddNodeDot(org.apache.jackrabbit.oak.jcr.RepositoryTest): Expected exception: javax.jcr.ItemExistsException", "getNodeDotDot(org.apache.jackrabbit.oak.jcr.RepositoryTest): ..", "getNodeAbsolutePath(org.apache.jackrabbit.oak.jcr.RepositoryTest): Unexpected exception, expected<javax.jcr.RepositoryException> but was<java.lang.IllegalArgumentException>"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\nindex 644096b..6fd4a9c 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\n@@ -33,6 +33,7 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Tree;\n import org.apache.jackrabbit.oak.api.TreeLocation;\n+import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;\n \n /**\n@@ -93,7 +94,7 @@ public long getPropertyCount() throws InvalidItemStateException {\n      * no such property exists\n      */\n     @CheckForNull\n-    public PropertyDelegate getProperty(String relPath) throws InvalidItemStateException {\n+    public PropertyDelegate getProperty(String relPath) throws RepositoryException {\n         TreeLocation propertyLocation = getChildLocation(relPath);\n         PropertyState propertyState = propertyLocation.getProperty();\n         return propertyState == null\n@@ -126,7 +127,7 @@ public long getChildCount() throws InvalidItemStateException {\n      * no such node exists\n      */\n     @CheckForNull\n-    public NodeDelegate getChild(String relPath) throws InvalidItemStateException {\n+    public NodeDelegate getChild(String relPath) throws RepositoryException {\n         return create(sessionDelegate, getChildLocation(relPath));\n     }\n \n@@ -241,8 +242,20 @@ Tree getTree() throws InvalidItemStateException {\n \n     // -----------------------------------------------------------< private >---\n \n-    private TreeLocation getChildLocation(String relPath) throws InvalidItemStateException {\n-        return getLocation().getChild(relPath);\n+    private TreeLocation getChildLocation(String relPath) throws RepositoryException {\n+        if (PathUtils.isAbsolute(relPath)) {\n+            throw new RepositoryException(\"Not a relative path: \" + relPath);\n+        }\n+\n+        TreeLocation loc = getLocation();\n+        for (String element : PathUtils.elements(relPath)) {\n+            if (PathUtils.denotesParent(element)) {\n+                loc = loc.getParent();\n+            } else if (!PathUtils.denotesCurrent(element)) {\n+                loc = loc.getChild(element);\n+            }  // else . -> skip to next element\n+        }\n+        return loc;\n     }\n \n     private Iterator<NodeDelegate> nodeDelegateIterator(\n", "nb_test": 347, "linesAdd": 17, "jira_id": "369", "singleLine": false, "nb_skipped": 4, "commit": "4e245a76", "nb_failure": 2, "linesRem": 4}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["clusterCompare2(org.apache.jackrabbit.oak.plugins.document.RevisionTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\nindex db6a698..79043e9 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n@@ -521,9 +521,14 @@ public int compare(Revision o1, Revision o2) {\n             if (range1 == FUTURE && range2 == FUTURE) {\n                 return o1.compareRevisionTimeThenClusterId(o2);\n             }\n-            if (range1 == null || range2 == null) {\n+            if (range1 == null && range2 == null) {\n                 return o1.compareRevisionTimeThenClusterId(o2);\n             }\n+            if (range1 == null) {\n+                return -1;\n+            } else if (range2 == null) {\n+                return 1;\n+            }\n             int comp = range1.compareRevisionTimeThenClusterId(range2);\n             if (comp != 0) {\n                 return comp;\n", "nb_test": 1845, "linesAdd": 6, "jira_id": "1727", "singleLine": false, "nb_skipped": 9, "commit": "26041fe7", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["illegalAddNodeWithProps(org.apache.jackrabbit.oak.jcr.nodetype.NodeTypeTest): Unexpected exception, expected<javax.jcr.nodetype.ConstraintViolationException> but was<javax.jcr.RepositoryException>"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\nindex a584c10..efde490 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\n@@ -169,7 +169,14 @@ void checkStatus() throws RepositoryException {\n     }\n \n     void checkProtected() throws RepositoryException {\n-        ItemDefinition definition = (isNode()) ? ((Node) this).getDefinition() : ((Property) this).getDefinition();\n+        ItemDefinition definition;\n+        try {\n+            definition = (isNode()) ? ((Node) this).getDefinition() : ((Property) this).getDefinition();\n+        }\n+        catch (RepositoryException ignore) {\n+            // No definition -> not protected but a different error which should be handled else where\n+            return;\n+        }\n         checkProtected(definition);\n     }\n \n", "nb_test": 424, "linesAdd": 7, "jira_id": "479", "singleLine": false, "nb_skipped": 4, "commit": "3270e761", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["indexTimeFieldBoostAndRelativeProperty(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): expected:<[/test/b, /test/c, /test/a]> but was:<[/test/a]>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\nindex 447e41f..44408aa 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n@@ -291,7 +291,7 @@ private Document makeDocument(String path, NodeState state, boolean isUpdate) th\n                 dirty |= addTypedOrderedFields(fields, property, pname, pd);\n             }\n \n-            dirty |= indexProperty(path, fields, state, property, pname, false, pd);\n+            dirty |= indexProperty(path, fields, state, property, pname, pd);\n         }\n \n         dirty |= indexAggregates(path, fields, state);\n@@ -335,7 +335,6 @@ private boolean indexProperty(String path,\n                                   NodeState state,\n                                   PropertyState property,\n                                   String pname,\n-                                  boolean aggregateMode,\n                                   PropertyDefinition pd) throws CommitFailedException {\n         boolean includeTypeForFullText = indexingRule.includePropertyType(property.getType().tag());\n         if (Type.BINARY.tag() == property.getType().tag()\n@@ -358,7 +357,7 @@ private boolean indexProperty(String path,\n                         fields.add(newPropertyField(analyzedPropName, value, !pd.skipTokenization(pname), pd.stored));\n                     }\n \n-                    if (pd.nodeScopeIndex && !aggregateMode) {\n+                    if (pd.nodeScopeIndex) {\n                         Field field = newFulltextField(value);\n                         field.setBoost(pd.boost);\n                         fields.add(field);\n@@ -533,7 +532,7 @@ public void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailed\n                             result.propertyPath, result.pd);\n                 }\n                 dirty |= indexProperty(path, fields, state, result.propertyState,\n-                        result.propertyPath, true, result.pd);\n+                        result.propertyPath, result.pd);\n \n                 if (dirty) {\n                     dirtyFlag.set(true);\n", "nb_test": 369, "linesAdd": 3, "jira_id": "2330", "singleLine": false, "nb_skipped": 1, "commit": "408a566e", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFailover(org.apache.jackrabbit.oak.plugins.segment.standby.FailoverTest): expected:<{ root = { ... } }> but was:<{ root : { } }>"], "patch": "diff --git a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyClient.java b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyClient.java\nindex bdcf513..79b348f 100644\n--- a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyClient.java\n+++ b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyClient.java\n@@ -81,7 +81,7 @@\n     private final AtomicBoolean running = new AtomicBoolean(true);\n \n     public StandbyClient(String host, int port, SegmentStore store) throws SSLException {\n-        this(host, port, store, false, 5000);\n+        this(host, port, store, false, 10000);\n     }\n \n     public StandbyClient(String host, int port, SegmentStore store, boolean secure, int readTimeoutMs) throws SSLException {\n", "nb_test": 7, "linesAdd": 1, "jira_id": "2355", "singleLine": false, "nb_skipped": 0, "commit": "74f22886", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testGetItemReturnsNodeBeforeProperty[0](org.apache.jackrabbit.oak.jcr.RepositoryTest): should retrieve Node before property"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/SessionDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/SessionDelegate.java\nindex 5fd1988..2cab01a 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/SessionDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/SessionDelegate.java\n@@ -426,12 +426,12 @@ public ItemDelegate getItem(String path) {\n             return getRootNode();\n         } else {\n             Tree parent = root.getTree(PathUtils.getParentPath(path));\n-            if (parent.hasProperty(name)) {\n-                return new PropertyDelegate(this, parent, name);\n-            }\n+\n             Tree child = parent.getChild(name);\n             if (child.exists()) {\n                 return new NodeDelegate(this, child);\n+            } else if (parent.hasProperty(name)) {\n+                return new PropertyDelegate(this, parent, name);\n             } else {\n                 return null;\n             }\n", "nb_test": 1314, "linesAdd": 3, "jira_id": "2238", "singleLine": false, "nb_skipped": 1, "commit": "a28098fd", "nb_failure": 1, "linesRem": 3}, {"files": 6, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testConcurrentWriting(org.apache.jackrabbit.mk.ConcurrentWriteTest): java.lang.IllegalArgumentException: -\"/org.apache.jackrabbit.mk.ConcurrentWriteTest\""], "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\nindex 2445959..2cbb066 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\n@@ -18,9 +18,7 @@\n \n import java.io.InputStream;\n import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.HashMap;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n@@ -31,6 +29,7 @@\n import org.apache.jackrabbit.mk.model.ChildNodeEntry;\n import org.apache.jackrabbit.mk.model.Commit;\n import org.apache.jackrabbit.mk.model.CommitBuilder;\n+import org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree;\n import org.apache.jackrabbit.mk.model.Id;\n import org.apache.jackrabbit.mk.model.NodeState;\n import org.apache.jackrabbit.mk.model.PropertyState;\n@@ -40,7 +39,6 @@\n import org.apache.jackrabbit.mk.store.RevisionProvider;\n import org.apache.jackrabbit.mk.util.CommitGate;\n import org.apache.jackrabbit.mk.util.PathUtils;\n-import org.apache.jackrabbit.mk.util.SimpleLRUCache;\n \n /**\n  *\n@@ -50,11 +48,6 @@\n     protected Repository rep;\n     private final CommitGate gate = new CommitGate();\n \n-    /**\n-     * Key: revision id, Value: diff string\n-     */\n-    private final Map<Id, String> diffCache = Collections.synchronizedMap(SimpleLRUCache.<Id, String>newInstance(100));\n-\n     public MicroKernelImpl(String homeDir) throws MicroKernelException {\n         init(homeDir);\n     }\n@@ -97,7 +90,6 @@ public void dispose() {\n             }\n             rep = null;\n         }\n-        diffCache.clear();\n     }\n \n     public String getHeadRevision() throws MicroKernelException {\n@@ -211,13 +203,8 @@ public String getJournal(String fromRevision, String toRevision, String filter)\n             commitBuff.object().\n                     key(\"id\").value(commit.getId().toString()).\n                     key(\"ts\").value(commit.getCommitTS()).\n-                    key(\"msg\").value(commit.getMsg());\n-            String diff = diffCache.get(commit.getId());\n-            if (diff == null) {\n-                diff = diff(commit.getParentId(), commit.getId(), filter);\n-                diffCache.put(commit.getId(), diff);\n-            }\n-            commitBuff.key(\"changes\").value(diff).endObject();\n+                    key(\"msg\").value(commit.getMsg()).\n+                    key(\"changes\").value(commit.getChanges()).endObject();\n         }\n         return commitBuff.endArray().toString();\n     }\n@@ -478,12 +465,7 @@ public String commit(String path, String jsonDiff, String revision, String messa\n                             }\n                             String parentPath = PathUtils.getParentPath(nodePath);\n                             String nodeName = PathUtils.getName(nodePath);\n-                            // build the list of added nodes recursively\n-                            LinkedList<AddNodeOperation> list = new LinkedList<AddNodeOperation>();\n-                            addNode(list, parentPath, nodeName, t);\n-                            for (AddNodeOperation op : list) {\n-                                cb.addNode(op.path, op.name, op.props);\n-                            }\n+                            cb.addNode(parentPath, nodeName, parseNode(t));\n                         } else {\n                             String value;\n                             if (t.matches(JsopTokenizer.NULL)) {\n@@ -637,30 +619,20 @@ void toJson(JsopBuilder builder, NodeState node, int depth, int offset, int coun\n         }\n     }\n     \n-    static void addNode(LinkedList<AddNodeOperation> list, String path, String name, JsopTokenizer t) throws Exception {\n-        AddNodeOperation op = new AddNodeOperation();\n-        op.path = path;\n-        op.name = name;\n-        list.add(op);\n+    NodeTree parseNode(JsopTokenizer t) throws Exception {\n+        NodeTree node = new NodeTree();\n         if (!t.matches('}')) {\n             do {\n                 String key = t.readString();\n                 t.read(':');\n                 if (t.matches('{')) {\n-                    addNode(list, PathUtils.concat(path, name), key, t);\n+                    node.nodes.put(key, parseNode(t));\n                 } else {\n-                    op.props.put(key, t.readRawValue().trim());\n+                    node.props.put(key, t.readRawValue().trim());\n                 }\n             } while (t.matches(','));\n             t.read('}');\n         }\n+        return node;\n     }\n-\n-    //--------------------------------------------------------< inner classes >\n-    static class AddNodeOperation {\n-        String path;\n-        String name;\n-        Map<String, String> props = new HashMap<String, String>();\n-    }\n-\n }\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/AbstractCommit.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/AbstractCommit.java\nindex 97f2dea..4f766ee 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/AbstractCommit.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/AbstractCommit.java\n@@ -32,6 +32,9 @@\n     // commit message\n     protected String msg;\n \n+    // changes\n+    protected String changes;\n+\n     // id of parent commit\n     protected Id parentId;\n \n@@ -42,6 +45,7 @@ protected AbstractCommit(Commit other) {\n         this.parentId = other.getParentId();\n         this.rootNodeId = other.getRootNodeId();\n         this.msg = other.getMsg();\n+        this.changes = other.getChanges();\n         this.commitTS = other.getCommitTS();\n     }\n \n@@ -61,10 +65,15 @@ public String getMsg() {\n         return msg;\n     }\n \n+    public String getChanges() {\n+        return changes;\n+    }\n+\n     public void serialize(Binding binding) throws Exception {\n         binding.write(\"rootNodeId\", rootNodeId.getBytes());\n         binding.write(\"commitTS\", commitTS);\n         binding.write(\"msg\", msg == null ? \"\" : msg);\n+        binding.write(\"changes\", changes == null ? \"\" : changes);\n         binding.write(\"parentId\", parentId == null ? \"\" : parentId.toString());\n     }\n }\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Commit.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Commit.java\nindex 82501a0..697693c 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Commit.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Commit.java\n@@ -31,5 +31,7 @@\n \n     public String getMsg();\n \n+    public String getChanges();\n+\n     void serialize(Binding binding) throws Exception;\n }\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/CommitBuilder.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/CommitBuilder.java\nindex 645851b..b7cfc9c 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/CommitBuilder.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/CommitBuilder.java\n@@ -50,130 +50,39 @@ public CommitBuilder(Id baseRevId, String msg, RevisionStore store) throws Excep\n         this.store = store;\n     }\n \n-    public void addNode(String parentNodePath, String nodeName) throws Exception {\n-        addNode(parentNodePath, nodeName, Collections.<String, String>emptyMap());\n-    }\n-\n-    public void addNode(String parentNodePath, String nodeName, Map<String, String> properties) throws Exception {\n-        MutableNode modParent = getOrCreateStagedNode(parentNodePath);\n-        if (modParent.getChildNodeEntry(nodeName) != null) {\n-            throw new Exception(\"there's already a child node with name '\" + nodeName + \"'\");\n-        }\n-        String newPath = PathUtils.concat(parentNodePath, nodeName);\n-        MutableNode newChild = new MutableNode(store, newPath);\n-        newChild.getProperties().putAll(properties);\n-\n-        // id will be computed on commit\n-        modParent.add(new ChildNode(nodeName, null));\n-        staged.put(newPath, newChild);\n+    public void addNode(String parentNodePath, String nodeName, NodeTree node) throws Exception {\n+        Change change = new AddNode(parentNodePath, nodeName, node);\n+        change.apply();\n         // update change log\n-        changeLog.add(new AddNode(parentNodePath, nodeName, properties));\n+        changeLog.add(change);\n     }\n \n     public void removeNode(String nodePath) throws NotFoundException, Exception {\n-        String parentPath = PathUtils.getParentPath(nodePath);\n-        String nodeName = PathUtils.getName(nodePath);\n-\n-        MutableNode parent = getOrCreateStagedNode(parentPath);\n-        if (parent.remove(nodeName) == null) {\n-            throw new NotFoundException(nodePath);\n-        }\n-\n-        // update staging area\n-        removeStagedNodes(nodePath);\n-\n+        Change change = new RemoveNode(nodePath);\n+        change.apply();\n         // update change log\n-        changeLog.add(new RemoveNode(nodePath));\n+        changeLog.add(change);\n     }\n \n     public void moveNode(String srcPath, String destPath) throws NotFoundException, Exception {\n-        if (PathUtils.isAncestor(srcPath, destPath)) {\n-            throw new Exception(\"target path cannot be descendant of source path: \" + destPath);\n-        }\n-\n-        String srcParentPath = PathUtils.getParentPath(srcPath);\n-        String srcNodeName = PathUtils.getName(srcPath);\n-\n-        String destParentPath = PathUtils.getParentPath(destPath);\n-        String destNodeName = PathUtils.getName(destPath);\n-\n-        MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n-        if (srcParentPath.equals(destParentPath)) {\n-            if (srcParent.getChildNodeEntry(destNodeName) != null) {\n-                throw new Exception(\"node already exists at move destination path: \" + destPath);\n-            }\n-            if (srcParent.rename(srcNodeName, destNodeName) == null) {\n-                throw new NotFoundException(srcPath);\n-            }\n-        } else {\n-            ChildNode srcCNE = srcParent.remove(srcNodeName);\n-            if (srcCNE == null) {\n-                throw new NotFoundException(srcPath);\n-            }\n-\n-            MutableNode destParent = getOrCreateStagedNode(destParentPath);\n-            if (destParent.getChildNodeEntry(destNodeName) != null) {\n-                throw new Exception(\"node already exists at move destination path: \" + destPath);\n-            }\n-            destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n-        }\n-\n-        // update staging area\n-        moveStagedNodes(srcPath, destPath);\n-\n+        Change change = new MoveNode(srcPath, destPath);\n+        change.apply();\n         // update change log\n-        changeLog.add(new MoveNode(srcPath, destPath));\n+        changeLog.add(change);\n     }\n \n     public void copyNode(String srcPath, String destPath) throws NotFoundException, Exception {\n-        String srcParentPath = PathUtils.getParentPath(srcPath);\n-        String srcNodeName = PathUtils.getName(srcPath);\n-\n-        String destParentPath = PathUtils.getParentPath(destPath);\n-        String destNodeName = PathUtils.getName(destPath);\n-\n-        MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n-        ChildNode srcCNE = srcParent.getChildNodeEntry(srcNodeName);\n-        if (srcCNE == null) {\n-            throw new NotFoundException(srcPath);\n-        }\n-\n-        MutableNode destParent = getOrCreateStagedNode(destParentPath);\n-        destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n-\n-        if (srcCNE.getId() == null) {\n-            // a 'new' node is being copied\n-\n-            // update staging area\n-            copyStagedNodes(srcPath, destPath);\n-        }\n-\n+        Change change = new CopyNode(srcPath, destPath);\n+        change.apply();\n         // update change log\n-        changeLog.add(new CopyNode(srcPath, destPath));\n+        changeLog.add(change);\n     }\n \n     public void setProperty(String nodePath, String propName, String propValue) throws Exception {\n-        MutableNode node = getOrCreateStagedNode(nodePath);\n-\n-        Map<String, String> properties = node.getProperties();\n-        if (propValue == null) {\n-            properties.remove(propName);\n-        } else {\n-            properties.put(propName, propValue);\n-        }\n-\n-        // update change log\n-        changeLog.add(new SetProperty(nodePath, propName, propValue));\n-    }\n-\n-    public void setProperties(String nodePath, Map<String, String> properties) throws Exception {\n-        MutableNode node = getOrCreateStagedNode(nodePath);\n-\n-        node.getProperties().clear();\n-        node.getProperties().putAll(properties);\n-\n+        Change change = new SetProperty(nodePath, propName, propValue);\n+        change.apply();\n         // update change log\n-        changeLog.add(new SetProperties(nodePath, properties));\n+        changeLog.add(change);\n     }\n \n     public Id /* new revId */ doCommit() throws Exception {\n@@ -190,9 +99,7 @@ public void setProperties(String nodePath, Map<String, String> properties) throw\n             // clear staging area\n             staged.clear();\n             // replay change log on new base revision\n-            // copy log in order to avoid concurrent modifications\n-            List<Change> log = new ArrayList<Change>(changeLog);\n-            for (Change change : log) {\n+            for (Change change : changeLog) {\n                 change.apply();\n             }\n         }\n@@ -222,19 +129,29 @@ public void setProperties(String nodePath, Map<String, String> properties) throw\n             newCommit.setParentId(baseRevId);\n             newCommit.setCommitTS(System.currentTimeMillis());\n             newCommit.setMsg(msg);\n+            StringBuilder diff = new StringBuilder();\n+            for (Change change : changeLog) {\n+                if (diff.length() > 0) {\n+                    diff.append('\\n');\n+                }\n+                diff.append(change.asDiff());\n+            }\n+            newCommit.setChanges(diff.toString());\n             newCommit.setRootNodeId(rootNodeId);\n             newRevId = store.putHeadCommit(newCommit);\n         } finally {\n             store.unlockHead();\n         }\n \n-        // reset instance in order to be reusable\n+        // reset instance\n         staged.clear();\n         changeLog.clear();\n \n         return newRevId;\n     }\n \n+    //--------------------------------------------------------< inner classes >\n+\n     MutableNode getOrCreateStagedNode(String nodePath) throws Exception {\n         MutableNode node = staged.get(nodePath);\n         if (node == null) {\n@@ -418,23 +335,79 @@ void mergeNode(StoredNode baseNode, StoredNode ourNode, StoredNode theirNode, St\n     }\n \n     //--------------------------------------------------------< inner classes >\n+\n+    public static class NodeTree {\n+        public Map<String, String> props = new HashMap<String, String>();\n+        public Map<String, NodeTree> nodes = new HashMap<String, NodeTree>();\n+\n+        void toJson(StringBuffer buf) {\n+            toJson(buf, this);\n+        }\n+\n+        private static void toJson(StringBuffer buf, NodeTree node) {\n+            buf.append('{');\n+            for (String name : node.props.keySet()) {\n+                if (buf.charAt(buf.length() - 1) != '{')  {\n+                    buf.append(',');\n+                }\n+                buf.append('\"').append(name).append(\"\\\":\").append(node.props.get(name));\n+            }\n+            for (String name : node.nodes.keySet()) {\n+                if (buf.charAt(buf.length() - 1) != '{')  {\n+                    buf.append(',');\n+                }\n+                buf.append('\"').append(name).append(\"\\\":\");\n+                toJson(buf, node.nodes.get(name));\n+            }\n+            buf.append('}');\n+        }\n+    }\n+\n     abstract class Change {\n         abstract void apply() throws Exception;\n+        abstract String asDiff();\n     }\n \n     class AddNode extends Change {\n         String parentNodePath;\n         String nodeName;\n-        Map<String, String> properties;\n+        NodeTree node;\n \n-        AddNode(String parentNodePath, String nodeName, Map<String, String> properties) {\n+        AddNode(String parentNodePath, String nodeName, NodeTree node) {\n             this.parentNodePath = parentNodePath;\n             this.nodeName = nodeName;\n-            this.properties = properties;\n+            this.node = node;\n         }\n \n+        @Override\n         void apply() throws Exception {\n-            addNode(parentNodePath, nodeName, properties);\n+            recursiveAddNode(parentNodePath, nodeName, node);\n+        }\n+\n+        @Override\n+        String asDiff() {\n+            StringBuffer diff = new StringBuffer(\"+\");\n+            diff.append('\"').append(PathUtils.concat(parentNodePath, nodeName)).append(\"\\\":\");\n+            node.toJson(diff);\n+            return diff.toString();\n+        }\n+\n+        private void recursiveAddNode(String parentPath, String name, NodeTree node) throws Exception {\n+            MutableNode modParent = getOrCreateStagedNode(parentPath);\n+            if (modParent.getChildNodeEntry(name) != null) {\n+                throw new Exception(\"there's already a child node with name '\" + name + \"'\");\n+            }\n+            String newPath = PathUtils.concat(parentPath, name);\n+            MutableNode newChild = new MutableNode(store, newPath);\n+            newChild.getProperties().putAll(node.props);\n+\n+            // id will be computed on commit\n+            modParent.add(new ChildNode(name, null));\n+            staged.put(newPath, newChild);\n+\n+            for (String childName : node.nodes.keySet()) {\n+                recursiveAddNode(PathUtils.concat(parentPath, name), childName, node.nodes.get(childName));\n+            }\n         }\n     }\n \n@@ -445,8 +418,25 @@ void apply() throws Exception {\n             this.nodePath = nodePath;\n         }\n \n+        @Override\n         void apply() throws Exception {\n-            removeNode(nodePath);\n+            String parentPath = PathUtils.getParentPath(nodePath);\n+            String nodeName = PathUtils.getName(nodePath);\n+\n+            MutableNode parent = getOrCreateStagedNode(parentPath);\n+            if (parent.remove(nodeName) == null) {\n+                throw new NotFoundException(nodePath);\n+            }\n+\n+            // update staging area\n+            removeStagedNodes(nodePath);\n+        }\n+\n+        @Override\n+        String asDiff() {\n+            StringBuffer diff = new StringBuffer(\"-\");\n+            diff.append('\"').append(nodePath).append('\"');\n+            return diff.toString();\n         }\n     }\n \n@@ -459,8 +449,48 @@ void apply() throws Exception {\n             this.destPath = destPath;\n         }\n \n+        @Override\n         void apply() throws Exception {\n-            moveNode(srcPath, destPath);\n+            if (PathUtils.isAncestor(srcPath, destPath)) {\n+                throw new Exception(\"target path cannot be descendant of source path: \" + destPath);\n+            }\n+\n+            String srcParentPath = PathUtils.getParentPath(srcPath);\n+            String srcNodeName = PathUtils.getName(srcPath);\n+\n+            String destParentPath = PathUtils.getParentPath(destPath);\n+            String destNodeName = PathUtils.getName(destPath);\n+\n+            MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n+            if (srcParentPath.equals(destParentPath)) {\n+                if (srcParent.getChildNodeEntry(destNodeName) != null) {\n+                    throw new Exception(\"node already exists at move destination path: \" + destPath);\n+                }\n+                if (srcParent.rename(srcNodeName, destNodeName) == null) {\n+                    throw new NotFoundException(srcPath);\n+                }\n+            } else {\n+                ChildNode srcCNE = srcParent.remove(srcNodeName);\n+                if (srcCNE == null) {\n+                    throw new NotFoundException(srcPath);\n+                }\n+\n+                MutableNode destParent = getOrCreateStagedNode(destParentPath);\n+                if (destParent.getChildNodeEntry(destNodeName) != null) {\n+                    throw new Exception(\"node already exists at move destination path: \" + destPath);\n+                }\n+                destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n+            }\n+\n+            // update staging area\n+            moveStagedNodes(srcPath, destPath);\n+        }\n+\n+        @Override\n+        String asDiff() {\n+            StringBuffer diff = new StringBuffer(\">\");\n+            diff.append('\"').append(srcPath).append(\"\\\":\\\"\").append(destPath).append('\"');\n+            return diff.toString();\n         }\n     }\n \n@@ -473,8 +503,36 @@ void apply() throws Exception {\n             this.destPath = destPath;\n         }\n \n+        @Override\n         void apply() throws Exception {\n-            copyNode(srcPath, destPath);\n+            String srcParentPath = PathUtils.getParentPath(srcPath);\n+            String srcNodeName = PathUtils.getName(srcPath);\n+\n+            String destParentPath = PathUtils.getParentPath(destPath);\n+            String destNodeName = PathUtils.getName(destPath);\n+\n+            MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n+            ChildNode srcCNE = srcParent.getChildNodeEntry(srcNodeName);\n+            if (srcCNE == null) {\n+                throw new NotFoundException(srcPath);\n+            }\n+\n+            MutableNode destParent = getOrCreateStagedNode(destParentPath);\n+            destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n+\n+            if (srcCNE.getId() == null) {\n+                // a 'new' node is being copied\n+\n+                // update staging area\n+                copyStagedNodes(srcPath, destPath);\n+            }\n+        }\n+\n+        @Override\n+        String asDiff() {\n+            StringBuffer diff = new StringBuffer(\"*\");\n+            diff.append('\"').append(srcPath).append(\"\\\":\\\"\").append(destPath).append('\"');\n+            return diff.toString();\n         }\n     }\n \n@@ -489,22 +547,23 @@ void apply() throws Exception {\n             this.propValue = propValue;\n         }\n \n+        @Override\n         void apply() throws Exception {\n-            setProperty(nodePath, propName, propValue);\n-        }\n-    }\n-\n-    class SetProperties extends Change {\n-        String nodePath;\n-        Map<String, String> properties;\n+            MutableNode node = getOrCreateStagedNode(nodePath);\n \n-        SetProperties(String nodePath, Map<String, String> properties) {\n-            this.nodePath = nodePath;\n-            this.properties = properties;\n+            Map<String, String> properties = node.getProperties();\n+            if (propValue == null) {\n+                properties.remove(propName);\n+            } else {\n+                properties.put(propName, propValue);\n+            }\n         }\n \n-        void apply() throws Exception {\n-            setProperties(nodePath, properties);\n+        @Override\n+        String asDiff() {\n+            StringBuffer diff = new StringBuffer(\"^\");\n+            diff.append('\"').append(PathUtils.concat(nodePath, propName)).append(\"\\\":\").append(propValue);\n+            return diff.toString();\n         }\n     }\n }\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/MutableCommit.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/MutableCommit.java\nindex 0992938..4a3312c 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/MutableCommit.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/MutableCommit.java\n@@ -39,6 +39,7 @@ public MutableCommit(StoredCommit other) {\n         setRootNodeId(other.getRootNodeId());\n         setCommitTS(other.getCommitTS());\n         setMsg(other.getMsg());\n+        setChanges(other.getChanges());\n         this.id = other.getId();\n     }\n \n@@ -58,6 +59,10 @@ public void setMsg(String msg) {\n         this.msg = msg;\n     }\n \n+    public void setChanges(String changes) {\n+        this.changes = changes;\n+    }\n+\n     /**\n      * Return the commit id.\n      * \ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/StoredCommit.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/StoredCommit.java\nindex 0cb15b7..95206c4 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/StoredCommit.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/StoredCommit.java\n@@ -29,17 +29,19 @@ public static StoredCommit deserialize(Id id, Binding binding) throws Exception\n         Id rootNodeId = new Id(binding.readBytesValue(\"rootNodeId\"));\n         long commitTS = binding.readLongValue(\"commitTS\");\n         String msg = binding.readStringValue(\"msg\");\n+        String changes = binding.readStringValue(\"changes\");\n         String parentId = binding.readStringValue(\"parentId\");\n         return new StoredCommit(id, \"\".equals(parentId) ? null : Id.fromString(parentId),\n-                commitTS, rootNodeId, \"\".equals(msg) ? null : msg);\n+                commitTS, rootNodeId, \"\".equals(msg) ? null : msg, changes);\n     }\n \n-    public StoredCommit(Id id, Id parentId, long commitTS, Id rootNodeId, String msg) {\n+    public StoredCommit(Id id, Id parentId, long commitTS, Id rootNodeId, String msg, String changes) {\n         this.id = id;\n         this.parentId = parentId;\n         this.commitTS = commitTS;\n         this.rootNodeId = rootNodeId;\n         this.msg = msg;\n+        this.changes = changes;\n     }\n \n     public StoredCommit(Id id, Commit commit) {\n", "nb_test": 93, "linesAdd": 210, "jira_id": "43", "singleLine": false, "nb_skipped": 1, "commit": "668f08f2", "nb_failure": 0, "linesRem": 156}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["verifyPrivileges(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Miss match in aggregate privilege jcr:write expected [jcr:modifyProperties, rep:addProperties, rep:alterProperties, rep:removeProperties, jcr:addChildNodes, jcr:removeChildNodes, jcr:removeNode] actual [jcr:addChildNodes, jcr:removeChildNodes, jcr:removeNode, jcr:modifyProperties]"], "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex 6db5152..27e82ab 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -257,6 +257,9 @@ public void copy(RepositoryInitializer initializer) throws RepositoryException {\n                 initializer.initialize(builder);\n             }\n             for (SecurityConfiguration sc : security.getConfigurations()) {\n+                sc.getRepositoryInitializer().initialize(builder);\n+            }\n+            for (SecurityConfiguration sc : security.getConfigurations()) {\n                 sc.getWorkspaceInitializer().initialize(builder, workspaceName);\n             }\n \n", "nb_test": 17, "linesAdd": 3, "jira_id": "2047", "singleLine": false, "nb_skipped": 0, "commit": "ca63fdf3", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCustomConfigPropertyLookup(org.apache.jackrabbit.oak.plugins.index.p2.Property2IndexTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java\nindex bbf71e3..7a31ae6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java\n@@ -18,6 +18,7 @@\n \n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFINITIONS_NAME;\n \n+import java.util.Iterator;\n import java.util.Set;\n \n import javax.annotation.Nullable;\n@@ -25,6 +26,7 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.Type;\n+import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.index.IndexConstants;\n import org.apache.jackrabbit.oak.plugins.index.p2.strategy.ContentMirrorStoreStrategy;\n import org.apache.jackrabbit.oak.plugins.index.p2.strategy.IndexStoreStrategy;\n@@ -72,22 +74,22 @@ public Property2IndexLookup(NodeState root) {\n      * @return true if the property is indexed\n      */\n     public boolean isIndexed(String name, String path) {\n-        if (getIndexDefinitionNode(name) != null) {\n-            return true;\n+        return isIndexed(root, name, path);\n     }\n     \n-        // TODO use PathUtils\n-        if (path.startsWith(\"/\")) {\n-            path = path.substring(1);\n+    private static boolean isIndexed(NodeState root, String name, String path) {\n+        NodeState node = root;\n+        Iterator<String> it = PathUtils.elements(path).iterator();\n+        while (true) {\n+            if (getIndexDefinitionNode(node, name) != null) {\n+                return true;\n             }\n-        int slash = path.indexOf('/');\n-        if (slash == -1) {\n-            return false;\n+            if (!it.hasNext()) {\n+                break;\n             }\n-\n-        NodeState child = root.getChildNode(path.substring(0, slash));\n-        return new Property2IndexLookup(child).isIndexed(\n-                name, path.substring(slash));\n+            node = node.getChildNode(it.next());\n+        }\n+        return false;\n     }\n     \n     /**\n@@ -112,69 +114,33 @@ public boolean isIndexed(String name, String path) {\n      * @return the set of matched paths\n      */\n     public Set<String> find(String name, PropertyValue value) {\n+        NodeState state = getIndexDefinitionNode(root, name);\n+        if (state == null || state.getChildNode(\":index\") == null) {\n+            throw new IllegalArgumentException(\"No index for \" + name);\n+        }\n         Set<String> paths = Sets.newHashSet();\n-\n-        NodeState state = getIndexDefinitionNode(name);\n-        if (state != null && state.getChildNode(\":index\") != null) {\n         state = state.getChildNode(\":index\");\n         if (value == null) {\n             paths.addAll(store.find(state, null));\n         } else {\n             paths.addAll(store.find(state, Property2Index.encode(value)));\n         }\n-        } else {\n-            // No index available, so first check this node for a match\n-            PropertyState property = root.getProperty(name);\n-            if (property != null) {\n-                if (value == null || value.isArray()) {\n-                    // let query engine handle property existence and\n-                    // multi-valued look ups;\n-                    // simply return all nodes that have this property\n-                    paths.add(\"\");\n-                } else {\n-                    // does it match any of the values of this property?\n-                    for (int i = 0; i < property.count(); i++) {\n-                        if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {\n-                            paths.add(\"\");\n-                            // no need to check for more matches in this property\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // ... and then recursively look up from the rest of the tree\n-            for (ChildNodeEntry entry : root.getChildNodeEntries()) {\n-                String base = entry.getName();\n-                Property2IndexLookup lookup =\n-                        new Property2IndexLookup(entry.getNodeState());\n-                for (String path : lookup.find(name, value)) {\n-                    if (path.isEmpty()) {\n-                        paths.add(base);\n-                    } else {\n-                        paths.add(base + \"/\" + path);\n-                    }\n-                }\n-            }\n-        }\n-\n         return paths;\n     }\n \n     public double getCost(String name, PropertyValue value) {\n-        double cost = 0.0;\n         // TODO the cost method is currently reading all the data - \n         // is not supposed to do that, it is only supposed to estimate\n-        NodeState state = getIndexDefinitionNode(name);\n-        if (state != null && state.getChildNode(\":index\") != null) {\n+        NodeState state = getIndexDefinitionNode(root, name);\n+        if (state == null || state.getChildNode(\":index\") == null) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n         state = state.getChildNode(\":index\");\n+        double cost;\n         if (value == null) {\n-                cost += store.count(state, null);\n-            } else {\n-                cost += store.count(state, Property2Index.encode(value));\n-            }\n+            cost = store.count(state, null);\n         } else {\n-            cost = Double.POSITIVE_INFINITY;\n+            cost = store.count(state, Property2Index.encode(value));\n         }\n         return cost;\n     }\n@@ -187,8 +153,8 @@ public double getCost(String name, PropertyValue value) {\n      *         index definition node was found\n      */\n     @Nullable\n-    private NodeState getIndexDefinitionNode(String name) {\n-        NodeState state = root.getChildNode(INDEX_DEFINITIONS_NAME);\n+    private static NodeState getIndexDefinitionNode(NodeState node, String name) {\n+        NodeState state = node.getChildNode(INDEX_DEFINITIONS_NAME);\n         if (state != null) {\n             for (ChildNodeEntry entry : state.getChildNodeEntries()) {\n                 PropertyState type = entry.getNodeState().getProperty(IndexConstants.TYPE_PROPERTY_NAME);\n", "nb_test": 404, "linesAdd": 27, "jira_id": "537", "singleLine": false, "nb_skipped": 1, "commit": "a8493efc", "nb_failure": 1, "linesRem": 53}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSuggestQueryWithUserAccess(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexSuggestionTest): There should be some suggestion", "testSuggestQueryFromMoreGeneralNodeType(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexSuggestionTest): There should be some suggestion", "testSuggestQueryOnNonNtBase(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexSuggestionTest): There should be some suggestion"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex 0a38732..a582292 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -1038,14 +1038,17 @@ public NodeAggregator getNodeAggregator() {\n         final String path;\n         final double score;\n         final Iterable<String> suggestWords;\n+        final boolean isVirtual;\n \n         LuceneResultRow(String path, double score) {\n+            this.isVirtual = false;\n             this.path = path;\n             this.score = score;\n             this.suggestWords = Collections.emptySet();\n         }\n \n         LuceneResultRow(Iterable<String> suggestWords) {\n+            this.isVirtual = true;\n             this.path = \"/\";\n             this.score = 1.0d;\n             this.suggestWords = suggestWords;\n@@ -1110,7 +1113,7 @@ public IndexRow next() {\n \n                 @Override\n                 public boolean isVirtualRow() {\n-                    return getPath() == null;\n+                    return currentRow.isVirtual;\n                 }\n \n                 @Override\ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex 4095277..2b7e477 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -1280,14 +1280,17 @@ private static Query newDepthQuery(String path) {\n         final String path;\n         final double score;\n         final Iterable<String> suggestWords;\n+        final boolean isVirutal;\n \n         LuceneResultRow(String path, double score) {\n+            this.isVirutal = false;\n             this.path = path;\n             this.score = score;\n             this.suggestWords = Collections.emptySet();\n         }\n \n         LuceneResultRow(Iterable<String> suggestWords) {\n+            this.isVirutal = true;\n             this.path = \"/\";\n             this.score = 1.0d;\n             this.suggestWords = suggestWords;\n@@ -1354,7 +1357,7 @@ public IndexRow next() {\n \n                 @Override\n                 public boolean isVirtualRow() {\n-                    return getPath() == null;\n+                    return currentRow.isVirutal;\n                 }\n \n                 @Override\n", "nb_test": 269, "linesAdd": 8, "jira_id": "3156", "singleLine": false, "nb_skipped": 4, "commit": "786b3d76", "nb_failure": 3, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFulltext(org.apache.jackrabbit.oak.jcr.query.QueryFulltextTest): expected:<...:base] /* aggregate [:fulltext:hallo :fulltext:hello] ft:(text:\"hallo\" OR...> but was:<...:base] /* aggregate [+(:fulltext:hallo :fulltext:hello) +text:{* TO *}] ft:(text:\"hallo\" OR...>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex 8be3395..8889094 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -475,6 +475,13 @@ private static void addNonFullTextConstraints(List<Query> qs,\n         }\n \n         for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n+\n+            if (pr.first == null && pr.last == null) {\n+                // ignore property existence checks, Lucene can't to 'property\n+                // is not null' queries (OAK-1208)\n+                continue;\n+            }\n+\n             String name = pr.propertyName;\n             if (name.contains(\"/\")) {\n                 // lucene cannot handle child-level property restrictions\n", "nb_test": 245, "linesAdd": 5, "jira_id": "1208", "singleLine": false, "nb_skipped": 1, "commit": "cb3ac20d", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCheckpoint(org.apache.jackrabbit.oak.plugins.segment.CheckpointTest): Checkpoint doesn't exist"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\nindex a2be123..d757585 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\n@@ -178,17 +178,45 @@ public Blob createBlob(InputStream stream) throws IOException {\n     @Override @Nonnull\n     public synchronized String checkpoint(long lifetime) {\n         checkArgument(lifetime > 0);\n-        // TODO: Guard the checkpoint from garbage collection\n-        return head.getRecordId().toString();\n+        String name = UUID.randomUUID().toString();\n+\n+        // try 5 times\n+        for (int i = 0; i < 5; i++) {\n+            if (commitSemaphore.tryAcquire()) {\n+                try {\n+                    refreshHead();\n+\n+                    SegmentNodeState ns = head;\n+                    RecordId ri = head.getRecordId();\n+\n+                    SegmentRootBuilder builder = ns.builder();\n+                    NodeBuilder cp = builder.child(name);\n+                    cp.setProperty(\"timestamp\", System.currentTimeMillis()\n+                            + lifetime);\n+                    cp.setChildNode(ROOT, ns.getChildNode(ROOT));\n+\n+                    if (journal.setHead(ri, builder.getNodeState()\n+                            .getRecordId())) {\n+                        refreshHead();\n+                        return name;\n+                    }\n+\n+                } finally {\n+                    commitSemaphore.release();\n+                }\n+            }\n+        }\n+\n+        return name;\n     }\n \n     @Override @CheckForNull\n     public synchronized NodeState retrieve(@Nonnull String checkpoint) {\n-        // TODO: Verify validity of the checkpoint\n-        RecordId id = RecordId.fromString(checkNotNull(checkpoint));\n-        SegmentNodeState root =\n-                new SegmentNodeState(store.getWriter().getDummySegment(), id);\n-        return root.getChildNode(ROOT);\n+        NodeState cp = head.getChildNode(checkpoint).getChildNode(ROOT);\n+        if (cp.exists()) {\n+            return cp;\n+        }\n+        return null;\n     }\n \n     private class Commit {\n", "nb_test": 1482, "linesAdd": 34, "jira_id": "1250", "singleLine": false, "nb_skipped": 6, "commit": "0c3b3306", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["readOnlyDirectory(org.apache.jackrabbit.oak.plugins.index.lucene.OakDirectoryTest): This builder is read-only."], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\nindex 50c7f9e..2e137d5 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n@@ -91,7 +91,7 @@ public OakDirectory(NodeBuilder builder, IndexDefinition definition, boolean rea\n     public OakDirectory(NodeBuilder builder, String dataNodeName, IndexDefinition definition, boolean readOnly) {\n         this.lockFactory = NoLockFactory.getNoLockFactory();\n         this.builder = builder;\n-        this.directoryBuilder = builder.child(dataNodeName);\n+        this.directoryBuilder = readOnly ? builder.getChildNode(dataNodeName) : builder.child(dataNodeName);\n         this.definition = definition;\n         this.readOnly = readOnly;\n         this.fileNames.addAll(getListing());\n", "nb_test": 326, "linesAdd": 1, "jira_id": "3920", "singleLine": false, "nb_skipped": 3, "commit": "99996c25", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["noPlanForSortOnlyByScore(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlannerTest)"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\nindex a2189a0..9a413dc 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\n@@ -36,6 +36,7 @@\n import org.apache.jackrabbit.oak.query.fulltext.FullTextTerm;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextVisitor;\n import org.apache.jackrabbit.oak.spi.query.Filter;\n+import org.apache.jackrabbit.oak.spi.query.QueryIndex;\n import org.apache.lucene.index.IndexReader;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -43,6 +44,7 @@\n import static com.google.common.collect.Lists.newArrayList;\n import static com.google.common.collect.Lists.newArrayListWithCapacity;\n import static com.google.common.collect.Maps.newHashMap;\n+import static org.apache.jackrabbit.JcrConstants.JCR_SCORE;\n import static org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath;\n import static org.apache.jackrabbit.oak.commons.PathUtils.getDepth;\n import static org.apache.jackrabbit.oak.commons.PathUtils.getParentPath;\n@@ -156,7 +158,8 @@ public String toString() {\n         //Fulltext expression can also be like jcr:contains(jcr:content/metadata/@format, 'image')\n \n         List<OrderEntry> sortOrder = createSortOrder(indexingRule);\n-        if (!indexedProps.isEmpty() || !sortOrder.isEmpty() || ft != null || evalPathRestrictions) {\n+        boolean canSort = canHandleSorting(sortOrder);\n+        if (!indexedProps.isEmpty() || canSort || ft != null || evalPathRestrictions) {\n             //TODO Need a way to have better cost estimate to indicate that\n             //this index can evaluate more propertyRestrictions natively (if more props are indexed)\n             //For now we reduce cost per entry\n@@ -191,6 +194,20 @@ public String toString() {\n         return null;\n     }\n \n+    private boolean canHandleSorting(List<OrderEntry> sortOrder) {\n+        if (sortOrder.isEmpty()){\n+            return false;\n+        }\n+\n+        //If jcr:score is the only sort order then opt out\n+        if (sortOrder.size() == 1\n+                && JCR_SCORE.equals(sortOrder.get(0).getPropertyName())){\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n     private boolean canEvalAllFullText(final IndexingRule indexingRule, FullTextExpression ft) {\n         if (ft == null){\n             return false;\n", "nb_test": 379, "linesAdd": 17, "jira_id": "2439", "singleLine": false, "nb_skipped": 3, "commit": "beaca1a4", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["deleteCorruptedFile(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierTest)"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\nindex 6f67427..47e57d5 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n@@ -188,9 +188,12 @@ private void copy(final FileReference reference) {\n                 @Override\n                 public void run() {\n                     String name = reference.name;\n+                    boolean success = false;\n+                    boolean copyAttempted = false;\n                     try {\n                         if (!local.fileExists(name)) {\n                             long start = System.currentTimeMillis();\n+                            copyAttempted = true;\n                             remote.copy(local, name, name, IOContext.READ);\n                             reference.markValid();\n                             downloadTime.addAndGet(System.currentTimeMillis() - start);\n@@ -210,11 +213,22 @@ public void run() {\n                                 reference.markValid();\n                             }\n                         }\n+                        success = true;\n                     } catch (IOException e) {\n                         //TODO In case of exception there would not be any other attempt\n                         //to download the file. Look into support for retry\n                         log.warn(\"Error occurred while copying file [{}] \" +\n                                 \"from {} to {}\", name, remote, local, e);\n+                    } finally {\n+                        if (copyAttempted && !success){\n+                            try {\n+                                if (local.fileExists(name)) {\n+                                    local.deleteFile(name);\n+                                }\n+                            } catch (IOException e) {\n+                                log.warn(\"Error occurred while deleting corrupted file [{}] from [{}]\", name, local, e);\n+                            }\n+                        }\n                     }\n                 }\n             });\n", "nb_test": 418, "linesAdd": 14, "jira_id": "2649", "singleLine": false, "nb_skipped": 2, "commit": "72d24f4b", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["exceptionOnUpdate(org.apache.jackrabbit.oak.plugins.document.CommitRootUpdateTest): Update of commit root document failed"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex 3d854d9..9074e68 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -388,7 +388,7 @@ private void applyToDocumentStore(RevisionVector baseBranchRevision) {\n                     // only set revision on commit root when there is\n                     // no collision for this commit revision\n                     commit.containsMapEntry(COLLISIONS, revision, false);\n-                    NodeDocument before = nodeStore.updateCommitRoot(commit);\n+                    NodeDocument before = nodeStore.updateCommitRoot(commit, revision);\n                     if (before == null) {\n                         String msg = \"Conflicting concurrent change. \" +\n                                 \"Update operation failed: \" + commitRoot;\n@@ -425,7 +425,13 @@ private void applyToDocumentStore(RevisionVector baseBranchRevision) {\n             if (success) {\n                 LOG.error(\"Exception occurred after commit. Rollback will be suppressed.\", e);\n             } else {\n+                try {\n                     rollback(newNodes, opLog, commitRoot);\n+                } catch (Exception ex) {\n+                    // catch any exception caused by the rollback, log it\n+                    // and throw the original exception\n+                    LOG.warn(\"Rollback failed\", ex);\n+                }\n                 throw e;\n             }\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 14e608f..8a715ac 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -73,7 +73,6 @@\n import com.google.common.base.Suppliers;\n import com.google.common.cache.Cache;\n import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.UncheckedExecutionException;\n@@ -1164,12 +1163,14 @@ void revisionsMerged(@Nonnull Iterable<Revision> revisions) {\n      * Updates a commit root document.\n      *\n      * @param commit the updates to apply on the commit root document.\n+     * @param commitRev the commit revision.\n      * @return the document before the update was applied or <code>null</code>\n      *          if the update failed because of a collision.\n      * @throws DocumentStoreException if the update fails with an error.\n      */\n     @CheckForNull\n-    NodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\n+    NodeDocument updateCommitRoot(UpdateOp commit, Revision commitRev)\n+            throws DocumentStoreException {\n         // use batch commit when there are only revision and modified updates\n         boolean batch = true;\n         for (Map.Entry<Key, Operation> op : commit.getChanges().entrySet()) {\n@@ -1181,11 +1182,63 @@ NodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\n             batch = false;\n             break;\n         }\n+        try {\n             if (batch) {\n                 return batchUpdateCommitRoot(commit);\n             } else {\n                 return store.findAndUpdate(NODES, commit);\n             }\n+        } catch (DocumentStoreException e) {\n+            return verifyCommitRootUpdateApplied(commit, commitRev, e);\n+        }\n+    }\n+\n+    /**\n+     * Verifies if the {@code commit} update on the commit root was applied by\n+     * reading the affected document and checks if the {@code commitRev} is\n+     * set in the revisions map.\n+     *\n+     * @param commit the update operation on the commit root document.\n+     * @param commitRev the commit revision.\n+     * @param e the exception that will be thrown when this method determines\n+     *          that the update was not applied.\n+     * @return the before document.\n+     * @throws DocumentStoreException the exception passed to this document\n+     *      in case the commit update was not applied.\n+     */\n+    private NodeDocument verifyCommitRootUpdateApplied(UpdateOp commit,\n+                                                       Revision commitRev,\n+                                                       DocumentStoreException e)\n+            throws DocumentStoreException {\n+        LOG.info(\"Update of commit root failed with exception\", e);\n+        int numRetries = 10;\n+        for (int i = 0; i < numRetries; i++) {\n+            LOG.info(\"Checking if change made it to the DocumentStore anyway {}/{} ...\",\n+                    i + 1, numRetries);\n+            NodeDocument commitRootDoc;\n+            try {\n+                commitRootDoc = store.find(NODES, commit.getId(), 0);\n+            } catch (Exception ex) {\n+                LOG.info(\"Failed to read commit root document\", ex);\n+                continue;\n+            }\n+            if (commitRootDoc == null) {\n+                LOG.info(\"Commit root document missing for {}\", commit.getId());\n+                break;\n+            }\n+            if (commitRootDoc.getLocalRevisions().containsKey(commitRev)) {\n+                LOG.info(\"Update made it to the store even though the call \" +\n+                        \"failed with an exception. Previous exception will \" +\n+                        \"be suppressed. {}\", commit);\n+                NodeDocument before = NODES.newDocument(store);\n+                commitRootDoc.deepCopy(before);\n+                UpdateUtils.applyChanges(before, commit.getReverseOperation());\n+                return before;\n+            }\n+            break;\n+        }\n+        LOG.info(\"Update didn't make it to the store. Re-throwing the exception\");\n+        throw e;\n     }\n \n     private NodeDocument batchUpdateCommitRoot(UpdateOp commit)\n", "nb_test": 2920, "linesAdd": 46, "jira_id": "3903", "singleLine": false, "nb_skipped": 1, "commit": "690fb9f4", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCheckpointMax(org.apache.jackrabbit.oak.plugins.segment.CheckpointTest)"], "patch": "diff --git a/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java b/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\nindex 2191a61..c5efa1a 100644\n--- a/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\n+++ b/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\n@@ -416,7 +416,11 @@ public Boolean call() {\n             }\n \n             NodeBuilder cp = checkpoints.child(name);\n+            if (Long.MAX_VALUE - now > lifetime) {\n                 cp.setProperty(\"timestamp\", now + lifetime);\n+            } else {\n+                cp.setProperty(\"timestamp\", Long.MAX_VALUE);\n+            }\n             cp.setProperty(\"created\", now);\n \n             NodeBuilder props = cp.setChildNode(\"properties\");\n", "nb_test": 206, "linesAdd": 4, "jira_id": "4423", "singleLine": false, "nb_skipped": 7, "commit": "275eca83", "nb_failure": 1, "linesRem": 0}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testWhitespace(org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest): with local mappings expected:<oak: leading> but was:<null>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrNameParser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrNameParser.java\nindex 205a754..ebc7c08 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrNameParser.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrNameParser.java\n@@ -92,7 +92,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n         String prefix;\n         int nameStart = 0;\n         int state = STATE_PREFIX_START;\n-        boolean trailingSpaces = false;\n \n         for (int i = 0; i < len; i++) {\n             char c = jcrName.charAt(i);\n@@ -101,10 +100,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                     listener.error(\"Prefix must not be empty\");\n                     return false;\n                 } else if (state == STATE_PREFIX) {\n-                    if (trailingSpaces) {\n-                        listener.error(\"Trailing spaces not allowed\");\n-                        return false;\n-                    }\n                     prefix = jcrName.substring(0, i);\n                     if (!XMLChar.isValidNCName(prefix)) {\n                         listener.error(\"Invalid name prefix: \"+ prefix);\n@@ -117,14 +112,7 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                     listener.error(\"'\" + c + \"' not allowed in name\");\n                     return false;\n                 }\n-                trailingSpaces = false;\n-            } else if (c == ' ') {\n-                if (state == STATE_PREFIX_START || state == STATE_NAME_START) {\n-                    listener.error(\"'\" + c + \"' not valid name start\");\n-                    return false;\n-                }\n-                trailingSpaces = true;\n-            } else if (Character.isWhitespace(c) || c == '[' || c == ']' || c == '*' || c == '|') {\n+            } else if (c == '[' || c == ']' || c == '*' || c == '|') {\n                 listener.error(\"'\" + c + \"' not allowed in name\");\n                 return false;\n             } else if (c == '/') {\n@@ -134,7 +122,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                     listener.error(\"'\" + c + \"' not allowed in name\");\n                     return false;\n                 }\n-                trailingSpaces = false;\n             } else if (c == '{') {\n                 if (state == STATE_PREFIX_START) {\n                     state = STATE_URI_START;\n@@ -147,7 +134,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                     state = STATE_NAME;\n                     nameStart = i;\n                 }\n-                trailingSpaces = false;\n             } else if (c == '}') {\n                 if (state == STATE_URI_START || state == STATE_URI) {\n                     String tmp = jcrName.substring(1, i);\n@@ -178,7 +164,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                     state = STATE_NAME;\n                     nameStart = i;\n                 }\n-                trailingSpaces = false;\n             } else {\n                 if (state == STATE_PREFIX_START) {\n                     state = STATE_PREFIX; // prefix start\n@@ -188,7 +173,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                 } else if (state == STATE_URI_START) {\n                     state = STATE_URI;\n                 }\n-                trailingSpaces = false;\n             }\n         }\n \n@@ -203,10 +187,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n             listener.error(\"Local name must not be empty\");\n             return false;\n         }\n-        if (trailingSpaces) {\n-            listener.error(\"Trailing spaces not allowed\");\n-            return false;\n-        }\n \n         return listener.name(jcrName, index);\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\nindex b63958a..54c1c9e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\n@@ -80,10 +80,6 @@ public static boolean parse(String jcrPath, Listener listener) {\n         while (pos <= len) {\n             char c = pos == len ? EOF : jcrPath.charAt(pos);\n             pos++;\n-            // special check for whitespace\n-            if (c != ' ' && Character.isWhitespace(c)) {\n-                c = '\\t';\n-            }\n \n             switch (c) {\n                 case '/':\n@@ -205,24 +201,6 @@ public static boolean parse(String jcrPath, Listener listener) {\n                     }\n                     break;\n \n-                case ' ':\n-                    if (state == STATE_PREFIX_START || state == STATE_NAME_START) {\n-                        listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c +\n-                                \"' not valid name start\");\n-                        return false;\n-                    } else if (state == STATE_INDEX_END) {\n-                        listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c +\n-                                \"' not valid after index. '/' expected.\");\n-                        return false;\n-                    } else if (state == STATE_DOT || state == STATE_DOTDOT) {\n-                        state = STATE_PREFIX;\n-                    }\n-                    break;\n-\n-                case '\\t':\n-                    listener.error('\\'' + jcrPath + \"' is not a valid path. \" +\n-                            \"Whitespace not a allowed in name.\");\n-                    return false;\n                 case '*':\n                 case '|':\n                     listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c +\n@@ -257,7 +235,7 @@ public static boolean parse(String jcrPath, Listener listener) {\n                         return false;\n                     }\n             }\n-            wasSlash = c == ' ';\n+            wasSlash = c == '/';\n         }\n         return true;\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\nindex 3b4219c..d0d1e26 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n@@ -244,10 +244,14 @@ public static boolean isValidLocalName(String local) {\n \n         for (int i = 0; i < local.length(); i++) {\n             char ch = local.charAt(i);\n-            if (i == 0 && Character.isWhitespace(ch)) {\n+            if (Character.isSpaceChar(ch)) {\n+                if (i == 0) {\n                     return false; // leading whitespace\n-            } else if (i == local.length() - 1 && Character.isWhitespace(ch)) {\n+                } else if (i == local.length() - 1) {\n                     return false; // trailing whitespace\n+                } else if (ch != ' ') {\n+                    return false; // only spaces are allowed as whitespace\n+                }\n             } else if (\"/:[]|*\".indexOf(ch) != -1) { // TODO: XMLChar check\n                 return false; // invalid name character\n             }\n", "nb_test": 1756, "linesAdd": 8, "jira_id": "1174", "singleLine": false, "nb_skipped": 8, "commit": "342809f7", "nb_failure": 1, "linesRem": 45}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSyncLoop(org.apache.jackrabbit.oak.plugins.segment.standby.StandbyTest)"], "patch": "diff --git a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyApplyDiff.java b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyApplyDiff.java\nindex fc055e2..7b32f51 100644\n--- a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyApplyDiff.java\n+++ b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyApplyDiff.java\n@@ -26,9 +26,9 @@\n import org.apache.jackrabbit.oak.api.Blob;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Type;\n-import org.apache.jackrabbit.oak.commons.PathUtils;\n-import org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState;\n+import org.apache.jackrabbit.oak.plugins.segment.RecordId;\n import org.apache.jackrabbit.oak.plugins.segment.SegmentBlob;\n+import org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState;\n import org.apache.jackrabbit.oak.plugins.segment.SegmentStore;\n import org.apache.jackrabbit.oak.plugins.segment.standby.store.RemoteSegmentLoader;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n@@ -50,22 +50,20 @@\n \n     private final String path;\n \n+    private final boolean logOnly;\n+\n     public StandbyApplyDiff(NodeBuilder builder, SegmentStore store,\n             RemoteSegmentLoader loader) {\n-        this(builder, store, loader, \"/\");\n+        this(builder, store, loader, \"/\", false);\n     }\n \n     private StandbyApplyDiff(NodeBuilder builder, SegmentStore store,\n-            RemoteSegmentLoader loader, String path) {\n+            RemoteSegmentLoader loader, String path, boolean logOnly) {\n         this.builder = builder;\n         this.store = store;\n         this.loader = loader;\n         this.path = path;\n-        if (log.isTraceEnabled()) {\n-            if (PathUtils.getDepth(path) < 5) {\n-                log.trace(\"running diff on {}\", path);\n-            }\n-        }\n+        this.logOnly = logOnly;\n     }\n \n     @Override\n@@ -73,7 +71,9 @@ public boolean propertyAdded(PropertyState after) {\n         if (!loader.isRunning()) {\n             return false;\n         }\n+        if (!logOnly) {\n             builder.setProperty(binaryCheck(after));\n+        }\n         return true;\n     }\n \n@@ -82,7 +82,9 @@ public boolean propertyChanged(PropertyState before, PropertyState after) {\n         if (!loader.isRunning()) {\n             return false;\n         }\n+        if (!logOnly) {\n             builder.setProperty(binaryCheck(after));\n+        }\n         return true;\n     }\n \n@@ -91,7 +93,9 @@ public boolean propertyDeleted(PropertyState before) {\n         if (!loader.isRunning()) {\n             return false;\n         }\n+        if (!logOnly) {\n             builder.removeProperty(before.getName());\n+        }\n         return true;\n     }\n \n@@ -143,13 +147,18 @@ public boolean childNodeAdded(String name, NodeState after) {\n         if (!loader.isRunning()) {\n             return false;\n         }\n-        NodeBuilder child = EmptyNodeState.EMPTY_NODE.builder();\n-        boolean success = EmptyNodeState.compareAgainstEmptyState(after,\n-                new StandbyApplyDiff(child, store, loader, path + name + \"/\"));\n-        if (success) {\n-            builder.setChildNode(name, child.getNodeState());\n+\n+        if (after instanceof SegmentNodeState) {\n+            if (log.isTraceEnabled()) {\n+                log.trace(\"childNodeAdded {}, RO:{}\", path + name, logOnly);\n             }\n-        return success;\n+            if (!logOnly) {\n+                RecordId id = ((SegmentNodeState) after).getRecordId();\n+                builder.setChildNode(name, new SegmentNodeState(id));\n+            }\n+            return true;\n+        }\n+        return false;\n     }\n \n     @Override\n@@ -159,8 +168,26 @@ public boolean childNodeChanged(String name, NodeState before,\n             return false;\n         }\n \n+        if (after instanceof SegmentNodeState) {\n+            RecordId id = ((SegmentNodeState) after).getRecordId();\n+\n+            if (log.isTraceEnabled()) {\n+                // if (PathUtils.getDepth(path) < 5) {\n+                RecordId oldId = ((SegmentNodeState) before).getRecordId();\n+                log.trace(\"childNodeChanged {}, {} -> {}, RO:{}\", path + name,\n+                        oldId, id, logOnly);\n+                // }\n+            }\n+            if (!logOnly) {\n+                builder.setChildNode(name, new SegmentNodeState(id));\n+            }\n+\n+            // return true;\n             return after.compareAgainstBaseState(before, new StandbyApplyDiff(\n-                builder.getChildNode(name), store, loader, path + name + \"/\"));\n+                    builder.getChildNode(name), store, loader, path + name\n+                            + \"/\", true));\n+        }\n+        return false;\n     }\n \n     @Override\n@@ -168,7 +195,10 @@ public boolean childNodeDeleted(String name, NodeState before) {\n         if (!loader.isRunning()) {\n             return false;\n         }\n+        log.trace(\"childNodeDeleted {}, RO:{}\", path + name, logOnly);\n+        if (!logOnly) {\n             builder.getChildNode(name).remove();\n+        }\n         return true;\n     }\n }\n", "nb_test": 8, "linesAdd": 43, "jira_id": "2430", "singleLine": false, "nb_skipped": 0, "commit": "be3a9114", "nb_failure": 1, "linesRem": 16}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["recoveryWithoutRootUpdate(org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryTest): must not recover any documents expected:<0> but was:<2>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\nindex fee60dc..dc3074f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n@@ -19,12 +19,10 @@\n \n package org.apache.jackrabbit.oak.plugins.document;\n \n-import static com.google.common.collect.ImmutableList.of;\n-import static com.google.common.collect.Iterables.filter;\n-import static com.google.common.collect.Iterables.mergeSorted;\n+import static com.google.common.collect.Maps.filterKeys;\n import static java.util.Collections.singletonList;\n import static org.apache.jackrabbit.oak.plugins.document.Collection.JOURNAL;\n-import static org.apache.jackrabbit.oak.plugins.document.UnsavedModifications.Snapshot.IGNORE;\n+import static org.apache.jackrabbit.oak.plugins.document.util.Utils.PROPERTY_OR_DELETED;\n \n import java.util.Iterator;\n import java.util.List;\n@@ -35,6 +33,7 @@\n \n import com.google.common.base.Predicate;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n \n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore;\n@@ -152,13 +151,17 @@ public int recover(Iterator<NodeDocument> suspects,\n             }\n \n             Revision currentLastRev = doc.getLastRev().get(clusterId);\n-            if (currentLastRev != null) {\n-                knownLastRevs.put(doc.getPath(), currentLastRev);\n-            }\n+\n             // 1. determine last committed modification on document\n             Revision lastModifiedRev = determineLastModification(doc, clusterId);\n \n             Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);\n+            // remember the higher of the two revisions. this is the\n+            // most recent revision currently obtained from either a\n+            // _lastRev entry or an explicit modification on the document\n+            if (lastRevForParents != null) {\n+                knownLastRevs.put(doc.getPath(), lastRevForParents);\n+            }\n \n             //If both currentLastRev and lostLastRev are null it means\n             //that no change is done by suspect cluster on this document\n@@ -306,21 +309,17 @@ private int recoverCandidates(final int clusterId, final long startTime) {\n     private Revision determineLastModification(NodeDocument doc, int clusterId) {\n         ClusterPredicate cp = new ClusterPredicate(clusterId);\n \n-        // Merge sort the revs for which changes have been made\n-        // to this doc\n-\n-        // localMap always keeps the most recent valid commit entry\n-        // per cluster node so looking into that should be sufficient\n-        Iterable<Revision> revs = mergeSorted(of(\n-                filter(doc.getLocalCommitRoot().keySet(), cp),\n-                filter(doc.getLocalRevisions().keySet(), cp)),\n-                StableRevisionComparator.REVERSE\n-                );\n-\n         Revision lastModified = null;\n-        // Look for latest valid revision\n-        for (Revision rev : revs) {\n+        for (String property : Sets.filter(doc.keySet(), PROPERTY_OR_DELETED)) {\n+            Map<Revision, String> valueMap = doc.getLocalMap(property);\n+            // collect committed changes of this cluster node\n+            for (Map.Entry<Revision, String> entry : filterKeys(valueMap, cp).entrySet()) {\n+                Revision rev = entry.getKey();\n+                if (doc.isCommitted(rev)) {\n                     lastModified = Utils.max(lastModified, doc.getCommitRevision(rev));\n+                    break;\n+                }\n+            }\n         }\n         return lastModified;\n     }\n", "nb_test": 2412, "linesAdd": 15, "jira_id": "3079", "singleLine": false, "nb_skipped": 1, "commit": "33c18762", "nb_failure": 1, "linesRem": 15}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["multiValuesForOrderedIndexShouldNotThrow(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexTest): Exception thrown when indexing invalid content", "sortQueriesWithStringIgnoredMulti_OrderedProps(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest): OakLucene0003: Failed to index the node /test/a"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\nindex ea255df..2e60d8d 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n@@ -461,6 +461,14 @@ private boolean addTypedOrderedFields(List<Field> fields,\n                                           PropertyState property,\n                                           String pname,\n                                           PropertyDefinition pd) throws CommitFailedException {\n+        // Ignore and warn if property multi-valued as not supported\n+        if (property.getType().isArray()) {\n+            log.warn(\n+                \"Ignoring ordered property {} of type {} for path {} as multivalued ordered property not supported\",\n+                pname, Type.fromTag(property.getType().tag(), true), getPath());\n+            return false;\n+        }\n+\n         int tag = property.getType().tag();\n         int idxDefinedTag = pd.getType();\n         // Try converting type to the defined type in the index definition\n@@ -475,24 +483,23 @@ private boolean addTypedOrderedFields(List<Field> fields,\n \n         String name = FieldNames.createDocValFieldName(pname);\n         boolean fieldAdded = false;\n-        for (int i = 0; i < property.count(); i++) {\n         Field f = null;\n         try {\n             if (tag == Type.LONG.tag()) {\n                 //TODO Distinguish fields which need to be used for search and for sort\n                 //If a field is only used for Sort then it can be stored with less precision\n-                    f = new NumericDocValuesField(name, property.getValue(Type.LONG, i));\n+                f = new NumericDocValuesField(name, property.getValue(Type.LONG));\n             } else if (tag == Type.DATE.tag()) {\n-                    String date = property.getValue(Type.DATE, i);\n+                String date = property.getValue(Type.DATE);\n                 f = new NumericDocValuesField(name, FieldFactory.dateToLong(date));\n             } else if (tag == Type.DOUBLE.tag()) {\n-                    f = new DoubleDocValuesField(name, property.getValue(Type.DOUBLE, i));\n+                f = new DoubleDocValuesField(name, property.getValue(Type.DOUBLE));\n             } else if (tag == Type.BOOLEAN.tag()) {\n                 f = new SortedDocValuesField(name,\n-                        new BytesRef(property.getValue(Type.BOOLEAN, i).toString()));\n+                    new BytesRef(property.getValue(Type.BOOLEAN).toString()));\n             } else if (tag == Type.STRING.tag()) {\n                 f = new SortedDocValuesField(name,\n-                        new BytesRef(property.getValue(Type.STRING, i)));\n+                    new BytesRef(property.getValue(Type.STRING)));\n             }\n \n             if (f != null) {\n@@ -506,7 +513,6 @@ private boolean addTypedOrderedFields(List<Field> fields,\n                 pname, Type.fromTag(property.getType().tag(), false),\n                 Type.fromTag(tag, false), getPath(), e);\n         }\n-        }\n         return fieldAdded;\n     }\n \n", "nb_test": 459, "linesAdd": 12, "jira_id": "3020", "singleLine": false, "nb_skipped": 3, "commit": "147515ae", "nb_failure": 1, "linesRem": 7}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testUnmodifiedEqualsBase(org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest): expected:<null> but was:<{ q }>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex ce13f08..6600cc7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -268,11 +267,12 @@ private boolean isRemoved(String name) {\n \n     @Override\n     public boolean isModified() {\n+        NodeState baseState = getBaseState();\n         if (writeState == null) {\n             return false;\n         }\n         else {\n-            NodeState baseState = getBaseState();\n+            Map<String, MutableNodeState> nodes = writeState.nodes;\n             for (Entry<String, MutableNodeState> n : writeState.nodes.entrySet()) {\n                 if (n.getValue() == null) {\n                     return true;\n@@ -308,6 +308,7 @@ public NodeState getNodeState() {\n \n     @Override\n     public NodeState getBaseState() {\n+        read();\n         return baseState;\n     }\n \n", "nb_test": 399, "linesAdd": 3, "jira_id": "448", "singleLine": false, "nb_skipped": 1, "commit": "999097e1", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["xpath(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/oajopi.property.PropertyIndexQueryTest_xpath.txt don't match expected results in /home/ylyu/parallel/oak/oak9/dataset/oak/OAK-4376_037dea72ff44f35aa866d96292fd2d21ceecccb6/oak-core/target/test-classes/org/apache/jackrabbit/oak/query/xpath.txt; compare the files for details; got=(..)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\nindex 9bfbd2d..d64d7cf 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n@@ -162,6 +162,10 @@ private Statement convertToStatement(String query) throws ParseException {\n             } else if (readIf(\"/\")) {\n                 // \"//\" was read\n                 pathPattern += \"%\";\n+                if (currentSelector.isDescendant) {\n+                    // the query started with \"//\", and now \"//\" was read\n+                    nextSelector(true);\n+                }\n                 currentSelector.isDescendant = true;\n             } else {\n                 // the token \"/\" was read\n@@ -169,6 +173,10 @@ private Statement convertToStatement(String query) throws ParseException {\n                 if (startOfQuery) {\n                     currentSelector.path = \"/\";\n                 } else {\n+                    if (currentSelector.isDescendant) {\n+                        // the query started with \"//\", and now \"/\" was read\n+                        nextSelector(true);\n+                    }\n                     currentSelector.isChild = true;\n                 }\n             }\n", "nb_test": 2882, "linesAdd": 6, "jira_id": "4376", "singleLine": false, "nb_skipped": 1, "commit": "037dea72", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["luceneWithFSDirectory(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexTest)"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\nindex 6c2bfcc..3107e21 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n@@ -26,6 +26,7 @@\n \n import java.io.File;\n import java.io.IOException;\n+import java.util.Calendar;\n import java.util.Set;\n \n import javax.jcr.PropertyType;\n@@ -35,6 +36,7 @@\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.plugins.index.IndexUpdateCallback;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n+import org.apache.jackrabbit.util.ISO8601;\n import org.apache.lucene.analysis.Analyzer;\n import org.apache.lucene.index.IndexWriter;\n import org.apache.lucene.index.IndexWriterConfig;\n@@ -165,6 +167,13 @@ IndexWriter getWriter() throws IOException {\n     void closeWriter() throws IOException {\n         if (writer != null) {\n             writer.close();\n+\n+            //OAK-2029 Record the last updated status so\n+            //as to make IndexTracker detect changes when index\n+            //is stored in file system\n+            NodeBuilder status = definition.child(\":status\");\n+            status.setProperty(\"lastUpdated\", ISO8601.format(Calendar.getInstance()), Type.DATE);\n+            status.setProperty(\"indexedNodes\",indexedNodes);\n         }\n     }\n \n", "nb_test": 260, "linesAdd": 6, "jira_id": "2029", "singleLine": false, "nb_skipped": 0, "commit": "e30023ba", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["rebaseMultiple(org.apache.jackrabbit.oak.plugins.mongomk.MongoMKRebaseTest): repeated rebase with same head must not create new branch revision expected:<br156387b6de8-[b]-1> but was:<br156387b6de8-[c]-1>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\nindex c92d4f5..4047727 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\n@@ -747,7 +747,7 @@ Revision rebase(@Nonnull Revision branchHead, @Nonnull Revision base) {\n             // empty branch\n             return base.asBranchRevision();\n         }\n-        if (b.getBase().equals(base)) {\n+        if (b.getBase(branchHead).equals(base)) {\n             return branchHead;\n         }\n         // add a pseudo commit to make sure current head of branch\n", "nb_test": 1312, "linesAdd": 1, "jira_id": "1129", "singleLine": false, "nb_skipped": 6, "commit": "2f95b81f", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMultiNotEqual(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Result set size is different expected:<2> but was:<1>", "testMultiAndLike(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Result set size is different expected:<1> but was:<0>", "testSubPropertyMultiAndLike(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Result set size is different expected:<1> but was:<0>", "propertyRestriction(org.apache.jackrabbit.oak.query.index.FilterTest): expected:<[[]1..2]> but was:<[(]1..2]>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\nindex 75e48bc..26a3a43 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\n@@ -118,7 +118,7 @@ private boolean evaluate(PropertyValue p1, PropertyValue p2) {\n         case EQUAL:\n             return PropertyValues.match(p1, p2);\n         case NOT_EQUAL:\n-            return !PropertyValues.match(p1, p2);\n+            return PropertyValues.notMatch(p1, p2);\n         case GREATER_OR_EQUAL:\n             return p1.compareTo(p2) >= 0;\n         case GREATER_THAN:\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\nindex 6eb282e..b31e740 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n@@ -252,16 +252,17 @@ public void restrictProperty(String propertyName, Operator op, PropertyValue v)\n         switch (op) {\n         case EQUAL:\n             if (x.first != null && x.last == x.first && x.firstIncluding && x.lastIncluding) {\n-                // there is already an equality condition on this property\n-                // we will keep this, as it could be a multi-valued property\n-                // (unlike in databases, \"x = 1 and x = 2\" can match a node\n-                // if x is a multi-valued property with value \"{1, 2}\")\n-                return;\n+                // we keep the old equality condition if there is one;\n+                // we can not use setAlwaysFalse, as this would not be correct\n+                // for multi-valued properties:\n+                // unlike in databases, \"x = 1 and x = 2\" can match a node\n+                // if x is a multi-valued property with value {1, 2}\n+            } else {\n+                // all other conditions (range conditions) are replaced with this one\n+                // (we can not use setAlwaysFalse for the same reason as above)\n+                x.first = x.last = v;\n+                x.firstIncluding = x.lastIncluding = true;\n             }\n-            x.first = maxValue(oldFirst, v);\n-            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n-            x.last = minValue(oldLast, v);\n-            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\n             break;\n         case NOT_EQUAL:\n             if (v != null) {\n@@ -269,25 +270,40 @@ public void restrictProperty(String propertyName, Operator op, PropertyValue v)\n             }\n             break;\n         case GREATER_THAN:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.first == null) {\n                 x.first = maxValue(oldFirst, v);\n                 x.firstIncluding = false;\n+            }\n             break;\n         case GREATER_OR_EQUAL:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.first == null) {\n                 x.first = maxValue(oldFirst, v);\n                 x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n+            }\n             break;\n         case LESS_THAN:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.last == null) {\n                 x.last = minValue(oldLast, v);\n                 x.lastIncluding = false;\n+            }\n             break;\n         case LESS_OR_EQUAL:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.last == null) {\n                 x.last = minValue(oldLast, v);\n                 x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\n+            }\n             break;\n         case LIKE:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.first == null) {\n                 // LIKE is handled in the fulltext index\n                 x.isLike = true;\n                 x.first = v;\n+            }\n             break;\n         case IN:\n             \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java\nindex 67e9cdb..5320a4f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java\n@@ -167,7 +167,7 @@ public static boolean match(PropertyValue p1, PropertyValue p2) {\n             }\n             if (!p1.isArray() && p2.isArray()) {\n                 return contains(p2.getValue(Type.BINARIES),\n-                        p2.getValue(Type.BINARY));\n+                        p1.getValue(Type.BINARY));\n             }\n             break;\n         default:\n@@ -185,6 +185,53 @@ public static boolean match(PropertyValue p1, PropertyValue p2) {\n \n     }\n \n+    public static boolean notMatch(PropertyValue p1, PropertyValue p2) {\n+        if (p1.getType().tag() != p2.getType().tag()) {\n+            return true;\n+        }\n+\n+        switch (p1.getType().tag()) {\n+        case PropertyType.BINARY:\n+            if (p1.isArray() && !p2.isArray()) {\n+                if (p1.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p1.getValue(Type.BINARIES),\n+                        p2.getValue(Type.BINARY));\n+            }\n+            if (!p1.isArray() && p2.isArray()) {\n+                if (p2.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p2.getValue(Type.BINARIES),\n+                        p1.getValue(Type.BINARY));\n+            }\n+            break;\n+        default:\n+            if (p1.isArray() && !p2.isArray()) {\n+                if (p1.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p1.getValue(Type.STRINGS),\n+                        p2.getValue(Type.STRING));\n+            }\n+            if (!p1.isArray() && p2.isArray()) {\n+                if (p2.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p2.getValue(Type.STRINGS),\n+                        p1.getValue(Type.STRING));\n+            }\n+        }\n+        // both arrays or both single values\n+        return p1.compareTo(p2) != 0;\n+\n+    }\n+\n     // --\n \n     /**\n", "nb_test": 1461, "linesAdd": 57, "jira_id": "1075", "singleLine": false, "nb_skipped": 6, "commit": "79467350", "nb_failure": 4, "linesRem": 7}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["purgeAllButMostRecentCommitRoot(org.apache.jackrabbit.oak.plugins.document.DocumentSplitTest): merge must fail with CommitFailedException"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\nindex 33aafe5..a426521 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n@@ -233,6 +233,7 @@ private void collectRevisionsAndCommitRoot() {\n         committedChanges.put(REVISIONS, revisions);\n         NavigableMap<Revision, String> commitRoot =\n                 new TreeMap<Revision, String>(context.getRevisionComparator());\n+        boolean mostRecent = true;\n         for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\n             Revision r = entry.getKey();\n             if (splitRevs.contains(r)) {\n@@ -240,11 +241,15 @@ private void collectRevisionsAndCommitRoot() {\n                 numValues++;\n             } else if (r.getClusterId() == context.getClusterId() \n                     && !changes.contains(r)) {\n-                // OAK-2528: _commitRoot entry without associated\n-                // change -> consider as garbage\n+                // OAK-2528: _commitRoot entry without associated change\n+                // consider all but most recent as garbage (OAK-3333)\n+                if (mostRecent) {\n+                    mostRecent = false;\n+                } else {\n                     addGarbage(r, COMMIT_ROOT);\n                 }\n             }\n+        }\n         committedChanges.put(COMMIT_ROOT, commitRoot);\n     }\n \n", "nb_test": 2425, "linesAdd": 5, "jira_id": "3333", "singleLine": false, "nb_skipped": 1, "commit": "194999ed", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBinaryCoercion[0](org.apache.jackrabbit.oak.jcr.CompatibilityIssuesTest)", "testBinaryCoercion[1](org.apache.jackrabbit.oak.jcr.CompatibilityIssuesTest)", "testBinaryCoercion[2](org.apache.jackrabbit.oak.jcr.CompatibilityIssuesTest)"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\nindex 925a88b..c42f7f9 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\n@@ -586,6 +586,7 @@ private Tree findMatchingPropertyDefinition(\n         }\n \n         // First look for a matching named property definition\n+        Tree fuzzyMatch = null;\n         for (Tree type : types) {\n             Tree definitions = type\n                     .getChild(OAK_NAMED_PROPERTY_DEFINITIONS)\n@@ -598,10 +599,12 @@ private Tree findMatchingPropertyDefinition(\n             if (definition.exists()) {\n                 return definition;\n             }\n-            if (!exactTypeMatch) {\n             for (Tree def : definitions.getChildren()) {\n                 if (propertyType.isArray() == TreeUtil.getBoolean(def, JCR_MULTIPLE)) {\n-                        return def;\n+                    if (getBoolean(def, JCR_PROTECTED)) {\n+                        return null; // no fuzzy matches for protected items\n+                    } else if (!exactTypeMatch && fuzzyMatch == null) {\n+                        fuzzyMatch = def;\n                     }\n                 }\n             }\n@@ -618,16 +621,17 @@ private Tree findMatchingPropertyDefinition(\n             if (definition.exists()) {\n                 return definition;\n             }\n-            if (!exactTypeMatch) {\n+            if (!exactTypeMatch && fuzzyMatch == null) {\n                 for (Tree def : definitions.getChildren()) {\n                     if (propertyType.isArray() == TreeUtil.getBoolean(def, JCR_MULTIPLE)) {\n-                        return def;\n+                        fuzzyMatch = def;\n+                        break;\n                     }\n                 }\n             }\n         }\n \n-        return null;\n+        return fuzzyMatch;\n     }\n \n     private Tree findMatchingChildNodeDefinition(\n", "nb_test": 1355, "linesAdd": 9, "jira_id": "1020", "singleLine": false, "nb_skipped": 3, "commit": "83427028", "nb_failure": 3, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testImportUserWithPwdHistory(org.apache.jackrabbit.oak.jcr.security.user.UserImportHistoryTest): rep:pwdHistory = {sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375 is single-valued."], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/SysViewImportHandler.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/SysViewImportHandler.java\nindex d9cbf9c..121511a 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/SysViewImportHandler.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/SysViewImportHandler.java\n@@ -277,7 +277,8 @@ public void endElement(String namespaceURI, String localName, String qName)\n                 PropInfo prop = new PropInfo(\n                         currentPropName == null ? null : currentPropName.getRepoQualifiedName(),\n                         currentPropType,\n-                        currentPropValues);\n+                        currentPropValues,\n+                        currentPropMultipleStatus);\n                 state.props.add(prop);\n             }\n             // reset temp fields\n", "nb_test": 1229, "linesAdd": 2, "jira_id": "3930", "singleLine": false, "nb_skipped": 1, "commit": "b939aa6e", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testValidTokenCredentialsWithConflict(org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\nindex 2d4600f..a10b41d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\n@@ -29,6 +29,7 @@\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n+import java.util.UUID;\n import javax.annotation.CheckForNull;\n import javax.annotation.Nonnull;\n import javax.jcr.AccessDeniedException;\n@@ -210,11 +211,7 @@ public TokenInfo createToken(String userId, Map<String, ?> attributes) {\n         if (tokenParent != null) {\n             try {\n                 long creationTime = new Date().getTime();\n-                Calendar creation = GregorianCalendar.getInstance();\n-                creation.setTimeInMillis(creationTime);\n-                String tokenName = Text.replace(ISO8601.format(creation), \":\", \".\");\n-\n-                NodeUtil tokenNode = tokenParent.addChild(tokenName, TOKEN_NT_NAME);\n+                NodeUtil tokenNode = createTokenNode(tokenParent, creationTime);\n                 tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());\n \n                 String key = generateKey(options.getConfigValue(PARAM_TOKEN_LENGTH, DEFAULT_KEY_SIZE));\n@@ -397,6 +394,31 @@ private NodeUtil getTokenParent(String userId) {\n         return tokenParent;\n     }\n \n+    /**\n+     * Create a new token node below the specified {@code parent}.\n+     *\n+     * @param parent The parent node.\n+     * @param creationTime The creation time that is used as name hint.\n+     * @return The new token node\n+     * @throws AccessDeniedException\n+     */\n+    private NodeUtil createTokenNode(@Nonnull NodeUtil parent, @Nonnull long creationTime) throws AccessDeniedException {\n+        Calendar creation = GregorianCalendar.getInstance();\n+        creation.setTimeInMillis(creationTime);\n+        String tokenName = Text.replace(ISO8601.format(creation), \":\", \".\");\n+        NodeUtil tokenNode;\n+        try {\n+            tokenNode = parent.addChild(tokenName, TOKEN_NT_NAME);\n+            root.commit();\n+        } catch (CommitFailedException e) {\n+            // conflict while creating token node -> retry\n+            log.debug(\"Failed to create token node \" + tokenName + \". Using random name as fallback.\");\n+            root.refresh();\n+            tokenNode = parent.addChild(UUID.randomUUID().toString(), TOKEN_NT_NAME);\n+        }\n+        return tokenNode;\n+    }\n+\n     //--------------------------------------------------------------------------\n \n     /**\n", "nb_test": 1838, "linesAdd": 18, "jira_id": "1697", "singleLine": false, "nb_skipped": 8, "commit": "1552be04", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testGetDepth(org.apache.jackrabbit.oak.commons.PathUtilsTest): expected:<0> but was:<1>"], "patch": "diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\nindex 6e68cb0..f82ec93 100644\n--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\n+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\n@@ -185,6 +185,9 @@ public static String dropIndexFromName(@Nonnull String name) {\n     public static int getDepth(String path) {\n         assert isValid(path);\n \n+        if (path.isEmpty()) {\n+            return 0;\n+        }\n         int count = 1, i = 0;\n         if (isAbsolutePath(path)) {\n             if (denotesRootPath(path)) {\n", "nb_test": 7, "linesAdd": 3, "jira_id": "888", "singleLine": false, "nb_skipped": 0, "commit": "6d82cb64", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testGetProviderName(org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalIdentityRefTest)"], "patch": "diff --git a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/ExternalIdentityRef.java b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/ExternalIdentityRef.java\nindex ae67498..f3ffd6f 100644\n--- a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/ExternalIdentityRef.java\n+++ b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/ExternalIdentityRef.java\n@@ -39,13 +39,13 @@\n      */\n     public ExternalIdentityRef(@Nonnull String id, @CheckForNull String providerName) {\n         this.id = id;\n-        this.providerName = providerName;\n+        this.providerName = (providerName == null || providerName.isEmpty()) ? null : providerName;\n \n         StringBuilder b = new StringBuilder();\n         escape(b, id);\n-        if (providerName != null && providerName.length() > 0) {\n+        if (this.providerName != null) {\n             b.append(';');\n-            escape(b, providerName);\n+            escape(b, this.providerName);\n         }\n         string =  b.toString();\n     }\n@@ -82,6 +82,7 @@ public String getString() {\n      * @param str the string\n      * @return the reference\n      */\n+    @Nonnull\n     public static ExternalIdentityRef fromString(@Nonnull String str) {\n         int idx = str.indexOf(';');\n         if (idx < 0) {\n@@ -99,7 +100,7 @@ public static ExternalIdentityRef fromString(@Nonnull String str) {\n      * @param builder the builder\n      * @param str the string\n      */\n-    private void escape(StringBuilder builder, CharSequence str) {\n+    private static void escape(@Nonnull StringBuilder builder, @Nonnull CharSequence str) {\n         final int len = str.length();\n         for (int i=0; i<len; i++) {\n             char c = str.charAt(i);\n@@ -119,16 +120,20 @@ public String toString() {\n     }\n \n     /**\n-     * Tests if the given object is an external identity reference and if it's getString() is equal to this.\n+     * Tests if the given object is an external identity reference and if it's\n+     * getString() is equal to this. Note, that there is no need to\n+     * include {@code id} and {@code provider} fields in the comparison as\n+     * the string representation already incorporates both.\n      */\n     @Override\n     public boolean equals(Object o) {\n-        try {\n-            // assuming that we never compare other types of classes\n-            return this == o || string.equals(((ExternalIdentityRef) o).string);\n-        } catch (Exception e) {\n-            return false;\n+        if (this == o) {\n+            return true;\n         }\n+        if (o instanceof ExternalIdentityRef) {\n+            return string.equals(((ExternalIdentityRef) o).string);\n+        }\n+        return false;\n     }\n \n     /**\n", "nb_test": 17, "linesAdd": 11, "jira_id": "3510", "singleLine": false, "nb_skipped": 0, "commit": "01f5a26f", "nb_failure": 1, "linesRem": 8}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testNoEffectiveDuplicateEntries(org.apache.jackrabbit.oak.security.authorization.accesscontrol.AccessControlManagerImplTest): expected:<1> but was:<3>", "testEffectiveSorting(org.apache.jackrabbit.oak.security.authorization.accesscontrol.AccessControlManagerImplTest): expected:<3> but was:<5>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlManagerImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlManagerImpl.java\nindex 806e992..0bad785 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlManagerImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlManagerImpl.java\n@@ -22,6 +22,7 @@\n import java.text.ParseException;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n@@ -47,6 +48,8 @@\n import com.google.common.base.Objects;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.primitives.Ints;\n import org.apache.jackrabbit.JcrConstants;\n import org.apache.jackrabbit.api.security.JackrabbitAccessControlList;\n import org.apache.jackrabbit.api.security.JackrabbitAccessControlPolicy;\n@@ -361,7 +364,30 @@ public void removePolicy(@Nullable String absPath, @Nonnull AccessControlPolicy\n         Root r = getLatestRoot();\n \n         Result aceResult = searchAces(principals, r);\n-        List<AccessControlPolicy> effective = new ArrayList<AccessControlPolicy>();\n+        Set<JackrabbitAccessControlList> effective = Sets.newTreeSet(new Comparator<JackrabbitAccessControlList>() {\n+            @Override\n+            public int compare(JackrabbitAccessControlList list1, JackrabbitAccessControlList list2) {\n+                if (list1.equals(list2)) {\n+                    return 0;\n+                } else {\n+                    String p1 = list1.getPath();\n+                    String p2 = list2.getPath();\n+\n+                    if (p1 == null) {\n+                        return -1;\n+                    } else if (p2 == null) {\n+                        return 1;\n+                    } else {\n+                        int depth1 = PathUtils.getDepth(p1);\n+                        int depth2 = PathUtils.getDepth(p2);\n+                        return (depth1 == depth2) ? p1.compareTo(p2) : Ints.compare(depth1, depth2);\n+                    }\n+\n+                }\n+            }\n+        });\n+\n+        Set<String> paths = Sets.newHashSet();\n         for (ResultRow row : aceResult.getRows()) {\n             String acePath = row.getPath();\n             String aclName = Text.getName(Text.getRelativeParent(acePath, 1));\n@@ -373,9 +399,13 @@ public void removePolicy(@Nullable String absPath, @Nonnull AccessControlPolicy\n             }\n \n             String path = (REP_REPO_POLICY.equals(aclName)) ? null : accessControlledTree.getPath();\n-            AccessControlPolicy policy = createACL(path, accessControlledTree, true);\n+            if (paths.contains(path)) {\n+                continue;\n+            }\n+            JackrabbitAccessControlList policy = createACL(path, accessControlledTree, true);\n             if (policy != null) {\n                 effective.add(policy);\n+                paths.add(path);\n             }\n         }\n         return effective.toArray(new AccessControlPolicy[effective.size()]);\n", "nb_test": 2200, "linesAdd": 32, "jira_id": "3082", "singleLine": false, "nb_skipped": 1, "commit": "29e5b734", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["analyzedEnabledForBoostedField(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest): expected:<2> but was:<1>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\nindex cd4a119..843fc82 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n@@ -865,7 +865,6 @@ public boolean isBasedOnNtBase(){\n \n                     //Include props with name, boosted and nodeScopeIndex\n                     if (pd.nodeScopeIndex\n-                            && pd.boost != PropertyDefinition.DEFAULT_BOOST\n                             && pd.analyzed\n                             && !pd.isRegexp){\n                         boostedProps.add(pd);\n", "nb_test": 257, "linesAdd": 0, "jira_id": "3367", "singleLine": true, "nb_skipped": 4, "commit": "06812d25", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["suggestionUpdateWithoutIndexChange(org.apache.jackrabbit.oak.plugins.index.lucene.SuggestionIntervalTest): expected:<1> but was:<0>"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\nindex c49902c..fb79cc7 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n@@ -245,6 +245,12 @@ void closeWriter() throws IOException {\n             getWriter();\n         }\n \n+        boolean updateSuggestions = shouldUpdateSuggestions();\n+        if (writer == null && updateSuggestions) {\n+            log.debug(\"Would update suggester dictionary although no index changes were detected in current cycle\");\n+            getWriter();\n+        }\n+\n         if (writer != null) {\n             if (log.isTraceEnabled()) {\n                 trackIndexSizeInfo(writer, definition, directory);\n@@ -252,8 +258,14 @@ void closeWriter() throws IOException {\n \n             final long start = PERF_LOGGER.start();\n \n-            updateSuggester(writer.getAnalyzer());\n+            Calendar lastUpdated = null;\n+            if (updateSuggestions) {\n+                lastUpdated = updateSuggester(writer.getAnalyzer());\n                 PERF_LOGGER.end(start, -1, \"Completed suggester for directory {}\", definition);\n+            }\n+            if (lastUpdated == null) {\n+                lastUpdated = getCalendar();\n+            }\n \n             writer.close();\n             PERF_LOGGER.end(start, -1, \"Closed writer for directory {}\", definition);\n@@ -265,8 +277,9 @@ void closeWriter() throws IOException {\n             //as to make IndexTracker detect changes when index\n             //is stored in file system\n             NodeBuilder status = definitionBuilder.child(\":status\");\n-            status.setProperty(\"lastUpdated\", ISO8601.format(getCalendar()), Type.DATE);\n+            status.setProperty(\"lastUpdated\", ISO8601.format(lastUpdated), Type.DATE);\n             status.setProperty(\"indexedNodes\", indexedNodes);\n+\n             PERF_LOGGER.end(start, -1, \"Overall Closed IndexWriter for directory {}\", definition);\n \n             textExtractionStats.log(reindex);\n@@ -278,38 +291,69 @@ void closeWriter() throws IOException {\n      * eventually update suggest dictionary\n      * @throws IOException if suggest dictionary update fails\n      * @param analyzer the analyzer used to update the suggester\n+     * @return {@link Calendar} object representing the lastUpdated value written by suggestions\n      */\n-    private void updateSuggester(Analyzer analyzer) throws IOException {\n-\n-        if (definition.isSuggestEnabled()) {\n-\n-            boolean updateSuggester = false;\n+    private Calendar updateSuggester(Analyzer analyzer) throws IOException {\n+        Calendar ret = null;\n         NodeBuilder suggesterStatus = definitionBuilder.child(\":suggesterStatus\");\n-            if (suggesterStatus.hasProperty(\"lastUpdated\")) {\n-                PropertyState suggesterLastUpdatedValue = suggesterStatus.getProperty(\"lastUpdated\");\n-                Calendar suggesterLastUpdatedTime = ISO8601.parse(suggesterLastUpdatedValue.getValue(Type.DATE));\n-                int updateFrequency = definition.getSuggesterUpdateFrequencyMinutes();\n-                suggesterLastUpdatedTime.add(Calendar.MINUTE, updateFrequency);\n-                if (getCalendar().after(suggesterLastUpdatedTime)) {\n-                    updateSuggester = true;\n-                }\n-            } else {\n-                updateSuggester = true;\n-            }\n-\n-            if (updateSuggester) {\n         DirectoryReader reader = DirectoryReader.open(writer, false);\n         final OakDirectory suggestDirectory = new OakDirectory(definitionBuilder, \":suggest-data\", definition, false);\n         try {\n             SuggestHelper.updateSuggester(suggestDirectory, analyzer, reader);\n-                    suggesterStatus.setProperty(\"lastUpdated\", ISO8601.format(getCalendar()), Type.DATE);\n+            ret = getCalendar();\n+            suggesterStatus.setProperty(\"lastUpdated\", ISO8601.format(ret), Type.DATE);\n         } catch (Throwable e) {\n             log.warn(\"could not update suggester\", e);\n         } finally {\n             suggestDirectory.close();\n             reader.close();\n         }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Checks if last suggestion build time was done sufficiently in the past AND that there were non-zero indexedNodes\n+     * stored in the last run. Note, if index is updated only to rebuild suggestions, even then we update indexedNodes,\n+     * which would be zero in case it was a forced update of suggestions.\n+     * @return is suggest dict should be updated\n+     */\n+    private boolean shouldUpdateSuggestions() {\n+        boolean updateSuggestions = false;\n+\n+        if (definition.isSuggestEnabled()) {\n+            NodeBuilder suggesterStatus = definitionBuilder.child(\":suggesterStatus\");\n+\n+            PropertyState suggesterLastUpdatedValue = suggesterStatus.getProperty(\"lastUpdated\");\n+\n+            if (suggesterLastUpdatedValue != null) {\n+                Calendar suggesterLastUpdatedTime = ISO8601.parse(suggesterLastUpdatedValue.getValue(Type.DATE));\n+\n+                int updateFrequency = definition.getSuggesterUpdateFrequencyMinutes();\n+                Calendar nextSuggestUpdateTime = (Calendar)suggesterLastUpdatedTime.clone();\n+                nextSuggestUpdateTime.add(Calendar.MINUTE, updateFrequency);\n+                if (getCalendar().after(nextSuggestUpdateTime)) {\n+                    updateSuggestions = (writer != null || isIndexUpdatedAfter(suggesterLastUpdatedTime));\n+                }\n+            } else {\n+                updateSuggestions = true;\n+            }\n+        }\n+\n+        return updateSuggestions;\n     }\n+\n+    /**\n+     * @return {@code false} if persisted lastUpdated time for index is after {@code calendar}. {@code true} otherwise\n+     */\n+    private boolean isIndexUpdatedAfter(Calendar calendar) {\n+        NodeBuilder indexStats = definitionBuilder.child(\":status\");\n+        PropertyState indexLastUpdatedValue = indexStats.getProperty(\"lastUpdated\");\n+        if (indexLastUpdatedValue != null) {\n+            Calendar indexLastUpdatedTime = ISO8601.parse(indexLastUpdatedValue.getValue(Type.DATE));\n+            return indexLastUpdatedTime.after(calendar);\n+        } else {\n+            return true;\n         }\n     }\n \n", "nb_test": 354, "linesAdd": 55, "jira_id": "4066", "singleLine": false, "nb_skipped": 6, "commit": "9a109aa3", "nb_failure": 1, "linesRem": 21}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["splitRevisionsManyClusterNodes(org.apache.jackrabbit.oak.plugins.document.DocumentSplitTest): expected:<2> but was:<0>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex bb5984c..bd753f7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -969,7 +969,8 @@ boolean isConflicting(@Nonnull UpdateOp op,\n             UpdateUtils.applyChanges(oldDoc, old, context.getRevisionComparator());\n             setSplitDocProps(this, oldDoc, old, high);\n             // only split if enough of the data can be moved to old document\n-            if (oldDoc.getMemory() > getMemory() * SPLIT_RATIO) {\n+            if (oldDoc.getMemory() > getMemory() * SPLIT_RATIO\n+                    || numValues >= NUM_REVS_THRESHOLD) {\n                 splitOps.add(old);\n             } else {\n                 main = null;\n", "nb_test": 1846, "linesAdd": 2, "jira_id": "1770", "singleLine": false, "nb_skipped": 9, "commit": "192ee9e4", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["tooManyReadsOnGetNewestRevision(org.apache.jackrabbit.oak.plugins.document.NodeDocumentTest): expected:<1> but was:<10>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex cdff3e1..e36d1ad 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -19,6 +19,7 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.NavigableMap;\n@@ -39,6 +40,7 @@\n import com.google.common.collect.AbstractIterator;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Queues;\n import org.apache.jackrabbit.oak.cache.CacheValue;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n@@ -54,7 +56,6 @@\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n-import com.google.common.primitives.Longs;\n \n import static com.google.common.base.Objects.equal;\n import static com.google.common.base.Preconditions.checkArgument;\n@@ -65,6 +66,7 @@\n import static org.apache.jackrabbit.oak.plugins.document.StableRevisionComparator.REVERSE;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation;\n+import static org.apache.jackrabbit.oak.plugins.document.util.Utils.abortingIterable;\n import static org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision;\n \n /**\n@@ -759,18 +761,24 @@ Revision getNewestRevision(final RevisionContext context,\n         }\n         // if we don't have clusterIds, we can use the local changes only\n         boolean fullScan = true;\n-        Iterable<Revision> changes;\n-        if (clusterIds.isEmpty()) {\n-            // baseRev is newer than all previous documents\n-            changes = Iterables.mergeSorted(\n+        Iterable<Revision> changes = Iterables.mergeSorted(\n                 ImmutableList.of(\n                         getLocalRevisions().keySet(),\n                         getLocalCommitRoot().keySet()),\n-                    getLocalRevisions().comparator());\n-        } else {\n+                getLocalRevisions().comparator()\n+        );\n+        if (!clusterIds.isEmpty()) {\n+            // there are some previous documents that potentially\n+            // contain changes after 'lower' revision vector\n             // include previous documents as well (only needed in rare cases)\n             fullScan = false;\n-            changes = getAllChanges();\n+            changes = Iterables.mergeSorted(\n+                    ImmutableList.of(\n+                            changes,\n+                            getChanges(REVISIONS, lower),\n+                            getChanges(COMMIT_ROOT, lower)\n+                    ), getLocalRevisions().comparator()\n+            );\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" +\n                                 \"_revisions {}, _commitRoot {}\",\n@@ -1453,90 +1461,18 @@ NodeDocument findPrevReferencingDoc(Revision revision, int height) {\n      * @return revisions of all changes performed on this document.\n      */\n     Iterable<Revision> getAllChanges() {\n-        final SortedSet<Revision> stack = Sets.newTreeSet(REVERSE);\n-        // initialize with local revisions and commitRoot entries\n-        stack.addAll(getLocalCommitRoot().keySet());\n-        stack.addAll(getLocalRevisions().keySet());\n-        if (getPreviousRanges().isEmpty()) {\n-            return stack;\n-        }\n-        return new Iterable<Revision>() {\n-            @Override\n-            public Iterator<Revision> iterator() {\n-                final Iterator<NodeDocument> previousDocs = getPreviousDocLeaves();\n-                return new AbstractIterator<Revision>() {\n-                    private NodeDocument nextDoc;\n-                    private Revision nextRevision;\n-                    @Override\n-                    protected Revision computeNext() {\n-                        if (stack.isEmpty()) {\n-                            return endOfData();\n-                        }\n-                        Revision next = stack.first();\n-                        stack.remove(next);\n-                        fillStackIfNeeded();\n-                        return next;\n-                    }\n-\n-                    private void fillStackIfNeeded() {\n-                        for (;;) {\n-                            fetchNextDoc();\n-\n-                            // no more changes to compare with\n-                            if (nextDoc == null) {\n-                                return;\n-                            }\n-\n-                            // check if current top revision is still newer than\n-                            // most recent revision of next document\n-                            if (!stack.isEmpty()) {\n-                                Revision top = stack.first();\n-                                if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {\n-                                    return;\n-                                }\n-                            }\n-\n-                            // if we get here, we need to pull in changes\n-                            // from nextDoc\n-                            Iterables.addAll(stack, nextDoc.getAllChanges());\n-                            nextDoc = null;\n-                            nextRevision = null;\n-                        }\n-                    }\n-\n-                    /**\n-                     * Fetch the next document if {@code nextDoc} is\n-                     * {@code null} and there are more documents.\n-                     */\n-                    private void fetchNextDoc() {\n-                        for (;;) {\n-                            if (nextDoc != null) {\n-                                break;\n-                            }\n-                            if (!previousDocs.hasNext()) {\n-                                // no more previous docs\n-                                break;\n-                            }\n-                            nextDoc = previousDocs.next();\n-                            Iterator<Revision> changes = nextDoc.getAllChanges().iterator();\n-                            if (changes.hasNext()) {\n-                                nextRevision = changes.next();\n-                                break;\n-                            } else {\n-                                // empty document, try next\n-                                nextDoc = null;\n-                            }\n-                        }\n-                    }\n-                };\n-            }\n-        };\n+        RevisionVector empty = new RevisionVector();\n+        return Iterables.mergeSorted(ImmutableList.of(\n+                getChanges(REVISIONS, empty),\n+                getChanges(COMMIT_ROOT, empty)\n+        ), StableRevisionComparator.REVERSE);\n     }\n \n     /**\n      * Returns all changes for the given property back to {@code min} revision\n      * (exclusive). The revisions include committed as well as uncommitted\n-     * changes.\n+     * changes. The returned revisions are sorted in reverse order (newest\n+     * first).\n      *\n      * @param property the name of the property.\n      * @param min the lower bound revision (exclusive).\n@@ -1545,43 +1481,27 @@ private void fetchNextDoc() {\n     @Nonnull\n     Iterable<Revision> getChanges(@Nonnull final String property,\n                                   @Nonnull final RevisionVector min) {\n-        return new Iterable<Revision>() {\n-            @Override\n-            public Iterator<Revision> iterator() {\n-                final Set<Revision> changes = getValueMap(property).keySet();\n-                final Set<Integer> clusterIds = Sets.newHashSet();\n-                for (Revision r : getLocalMap(property).keySet()) {\n-                    clusterIds.add(r.getClusterId());\n-                }\n-                for (Range r : getPreviousRanges().values()) {\n-                    if (min.isRevisionNewer(r.high)) {\n-                        clusterIds.add(r.high.getClusterId());\n-                    }\n-                }\n-                final Iterator<Revision> unfiltered = changes.iterator();\n-                return new AbstractIterator<Revision>() {\n+        Predicate<Revision> p = new Predicate<Revision>() {\n             @Override\n-                    protected Revision computeNext() {\n-                        while (unfiltered.hasNext()) {\n-                            Revision next = unfiltered.next();\n-                            if (min.isRevisionNewer(next)) {\n-                                return next;\n-                            } else {\n-                                // further revisions with this clusterId\n-                                // are older than min revision\n-                                clusterIds.remove(next.getClusterId());\n-                                // no more revisions to check\n-                                if (clusterIds.isEmpty()) {\n-                                    return endOfData();\n+            public boolean apply(Revision input) {\n+                return min.isRevisionNewer(input);\n             }\n+        };\n+        List<Iterable<Revision>> changes = Lists.newArrayList();\n+        changes.add(abortingIterable(getLocalMap(property).keySet(), p));\n+        for (Map.Entry<Revision, Range> e : getPreviousRanges().entrySet()) {\n+            if (min.isRevisionNewer(e.getKey())) {\n+                final NodeDocument prev = getPreviousDoc(e.getKey(), e.getValue());\n+                if (prev != null) {\n+                    changes.add(abortingIterable(prev.getValueMap(property).keySet(), p));\n                 }\n             }\n-                        return endOfData();\n         }\n-                };\n+        if (changes.size() == 1) {\n+            return changes.get(0);\n+        } else {\n+            return Iterables.mergeSorted(changes, StableRevisionComparator.REVERSE);\n         }\n-        };\n-\n     }\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java\nindex c7a4253..40ad9bb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java\n@@ -758,4 +758,36 @@ public static long getMinTimestampForDiff(@Nonnull RevisionVector fromRev,\n         }\n         return min;\n     }\n+\n+    /**\n+     * Wraps the given iterable and aborts iteration over elements when the\n+     * predicate on an element evaluates to {@code false}.\n+     *\n+     * @param iterable the iterable to wrap.\n+     * @param p the predicate.\n+     * @return the aborting iterable.\n+     */\n+    public static <T> Iterable<T> abortingIterable(final Iterable<T> iterable,\n+                                                   final Predicate<T> p) {\n+        checkNotNull(iterable);\n+        checkNotNull(p);\n+        return new Iterable<T>() {\n+            @Override\n+            public Iterator<T> iterator() {\n+                final Iterator<T> it = iterable.iterator();\n+                return new AbstractIterator<T>() {\n+                    @Override\n+                    protected T computeNext() {\n+                        if (it.hasNext()) {\n+                            T next = it.next();\n+                            if (p.apply(next)) {\n+                                return next;\n+                            }\n+                        }\n+                        return endOfData();\n+                    }\n+                };\n+            }\n+        };\n+    }\n }\n", "nb_test": 2886, "linesAdd": 58, "jira_id": "4358", "singleLine": false, "nb_skipped": 1, "commit": "74cbba24", "nb_failure": 1, "linesRem": 101}, {"files": 0, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["resetConflictAddExistingNode(org.apache.jackrabbit.oak.plugins.mongomk.MongoMKResetTest): /foo does not exist", "resetConflictRemoveRemovedNode(org.apache.jackrabbit.oak.plugins.mongomk.MongoMKResetTest): /foo should not exist"], "patch": "", "nb_test": 1443, "linesAdd": 0, "jira_id": "1186", "singleLine": false, "nb_skipped": 6, "commit": "52372042", "nb_failure": 2, "linesRem": 0}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTokenAuthInfo(org.apache.jackrabbit.oak.security.authentication.Jackrabbit2ConfigurationTest): userid must be correct expected:<admin> but was:<null>", "testTokenAuthInfo(org.apache.jackrabbit.oak.security.authentication.TokenDefaultLoginModuleTest): userid must be correct expected:<admin> but was:<null>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenLoginModule.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenLoginModule.java\nindex 79a05df..74f5281 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenLoginModule.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenLoginModule.java\n@@ -170,7 +170,8 @@ public boolean commit() throws LoginException {\n                     for (String name : attributes.keySet()) {\n                         tc.setAttribute(name, attributes.get(name));\n                     }\n-                    updateSubject(tc, getAuthInfo(ti), null);\n+                    sharedState.put(SHARED_KEY_ATTRIBUTES, attributes);\n+                    updateSubject(tc, null, null);\n                 } else {\n                     // failed to create token -> fail commit()\n                     log.debug(\"TokenProvider failed to create a login token for user \" + userId);\n@@ -236,19 +237,21 @@ private TokenProvider getTokenProvider() {\n      * @param tokenInfo The tokenInfo to retrieve attributes from.\n      * @return The {@code AuthInfo} resulting from the successful login.\n      */\n-    @Nonnull\n-    private AuthInfo getAuthInfo(TokenInfo tokenInfo) {\n+    @CheckForNull\n+    private AuthInfo getAuthInfo(@Nullable TokenInfo tokenInfo) {\n+        if (tokenInfo != null) {\n             Map<String, Object> attributes = new HashMap<String, Object>();\n-        if (tokenProvider != null && tokenInfo != null) {\n             Map<String, String> publicAttributes = tokenInfo.getPublicAttributes();\n             for (String attrName : publicAttributes.keySet()) {\n                 attributes.put(attrName, publicAttributes.get(attrName));\n             }\n+            return new AuthInfoImpl(tokenInfo.getUserId(), attributes, principals);\n+        } else {\n+            return null;\n         }\n-        return new AuthInfoImpl(userId, attributes, principals);\n     }\n \n-    private void updateSubject(@Nonnull TokenCredentials tc, @Nonnull AuthInfo authInfo,\n+    private void updateSubject(@Nonnull TokenCredentials tc, @Nullable AuthInfo authInfo,\n                                @Nullable Set<? extends Principal> principals) {\n         if (!subject.isReadOnly()) {\n             subject.getPublicCredentials().add(tc);\n@@ -257,12 +260,9 @@ private void updateSubject(@Nonnull TokenCredentials tc, @Nonnull AuthInfo authI\n                 subject.getPrincipals().addAll(principals);\n             }\n \n-            // replace all existing auth-info\n-            Set<AuthInfo> ais = subject.getPublicCredentials(AuthInfo.class);\n-            if (!ais.isEmpty()) {\n-                subject.getPublicCredentials().removeAll(ais);\n+            if (authInfo != null) {\n+                setAuthInfo(authInfo, subject);\n             }\n-            subject.getPublicCredentials().add(authInfo);\n         }\n     }\n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/user/LoginModuleImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/user/LoginModuleImpl.java\nindex 6434c4b..489b5d2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/user/LoginModuleImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/user/LoginModuleImpl.java\n@@ -33,9 +33,9 @@\n \n import org.apache.jackrabbit.oak.api.AuthInfo;\n import org.apache.jackrabbit.oak.spi.security.ConfigurationParameters;\n-import org.apache.jackrabbit.oak.spi.security.authentication.AuthInfoImpl;\n import org.apache.jackrabbit.oak.spi.security.SecurityProvider;\n import org.apache.jackrabbit.oak.spi.security.authentication.AbstractLoginModule;\n+import org.apache.jackrabbit.oak.spi.security.authentication.AuthInfoImpl;\n import org.apache.jackrabbit.oak.spi.security.authentication.Authentication;\n import org.apache.jackrabbit.oak.spi.security.authentication.ImpersonationCredentials;\n import org.apache.jackrabbit.oak.spi.security.user.UserConfiguration;\n@@ -143,10 +143,7 @@ public boolean commit() {\n             if (!subject.isReadOnly()) {\n                 subject.getPrincipals().addAll(principals);\n                 subject.getPublicCredentials().add(credentials);\n-                Set<AuthInfo> ais = subject.getPublicCredentials(AuthInfo.class);\n-                if (ais.isEmpty()) {\n-                    subject.getPublicCredentials().add(createAuthInfo());\n-                }\n+                setAuthInfo(createAuthInfo(), subject);\n             } else {\n                 log.debug(\"Could not add information to read only subject {}\", subject);\n             }\n@@ -213,14 +210,19 @@ private String getAnonymousId() {\n     }\n \n     private AuthInfo createAuthInfo() {\n-        Map<String, Object> attributes = new HashMap<String, Object>();\n         Credentials creds;\n         if (credentials instanceof ImpersonationCredentials) {\n             creds = ((ImpersonationCredentials) credentials).getBaseCredentials();\n         } else {\n             creds = credentials;\n         }\n-        if (creds instanceof SimpleCredentials) {\n+        Map<String, Object> attributes = new HashMap<String, Object>();\n+        Object shared = sharedState.get(SHARED_KEY_ATTRIBUTES);\n+        if (shared instanceof Map) {\n+            for (Object key : ((Map) shared).keySet()) {\n+                attributes.put(key.toString(), ((Map) shared).get(key));\n+            }\n+        } else if (creds instanceof SimpleCredentials) {\n             SimpleCredentials sc = (SimpleCredentials) creds;\n             for (String attrName : sc.getAttributeNames()) {\n                 attributes.put(attrName, sc.getAttribute(attrName));\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/AbstractLoginModule.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/AbstractLoginModule.java\nindex 5a73a5c..e9a2d8d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/AbstractLoginModule.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/AbstractLoginModule.java\n@@ -35,6 +35,7 @@\n import javax.security.auth.spi.LoginModule;\n \n import org.apache.jackrabbit.api.security.user.UserManager;\n+import org.apache.jackrabbit.oak.api.AuthInfo;\n import org.apache.jackrabbit.oak.api.ContentRepository;\n import org.apache.jackrabbit.oak.api.ContentSession;\n import org.apache.jackrabbit.oak.api.Root;\n@@ -154,6 +155,12 @@\n      */\n     public static final String SHARED_KEY_LOGIN_NAME = \"javax.security.auth.login.name\";\n \n+    /**\n+     * Key of the sharedState entry referring to public attributes that are shared\n+     * between multiple login modules.\n+     */\n+    public static final String SHARED_KEY_ATTRIBUTES = \"javax.security.auth.login.attributes\";\n+\n     protected Subject subject;\n     protected CallbackHandler callbackHandler;\n     protected Map sharedState;\n@@ -441,4 +448,12 @@ protected PrincipalProvider getPrincipalProvider() {\n             return principalProvider.getPrincipals(userId);\n         }\n     }\n+\n+    static protected void setAuthInfo(@Nonnull AuthInfo authInfo, @Nonnull Subject subject) {\n+        Set<AuthInfo> ais = subject.getPublicCredentials(AuthInfo.class);\n+        if (!ais.isEmpty()) {\n+            subject.getPublicCredentials().removeAll(ais);\n+        }\n+        subject.getPublicCredentials().add(authInfo);\n+    }\n }\n", "nb_test": 1562, "linesAdd": 31, "jira_id": "1363", "singleLine": false, "nb_skipped": 6, "commit": "69b68890", "nb_failure": 2, "linesRem": 17}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["getNodes(org.apache.jackrabbit.oak.jcr.RepositoryTest): expected:<3> but was:<-1>", "getProperties(org.apache.jackrabbit.oak.jcr.RepositoryTest): expected:<4> but was:<-1>"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex 90b9c74..fbdc48d 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.jackrabbit.oak.jcr;\n \n-import static org.apache.jackrabbit.oak.util.Iterators.filter;\n-\n import java.io.InputStream;\n import java.math.BigDecimal;\n import java.util.ArrayList;\n@@ -70,6 +68,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.jackrabbit.oak.util.Iterators.filter;\n+\n /**\n  * {@code NodeImpl}...\n  */\n@@ -441,7 +441,8 @@ public NodeIterator getNodes() throws RepositoryException {\n         checkStatus();\n \n         Iterator<NodeDelegate> children = dlg.getChildren();\n-        return new NodeIteratorAdapter(nodeIterator(children));\n+        long size = dlg.getChildCount();\n+        return new NodeIteratorAdapter(nodeIterator(children), size);\n     }\n \n     @Override\n@@ -505,7 +506,8 @@ public PropertyIterator getProperties() throws RepositoryException {\n         checkStatus();\n \n         Iterator<PropertyDelegate> properties = dlg.getProperties();\n-        return new PropertyIteratorAdapter(propertyIterator(properties));\n+        long size = dlg.getPropertyCount();\n+        return new PropertyIteratorAdapter(propertyIterator(properties), size);\n     }\n \n     @Override\n", "nb_test": 194, "linesAdd": 6, "jira_id": "135", "singleLine": false, "nb_skipped": 1, "commit": "438e31a7", "nb_failure": 2, "linesRem": 4}, {"files": 4, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["potentialClashOfCommitIds(org.apache.jackrabbit.mk.MicroKernelImplTest): org.h2.jdbc.JdbcSQLException: Unique index or primary key violation: \"PRIMARY_KEY_2 ON PUBLIC.REVS(ID)\"; SQL statement:"], "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/H2Persistence.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/H2Persistence.java\nindex d6cb3b5..76030db 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/H2Persistence.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/H2Persistence.java\n@@ -70,6 +70,7 @@ public void initialize(File homeDir) throws Exception {\n         try {\n             Statement stmt = con.createStatement();\n             stmt.execute(\"create table if not exists REVS(ID binary primary key, DATA binary, TIME timestamp)\");\n+            stmt.execute(\"create table if not exists NODES(ID binary primary key, DATA binary, TIME timestamp)\");\n             stmt.execute(\"create table if not exists HEAD(ID binary) as select null\");\n             stmt.execute(\"create sequence if not exists DATASTORE_ID\");\n /*\n@@ -86,7 +87,16 @@ public void close() {\n         cp.dispose();\n     }\n \n-    public Id readHead() throws Exception {\n+    public Id[] readIds() throws Exception {\n+        Id lastCommitId = null;\n+        Id headId = readHead();\n+        if (headId != null) {\n+            lastCommitId = readLastCommitId();\n+        }\n+        return new Id[] { headId, lastCommitId };\n+    }\n+    \n+    private Id readHead() throws Exception {\n         Connection con = cp.getConnection();\n         try {\n             PreparedStatement stmt = con.prepareStatement(\"select * from HEAD\");\n@@ -102,6 +112,22 @@ public Id readHead() throws Exception {\n         }\n     }\n \n+    private Id readLastCommitId() throws Exception {\n+        Connection con = cp.getConnection();\n+        try {\n+            PreparedStatement stmt = con.prepareStatement(\"select MAX(ID) from REVS\");\n+            ResultSet rs = stmt.executeQuery();\n+            byte[] rawId = null;\n+            if (rs.next()) {\n+                rawId = rs.getBytes(1);\n+            }\n+            stmt.close();\n+            return rawId == null ? null : new Id(rawId); \n+        } finally {\n+            con.close();\n+        }\n+    }\n+\n     public void writeHead(Id id) throws Exception {\n         Connection con = cp.getConnection();\n         try {\n@@ -118,7 +144,7 @@ public void readNode(StoredNode node) throws NotFoundException, Exception {\n         Id id = node.getId();\n         Connection con = cp.getConnection();\n         try {\n-            PreparedStatement stmt = con.prepareStatement(\"select DATA from REVS where ID = ?\");\n+            PreparedStatement stmt = con.prepareStatement(\"select DATA from NODES where ID = ?\");\n             try {\n                 stmt.setBytes(1, id.getBytes());\n                 ResultSet rs = stmt.executeQuery();\n@@ -148,7 +174,7 @@ public Id writeNode(Node node) throws Exception {\n         try {\n             PreparedStatement stmt = con\n                     .prepareStatement(\n-                            \"insert into REVS (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from REVS where ID = ?)\");\n+                            \"insert into NODES (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from NODES where ID = ?)\");\n             try {\n                 stmt.setBytes(1, rawId);\n                 stmt.setBytes(2, bytes);\n@@ -212,7 +238,7 @@ public void writeCommit(Id id, Commit commit) throws Exception {\n     public ChildNodeEntriesMap readCNEMap(Id id) throws NotFoundException, Exception {\n         Connection con = cp.getConnection();\n         try {\n-            PreparedStatement stmt = con.prepareStatement(\"select DATA from REVS where ID = ?\");\n+            PreparedStatement stmt = con.prepareStatement(\"select DATA from NODES where ID = ?\");\n             try {\n                 stmt.setBytes(1, id.getBytes());\n                 ResultSet rs = stmt.executeQuery();\n@@ -241,7 +267,7 @@ public Id writeCNEMap(ChildNodeEntries map) throws Exception {\n         try {\n             PreparedStatement stmt = con\n                     .prepareStatement(\n-                            \"insert into REVS (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from REVS where ID = ?)\");\n+                            \"insert into NODES (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from NODES where ID = ?)\");\n             try {\n                 stmt.setBytes(1, rawId);\n                 stmt.setBytes(2, bytes);\n@@ -264,7 +290,7 @@ public void start() {\n     \n     @Override\n     public boolean markCommit(Id id) throws Exception {\n-        return touch(id, gcStart);\n+        return touch(\"REVS\", id, gcStart);\n     }\n \n     @Override\n@@ -292,22 +318,23 @@ public void replaceCommit(Id id, Commit commit) throws Exception {\n     \n     @Override\n     public boolean markNode(Id id) throws Exception {\n-        return touch(id, gcStart);\n+        return touch(\"NODES\", id, gcStart);\n     }\n \n     @Override\n     public boolean markCNEMap(Id id) throws Exception {\n-        return touch(id, gcStart);\n+        return touch(\"NODES\", id, gcStart);\n     }\n     \n-    private boolean touch(Id id, long timeMillis) throws Exception {\n+    private boolean touch(String table, Id id, long timeMillis) throws Exception {\n         Timestamp ts = new Timestamp(timeMillis);\n \n         Connection con = cp.getConnection();\n         try {\n-            PreparedStatement stmt = con\n-                    .prepareStatement(\n-                            \"update REVS set TIME = ? where ID = ? and TIME < ?\");\n+            PreparedStatement stmt = con.prepareStatement(\n+                    String.format(\"update %s set TIME = ? where ID = ? and TIME < ?\",\n+                            table));\n+                                    \n             try {\n                 stmt.setTimestamp(1, ts);\n                 stmt.setBytes(2, id.getBytes());\n@@ -324,20 +351,29 @@ private boolean touch(Id id, long timeMillis) throws Exception {\n     @Override\n     public int sweep() throws Exception {\n         Timestamp ts = new Timestamp(gcStart);\n+        int swept = 0;\n \n         Connection con = cp.getConnection();\n         try {\n-            PreparedStatement stmt = con\n-                    .prepareStatement(\n-                            \"delete REVS where TIME < ?\");\n+            PreparedStatement stmt = con.prepareStatement(\"delete REVS where TIME < ?\");\n+            try {\n+                stmt.setTimestamp(1, ts);\n+                swept += stmt.executeUpdate();\n+            } finally {\n+                stmt.close();\n+            }\n+\n+            stmt = con.prepareStatement(\"delete NODES where TIME < ?\");\n+            \n             try {\n                 stmt.setTimestamp(1, ts);\n-                return stmt.executeUpdate();\n+                swept += stmt.executeUpdate();\n             } finally {\n                 stmt.close();\n             }\n         } finally {\n             con.close();\n         }\n+        return swept;\n      }\n }\n\\ No newline at end of file\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/InMemPersistence.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/InMemPersistence.java\nindex bba95fc..f8ddafe 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/InMemPersistence.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/InMemPersistence.java\n@@ -42,7 +42,6 @@\n     private final Map<Id, byte[]> objects = Collections.synchronizedMap(new HashMap<Id, byte[]>());\n     private final Map<Id, byte[]> marked = Collections.synchronizedMap(new HashMap<Id, byte[]>());\n \n-    private Id head;\n     private long gcStart;\n \n     // TODO: make this configurable\n@@ -53,12 +52,13 @@ public void initialize(File homeDir) {\n         // nothing to initialize\n     }\n     \n-    public Id readHead() {\n-        return head;\n+    @Override\n+    public Id[] readIds() throws Exception {\n+        return new Id[2];\n     }\n \n     public void writeHead(Id id) {\n-        head = id;\n+        \n     }\n \n     public void readNode(StoredNode node) throws NotFoundException, Exception {\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/Persistence.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/Persistence.java\nindex dbb4253..45ca883 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/Persistence.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/Persistence.java\n@@ -36,7 +36,19 @@\n \n     public void initialize(File homeDir) throws Exception;\n     \n-    Id readHead() throws Exception;\n+    /**\n+     * Return an array of ids, where the first is the head id (as stored\n+     * with {@link #writeHead(Id)}) and the second is the highest commit\n+     * id found or {@code null}.\n+     * <p/>\n+     * This method is not guaranteed to deliver \"live\" results, after\n+     * something is written to the storage, so it should better be used\n+     * once after initialization. \n+     * \n+     * @return array of ids\n+     * @throws Exception if an error occurs\n+     */\n+    Id[] readIds() throws Exception;\n \n     void writeHead(Id id) throws Exception;\n \ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\nindex 1d71ff8..42b50a5 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\n@@ -134,7 +134,8 @@ public void initialize() throws Exception {\n         cache = Collections.synchronizedMap(SimpleLRUCache.<Id, Object> newInstance(initialCacheSize));\n \n         // make sure we've got a HEAD commit\n-        head = pm.readHead();\n+        Id[] ids = pm.readIds();\n+        head = ids[0];\n         if (head == null || head.getBytes().length == 0) {\n             // assume virgin repository\n             byte[] rawHead = Id.fromLong(commitCounter.incrementAndGet())\n@@ -148,7 +149,11 @@ public void initialize() throws Exception {\n             pm.writeCommit(head, initialCommit);\n             pm.writeHead(head);\n         } else {\n-            commitCounter.set(Long.parseLong(head.toString(), 16));\n+            Id lastCommitId = head;\n+            if (ids[1] != null && ids[1].compareTo(lastCommitId) > 0) {\n+                lastCommitId = ids[1];\n+            }\n+            commitCounter.set(Long.parseLong(lastCommitId.toString(), 16));\n         }\n \n         if (gcpm != null) {\n", "nb_test": 72, "linesAdd": 64, "jira_id": "276", "singleLine": false, "nb_skipped": 1, "commit": "1bf5c550", "nb_failure": 0, "linesRem": 23}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBlobIdLengthLongerThanUpperLimit(org.apache.jackrabbit.oak.plugins.segment.file.ExternalBlobReferenceTest): Expected exception: java.lang.IllegalArgumentException"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\nindex abab3d4..ab762f7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n@@ -595,7 +595,12 @@ private synchronized RecordId writeValueRecord(String reference) {\n         byte[] data = reference.getBytes(Charsets.UTF_8);\n         int length = data.length;\n \n-        checkArgument(length < 8192);\n+        // When writing a binary ID, the four most significant bits of the\n+        // length field should be \"1110\", leaving 12 other bits to store the\n+        // length itself. This means that the values of the length field can\n+        // only range between 0 and 2^12 - 1.\n+\n+        checkArgument(length < 4096);\n \n         RecordId id = prepare(RecordType.VALUE, 2 + length);\n         int len = length | 0xE000;\n", "nb_test": 2209, "linesAdd": 2, "jira_id": "3105", "singleLine": false, "nb_skipped": 1, "commit": "311e8b33", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["mvp(org.apache.jackrabbit.oak.query.FilterTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\nindex 14d8639..6eb282e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n@@ -251,6 +251,13 @@ public void restrictProperty(String propertyName, Operator op, PropertyValue v)\n         PropertyValue oldLast = x.last;\n         switch (op) {\n         case EQUAL:\n+            if (x.first != null && x.last == x.first && x.firstIncluding && x.lastIncluding) {\n+                // there is already an equality condition on this property\n+                // we will keep this, as it could be a multi-valued property\n+                // (unlike in databases, \"x = 1 and x = 2\" can match a node\n+                // if x is a multi-valued property with value \"{1, 2}\")\n+                return;\n+            }\n             x.first = maxValue(oldFirst, v);\n             x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n             x.last = minValue(oldLast, v);\n", "nb_test": 1445, "linesAdd": 3, "jira_id": "1108", "singleLine": false, "nb_skipped": 6, "commit": "a8c925e0", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["copyOriginalNotChanged(org.apache.jackrabbit.mongomk.impl.model.MongoNodeTest): expected:<1> but was:<2>"], "patch": "diff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/impl/model/MongoNode.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/impl/model/MongoNode.java\nindex f58a597..4bbd8dc 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/impl/model/MongoNode.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/impl/model/MongoNode.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.jackrabbit.mongomk.impl.model;\n \n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -148,6 +149,11 @@ public void setRevisionId(long revisionId) {\n     public MongoNode copy() {\n         MongoNode copy = new MongoNode();\n         copy.putAll((Map) super.copy());\n+        List<String> children = getChildren();\n+        if (children != null) {\n+            copy.put(KEY_CHILDREN, new ArrayList<String>(children));\n+        }\n+        copy.put(KEY_PROPERTIES, new HashMap<String, Object>(getProperties()));\n         return copy;\n     }\n \n", "nb_test": 57, "linesAdd": 6, "jira_id": "596", "singleLine": false, "nb_skipped": 3, "commit": "9b268da0", "nb_failure": 1, "linesRem": 0}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFindUserPrincipal(org.apache.jackrabbit.oak.security.principal.PrincipalProviderImplTest): Expected principal to be found by name hint TestUser", "testFindGroupPrincipal(org.apache.jackrabbit.oak.security.principal.PrincipalProviderImplTest): Expected principal to be found by name hint TestGroup", "testFindWithoutHint(org.apache.jackrabbit.oak.security.principal.PrincipalProviderImplTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/QueryEngine.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/QueryEngine.java\nindex c43f58e..96b3ef8 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/QueryEngine.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/QueryEngine.java\n@@ -52,8 +52,8 @@\n      *\n      * @param statement the query statement\n      * @param language the language\n-     * @param limit the maximum result set size\n-     * @param offset the number of rows to skip\n+     * @param limit the maximum result set size (may not be negative)\n+     * @param offset the number of rows to skip (may not be negative)\n      * @param bindings the bind variable value bindings\n      * @param namePathMapper the name and path mapper to use\n      * @return the result\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\nindex 4dcb86b..e5d4adb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\n@@ -138,6 +138,12 @@ private Query parseQuery(String statement, String language) throws ParseExceptio\n     public Result executeQuery(String statement, String language, long limit,\n             long offset, Map<String, ? extends PropertyValue> bindings,\n             NamePathMapper namePathMapper) throws ParseException {\n+        if (limit < 0) {\n+            throw new IllegalArgumentException(\"Limit may not be negative, is: \" + limit);\n+        }\n+        if (offset < 0) {\n+            throw new IllegalArgumentException(\"Offset may not be negative, is: \" + offset);\n+        }\n         Query q = parseQuery(statement, language);\n         q.setRootTree(getRootTree());\n         q.setRootState(getRootState());\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/query/XPathQueryBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/query/XPathQueryBuilder.java\nindex 893738b..d1dd992 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/query/XPathQueryBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/query/XPathQueryBuilder.java\n@@ -35,7 +35,7 @@\n     private boolean sortIgnoreCase;\n     private Value bound;\n     private long offset;\n-    private long maxCount = -1;\n+    private long maxCount = Long.MAX_VALUE;\n \n     //-------------------------------------------------------< QueryBuilder >---\n     @Override\n", "nb_test": 413, "linesAdd": 7, "jira_id": "546", "singleLine": false, "nb_skipped": 1, "commit": "428e32c6", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["testTransientRemoveUUIDSameTree(org.apache.jackrabbit.oak.jcr.xml.ImportTest): ConstraintViolationException expected", "testTransientThrow(org.apache.jackrabbit.oak.jcr.xml.ImportTest): ItemExistsException expected", "testTransientReplaceUUID(org.apache.jackrabbit.oak.jcr.xml.ImportTest): OakConstraint0030: Uniqueness constraint violated at path [/] for one of the property in [jcr:uuid] having value aa04df9f-e9d4-4421-8b29-9cef12cd8230", "testTransientReplaceUUIDSameTree(org.apache.jackrabbit.oak.jcr.xml.ImportTest): OakConstraint0030: Uniqueness constraint violated at path [/] for one of the property in [jcr:uuid] having value d10811b4-8c32-4e9d-877b-7d733f039379", "testTransientRemoveUUID(org.apache.jackrabbit.oak.jcr.xml.ImportTest): OakConstraint0030: Uniqueness constraint violated at path [/] for one of the property in [jcr:uuid] having value ab5add50-2ca6-41de-9e47-844732ad6a05"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\nindex 176dffe..8e7e72f 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\n@@ -47,6 +47,7 @@\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import org.apache.jackrabbit.JcrConstants;\n+import org.apache.jackrabbit.oak.api.ContentSession;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Root;\n import org.apache.jackrabbit.oak.api.Tree;\n@@ -82,26 +83,10 @@\n     private final String userID;\n     private final AccessManager accessManager;\n \n-    /**\n-     * There are two IdentifierManagers used.\n-     *\n-     * 1) currentStateIdManager - Associated with current root on which all import\n-     *    operations are being performed\n-     *\n-     * 2) baseStateIdManager - Associated with the initial root on which\n-     *    no modifications are performed\n-     */\n-    private final IdentifierManager currentStateIdManager;\n-    private final IdentifierManager baseStateIdManager;\n-\n     private final EffectiveNodeTypeProvider effectiveNodeTypeProvider;\n     private final DefinitionProvider definitionProvider;\n \n-    /**\n-     * Set of newly created uuid from nodes which are\n-     * created in this import\n-     */\n-    private final Set<String> uuids = new HashSet<String>();\n+    private final IdResolver idLookup;\n \n     private final Stack<Tree> parents;\n \n@@ -171,8 +156,7 @@ public ImporterImpl(String absPath,\n \n         accessManager = sessionContext.getAccessManager();\n \n-        currentStateIdManager = new IdentifierManager(root);\n-        baseStateIdManager = new IdentifierManager(sd.getContentSession().getLatestRoot());\n+        idLookup = new IdResolver(root, sd.getContentSession());\n \n         refTracker = new ReferenceChangeTracker();\n \n@@ -465,24 +449,7 @@ public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos)\n                 }\n             } else {\n \n-                //1. First check from base state that tree corresponding to\n-                //this id exist\n-                Tree conflicting = baseStateIdManager.getTree(id);\n-\n-                if (conflicting == null) {\n-                    //1.a. Check if id is found in newly created nodes\n-                    if (uuids.contains(id)) {\n-                        conflicting = currentStateIdManager.getTree(id);\n-                    }\n-                } else {\n-                    //1.b Re obtain the conflicting tree from Id Manager\n-                    //associated with current root. Such that any operation\n-                    //on it gets reflected in later operations\n-                    //In case a tree with same id was removed earlier then it\n-                    //would return null\n-                    conflicting = currentStateIdManager.getTree(id);\n-                }\n-\n+                Tree conflicting = idLookup.getConflictingTree(id);\n                 if (conflicting != null && conflicting.exists()) {\n                     // resolve uuid conflict\n                     tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n@@ -522,22 +489,7 @@ public void endNode(NodeInfo nodeInfo) throws RepositoryException {\n             }\n         }\n \n-        collectUUIDs(parent);\n-    }\n-\n-    private void collectUUIDs(Tree tree) {\n-        if (tree == null) {\n-            return;\n-        }\n-\n-        String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n-        if (uuid != null) {\n-            uuids.add(uuid);\n-        }\n-\n-        for (Tree child : tree.getChildren()) {\n-            collectUUIDs(child);\n-        }\n+        idLookup.rememberImportedUUIDs(parent);\n     }\n \n     @Override\n@@ -621,4 +573,78 @@ private void setProperty(Iterable<String> newValues) {\n             tree.setProperty(prop);\n         }\n     }\n+\n+    /**\n+     * Resolves 'uuid' property values to {@code Tree} objects and optionally\n+     * keeps track of newly imported UUIDs.\n+     */\n+    private static final class IdResolver {\n+        /**\n+         * There are two IdentifierManagers used.\n+         *\n+         * 1) currentStateIdManager - Associated with current root on which all import\n+         *    operations are being performed\n+         *\n+         * 2) baseStateIdManager - Associated with the initial root on which\n+         *    no modifications are performed\n+         */\n+        private final IdentifierManager currentStateIdManager;\n+        private final IdentifierManager baseStateIdManager;\n+\n+        /**\n+         * Set of newly created uuid from nodes which are\n+         * created in this import, which are only remembered if the editing\n+         * session doesn't have any pending transient changes preventing this\n+         * performance optimisation from working properly (see OAK-2246).\n+         */\n+        private final Set<String> importedUUIDs;\n+\n+        private IdResolver(@Nonnull Root root, @Nonnull ContentSession contentSession) {\n+            currentStateIdManager = new IdentifierManager(root);\n+            baseStateIdManager = new IdentifierManager(contentSession.getLatestRoot());\n+\n+            if (!root.hasPendingChanges()) {\n+                importedUUIDs = new HashSet<String>();\n+            } else {\n+                importedUUIDs = null;\n+            }\n+        }\n+\n+\n+        @CheckForNull\n+        private Tree getConflictingTree(@Nonnull String id) {\n+            //1. First check from base state that tree corresponding to\n+            //this id exist\n+            Tree conflicting = baseStateIdManager.getTree(id);\n+            if (conflicting == null && importedUUIDs != null) {\n+                //1.a. Check if id is found in newly created nodes\n+                if (importedUUIDs.contains(id)) {\n+                    conflicting = currentStateIdManager.getTree(id);\n+                }\n+            } else {\n+                //1.b Re obtain the conflicting tree from Id Manager\n+                //associated with current root. Such that any operation\n+                //on it gets reflected in later operations\n+                //In case a tree with same id was removed earlier then it\n+                //would return null\n+                conflicting = currentStateIdManager.getTree(id);\n+            }\n+            return conflicting;\n+        }\n+\n+        private void rememberImportedUUIDs(@CheckForNull Tree tree) {\n+            if (tree == null || importedUUIDs == null) {\n+                return;\n+            }\n+\n+            String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n+            if (uuid != null) {\n+                importedUUIDs.add(uuid);\n+            }\n+\n+            for (Tree child : tree.getChildren()) {\n+                rememberImportedUUIDs(child);\n+            }\n+        }\n+    }\n }\n", "nb_test": 1351, "linesAdd": 52, "jira_id": "2246", "singleLine": false, "nb_skipped": 1, "commit": "dcadb0e1", "nb_failure": 2, "linesRem": 32}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["getMinimumTimestampSingleClusterId(org.apache.jackrabbit.oak.plugins.document.RevisionTest): expected:<2> but was:<1>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\nindex a9cff7e..3079d88 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n@@ -554,7 +554,14 @@ public long getMinimumTimestamp(@Nonnull Revision revision,\n                 return timestamp;\n             }\n             // go through all known cluster nodes\n-            for (List<RevisionRange> list : map.values()) {\n+            for (Map.Entry<Integer, List<RevisionRange>> e : map.entrySet()) {\n+                if (revision.getClusterId() == currentClusterNodeId\n+                        && e.getKey() == currentClusterNodeId) {\n+                    // range and revision is for current cluster node\n+                    // no need to adjust timestamp\n+                    continue;\n+                }\n+                List<RevisionRange> list = e.getValue();\n                 RevisionRange range;\n                 for (int i = list.size() - 1; i >= 0; i--) {\n                     range = list.get(i);\n", "nb_test": 2016, "linesAdd": 6, "jira_id": "2318", "singleLine": false, "nb_skipped": 9, "commit": "1d08cbd3", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAddEntriesWithCustomPrincipal(org.apache.jackrabbit.oak.security.authorization.accesscontrol.ACLTest): expected:<1> but was:<2>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/ACL.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/ACL.java\nindex a868b62..9b0afaa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/ACL.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/ACL.java\n@@ -190,7 +190,7 @@ private boolean internalAddEntry(@Nonnull ACE entry) throws RepositoryException\n         List<ACE> subList = Lists.newArrayList(Iterables.filter(entries, new Predicate<ACE>() {\n             @Override\n             public boolean apply(@Nullable ACE ace) {\n-                return (ace != null) && ace.getPrincipal().equals(principal);\n+                return (ace != null) && ace.getPrincipal().getName().equals(principal.getName());\n             }\n         }));\n \n", "nb_test": 1559, "linesAdd": 1, "jira_id": "1348", "singleLine": false, "nb_skipped": 6, "commit": "bc7b7e8c", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSurrogates(org.apache.jackrabbit.oak.commons.json.JsopTest): expected:<surrogate-broken: [\\ud800] > but was:<surrogate-broken: [?] >"], "patch": "diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\nindex a9a8b9a..8489197 100644\n--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n@@ -285,6 +285,7 @@ public static void escape(String s, StringBuilder buff) {\n     private static void escape(String s, int length, StringBuilder buff) {\n         for (int i = 0; i < length; i++) {\n             char c = s.charAt(i);\n+            int ic = (int)c;\n             switch (c) {\n             case '\"':\n                 // quotation mark\n@@ -316,10 +317,18 @@ private static void escape(String s, int length, StringBuilder buff) {\n                 break;\n             default:\n                 if (c < ' ') {\n-                    buff.append(\"\\\\u00\");\n-                    // guaranteed to be 1 or 2 hex digits only\n-                    buff.append(Character.forDigit(c >>> 4, 16));\n-                    buff.append(Character.forDigit(c & 15, 16));\n+                    buff.append(String.format(\"\\\\u%04x\", ic));\n+                } else if (ic >= 0xD800 && ic <= 0xDBFF) {\n+                    // isSurrogate(), only available in Java 7\n+                    if (i < length - 1 && Character.isSurrogatePair(c, s.charAt(i + 1))) {\n+                        // ok surrogate\n+                        buff.append(c);\n+                        buff.append(s.charAt(i + 1));\n+                        i += 1;\n+                    } else {\n+                        // broken surrogate -> escape\n+                        buff.append(String.format(\"\\\\u%04x\", ic));\n+                    }\n                 } else {\n                     buff.append(c);\n                 }\n", "nb_test": 53, "linesAdd": 10, "jira_id": "2389", "singleLine": false, "nb_skipped": 0, "commit": "8079f7b5", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["costEstimation(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexTest): cost: 0.0"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\nindex 433bac3..97a3408 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n@@ -164,7 +164,9 @@ public long count(NodeState indexMeta, Set<String> values, int max) {\n             int i = 0;\n             for (String p : values) {\n                 if (count > max && i > 3) {\n-                    count = count / size / i;\n+                    // the total count is extrapolated from the the number \n+                    // of values counted so far to the total number of values\n+                    count = count * size / i;\n                     break;\n                 }\n                 NodeState s = index.getChildNode(p);\n", "nb_test": 1269, "linesAdd": 1, "jira_id": "1035", "singleLine": false, "nb_skipped": 8, "commit": "b2ca8baa", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testInvalidJcrPaths(org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest)", "testInvalidOakPaths(org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest): Expected IllegalArgumentException", "testValidateInvalidPaths(org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\nindex 2dc5bee..2854048 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\n@@ -261,6 +261,7 @@ public static boolean parse(String jcrPath, Listener listener) {\n \n     public static boolean validate(String jcrPath) {\n         Listener listener = new Listener() {\n+            int depth;\n             boolean hasRoot;\n             @Override\n             public boolean root() {\n@@ -280,7 +281,8 @@ public boolean current() {\n \n             @Override\n             public boolean parent() {\n-                return true;\n+                depth--;\n+                return !hasRoot || depth >= 0;\n             }\n \n             @Override\n@@ -289,6 +291,7 @@ public void error(String message) {\n \n             @Override\n             public boolean name(String name, int index) {\n+                depth++;\n                 return true;\n             }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\nindex 65639f1..c19578f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n@@ -21,6 +21,7 @@\n \n import javax.annotation.Nonnull;\n \n+import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -77,7 +78,7 @@ public String getOakPathKeepIndex(String jcrPath) {\n \n     @Override\n     @Nonnull\n-    public String getJcrPath(String oakPath) {\n+    public String getJcrPath(final String oakPath) {\n         final List<String> elements = new ArrayList<String>();\n \n         if (\"/\".equals(oakPath)) {\n@@ -103,11 +104,18 @@ public boolean current() {\n \n             @Override\n             public boolean parent() {\n-                if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\n+                int prevIdx = elements.size() - 1;\n+                String prevElem = prevIdx >= 0 ? elements.get(prevIdx) : null;\n+\n+                if (prevElem == null || PathUtils.denotesParent(prevElem)) {\n                     elements.add(\"..\");\n                     return true;\n                 }\n-                elements.remove(elements.size() - 1);\n+                if (prevElem.isEmpty()) {\n+                    throw new IllegalArgumentException(\"Absolute path escapes root: \" + oakPath);\n+                }\n+\n+                elements.remove(prevElem);\n                 return true;\n             }\n \n@@ -150,7 +158,7 @@ public boolean name(String name, int index) {\n         return jcrPath.toString();\n     }\n \n-    private String getOakPath(String jcrPath, final boolean keepIndex) {\n+    private String getOakPath(final String jcrPath, final boolean keepIndex) {\n         if (\"/\".equals(jcrPath)) {\n             // avoid the need to special case the root path later on\n             return \"/\";\n@@ -237,11 +245,19 @@ public boolean current() {\n \n             @Override\n             public boolean parent() {\n-                if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\n+                int prevIdx = elements.size() - 1;\n+                String prevElem = prevIdx >= 0 ? elements.get(prevIdx) : null;\n+\n+                if (prevElem == null || PathUtils.denotesParent(prevElem)) {\n                     elements.add(\"..\");\n                     return true;\n                 }\n-                elements.remove(elements.size() - 1);\n+                if (prevElem.isEmpty()) {\n+                    parseErrors.append(\"Absolute path escapes root: \").append(jcrPath);\n+                    return false;\n+                }\n+\n+                elements.remove(prevElem);\n                 return true;\n             }\n \n", "nb_test": 404, "linesAdd": 26, "jira_id": "498", "singleLine": false, "nb_skipped": 0, "commit": "f2a2edec", "nb_failure": 3, "linesRem": 7}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 14, "classification": {"singleLine": false}, "failing_tests": ["verifyMemberOf(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberSplitUpgradeTest): Failed to copy content", "verifyGroupNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberSplitUpgradeTest): Failed to copy content", "verifyMembers(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberSplitUpgradeTest): Failed to copy content", "verifyNameSpaces(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyCustomPrivileges(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyCustomNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyNewBuiltinNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyReplacedBuiltinNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyGenericProperties(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyReferencePropertiesContent(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyVersionHistory(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest): Failed to copy content", "verifyMemberOf(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberUpgradeTest): Failed to copy content", "verifyGroupNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberUpgradeTest): Failed to copy content", "verifyMembers(org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberUpgradeTest): Failed to copy content"], "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\nindex c063a26..3752b91 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n@@ -32,6 +32,7 @@\n import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;\n import static org.apache.jackrabbit.JcrConstants.JCR_UUID;\n import static org.apache.jackrabbit.JcrConstants.MIX_REFERENCEABLE;\n+import static org.apache.jackrabbit.JcrConstants.NT_BASE;\n import static org.apache.jackrabbit.JcrConstants.NT_FROZENNODE;\n import static org.apache.jackrabbit.JcrConstants.NT_UNSTRUCTURED;\n import static org.apache.jackrabbit.oak.api.Type.NAME;\n@@ -131,6 +132,8 @@ private JackrabbitNodeState(\n         this.uriToPrefix = parent.uriToPrefix;\n         this.properties = createProperties(bundle);\n         this.nodes = createNodes(bundle);\n+        setChildOrder();\n+        fixFrozenUuid();\n         this.useBinaryReferences = parent.useBinaryReferences;\n         logNewNode(this);\n     }\n@@ -151,6 +154,7 @@ private JackrabbitNodeState(\n             NodePropBundle bundle = loader.loadBundle(id);\n             this.properties = createProperties(bundle);\n             this.nodes = createNodes(bundle);\n+            setChildOrder();\n         } catch (ItemStateException e) {\n             throw new IllegalStateException(\"Unable to access node \" + id, e);\n         }\n@@ -239,6 +243,13 @@ public NodeBuilder builder() {\n \n     //-----------------------------------------------------------< private >--\n \n+    private void setChildOrder() {\n+        if (isOrderable.apply(this)) {\n+            properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(\n+                    OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));\n+        }\n+    }\n+\n     private Map<String, NodeId> createNodes(NodePropBundle bundle) {\n         Map<String, NodeId> children = newLinkedHashMap();\n         for (ChildNodeEntry entry : bundle.getChildNodeEntries()) {\n@@ -282,11 +293,6 @@ public NodeBuilder builder() {\n                     JCR_UUID, bundle.getId().toString()));\n         }\n \n-        if (isOrderable.apply(primary, mixins)) {\n-            properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(\n-                    OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));\n-        }\n-\n         for (PropertyEntry property : bundle.getPropertyEntries()) {\n             String name = createName(property.getName());\n             try {\n@@ -303,18 +309,22 @@ public NodeBuilder builder() {\n             }\n         }\n \n+        return properties;\n+    }\n+\n+    private void fixFrozenUuid() {\n         // OAK-1789: Convert the jcr:frozenUuid of a non-referenceable\n         // frozen node from UUID to a path identifier\n         PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\n         if (frozenUuid != null\n                 && frozenUuid.getType() == STRING\n-                && isFrozenNode.apply(primary, mixins)) {\n-            String frozenPrimary = NT_UNSTRUCTURED;\n+                && isFrozenNode.apply(this)) {\n+            String frozenPrimary = NT_BASE;\n             Set<String> frozenMixins = newHashSet();\n \n             PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\n             if (property != null && property.getType() == NAME) {\n-                primary = property.getValue(NAME);\n+                frozenPrimary = property.getValue(NAME);\n             }\n             property = properties.get(JCR_FROZENMIXINTYPES);\n             if (property != null && property.getType() == NAMES) {\n@@ -328,8 +338,6 @@ public NodeBuilder builder() {\n                 properties.put(JCR_FROZENUUID, frozenUuid);\n             }\n         }\n-\n-        return properties;\n     }\n \n     private org.apache.jackrabbit.oak.api.PropertyState createProperty(\n", "nb_test": 14, "linesAdd": 18, "jira_id": "1789", "singleLine": false, "nb_skipped": 0, "commit": "9f7c1df0", "nb_failure": 0, "linesRem": 10}, {"files": 4, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["modifiedReset(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): 1469806745 < 1469806750"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex e0eb865..e63e2d8 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -1205,7 +1205,7 @@ public static void setChildrenFlag(@Nonnull UpdateOp op,\n \n     public static void setModified(@Nonnull UpdateOp op,\n                                    @Nonnull Revision revision) {\n-        checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n+        checkNotNull(op).max(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n     }\n \n     public static void setRevision(@Nonnull UpdateOp op,\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\nindex f00df7a..b957c37 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n@@ -131,9 +131,7 @@ public boolean hasChanges() {\n      * @param value the value\n      */\n     void setMapEntry(@Nonnull String property, @Nonnull Revision revision, String value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.SET_MAP_ENTRY;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.SET_MAP_ENTRY, value);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -145,8 +143,7 @@ void setMapEntry(@Nonnull String property, @Nonnull Revision revision, String va\n      * @param revision the revision\n      */\n     public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.REMOVE_MAP_ENTRY;\n+        Operation op = new Operation(Operation.Type.REMOVE_MAP_ENTRY, null);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -157,9 +154,23 @@ public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision)\n      * @param value the value\n      */\n     void set(String property, Object value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.SET;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.SET, value);\n+        changes.put(new Key(property, null), op);\n+    }\n+\n+    /**\n+     * Set the property to the given value if the new value is higher than the\n+     * existing value. The property is also set to the given value if the\n+     * property does not yet exist.\n+     * <p>\n+     * The result of a max operation with different types of values is\n+     * undefined.\n+     *\n+     * @param property the name of the property to set.\n+     * @param value the new value for the property.\n+     */\n+    <T> void max(String property, Comparable<T> value) {\n+        Operation op = new Operation(Operation.Type.MAX, value);\n         changes.put(new Key(property, null), op);\n     }\n \n@@ -187,9 +198,7 @@ void containsMapEntry(@Nonnull String property,\n         if (isNew) {\n             throw new IllegalStateException(\"Cannot use containsMapEntry() on new document\");\n         }\n-        Operation op = new Operation();\n-        op.type = Operation.Type.CONTAINS_MAP_ENTRY;\n-        op.value = exists;\n+        Operation op = new Operation(Operation.Type.CONTAINS_MAP_ENTRY, exists);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -200,9 +209,7 @@ void containsMapEntry(@Nonnull String property,\n      * @param value the increment\n      */\n     public void increment(@Nonnull String property, long value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.INCREMENT;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.INCREMENT, value);\n         changes.put(new Key(property, null), op);\n     }\n \n@@ -239,6 +246,14 @@ public String toString() {\n             SET,\n \n             /**\n+             * Set the value if the new value is higher than the existing value.\n+             * The new value is also considered higher, when there is no\n+             * existing value.\n+             * The sub-key is not used.\n+             */\n+            MAX,\n+\n+            /**\n              * Increment the Long value with the provided Long value.\n              * The sub-key is not used.\n              */\n@@ -267,12 +282,17 @@ public String toString() {\n         /**\n          * The operation type.\n          */\n-        public Type type;\n+        public final Type type;\n \n         /**\n          * The value, if any.\n          */\n-        public Object value;\n+        public final Object value;\n+\n+        Operation(Type type, Object value) {\n+            this.type = checkNotNull(type);\n+            this.value = value;\n+        }\n \n         @Override\n         public String toString() {\n@@ -283,18 +303,16 @@ public Operation getReverse() {\n             Operation reverse = null;\n             switch (type) {\n             case INCREMENT:\n-                reverse = new Operation();\n-                reverse.type = Type.INCREMENT;\n-                reverse.value = -(Long) value;\n+                reverse = new Operation(Type.INCREMENT, -(Long) value);\n                 break;\n             case SET:\n+            case MAX:\n             case REMOVE_MAP_ENTRY:\n             case CONTAINS_MAP_ENTRY:\n                 // nothing to do\n                 break;\n             case SET_MAP_ENTRY:\n-                reverse = new Operation();\n-                reverse.type = Type.REMOVE_MAP_ENTRY;\n+                reverse = new Operation(Type.REMOVE_MAP_ENTRY, null);\n                 break;\n             }\n             return reverse;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\nindex b8015ff..240665d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\n@@ -44,7 +44,9 @@\n      * @param comparator\n      *            the revision comparator.\n      */\n-    public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\n+    public static void applyChanges(@Nonnull Document doc,\n+                                    @Nonnull UpdateOp update,\n+                                    @Nonnull Comparator<Revision> comparator) {\n         for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\n             Key k = e.getKey();\n             Operation op = e.getValue();\n@@ -53,6 +55,15 @@ public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update,\n                     doc.put(k.toString(), op.value);\n                     break;\n                 }\n+                case MAX: {\n+                    Comparable newValue = (Comparable) op.value;\n+                    Object old = doc.get(k.toString());\n+                    //noinspection unchecked\n+                    if (old == null || newValue.compareTo(old) > 0) {\n+                        doc.put(k.toString(), op.value);\n+                    }\n+                    break;\n+                }\n                 case INCREMENT: {\n                     Object old = doc.get(k.toString());\n                     Long x = (Long) op.value;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\nindex 0266e38..684f39f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n@@ -29,6 +29,8 @@\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.locks.Lock;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n import javax.annotation.CheckForNull;\n import javax.annotation.Nonnull;\n@@ -127,6 +129,7 @@\n     private String lastReadWriteMode;\n \n     public MongoDocumentStore(DB db, DocumentMK.Builder builder) {\n+        checkVersion(db);\n         nodes = db.getCollection(\n                 Collection.NODES.toString());\n         clusterNodes = db.getCollection(\n@@ -179,6 +182,24 @@ public MongoDocumentStore(DB db, DocumentMK.Builder builder) {\n                 builder.getDocumentCacheSize());\n     }\n \n+    private static void checkVersion(DB db) {\n+        String version = db.command(\"buildInfo\").getString(\"version\");\n+        Matcher m = Pattern.compile(\"^(\\\\d+)\\\\.(\\\\d+)\\\\..*\").matcher(version);\n+        if (!m.matches()) {\n+            throw new IllegalArgumentException(\"Malformed MongoDB version: \" + version);\n+        }\n+        int major = Integer.parseInt(m.group(1));\n+        int minor = Integer.parseInt(m.group(2));\n+        if (major > 2) {\n+            return;\n+        }\n+        if (minor < 6) {\n+            String msg = \"MongoDB version 2.6.0 or higher required. \" +\n+                    \"Currently connected to a MongoDB with version: \" + version;\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n     private Cache<CacheValue, NodeDocument> createOffHeapCache(\n             DocumentMK.Builder builder) {\n         ForwardingListener<CacheValue, NodeDocument> listener = ForwardingListener.newInstance();\n@@ -570,6 +591,7 @@ public NodeDocument call() throws Exception {\n                 Operation op = entry.getValue();\n                 switch (op.type) {\n                     case SET:\n+                    case MAX:\n                     case INCREMENT: {\n                         inserts[i].put(k.toString(), op.value);\n                         break;\n@@ -965,6 +987,7 @@ private static QueryBuilder createQueryForUpdate(UpdateOp updateOp,\n     @Nonnull\n     private static DBObject createUpdate(UpdateOp updateOp) {\n         BasicDBObject setUpdates = new BasicDBObject();\n+        BasicDBObject maxUpdates = new BasicDBObject();\n         BasicDBObject incUpdates = new BasicDBObject();\n         BasicDBObject unsetUpdates = new BasicDBObject();\n \n@@ -980,16 +1003,17 @@ private static DBObject createUpdate(UpdateOp updateOp) {\n             }\n             Operation op = entry.getValue();\n             switch (op.type) {\n-                case SET: {\n+                case SET:\n+                case SET_MAP_ENTRY: {\n                     setUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n-                case INCREMENT: {\n-                    incUpdates.append(k.toString(), op.value);\n+                case MAX: {\n+                    maxUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n-                case SET_MAP_ENTRY: {\n-                    setUpdates.append(k.toString(), op.value);\n+                case INCREMENT: {\n+                    incUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n                 case REMOVE_MAP_ENTRY: {\n@@ -1003,6 +1027,9 @@ private static DBObject createUpdate(UpdateOp updateOp) {\n         if (!setUpdates.isEmpty()) {\n             update.append(\"$set\", setUpdates);\n         }\n+        if (!maxUpdates.isEmpty()) {\n+            update.append(\"$max\", maxUpdates);\n+        }\n         if (!incUpdates.isEmpty()) {\n             update.append(\"$inc\", incUpdates);\n         }\n", "nb_test": 1802, "linesAdd": 66, "jira_id": "1822", "singleLine": false, "nb_skipped": 9, "commit": "3e83a4c1", "nb_failure": 1, "linesRem": 28}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testAssignFromDate(org.apache.jackrabbit.oak.plugins.memory.MemoryPropertyBuilderTest): java.lang.Long cannot be cast to java.lang.String", "testAssignFromDates(org.apache.jackrabbit.oak.plugins.memory.MemoryPropertyBuilderTest): java.lang.Long cannot be cast to java.lang.String"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java\nindex 2e9ac56..286b453 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java\n@@ -223,13 +223,23 @@ else if (isArray()) {\n             setName(property.getName());\n             if (property.isArray()) {\n                 isArray = true;\n+                if (type == Type.DATE) {\n+                    setValues((Iterable<T>) property.getValue(Type.STRINGS));\n+                }\n+                else {\n                     setValues((Iterable<T>) property.getValue(type.getArrayType()));\n                 }\n+            }\n             else {\n                 isArray = false;\n+                if (type == Type.DATE) {\n+                    setValue((T) property.getValue(Type.STRING));\n+                }\n+                else {\n                     setValue(property.getValue(type));\n                 }\n             }\n+        }\n         return this;\n     }\n \n", "nb_test": 396, "linesAdd": 10, "jira_id": "429", "singleLine": false, "nb_skipped": 3, "commit": "c02ecef8", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["dispose(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): Merge must fail with CommitFailedException"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 043f344..2de0d39 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -459,8 +459,11 @@ private void checkLastRevRecovery() {\n     }\n \n     public void dispose() {\n-        runBackgroundOperations();\n-        if (!isDisposed.getAndSet(true)) {\n+        if (isDisposed.getAndSet(true)) {\n+            // only dispose once\n+            return;\n+        }\n+        // notify background threads waiting on isDisposed\n         synchronized (isDisposed) {\n             isDisposed.notifyAll();\n         }\n@@ -469,6 +472,11 @@ public void dispose() {\n         } catch (InterruptedException e) {\n             // ignore\n         }\n+\n+        // do a final round of background operations after\n+        // the background thread stopped\n+        internalRunBackgroundOperations();\n+\n         if (leaseUpdateThread != null) {\n             try {\n                 leaseUpdateThread.join();\n@@ -476,11 +484,13 @@ public void dispose() {\n                 // ignore\n             }\n         }\n+\n+        // now mark this cluster node as inactive by\n+        // disposing the clusterNodeInfo\n         if (clusterNodeInfo != null) {\n             clusterNodeInfo.dispose();\n         }\n         store.dispose();\n-            LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n \n         if (blobStore instanceof Closeable) {\n             try {\n@@ -489,10 +499,10 @@ public void dispose() {\n                 LOG.debug(\"Error closing blob store \" + blobStore, ex);\n             }\n         }\n-        }\n         if (persistentCache != null) {\n             persistentCache.close();\n         }\n+        LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n     }\n \n     Revision setHeadRevision(@Nonnull Revision newHead) {\n@@ -544,6 +554,7 @@ Commit newCommit(@Nullable Revision base,\n             base = headRevision;\n         }\n         backgroundOperationLock.readLock().lock();\n+        checkOpen();\n         boolean success = false;\n         Commit c;\n         try {\n@@ -573,6 +584,7 @@ MergeCommit newMergeCommit(@Nullable Revision base, int numBranchCommits) {\n             base = headRevision;\n         }\n         backgroundOperationLock.readLock().lock();\n+        checkOpen();\n         boolean success = false;\n         MergeCommit c;\n         try {\n@@ -1502,15 +1514,22 @@ public Revision getHeadRevision() {\n \n     //----------------------< background operations >---------------------------\n \n-    public synchronized void runBackgroundOperations() {\n+    public void runBackgroundOperations() {\n         if (isDisposed.get()) {\n             return;\n         }\n-        if (simpleRevisionCounter != null) {\n-            // only when using timestamp\n+        try {\n+            internalRunBackgroundOperations();\n+        } catch (RuntimeException e) {\n+            if (isDisposed.get()) {\n+                LOG.warn(\"Background operation failed: \" + e.toString(), e);\n                 return;\n             }\n-        try {\n+            throw e;\n+        }\n+    }\n+\n+    private synchronized void internalRunBackgroundOperations() {\n         long start = clock.getTime();\n         long time = start;\n         // clean orphaned branches and collisions\n@@ -1536,12 +1555,6 @@ public synchronized void runBackgroundOperations() {\n         } else {\n             LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n         }\n-        } catch (RuntimeException e) {\n-            if (isDisposed.get()) {\n-                return;\n-            }\n-            throw e;\n-        }\n     }\n \n     /**\n@@ -1771,6 +1784,19 @@ void backgroundWrite() {\n \n     //-----------------------------< internal >---------------------------------\n \n+    /**\n+     * Checks if this store is still open and throws an\n+     * {@link IllegalStateException} if it is already disposed (or a dispose\n+     * is in progress).\n+     *\n+     * @throws IllegalStateException if this store is disposed.\n+     */\n+    private void checkOpen() throws IllegalStateException {\n+        if (isDisposed.get()) {\n+            throw new IllegalStateException(\"This DocumentNodeStore is disposed\");\n+        }\n+    }\n+\n     private boolean dispatch(@Nonnull String jsonDiff,\n                              @Nonnull DocumentNodeState node,\n                              @Nonnull DocumentNodeState base,\n", "nb_test": 2004, "linesAdd": 27, "jira_id": "2642", "singleLine": false, "nb_skipped": 9, "commit": "36fe017c", "nb_failure": 1, "linesRem": 13}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["luceneWithCopyOnReadDir_Compat(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexTest): Index path property [:indexPath] not found"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\nindex 09914c6..8eac46e 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n@@ -137,13 +137,13 @@ public IndexCopier(Executor executor, File indexRootDir, boolean prefetchEnabled\n     public Directory wrapForRead(String indexPath, IndexDefinition definition,\n             Directory remote) throws IOException {\n         Directory local = createLocalDirForIndexReader(indexPath, definition);\n-        return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition));\n+        return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(indexPath));\n     }\n \n     public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {\n         Directory local = createLocalDirForIndexWriter(definition);\n         return new CopyOnWriteDirectory(remote, local, reindexMode,\n-                getIndexPathForLogging(definition), getSharedWorkingSet(definition));\n+                getIndexPathForLogging(definition), getSharedWorkingSet(definition.getIndexPathFromConfig()));\n     }\n \n     @Override\n@@ -238,9 +238,7 @@ private void successfullyDeleted(LocalIndexFile file, boolean fileExisted){\n      * @param defn index definition for which the directory is being created\n      * @return a set to maintain the state of new files being created by the COW Directory\n      */\n-    private Set<String> getSharedWorkingSet(IndexDefinition defn){\n-        String indexPath = defn.getIndexPathFromConfig();\n-\n+    private Set<String> getSharedWorkingSet(String indexPath){\n         Set<String> sharedSet;\n         synchronized (sharedWorkingSetMap){\n             sharedSet = sharedWorkingSetMap.get(indexPath);\n", "nb_test": 361, "linesAdd": 3, "jira_id": "4431", "singleLine": false, "nb_skipped": 6, "commit": "7441a3d5", "nb_failure": 0, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["emptySuggestWithNothingIndexed(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexSuggestionTest)", "emptySuggestDictionary(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest)"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/SuggestHelper.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/SuggestHelper.java\nindex 4d0aa5c..e6de6fb 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/SuggestHelper.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/SuggestHelper.java\n@@ -66,8 +66,10 @@ public static void updateSuggester(Directory directory, Analyzer analyzer, Index\n             tempDir = Files.createTempDir();\n             File tempSubChild = new File(tempDir, \"non-existing-sub-child\");\n \n+            if (reader.getDocCount(FieldNames.SUGGEST) > 0) {\n                 Dictionary dictionary = new LuceneDictionary(reader, FieldNames.SUGGEST);\n                 getLookup(directory, analyzer, tempSubChild).build(dictionary);\n+            }\n         } catch (RuntimeException e) {\n             log.debug(\"could not update the suggester\", e);\n         } finally {\n", "nb_test": 351, "linesAdd": 2, "jira_id": "4067", "singleLine": false, "nb_skipped": 6, "commit": "56accddf", "nb_failure": 2, "linesRem": 0}, {"files": 3, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testStreamRecord(org.apache.jackrabbit.oak.segment.RecordTest)"], "patch": "diff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/Segment.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/Segment.java\nindex d1c0f0c..2f38496 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/Segment.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/Segment.java\n@@ -26,6 +26,7 @@\n import static com.google.common.collect.Maps.newConcurrentMap;\n import static java.lang.Boolean.getBoolean;\n import static org.apache.jackrabbit.oak.commons.IOUtils.closeQuietly;\n+import static org.apache.jackrabbit.oak.segment.SegmentId.isDataSegmentId;\n import static org.apache.jackrabbit.oak.segment.SegmentVersion.isValid;\n import static org.apache.jackrabbit.oak.segment.SegmentWriter.BLOCK_SIZE;\n \n@@ -38,6 +39,7 @@\n import java.nio.channels.WritableByteChannel;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.UUID;\n import java.util.concurrent.ConcurrentMap;\n \n import javax.annotation.CheckForNull;\n@@ -314,12 +316,27 @@ public int getRootCount() {\n         return data.getShort(ROOT_COUNT_OFFSET) & 0xffff;\n     }\n \n-    public static int getGcGen(ByteBuffer data) {\n-        return data.getInt(GC_GEN_OFFSET);\n+    /**\n+     * Determine the gc generation a segment from its data. Note that bulk segments don't have\n+     * generations (i.e. stay at 0).\n+     *\n+     * @param data         the date of the segment\n+     * @param segmentId    the id of the segment\n+     * @return  the gc generation of this segment or 0 if this is bulk segment.\n+     */\n+    public static int getGcGen(ByteBuffer data, UUID segmentId) {\n+        return isDataSegmentId(segmentId.getLeastSignificantBits())\n+            ? data.getInt(GC_GEN_OFFSET)\n+            : 0;\n     }\n \n+    /**\n+     * Determine the gc generation of this segment. Note that bulk segments don't have\n+     * generations (i.e. stay at 0).\n+     * @return  the gc generation of this segment or 0 if this is bulk segment.\n+     */\n     public int getGcGen() {\n-        return getGcGen(data);\n+        return getGcGen(data, id.asUUID());\n     }\n \n     public RecordType getRootType(int index) {\ndiff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/FileStore.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/FileStore.java\nindex 84d61a7..e8954f4 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/FileStore.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/FileStore.java\n@@ -1368,7 +1368,7 @@ public Segment readSegment(SegmentId id) {\n     public void writeSegment(SegmentId id, byte[] data, int offset, int length) throws IOException {\n         fileStoreLock.writeLock().lock();\n         try {\n-            int generation = Segment.getGcGen(wrap(data, offset, length));\n+            int generation = Segment.getGcGen(wrap(data, offset, length), id.asUUID());\n             long size = writer.writeEntry(\n                     id.getMostSignificantBits(),\n                     id.getLeastSignificantBits(),\ndiff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/TarReader.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/TarReader.java\nindex 8fcdcc2..5c7ee7d 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/TarReader.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/TarReader.java\n@@ -218,7 +218,7 @@ private static void generateTarFile(LinkedHashMap<UUID, byte[]> entries,\n         for (Map.Entry<UUID, byte[]> entry : entries.entrySet()) {\n             UUID uuid = entry.getKey();\n             byte[] data = entry.getValue();\n-            int generation = getGcGen(wrap(data));\n+            int generation = getGcGen(wrap(data), uuid);\n             writer.writeEntry(\n                     uuid.getMostSignificantBits(),\n                     uuid.getLeastSignificantBits(),\n", "nb_test": 135, "linesAdd": 9, "jira_id": "4353", "singleLine": false, "nb_skipped": 2, "commit": "b0014b7d", "nb_failure": 0, "linesRem": 5}, {"files": 4, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["modifiedReset(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): 1469806455 < 1469806460"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 0433392..b49f72e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -1205,7 +1205,7 @@ public static void setChildrenFlag(@Nonnull UpdateOp op,\n \n     public static void setModified(@Nonnull UpdateOp op,\n                                    @Nonnull Revision revision) {\n-        checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n+        checkNotNull(op).max(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n     }\n \n     public static void setRevision(@Nonnull UpdateOp op,\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\nindex 56b0698..0517fe1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n@@ -131,9 +131,7 @@ public boolean hasChanges() {\n      * @param value the value\n      */\n     void setMapEntry(@Nonnull String property, @Nonnull Revision revision, Object value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.SET_MAP_ENTRY;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.SET_MAP_ENTRY, value);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -145,8 +143,7 @@ void setMapEntry(@Nonnull String property, @Nonnull Revision revision, Object va\n      * @param revision the revision\n      */\n     public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.REMOVE_MAP_ENTRY;\n+        Operation op = new Operation(Operation.Type.REMOVE_MAP_ENTRY, null);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -157,9 +154,23 @@ public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision)\n      * @param value the value\n      */\n     void set(String property, Object value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.SET;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.SET, value);\n+        changes.put(new Key(property, null), op);\n+    }\n+\n+    /**\n+     * Set the property to the given value if the new value is higher than the\n+     * existing value. The property is also set to the given value if the\n+     * property does not yet exist.\n+     * <p>\n+     * The result of a max operation with different types of values is\n+     * undefined.\n+     *\n+     * @param property the name of the property to set.\n+     * @param value the new value for the property.\n+     */\n+    <T> void max(String property, Comparable<T> value) {\n+        Operation op = new Operation(Operation.Type.MAX, value);\n         changes.put(new Key(property, null), op);\n     }\n \n@@ -187,9 +198,7 @@ void containsMapEntry(@Nonnull String property,\n         if (isNew) {\n             throw new IllegalStateException(\"Cannot use containsMapEntry() on new document\");\n         }\n-        Operation op = new Operation();\n-        op.type = Operation.Type.CONTAINS_MAP_ENTRY;\n-        op.value = exists;\n+        Operation op = new Operation(Operation.Type.CONTAINS_MAP_ENTRY, exists);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -200,9 +209,7 @@ void containsMapEntry(@Nonnull String property,\n      * @param value the increment\n      */\n     public void increment(@Nonnull String property, long value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.INCREMENT;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.INCREMENT, value);\n         changes.put(new Key(property, null), op);\n     }\n \n@@ -239,6 +246,14 @@ public String toString() {\n             SET,\n \n             /**\n+             * Set the value if the new value is higher than the existing value.\n+             * The new value is also considered higher, when there is no\n+             * existing value.\n+             * The sub-key is not used.\n+             */\n+            MAX,\n+\n+            /**\n              * Increment the Long value with the provided Long value.\n              * The sub-key is not used.\n              */\n@@ -267,12 +282,17 @@ public String toString() {\n         /**\n          * The operation type.\n          */\n-        public Type type;\n+        public final Type type;\n \n         /**\n          * The value, if any.\n          */\n-        public Object value;\n+        public final Object value;\n+\n+        Operation(Type type, Object value) {\n+            this.type = checkNotNull(type);\n+            this.value = value;\n+        }\n \n         @Override\n         public String toString() {\n@@ -283,18 +303,16 @@ public Operation getReverse() {\n             Operation reverse = null;\n             switch (type) {\n             case INCREMENT:\n-                reverse = new Operation();\n-                reverse.type = Type.INCREMENT;\n-                reverse.value = -(Long) value;\n+                reverse = new Operation(Type.INCREMENT, -(Long) value);\n                 break;\n             case SET:\n+            case MAX:\n             case REMOVE_MAP_ENTRY:\n             case CONTAINS_MAP_ENTRY:\n                 // nothing to do\n                 break;\n             case SET_MAP_ENTRY:\n-                reverse = new Operation();\n-                reverse.type = Type.REMOVE_MAP_ENTRY;\n+                reverse = new Operation(Type.REMOVE_MAP_ENTRY, null);\n                 break;\n             }\n             return reverse;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\nindex b8015ff..240665d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\n@@ -44,7 +44,9 @@\n      * @param comparator\n      *            the revision comparator.\n      */\n-    public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\n+    public static void applyChanges(@Nonnull Document doc,\n+                                    @Nonnull UpdateOp update,\n+                                    @Nonnull Comparator<Revision> comparator) {\n         for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\n             Key k = e.getKey();\n             Operation op = e.getValue();\n@@ -53,6 +55,15 @@ public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update,\n                     doc.put(k.toString(), op.value);\n                     break;\n                 }\n+                case MAX: {\n+                    Comparable newValue = (Comparable) op.value;\n+                    Object old = doc.get(k.toString());\n+                    //noinspection unchecked\n+                    if (old == null || newValue.compareTo(old) > 0) {\n+                        doc.put(k.toString(), op.value);\n+                    }\n+                    break;\n+                }\n                 case INCREMENT: {\n                     Object old = doc.get(k.toString());\n                     Long x = (Long) op.value;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\nindex 0266e38..99db8d1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n@@ -570,6 +570,7 @@ public NodeDocument call() throws Exception {\n                 Operation op = entry.getValue();\n                 switch (op.type) {\n                     case SET:\n+                    case MAX:\n                     case INCREMENT: {\n                         inserts[i].put(k.toString(), op.value);\n                         break;\n@@ -965,6 +966,7 @@ private static QueryBuilder createQueryForUpdate(UpdateOp updateOp,\n     @Nonnull\n     private static DBObject createUpdate(UpdateOp updateOp) {\n         BasicDBObject setUpdates = new BasicDBObject();\n+        BasicDBObject maxUpdates = new BasicDBObject();\n         BasicDBObject incUpdates = new BasicDBObject();\n         BasicDBObject unsetUpdates = new BasicDBObject();\n \n@@ -980,16 +982,17 @@ private static DBObject createUpdate(UpdateOp updateOp) {\n             }\n             Operation op = entry.getValue();\n             switch (op.type) {\n-                case SET: {\n+                case SET:\n+                case SET_MAP_ENTRY: {\n                     setUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n-                case INCREMENT: {\n-                    incUpdates.append(k.toString(), op.value);\n+                case MAX: {\n+                    maxUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n-                case SET_MAP_ENTRY: {\n-                    setUpdates.append(k.toString(), op.value);\n+                case INCREMENT: {\n+                    incUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n                 case REMOVE_MAP_ENTRY: {\n@@ -1003,6 +1006,9 @@ private static DBObject createUpdate(UpdateOp updateOp) {\n         if (!setUpdates.isEmpty()) {\n             update.append(\"$set\", setUpdates);\n         }\n+        if (!maxUpdates.isEmpty()) {\n+            update.append(\"$max\", maxUpdates);\n+        }\n         if (!incUpdates.isEmpty()) {\n             update.append(\"$inc\", incUpdates);\n         }\n", "nb_test": 1866, "linesAdd": 45, "jira_id": "1822", "singleLine": false, "nb_skipped": 9, "commit": "016df669", "nb_failure": 1, "linesRem": 28}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["idCompareToGreaterThanOneByteTest(org.apache.jackrabbit.mk.model.IdTest): 0000000000000070 should be less than 00000000000000c0", "idCompareToGreaterThanTwoBytesTest(org.apache.jackrabbit.mk.model.IdTest): 0000000000000270 should be less than 00000000000002c0"], "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Id.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Id.java\nindex a263ddb..021b5ef 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Id.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Id.java\n@@ -113,7 +113,9 @@ public int compareTo(Id o) {\n         \n         for (int i = 0; i < len; i++) {\n             if (raw[i] != other[i]) {\n-                return raw[i] - other[i];\n+                final int rawValue = raw[i] & 0xFF; // unsigned value\n+                final int otherValue = other[i] & 0xFF; // unsigned value\n+                return rawValue - otherValue;\n             }\n         }\n         return raw.length - other.length;\n", "nb_test": 77, "linesAdd": 3, "jira_id": "539", "singleLine": false, "nb_skipped": 2, "commit": "ffa818f3", "nb_failure": 2, "linesRem": 1}, {"files": 6, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["rebaseInvariant(org.apache.jackrabbit.oak.kernel.KernelNodeBuilderTest): expected:</@0000000000000001 children: 0 hash: 62571891215b4efc1ceab744ce59dd0b66ea6f73 id: 62571891215b4efc1ceab744ce59dd0b66ea6f73 { }> but was:<{ added : { } }>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/MutableTree.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/MutableTree.java\nindex a1aa87d..1b02d0a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/MutableTree.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/MutableTree.java\n@@ -18,8 +18,22 @@\n  */\n package org.apache.jackrabbit.oak.core;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.filter;\n+import static com.google.common.collect.Iterables.indexOf;\n+import static org.apache.jackrabbit.oak.api.Tree.Status.EXISTING;\n+import static org.apache.jackrabbit.oak.api.Tree.Status.MODIFIED;\n+import static org.apache.jackrabbit.oak.api.Tree.Status.NEW;\n+import static org.apache.jackrabbit.oak.api.Type.STRING;\n+import static org.apache.jackrabbit.oak.commons.PathUtils.elements;\n+import static org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute;\n+import static org.apache.jackrabbit.oak.spi.state.NodeStateUtils.isHidden;\n+\n import java.util.Collections;\n import java.util.Set;\n+\n import javax.annotation.CheckForNull;\n import javax.annotation.Nonnull;\n \n@@ -36,19 +50,6 @@\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n import org.apache.jackrabbit.oak.spi.state.PropertyBuilder;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n-import static com.google.common.base.Preconditions.checkState;\n-import static com.google.common.collect.Iterables.filter;\n-import static com.google.common.collect.Iterables.indexOf;\n-import static org.apache.jackrabbit.oak.api.Tree.Status.EXISTING;\n-import static org.apache.jackrabbit.oak.api.Tree.Status.MODIFIED;\n-import static org.apache.jackrabbit.oak.api.Tree.Status.NEW;\n-import static org.apache.jackrabbit.oak.api.Type.STRING;\n-import static org.apache.jackrabbit.oak.commons.PathUtils.elements;\n-import static org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute;\n-import static org.apache.jackrabbit.oak.spi.state.NodeStateUtils.isHidden;\n-\n public class MutableTree extends AbstractTree {\n \n     /**\n@@ -86,7 +87,7 @@ protected MutableTree createChild(String name) {\n \n     @Override\n     protected boolean isNew() {\n-        return !getBase().exists();\n+        return nodeBuilder.isNew();\n     }\n \n     @Override\n@@ -335,15 +336,6 @@ public String toString() {\n     }\n \n     //---------------------------------------------------------< internal >---\n-\n-    private NodeState getBase() {\n-        if (parent == null) {\n-            return root.getBaseState();\n-        } else {\n-            return parent.getBase().getChildNode(name);\n-        }\n-    }\n-\n     /**\n      * Set the parent and name of this tree.\n      * @param parent  parent of this tree\n@@ -480,7 +472,7 @@ private void beforeWrite() throws IllegalStateException {\n      * Internal method for checking whether this node exists and is visible\n      * (i.e. not hidden).\n      *\n-     * @return {@true} if the node is visible, {@code false} if not\n+     * @return {@code true} if the node is visible, {@code false} if not\n      */\n     private boolean isVisible() {\n         return !isHidden(name) && nodeBuilder.exists();\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeBuilder.java\nindex aa9d7d8..5058a8b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeBuilder.java\n@@ -34,7 +34,7 @@\n \n     private NodeState base = null;\n \n-    protected NodeState rootBase = null;\n+    private NodeState rootBase = null;\n \n     KernelNodeBuilder(MemoryNodeBuilder parent, String name, KernelRootBuilder root) {\n         super(parent, name);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\nindex dfe7596..87b2a0d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\n@@ -117,7 +117,8 @@ NodeState rebase() {\n         purge();\n         branch.rebase();\n         NodeState head = branch.getHead();\n-        reset(head);\n+        reset(branch.getBase());\n+        super.reset(head);\n         return head;\n     }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex 00136aa..a83ca87 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -260,7 +260,7 @@ public boolean exists() {\n \n     @Override\n     public boolean isNew() {\n-        return exists() && !base.exists();\n+        return exists() && !getBaseState().exists();\n     }\n \n     @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeBuilder.java\nindex 4b10bd0..3837974 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeBuilder.java\n@@ -18,11 +18,13 @@\n \n import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilder;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n+import org.apache.jackrabbit.oak.spi.state.NodeState;\n \n /**\n  * A node builder implementation for MongoMK.\n  */\n class MongoNodeBuilder extends MemoryNodeBuilder {\n+    private NodeState base;\n \n     protected MongoNodeBuilder(MongoNodeState base) {\n         super(base);\n@@ -33,6 +35,14 @@ private MongoNodeBuilder(MongoNodeBuilder parent, String name) {\n     }\n \n     @Override\n+    public NodeState getBaseState() {\n+        if (base == null) {\n+            base = getParent().getBaseState().getChildNode(getName());\n+        }\n+        return base;\n+    }\n+\n+    @Override\n     protected MongoNodeBuilder createChildBuilder(String name) {\n         return new MongoNodeBuilder(this, name);\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\nindex 7a1d815..aa6460e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\n@@ -98,7 +98,8 @@ NodeState rebase() {\n         purge();\n         branch.rebase();\n         NodeState head = branch.getHead();\n-        reset(head);\n+        reset(branch.getBase());\n+        super.reset(head);\n         return head;\n     }\n \n", "nb_test": 1425, "linesAdd": 31, "jira_id": "1178", "singleLine": false, "nb_skipped": 6, "commit": "f2bb1a17", "nb_failure": 1, "linesRem": 27}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOak1104(org.apache.jackrabbit.oak.plugins.segment.MapRecordTest):"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapEntry.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapEntry.java\nindex ad93d4b..93f798d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapEntry.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapEntry.java\n@@ -18,6 +18,7 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.base.Preconditions.checkState;\n+import static org.apache.jackrabbit.oak.plugins.segment.MapRecord.HASH_MASK;\n \n import java.util.Map;\n \n@@ -87,7 +88,7 @@ public RecordId setValue(RecordId value) {\n     @Override\n     public int compareTo(MapEntry that) {\n         return ComparisonChain.start()\n-                .compare(getHash(), that.getHash())\n+                .compare(getHash() & HASH_MASK, that.getHash() & HASH_MASK)\n                 .compare(name, that.name)\n                 .compare(value, that.value)\n                 .result();\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapRecord.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapRecord.java\nindex 9e0c76e..e39b928 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapRecord.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapRecord.java\n@@ -37,6 +37,7 @@\n \n     private static final long M = 0x5DEECE66DL;\n     private static final long A = 0xBL;\n+    static final long HASH_MASK = 0xFFFFFFFFL;\n \n     static int getHash(String name) {\n         return (int) (((name.hashCode() ^ M) * M + A) >> 16);\n@@ -153,7 +154,7 @@ MapEntry getEntry(String key) {\n             int bitmap = segment.readInt(getOffset(4));\n             int mask = BUCKETS_PER_LEVEL - 1;\n             int shift = 32 - (level + 1) * LEVEL_BITS;\n-            int index = (hash >> shift) & mask;\n+            int index = (int) (hash >> shift) & mask;\n             int bit = 1 << index;\n             if ((bitmap & bit) != 0) {\n                 int ids = bitCount(bitmap & (bit - 1));\n@@ -167,8 +168,8 @@ MapEntry getEntry(String key) {\n         // this is a leaf record; scan the list to find a matching entry\n         int d = -1;\n         for (int i = 0; i < size && d < 0; i++) {\n-            d = Integer.valueOf(segment.readInt(getOffset(4 + i * 4)))\n-                    .compareTo(Integer.valueOf(hash));\n+            d = Long.valueOf(segment.readInt(getOffset(4 + i * 4)) & HASH_MASK)\n+                    .compareTo(Long.valueOf(hash & HASH_MASK));\n             if (d == 0) {\n                 RecordId keyId = segment.readRecordId(\n                         getOffset(4 + size * 4, i));\n@@ -379,7 +380,7 @@ private static int compare(MapEntry before, MapEntry after) {\n             return -1;  // see above\n         } else {\n             return ComparisonChain.start()\n-                    .compare(before.getHash(), after.getHash())\n+                    .compare(before.getHash() & HASH_MASK, after.getHash() & HASH_MASK)\n                     .compare(before.getName(), after.getName())\n                     .result();\n         }\n", "nb_test": 1260, "linesAdd": 7, "jira_id": "1104", "singleLine": false, "nb_skipped": 5, "commit": "7ae92779", "nb_failure": 1, "linesRem": 5}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["purgeUnmergedBranch(org.apache.jackrabbit.oak.plugins.document.UnmergedBranchTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 92e0b0a..9e721a0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -556,30 +556,40 @@ public boolean containsRevision(@Nonnull Revision revision) {\n     }\n \n     /**\n-     * Gets a sorted map of uncommitted revisions of this document with the\n+     * Purge the  uncommitted revisions of this document with the\n      * local cluster node id as returned by the {@link RevisionContext}. These\n      * are the {@link #REVISIONS} entries where {@link Utils#isCommitted(String)}\n      * returns false.\n      *\n+     * <p>\n+     *     <bold>Note</bold> - This method should only be invoked upon startup\n+     *     as then only we can safely assume that these revisions would not be\n+     *     committed\n+     * </p>\n+     *\n      * @param context the revision context.\n-     * @return the uncommitted revisions of this document.\n+     * @return count of the revision entries purged\n      */\n-    public SortedMap<Revision, Revision> getUncommittedRevisions(RevisionContext context) {\n+    public int purgeUncommittedRevisions(RevisionContext context) {\n         // only look at revisions in this document.\n         // uncommitted revisions are not split off\n         Map<Revision, String> valueMap = getLocalRevisions();\n-        SortedMap<Revision, Revision> revisions =\n-                new TreeMap<Revision, Revision>(context.getRevisionComparator());\n+        UpdateOp op = new UpdateOp(getId(), false);\n+        int purgeCount = 0;\n         for (Map.Entry<Revision, String> commit : valueMap.entrySet()) {\n             if (!Utils.isCommitted(commit.getValue())) {\n                 Revision r = commit.getKey();\n                 if (r.getClusterId() == context.getClusterId()) {\n-                    Revision b = Revision.fromString(commit.getValue());\n-                    revisions.put(r, b);\n+                    purgeCount++;\n+                    op.removeMapEntry(REVISIONS, r);\n                 }\n             }\n         }\n-        return revisions;\n+\n+        if (op.hasChanges()) {\n+            store.findAndUpdate(Collection.NODES, op);\n+        }\n+        return purgeCount;\n     }\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java\nindex b39b8df..9573cb7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java\n@@ -21,7 +21,6 @@\n \n import java.util.Comparator;\n import java.util.List;\n-import java.util.SortedMap;\n import java.util.SortedSet;\n import java.util.TreeSet;\n import java.util.concurrent.CopyOnWriteArrayList;\n@@ -31,6 +30,8 @@\n import javax.annotation.Nonnull;\n \n import org.apache.jackrabbit.oak.plugins.document.util.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * <code>UnmergedBranches</code> contains all un-merged branches of a DocumentMK\n@@ -38,6 +39,8 @@\n  */\n class UnmergedBranches {\n \n+    private final Logger log = LoggerFactory.getLogger(getClass());\n+\n     /**\n      * Map of branches with the head of the branch as key.\n      */\n@@ -72,17 +75,9 @@ void init(DocumentStore store, RevisionContext context) {\n         if (doc == null) {\n             return;\n         }\n-        SortedMap<Revision, Revision> revisions = doc.getUncommittedRevisions(context);\n-        while (!revisions.isEmpty()) {\n-            SortedSet<Revision> commits = new TreeSet<Revision>(comparator);\n-            Revision head = revisions.lastKey();\n-            commits.add(head);\n-            Revision base = revisions.remove(head).asTrunkRevision();\n-            while (revisions.containsKey(base)) {\n-                commits.add(base);\n-                base = revisions.remove(base).asTrunkRevision();\n-            }\n-            branches.add(new Branch(commits, base));\n+        int purgeCount = doc.purgeUncommittedRevisions(context);\n+        if (purgeCount > 0) {\n+            log.info(\"Purged [{}] uncommitted branch revision entries\", purgeCount);\n         }\n     }\n \n", "nb_test": 1849, "linesAdd": 17, "jira_id": "1926", "singleLine": false, "nb_skipped": 9, "commit": "9225a3e2", "nb_failure": 1, "linesRem": 18}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["multiPhraseQuery(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest)"], "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex a16d437..467b64d 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -707,7 +707,7 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer, Inde\n                 MultiPhraseQuery mpq = new MultiPhraseQuery();\n                 for(String token: tokens){\n                     if (hasFulltextToken(token)) {\n-                        Term[] terms = extractMatchingTokens(reader, token);\n+                        Term[] terms = extractMatchingTokens(reader, fieldName, token);\n                         if (terms != null && terms.length > 0) {\n                             mpq.add(terms);\n                         }\n@@ -726,7 +726,7 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer, Inde\n         }\n     }\n \n-    private static Term[] extractMatchingTokens(IndexReader reader, String token) {\n+    private static Term[] extractMatchingTokens(IndexReader reader, String fieldName, String token) {\n         if (reader == null) {\n             // getPlan call\n             return null;\n@@ -734,13 +734,14 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer, Inde\n \n         try {\n             List<Term> terms = new ArrayList<Term>();\n-            Terms t = MultiFields.getTerms(reader, FieldNames.FULLTEXT);\n-            Automaton a = WildcardQuery.toAutomaton(newFulltextTerm(token));\n+            Term onTerm = newFulltextTerm(token, fieldName);\n+            Terms t = MultiFields.getTerms(reader, onTerm.field());\n+            Automaton a = WildcardQuery.toAutomaton(onTerm);\n             CompiledAutomaton ca = new CompiledAutomaton(a);\n             TermsEnum te = ca.getTermsEnum(t);\n             BytesRef text;\n             while ((text = te.next()) != null) {\n-                terms.add(newFulltextTerm(text.utf8ToString()));\n+                terms.add(newFulltextTerm(text.utf8ToString(), fieldName));\n             }\n             return terms.toArray(new Term[terms.size()]);\n         } catch (IOException e) {\n", "nb_test": 249, "linesAdd": 6, "jira_id": "1516", "singleLine": false, "nb_skipped": 1, "commit": "7c62bd81", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["verifyCustomNodeTypes(org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest)"], "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex 72899ea..7ba64cb 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -16,18 +16,83 @@\n  */\n package org.apache.jackrabbit.oak.upgrade;\n \n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static com.google.common.collect.Lists.newArrayListWithCapacity;\n+import static com.google.common.collect.Maps.newHashMap;\n+import static java.util.Arrays.asList;\n+import static org.apache.jackrabbit.JcrConstants.JCR_AUTOCREATED;\n+import static org.apache.jackrabbit.JcrConstants.JCR_CHILDNODEDEFINITION;\n+import static org.apache.jackrabbit.JcrConstants.JCR_DEFAULTPRIMARYTYPE;\n+import static org.apache.jackrabbit.JcrConstants.JCR_DEFAULTVALUES;\n+import static org.apache.jackrabbit.JcrConstants.JCR_HASORDERABLECHILDNODES;\n+import static org.apache.jackrabbit.JcrConstants.JCR_ISMIXIN;\n+import static org.apache.jackrabbit.JcrConstants.JCR_MANDATORY;\n+import static org.apache.jackrabbit.JcrConstants.JCR_MULTIPLE;\n+import static org.apache.jackrabbit.JcrConstants.JCR_NAME;\n+import static org.apache.jackrabbit.JcrConstants.JCR_NODETYPENAME;\n+import static org.apache.jackrabbit.JcrConstants.JCR_ONPARENTVERSION;\n+import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYITEMNAME;\n+import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;\n+import static org.apache.jackrabbit.JcrConstants.JCR_PROPERTYDEFINITION;\n+import static org.apache.jackrabbit.JcrConstants.JCR_PROTECTED;\n+import static org.apache.jackrabbit.JcrConstants.JCR_REQUIREDPRIMARYTYPES;\n+import static org.apache.jackrabbit.JcrConstants.JCR_REQUIREDTYPE;\n+import static org.apache.jackrabbit.JcrConstants.JCR_SAMENAMESIBLINGS;\n+import static org.apache.jackrabbit.JcrConstants.JCR_SUPERTYPES;\n+import static org.apache.jackrabbit.JcrConstants.JCR_SYSTEM;\n+import static org.apache.jackrabbit.JcrConstants.JCR_VALUECONSTRAINTS;\n+import static org.apache.jackrabbit.JcrConstants.JCR_VERSIONSTORAGE;\n+import static org.apache.jackrabbit.JcrConstants.NT_CHILDNODEDEFINITION;\n+import static org.apache.jackrabbit.JcrConstants.NT_NODETYPE;\n+import static org.apache.jackrabbit.JcrConstants.NT_PROPERTYDEFINITION;\n+import static org.apache.jackrabbit.core.RepositoryImpl.ACTIVITIES_NODE_ID;\n+import static org.apache.jackrabbit.core.RepositoryImpl.ROOT_NODE_ID;\n+import static org.apache.jackrabbit.core.RepositoryImpl.VERSION_STORAGE_NODE_ID;\n+import static org.apache.jackrabbit.oak.api.Type.BOOLEANS;\n+import static org.apache.jackrabbit.oak.api.Type.DECIMALS;\n+import static org.apache.jackrabbit.oak.api.Type.DOUBLES;\n+import static org.apache.jackrabbit.oak.api.Type.LONGS;\n+import static org.apache.jackrabbit.oak.api.Type.NAME;\n+import static org.apache.jackrabbit.oak.api.Type.NAMES;\n+import static org.apache.jackrabbit.oak.api.Type.PATHS;\n+import static org.apache.jackrabbit.oak.api.Type.STRINGS;\n+import static org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty;\n+import static org.apache.jackrabbit.oak.plugins.name.Namespaces.addCustomMapping;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_AVAILABLE_QUERY_OPERATORS;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_ABSTRACT;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_FULLTEXT_SEARCHABLE;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERYABLE;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERY_ORDERABLE;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_NODE_TYPES;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGE;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGES;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_AGGREGATES;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_BITS;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_IS_ABSTRACT;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_NEXT;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_PRIVILEGES;\n+import static org.apache.jackrabbit.spi.commons.name.NameConstants.ANY_NAME;\n+\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.math.BigDecimal;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Properties;\n \n import javax.jcr.NamespaceException;\n+import javax.jcr.PropertyType;\n import javax.jcr.RepositoryException;\n+import javax.jcr.UnsupportedRepositoryOperationException;\n import javax.jcr.security.Privilege;\n import javax.jcr.version.OnParentVersionAction;\n \n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n import org.apache.jackrabbit.core.RepositoryContext;\n import org.apache.jackrabbit.core.config.BeanConfig;\n import org.apache.jackrabbit.core.config.LoginModuleConfig;\n@@ -41,6 +106,8 @@\n import org.apache.jackrabbit.core.security.user.UserManagerImpl;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Type;\n+import org.apache.jackrabbit.oak.namepath.GlobalNameMapper;\n+import org.apache.jackrabbit.oak.namepath.NameMapper;\n import org.apache.jackrabbit.oak.plugins.index.CompositeIndexEditorProvider;\n import org.apache.jackrabbit.oak.plugins.index.IndexUpdateProvider;\n import org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexEditorProvider;\n@@ -68,6 +135,8 @@\n import org.apache.jackrabbit.oak.upgrade.security.GroupEditorProvider;\n import org.apache.jackrabbit.oak.upgrade.security.RestrictionEditorProvider;\n import org.apache.jackrabbit.spi.Name;\n+import org.apache.jackrabbit.spi.Path;\n+import org.apache.jackrabbit.spi.Path.Element;\n import org.apache.jackrabbit.spi.QItemDefinition;\n import org.apache.jackrabbit.spi.QNodeDefinition;\n import org.apache.jackrabbit.spi.QNodeTypeDefinition;\n@@ -77,59 +146,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.collect.ImmutableMap;\n-\n-import static com.google.common.base.Preconditions.checkState;\n-import static com.google.common.collect.Lists.newArrayList;\n-import static com.google.common.collect.Lists.newArrayListWithCapacity;\n-import static com.google.common.collect.Maps.newHashMap;\n-import static java.util.Arrays.asList;\n-import static org.apache.jackrabbit.JcrConstants.JCR_AUTOCREATED;\n-import static org.apache.jackrabbit.JcrConstants.JCR_CHILDNODEDEFINITION;\n-import static org.apache.jackrabbit.JcrConstants.JCR_DEFAULTPRIMARYTYPE;\n-import static org.apache.jackrabbit.JcrConstants.JCR_HASORDERABLECHILDNODES;\n-import static org.apache.jackrabbit.JcrConstants.JCR_ISMIXIN;\n-import static org.apache.jackrabbit.JcrConstants.JCR_MANDATORY;\n-import static org.apache.jackrabbit.JcrConstants.JCR_MULTIPLE;\n-import static org.apache.jackrabbit.JcrConstants.JCR_NAME;\n-import static org.apache.jackrabbit.JcrConstants.JCR_NODETYPENAME;\n-import static org.apache.jackrabbit.JcrConstants.JCR_ONPARENTVERSION;\n-import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYITEMNAME;\n-import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;\n-import static org.apache.jackrabbit.JcrConstants.JCR_PROPERTYDEFINITION;\n-import static org.apache.jackrabbit.JcrConstants.JCR_PROTECTED;\n-import static org.apache.jackrabbit.JcrConstants.JCR_REQUIREDPRIMARYTYPES;\n-import static org.apache.jackrabbit.JcrConstants.JCR_REQUIREDTYPE;\n-import static org.apache.jackrabbit.JcrConstants.JCR_SAMENAMESIBLINGS;\n-import static org.apache.jackrabbit.JcrConstants.JCR_SUPERTYPES;\n-import static org.apache.jackrabbit.JcrConstants.JCR_SYSTEM;\n-import static org.apache.jackrabbit.JcrConstants.JCR_VALUECONSTRAINTS;\n-import static org.apache.jackrabbit.JcrConstants.JCR_VERSIONSTORAGE;\n-import static org.apache.jackrabbit.JcrConstants.NT_CHILDNODEDEFINITION;\n-import static org.apache.jackrabbit.JcrConstants.NT_NODETYPE;\n-import static org.apache.jackrabbit.JcrConstants.NT_PROPERTYDEFINITION;\n-import static org.apache.jackrabbit.core.RepositoryImpl.ACTIVITIES_NODE_ID;\n-import static org.apache.jackrabbit.core.RepositoryImpl.ROOT_NODE_ID;\n-import static org.apache.jackrabbit.core.RepositoryImpl.VERSION_STORAGE_NODE_ID;\n-import static org.apache.jackrabbit.oak.api.Type.NAME;\n-import static org.apache.jackrabbit.oak.api.Type.NAMES;\n-import static org.apache.jackrabbit.oak.api.Type.STRINGS;\n-import static org.apache.jackrabbit.oak.plugins.name.Namespaces.addCustomMapping;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_AVAILABLE_QUERY_OPERATORS;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_ABSTRACT;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_FULLTEXT_SEARCHABLE;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERYABLE;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERY_ORDERABLE;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_NODE_TYPES;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGE;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGES;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_AGGREGATES;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_BITS;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_IS_ABSTRACT;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_NEXT;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_PRIVILEGES;\n-import static org.apache.jackrabbit.spi.commons.name.NameConstants.ANY_NAME;\n-\n public class RepositoryUpgrade {\n \n     /**\n@@ -236,10 +252,10 @@ public void copy(RepositoryInitializer initializer) throws RepositoryException {\n                 sc.getWorkspaceInitializer().initialize(builder, workspace);\n             }\n \n-            Map<String, String> uriToPrefix = newHashMap();\n+            HashBiMap<String, String> uriToPrefix = HashBiMap.create();\n             Map<Integer, String> idxToPrefix = newHashMap();\n             copyNamespaces(builder, uriToPrefix, idxToPrefix);\n-            copyNodeTypes(builder);\n+            copyNodeTypes(builder, uriToPrefix.inverse());\n             copyPrivileges(builder);\n \n             NodeState root = builder.getNodeState();\n@@ -458,7 +474,8 @@ private PrivilegeBits resolvePrivilegeBits(\n         return bits;\n     }\n \n-    private void copyNodeTypes(NodeBuilder root) throws RepositoryException {\n+    private void copyNodeTypes(NodeBuilder root, Map<String, String> prefixToUri)\n+            throws RepositoryException {\n         NodeTypeRegistry sourceRegistry = source.getNodeTypeRegistry();\n         NodeBuilder system = root.child(JCR_SYSTEM);\n         NodeBuilder types = system.child(JCR_NODE_TYPES);\n@@ -470,13 +487,14 @@ private void copyNodeTypes(NodeBuilder root) throws RepositoryException {\n             if (!types.hasChildNode(oakName)) {\n                 QNodeTypeDefinition def = sourceRegistry.getNodeTypeDef(name);\n                 NodeBuilder type = types.child(oakName);\n-                copyNodeType(def, type);\n+                copyNodeType(def, type, prefixToUri);\n             }\n         }\n     }\n \n-    private void copyNodeType(QNodeTypeDefinition def, NodeBuilder builder)\n-            throws NamespaceException {\n+    private void copyNodeType(\n+            QNodeTypeDefinition def, NodeBuilder builder, Map<String, String> prefixToUri)\n+            throws RepositoryException {\n         builder.setProperty(JCR_PRIMARYTYPE, NT_NODETYPE, NAME);\n \n         // - jcr:nodeTypeName (NAME) protected mandatory\n@@ -510,7 +528,7 @@ private void copyNodeType(QNodeTypeDefinition def, NodeBuilder builder)\n         QPropertyDefinition[] properties = def.getPropertyDefs();\n         for (int i = 0; i < properties.length; i++) {\n             String name = JCR_PROPERTYDEFINITION + '[' + (i + 1) + ']';\n-            copyPropertyDefinition(properties[i], builder.child(name));\n+            copyPropertyDefinition(properties[i], builder.child(name), prefixToUri);\n         }\n \n         // + jcr:childNodeDefinition (nt:childNodeDefinition) = nt:childNodeDefinition protected sns\n@@ -522,8 +540,8 @@ private void copyNodeType(QNodeTypeDefinition def, NodeBuilder builder)\n     }\n \n     private void copyPropertyDefinition(\n-            QPropertyDefinition def, NodeBuilder builder)\n-            throws NamespaceException {\n+            QPropertyDefinition def, NodeBuilder builder, Map<String, String> prefixToUri)\n+            throws RepositoryException {\n         builder.setProperty(JCR_PRIMARYTYPE, NT_PROPERTYDEFINITION, NAME);\n \n         copyItemDefinition(def, builder);\n@@ -545,9 +563,9 @@ private void copyPropertyDefinition(\n             builder.setProperty(JCR_VALUECONSTRAINTS, strings, STRINGS);\n         }\n         // - jcr:defaultValues (UNDEFINED) protected multiple\n-        QValue[] values = def.getDefaultValues();\n-        if (values != null) {\n-            // TODO\n+        QValue[] qValues = def.getDefaultValues();\n+        if (qValues != null) {\n+            copyDefaultValues(qValues, builder, new GlobalNameMapper(prefixToUri));\n         }\n         // - jcr:multiple (BOOLEAN) protected mandatory\n         builder.setProperty(JCR_MULTIPLE, def.isMultiple());\n@@ -561,6 +579,99 @@ private void copyPropertyDefinition(\n         builder.setProperty(JCR_IS_QUERY_ORDERABLE, def.isQueryOrderable());\n     }\n \n+    private static void copyDefaultValues(QValue[] qValues, NodeBuilder builder,\n+            NameMapper nameMapper) throws RepositoryException {\n+        if (qValues.length == 0) {\n+            builder.setProperty(JCR_DEFAULTVALUES, Collections.<String>emptyList(), STRINGS);\n+        } else {\n+            int type = qValues[0].getType();\n+            switch (type) {\n+                case PropertyType.STRING:\n+                    List<String> strings = newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        strings.add(qValue.getString());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, strings, STRINGS));\n+                    return;\n+                case PropertyType.LONG:\n+                    List<Long> longs = newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        longs.add(qValue.getLong());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, longs, LONGS));\n+                    return;\n+                case PropertyType.DOUBLE:\n+                    List<Double> doubles = newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        doubles.add(qValue.getDouble());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, doubles, DOUBLES));\n+                    return;\n+                case PropertyType.BOOLEAN:\n+                    List<Boolean> booleans = Lists.newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        booleans.add(qValue.getBoolean());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, booleans, BOOLEANS));\n+                    return;\n+                case PropertyType.NAME:\n+                    List<String> names = Lists.newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        names.add(nameMapper.getOakName(qValue.getName().toString()));\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, names, NAMES));\n+                    return;\n+                case PropertyType.PATH:\n+                    List<String> paths = Lists.newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        paths.add(getOakPath(qValue.getPath(), nameMapper));\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, paths, PATHS));\n+                    return;\n+                case PropertyType.DECIMAL:\n+                    List<BigDecimal> decimals = Lists.newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        decimals.add(qValue.getDecimal());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, decimals, DECIMALS));\n+                    return;\n+                case PropertyType.DATE:\n+                case PropertyType.URI:\n+                    List<String> values = newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        values.add(qValue.getString());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, values, Type.fromTag(type, true)));\n+                    return;\n+                default:\n+                    throw new UnsupportedRepositoryOperationException(\n+                            \"Cannot copy default value of type \" + Type.fromTag(type, true));\n+            }\n+        }\n+    }\n+\n+    private static String getOakPath(Path path, NameMapper nameMapper)\n+            throws RepositoryException {\n+        StringBuilder oakPath = new StringBuilder();\n+        String sep = \"\";\n+        for (Element element: path.getElements()) {\n+            if (element.denotesRoot()) {\n+                oakPath.append('/');\n+                continue;\n+            } else if (element.denotesName()) {\n+                oakPath.append(sep).append(nameMapper.getOakName(element.getString()));\n+            } else if (element.denotesCurrent()) {\n+                oakPath.append(sep).append('.');\n+            } else if (element.denotesParent()) {\n+                oakPath.append(sep).append(\"..\");\n+            } else {\n+                throw new UnsupportedRepositoryOperationException(\"Cannot copy default value \" + path);\n+            }\n+            sep = \"/\";\n+        }\n+        return oakPath.toString();\n+    }\n+\n     private void copyChildNodeDefinition(\n             QNodeDefinition def, NodeBuilder builder)\n             throws NamespaceException {\n", "nb_test": 13, "linesAdd": 176, "jira_id": "1731", "singleLine": false, "nb_skipped": 0, "commit": "024e5d37", "nb_failure": 1, "linesRem": 64}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["includes(org.apache.jackrabbit.oak.plugins.mongomk.RangeTest): Trying to compare revisions of different cluster ids: r300-0-1 and r200-0-2"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Range.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Range.java\nindex 19ed201..52045fc 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Range.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Range.java\n@@ -51,8 +51,9 @@\n      * @return <code>true</code> if within this range; <code>false</code>\n      * otherwise.\n      */\n-    boolean includes(Revision r) {\n-        return high.compareRevisionTime(r) >= 0\n+    boolean includes(@Nonnull Revision r) {\n+        return high.getClusterId() == r.getClusterId()\n+                && high.compareRevisionTime(r) >= 0\n                 && low.compareRevisionTime(r) <= 0;\n     }\n \n", "nb_test": 1497, "linesAdd": 3, "jira_id": "1289", "singleLine": false, "nb_skipped": 6, "commit": "0c3e3d70", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRelativeProperties2(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Result set size is different expected:<1> but was:<3>", "testRangeRelativeProperties(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Result set size is different expected:<4> but was:<12>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\nindex 11427c3..44e31c0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n@@ -58,6 +58,8 @@\n import org.apache.jackrabbit.oak.spi.query.QueryIndex.AdvancedQueryIndex;\n import org.apache.jackrabbit.oak.spi.query.QueryIndex.IndexPlan;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterables;\n@@ -66,6 +68,7 @@\n  * A selector within a query.\n  */\n public class SelectorImpl extends SourceImpl {\n+    private static final Logger LOG = LoggerFactory.getLogger(SelectorImpl.class);\n     \n     // TODO possibly support using multiple indexes (using index intersection / index merge)\n     private SelectorExecutionPlan plan;\n@@ -547,6 +550,10 @@ private PropertyValue currentOakProperty(String oakPropertyName, Integer propert\n         boolean asterisk = oakPropertyName.indexOf('*') >= 0;\n         if (asterisk) {\n             Tree t = currentTree();\n+            if (t != null) {\n+                LOG.trace(\"currentOakProperty() - '*' case. looking for '{}' in '{}'\",\n+                    oakPropertyName, t.getPath());\n+            }\n             ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\n             readOakProperties(list, t, oakPropertyName, propertyType);\n             if (list.size() == 0) {\n@@ -630,10 +637,13 @@ private PropertyValue currentOakProperty(Tree t, String oakPropertyName, Integer\n     \n     private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\n         boolean skipCurrentNode = false;\n-        while (true) {\n+\n+        while (!skipCurrentNode) {\n             if (t == null || !t.exists()) {\n                 return;\n             }\n+            LOG.trace(\"readOakProperties() - reading '{}' for '{}'\", t.getPath(),\n+                oakPropertyName);\n             int slash = oakPropertyName.indexOf('/');\n             if (slash < 0) {\n                 break;\n@@ -659,6 +669,7 @@ private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String o\n         if (!\"*\".equals(oakPropertyName)) {\n             PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\n             if (value != null) {\n+                LOG.trace(\"readOakProperties() - adding: '{}' from '{}'\", value, t.getPath());\n                 target.add(value);\n             }\n             return;\n", "nb_test": 1895, "linesAdd": 12, "jira_id": "2062", "singleLine": false, "nb_skipped": 9, "commit": "5c4589bd", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAddNodeWithExpandedName(org.apache.jackrabbit.oak.jcr.RepositoryTest)"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex f93c214..752a3e8 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -240,8 +240,7 @@ public Node perform() throws RepositoryException {\n                 String ntName = primaryNodeTypeName;\n                 if (ntName == null) {\n                     DefinitionProvider dp = getDefinitionProvider();\n-                    String childName = getOakName(PathUtils.getName(relPath));\n-                    NodeDefinition def = dp.getDefinition(parent.getTree(), childName);\n+                    NodeDefinition def = dp.getDefinition(parent.getTree(), oakName);\n                     ntName = def.getDefaultPrimaryTypeName();\n                     if (ntName == null) {\n                         throw new ConstraintViolationException(\n", "nb_test": 516, "linesAdd": 1, "jira_id": "738", "singleLine": false, "nb_skipped": 1, "commit": "8ed779dc", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testNameWithLineBreaks(org.apache.jackrabbit.oak.plugins.name.NameValidatorTest): Expected exception: org.apache.jackrabbit.oak.api.CommitFailedException"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\nindex d0d1e26..a0a2367 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n@@ -58,6 +58,13 @@\n      */\n     private static final Map<String, String> ENCODED_URIS = newConcurrentMap();\n \n+    /**\n+     * By default node names with non space whitespace chars are not allowed.\n+     * However initial Oak release did allowed that and this flag is provided\n+     * to revert back to old behaviour if required for some case temporarily\n+     */\n+    private static final boolean allowOtherWhitespaceChars = Boolean.getBoolean(\"oak.allowOtherWhitespaceChars\");\n+\n     private Namespaces() {\n     }\n \n@@ -244,7 +251,8 @@ public static boolean isValidLocalName(String local) {\n \n         for (int i = 0; i < local.length(); i++) {\n             char ch = local.charAt(i);\n-            if (Character.isSpaceChar(ch)) {\n+            boolean spaceChar = allowOtherWhitespaceChars ? Character.isSpaceChar(ch) : Character.isWhitespace(ch);\n+            if (spaceChar) {\n                 if (i == 0) {\n                     return false; // leading whitespace\n                 } else if (i == local.length() - 1) {\n", "nb_test": 2439, "linesAdd": 4, "jira_id": "3412", "singleLine": false, "nb_skipped": 1, "commit": "2f85bd78", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFullTextTermName(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Result set size is different expected:<1> but was:<0>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\nindex d22c83b..2cf9cef 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n@@ -184,6 +184,10 @@ public boolean evaluate() {\n             appendString(buff, p);\n         } else {\n             String path = selector.currentPath();\n+            if (!PathUtils.denotesRoot(path)) {\n+                appendString(buff,\n+                        PropertyValues.newString(PathUtils.getName(path)));\n+            }\n             if (relativePath != null) {\n                 path = PathUtils.concat(path, relativePath);\n             }\n", "nb_test": 1275, "linesAdd": 4, "jira_id": "1024", "singleLine": false, "nb_skipped": 8, "commit": "ecc5bdfd", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testTransformAndParse(org.apache.jackrabbit.oak.query.SQL2ParserTest): Query: select [jcr:path], [jcr:score], * from [nt:base] as a where isdescendantnode(a, '/etc/commerce/products') and [cq:commerceType] = 'product' and [size] = 'M' union select [jcr:path], [jcr:score], * from [nt:base] as a where isdescendantnode(a, '/etc/commerce/products') and [cq:commerceType] = 'product' and [*/size] = 'M' union select [jcr:path], [jcr:score], * from [nt:base] as a where isdescendantnode(a, '/etc/commerce/products') and [cq:commerceType] = 'product' and [*/*/size] = 'M' union select [jcr:path], [jcr:score], * from [nt:base] as a where isdescendantnode(a, '/etc/commerce/products') and [cq:commerceType] = 'product' and [*/*/*/size] = 'M' union select [jcr:path], [jcr:score], * from [nt:base] as a where isdescendantnode(a, '/etc/commerce/products') and [cq:commerceType] = 'product' and [*/*/*/*/size] = 'M' union select [jcr:path], [jcr:score], * from [nt:base] as a where isdescendantnode(a, '/etc/commerce/products') and [cq:commerceType] = 'product' and [*/*/*/*/*/size] = 'M' /* xpath: /jcr:root/etc/commerce/products//*[@cq:commerceType = 'product' and ((@size = 'M' or */@size(*)= 'M' or */*/@size = 'M' or */*/*/@size = 'M' or */*/*/*/@size = 'M' or */*/*/*/*/@size = 'M'))] */; expected: <end>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\nindex 6e614b5..66ccb04 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n@@ -179,16 +179,8 @@ public String toString() {\n                 buff.append(orderList.get(i));\n             }\n         }\n-\n         // leave original xpath string as a comment\n-        if (xpathQuery != null) {\n-            buff.append(\" /* xpath: \");\n-            // the xpath query may not contain the \"end comment\" marker\n-            String xpathEscaped = xpathQuery.replaceAll(\"\\\\*\\\\/\", \"* /\");\n-            buff.append(xpathEscaped);\n-            buff.append(\" */\");\n-        }\n-        \n+        appendXPathAsComment(buff, xpathQuery);\n         return buff.toString();        \n     }\n \n@@ -251,14 +243,21 @@ public String toString() {\n                 }\n             }\n             // leave original xpath string as a comment\n-            if (xpathQuery != null) {\n-                buff.append(\" /* xpath: \");\n-                buff.append(xpathQuery);\n-                buff.append(\" */\");\n-            }\n+            appendXPathAsComment(buff, xpathQuery);\n             return buff.toString();\n         }\n         \n     }\n     \n+    private static void appendXPathAsComment(StringBuilder buff, String xpath) {\n+        if (xpath == null) {\n+            return;\n+        }\n+        buff.append(\" /* xpath: \");\n+        // the xpath query may contain the \"end comment\" marker\n+        String xpathEscaped = xpath.replaceAll(\"\\\\*\\\\/\", \"* /\");\n+        buff.append(xpathEscaped);\n+        buff.append(\" */\");        \n+    }\n+\n }\n", "nb_test": 1867, "linesAdd": 12, "jira_id": "2427", "singleLine": false, "nb_skipped": 9, "commit": "e6d4f9a6", "nb_failure": 0, "linesRem": 13}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["commitRootForChildrenFlag(org.apache.jackrabbit.oak.plugins.document.DocumentSplitTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\nindex 3ca3e08..f6bbb19 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n@@ -21,7 +21,6 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.NavigableMap;\n@@ -65,6 +64,7 @@\n class SplitOperations {\n \n     private static final Logger LOG = LoggerFactory.getLogger(SplitOperations.class);\n+    private static final int GARBAGE_LIMIT = Integer.getInteger(\"oak.documentMK.garbage.limit\", 10000);\n     private static final DocumentStore STORE = new MemoryDocumentStore();\n \n     private final NodeDocument doc;\n@@ -75,7 +75,9 @@\n     private Revision low;\n     private int numValues;\n     private Map<String, NavigableMap<Revision, String>> committedChanges;\n+    private Set<Revision> changes;\n     private Map<String, Set<Revision>> garbage;\n+    private int garbageCount = 0;\n     private Set<Revision> mostRecentRevs;\n     private Set<Revision> splitRevs;\n     private List<UpdateOp> splitOps;\n@@ -119,7 +121,10 @@ private SplitOperations(@Nonnull NodeDocument doc,\n         mostRecentRevs = Sets.newHashSet();\n         splitRevs = Sets.newHashSet();\n         garbage = Maps.newHashMap();\n-        committedChanges = getCommittedLocalChanges();\n+        changes = Sets.newHashSet();\n+        committedChanges = Maps.newHashMap();\n+        \n+        collectLocalChanges(committedChanges, changes);\n \n         // revisions of the most recent committed changes on this document\n         // these are kept in the main document. _revisions and _commitRoot\n@@ -215,9 +220,15 @@ private void collectRevisionsAndCommitRoot() {\n         NavigableMap<Revision, String> commitRoot =\n                 new TreeMap<Revision, String>(context.getRevisionComparator());\n         for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\n-            if (splitRevs.contains(entry.getKey())) {\n-                commitRoot.put(entry.getKey(), entry.getValue());\n+            Revision r = entry.getKey();\n+            if (splitRevs.contains(r)) {\n+                commitRoot.put(r, entry.getValue());\n                 numValues++;\n+            } else if (r.getClusterId() == context.getClusterId() \n+                    && !changes.contains(r)) {\n+                // OAK-2528: _commitRoot entry without associated\n+                // change -> consider as garbage\n+                addGarbage(r, COMMIT_ROOT);\n             }\n         }\n         committedChanges.put(COMMIT_ROOT, commitRoot);\n@@ -350,15 +361,15 @@ private UpdateOp createSplitOps() {\n     }\n \n     /**\n-     * Returns a map of all local property changes committed by the current\n+     * Collects all local property changes committed by the current\n      * cluster node.\n      *\n-     * @return local changes committed by the current cluster node.\n+     * @param committedLocally local changes committed by the current cluster node.\n+     * @param changes all revisions of local changes (committed and uncommitted).\n      */\n-    @Nonnull\n-    private Map<String, NavigableMap<Revision, String>> getCommittedLocalChanges() {\n-        Map<String, NavigableMap<Revision, String>> committedLocally\n-                = new HashMap<String, NavigableMap<Revision, String>>();\n+    private void collectLocalChanges(\n+            Map<String, NavigableMap<Revision, String>> committedLocally,\n+            Set<Revision> changes) {\n         for (String property : filter(doc.keySet(), PROPERTY_OR_DELETED)) {\n             NavigableMap<Revision, String> splitMap\n                     = new TreeMap<Revision, String>(context.getRevisionComparator());\n@@ -370,6 +381,7 @@ private UpdateOp createSplitOps() {\n                 if (rev.getClusterId() != context.getClusterId()) {\n                     continue;\n                 }\n+                changes.add(rev);\n                 if (doc.isCommitted(rev)) {\n                     splitMap.put(rev, entry.getValue());\n                 } else if (isGarbage(rev)) {\n@@ -377,7 +389,6 @@ private UpdateOp createSplitOps() {\n                 }\n             }\n         }\n-        return committedLocally;\n     }\n     \n     private boolean isGarbage(Revision rev) {\n@@ -392,12 +403,17 @@ private boolean isGarbage(Revision rev) {\n     }\n     \n     private void addGarbage(Revision rev, String property) {\n+        if (garbageCount > GARBAGE_LIMIT) {\n+            return;\n+        }\n         Set<Revision> revisions = garbage.get(property);\n         if (revisions == null) {\n             revisions = Sets.newHashSet();\n             garbage.put(property, revisions);\n         }\n-        revisions.add(rev);\n+        if (revisions.add(rev)) {\n+            garbageCount++;\n+        }\n     }\n \n     private void disconnectStalePrevDocs() {\n@@ -444,11 +460,13 @@ private void removeGarbage() {\n         for (Map.Entry<String, Set<Revision>> entry : garbage.entrySet()) {\n             for (Revision r : entry.getValue()) {\n                 main.removeMapEntry(entry.getKey(), r);\n+                if (PROPERTY_OR_DELETED.apply(entry.getKey())) {\n                     NodeDocument.removeCommitRoot(main, r);\n                     NodeDocument.removeRevision(main, r);\n                 }\n             }\n         }\n+    }\n \n     private void trackHigh(Revision r) {\n         if (high == null || isRevisionNewer(context, r, high)) {\n", "nb_test": 1951, "linesAdd": 25, "jira_id": "2528", "singleLine": false, "nb_skipped": 9, "commit": "239de7b8", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["revisionComparatorCluster(org.apache.jackrabbit.oak.plugins.document.RevisionTest): expected:<1> but was:<-1>", "revisionSeen(org.apache.jackrabbit.oak.plugins.document.RevisionTest): expected:<r10-0-0> but was:<null>", "seenAtBeforeFirstRangeAfterPurge(org.apache.jackrabbit.oak.plugins.document.RevisionTest): expected:<r3-0-0> but was:<null>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\nindex 9265368..be45ba3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n@@ -549,6 +549,9 @@ public int compare(Revision o1, Revision o2) {\n          * <ul>\n          *     <li>\n          *         {@code null} if the revision is older than the earliest range\n+         *         and the revision timestamp is less than or equal the time\n+         *         of the last {@link #purge(long)} (see also\n+         *         {@link #oldestTimestamp}).\n          *     </li>\n          *     <li>\n          *         if the revision is newer than the lower bound of the newest\n@@ -565,9 +568,49 @@ public int compare(Revision o1, Revision o2) {\n          *     </li>\n          * </ul>\n          *\n+         * Below is a graph for a revision comparison example as seen from one\n+         * cluster node with some known revision ranges. Revision ranges less\n+         * than or equal r2-0-0 have been purged and there are known ranges for\n+         * cluster node 1 (this cluster node) and cluster node 2 (some other\n+         * cluster node).\n+         * <pre>\n+         *     View from cluster node 1:\n+         *\n+         *                purge    r3-0-1    r5-0-2    r7-0-1\n+         *                  \u02c5         \u02c5         \u02c5         \u02c5\n+         *     ---+---------+---------+---------+---------+---------\n+         *     r1-0-0    r2-0-0    r3-0-0    r4-0-0    r5-0-0\n+         *\n+         *            ^\n+         *         r1-0-1 -> null (1)\n+         *\n+         *                      ^\n+         *                   r4-0-2 -> r4-0-0 (2)\n+         *\n+         *                            ^\n+         *                         r3-0-1 -> r3-0-0 (3)\n+         *\n+         *                                           ^\n+         *                                        r6-0-2 -> FUTURE (4)\n+         *\n+         *                                                       ^\n+         *                                                    r9-0-1 -> NEWEST (5)\n+         * </pre>\n+         * <ol>\n+         *     <li>older than earliest range and purge time</li>\n+         *     <li>seen-at of next higher range</li>\n+         *     <li>seen-at of matching lower bound of range</li>\n+         *     <li>foreign revision is newer than most recent range</li>\n+         *     <li>local revision is newer than most recent range</li>\n+         * </ol>\n+         * This gives the following revision ordering:\n+         * <pre>\n+         * r1-0-1 < r3-0-1 < r-4-0-2 < r9-0-1 < r6-0-2\n+         * </pre>\n+         *\n          * @param r the revision\n          * @return the seen-at revision or {@code null} if the revision is older\n-         *          than the earliest range.\n+         *          than the earliest range and purge time.\n          */\n         Revision getRevisionSeen(Revision r) {\n             List<RevisionRange> list = map.get(r.getClusterId());\n@@ -586,8 +629,9 @@ Revision getRevisionSeen(Revision r) {\n             // search from latest backward\n             // (binary search could be used, but we expect most queries\n             // at the end of the list)\n+            RevisionRange range = null;\n             for (int i = list.size() - 1; i >= 0; i--) {\n-                RevisionRange range = list.get(i);\n+                range = list.get(i);\n                 int compare = r.compareRevisionTime(range.revision);\n                 if (compare == 0) {\n                     return range.seenAt;\n@@ -597,15 +641,21 @@ Revision getRevisionSeen(Revision r) {\n                         if (r.getClusterId() == currentClusterNodeId) {\n                             // newer than all others, except for FUTURE\n                             return NEWEST;\n-                        }\n+                        } else {\n                             // happens in the future (not visible yet)\n                             return FUTURE;\n+                        }\n                     } else {\n                         // there is a newer range\n                         return list.get(i + 1).seenAt;\n                     }\n                 }\n             }\n+            if (range != null && r.getTimestamp() > oldestTimestamp) {\n+                // revision is older than earliest range and after purge\n+                // timestamp. return seen-at revision of earliest range.\n+                return range.seenAt;\n+            }\n             return null;\n         }\n \n", "nb_test": 1805, "linesAdd": 7, "jira_id": "1788", "singleLine": false, "nb_skipped": 9, "commit": "dd3437d4", "nb_failure": 3, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 16, "classification": {"singleLine": false}, "failing_tests": ["sql1(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): No LoginModules configured for jackrabbit.oak", "sql2(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): No LoginModules configured for jackrabbit.oak", "xpath(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): No LoginModules configured for jackrabbit.oak", "bindVariableTest(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): No LoginModules configured for jackrabbit.oak", "sql1(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): No LoginModules configured for jackrabbit.oak", "sql2(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): No LoginModules configured for jackrabbit.oak", "xpath(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): No LoginModules configured for jackrabbit.oak", "bindVariableTest(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): No LoginModules configured for jackrabbit.oak", "sql1(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest): No LoginModules configured for jackrabbit.oak", "sql2(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest): No LoginModules configured for jackrabbit.oak", "xpath(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest): No LoginModules configured for jackrabbit.oak", "bindVariableTest(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest): No LoginModules configured for jackrabbit.oak", "sql2Explain(org.apache.jackrabbit.oak.plugins.index.old.QueryTest): No LoginModules configured for jackrabbit.oak", "sql1(org.apache.jackrabbit.oak.plugins.index.old.QueryTest): No LoginModules configured for jackrabbit.oak", "xpath(org.apache.jackrabbit.oak.plugins.index.old.QueryTest): No LoginModules configured for jackrabbit.oak", "bindVariableTest(org.apache.jackrabbit.oak.plugins.index.old.QueryTest): No LoginModules configured for jackrabbit.oak"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/SecurityProviderImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/SecurityProviderImpl.java\nindex 5e199bf..6d6487b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/SecurityProviderImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/SecurityProviderImpl.java\n@@ -77,6 +77,11 @@ public LoginContextProvider getLoginContextProvider(NodeStore nodeStore) {\n             loginConfig = new OakConfiguration();\n             Configuration.setConfiguration(loginConfig);\n         }\n+        if (loginConfig.getAppConfigurationEntry(appName) == null) {\n+            log.warn(\"Failed to retrieve login configuration for {}: using default configuration.\", appName);\n+            loginConfig = new OakConfiguration();\n+            Configuration.setConfiguration(loginConfig);\n+        }\n         return new LoginContextProviderImpl(appName, loginConfig, nodeStore, this);\n     }\n \n", "nb_test": 265, "linesAdd": 5, "jira_id": "379", "singleLine": false, "nb_skipped": 7, "commit": "621a5101", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["addEmptyMultiValue(org.apache.jackrabbit.oak.jcr.RepositoryTest): Invalid type: UNDEFINEDS"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\nindex d59feb5..ba16709 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\n@@ -430,8 +430,12 @@ PropertyState createMultiState(String name, int type, Value[] values, PropertyDe\n         Value[] nonNullValues = compact(values);\n         int targetType = getType(definition, type);\n         if (nonNullValues.length == 0) {\n+            if (targetType == PropertyType.UNDEFINED) {\n+                // default to string when no other type hints are available\n+                targetType = PropertyType.STRING;\n+            }\n             return MemoryPropertyBuilder\n-                    .array(Type.fromTag(type, false), name)\n+                    .array(Type.fromTag(targetType, false), name)\n                     .getPropertyState();\n         } else if (targetType == type) {\n             return PropertyStates.createProperty(name, Arrays.asList(nonNullValues));\n", "nb_test": 702, "linesAdd": 4, "jira_id": "510", "singleLine": false, "nb_skipped": 7, "commit": "f63d745a", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 23, "classification": {"singleLine": false}, "failing_tests": ["testPrivilegeFromName(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testGetApplicablePolicies(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testGetApplicableRepoPolicies(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testGetApplicablePoliciesForAccessControlled(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testGetApplicablePoliciesForAcContentPaths(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testGetPolicies(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testGetPoliciesAfterSet(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testGetPoliciesAfterRemove(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testGetPolicyWithInvalidPrincipal(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testGetRepoPolicies(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testGetPoliciesAcContentPaths(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testGetEffectivePoliciesForAcContentPaths(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testSetPolicy(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testSetPolicyWritesAcContent(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testModifyExistingPolicy(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testSetPolicyAcContent(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testRemovePolicyAcContent(org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest)", "testOakToJcr(org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest)", "testEmptyName(org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest)", "testEquals(org.apache.jackrabbit.oak.spi.security.authorization.restriction.RestrictionImplTest)", "testGetJcrName(org.apache.jackrabbit.oak.spi.security.authorization.restriction.RestrictionImplTest)", "testEquals(org.apache.jackrabbit.oak.spi.security.authorization.restriction.RestrictionDefinitionImplTest)", "testGetJcrName(org.apache.jackrabbit.oak.spi.security.authorization.restriction.RestrictionDefinitionImplTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/LocalNameMapper.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/LocalNameMapper.java\nindex f17a69b..eb558c5 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/LocalNameMapper.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/LocalNameMapper.java\n@@ -40,8 +40,8 @@ private static boolean isExpandedName(String name) {\n     @Override @CheckForNull\n     public String getJcrName(String oakName) {\n         checkNotNull(oakName);\n-        checkArgument(!oakName.startsWith(\":\")); // hidden name\n-        checkArgument(isExpandedName(oakName));  // expanded name\n+        checkArgument(!oakName.startsWith(\":\"), oakName); // hidden name\n+        checkArgument(!isExpandedName(oakName), oakName); // expanded name\n \n         if (hasSessionLocalMappings()) {\n             int colon = oakName.indexOf(':');\n", "nb_test": 705, "linesAdd": 2, "jira_id": "509", "singleLine": false, "nb_skipped": 1, "commit": "b896c926", "nb_failure": 0, "rtElixir": true, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 5, "classification": {"singleLine": false}, "failing_tests": ["invalidItemStateExceptionOnRemovedNode(org.apache.jackrabbit.oak.jcr.RepositoryTest): stale", "removeExistingNodeRefreshParent(org.apache.jackrabbit.oak.jcr.MoveRemoveTest): stale", "moveExistingNodeRefresh(org.apache.jackrabbit.oak.jcr.MoveRemoveTest): stale", "moveExistingNodeRefreshParent(org.apache.jackrabbit.oak.jcr.MoveRemoveTest): stale", "removeExistingNodeRefresh(org.apache.jackrabbit.oak.jcr.MoveRemoveTest): stale"], "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemDelegate.java\nindex 501cebb..426621f 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemDelegate.java\n@@ -83,8 +83,7 @@ public NodeDelegate getParent() throws InvalidItemStateException {\n      * @return  {@code true} iff stale\n      */\n     public boolean isStale() {\n-        Status status = getLocationOrNull().getStatus();\n-        return status == Status.DISCONNECTED || status == null;\n+        return !getLocationInternal().exists();\n     }\n \n     /**\n@@ -116,7 +115,7 @@ public final SessionDelegate getSessionDelegate() {\n      */\n     @Nonnull\n     public TreeLocation getLocation() throws InvalidItemStateException {\n-        TreeLocation location = getLocationOrNull();\n+        TreeLocation location = getLocationInternal();\n         if (!location.exists()) {\n             throw new InvalidItemStateException(\"Item is stale\");\n         }\n@@ -134,12 +133,12 @@ public String toString() {\n     /**\n      * The underlying {@link org.apache.jackrabbit.oak.api.TreeLocation} of this item.\n      * The location is only re-resolved when the revision of this item does not match\n-     * the revision of the session.\n+     * the revision of the session or when the location does not exist (anymore).\n      * @return  tree location of the underlying item.\n      */\n     @Nonnull\n-    private synchronized TreeLocation getLocationOrNull() {\n-        if (location.exists() && sessionDelegate.getRevision() != revision) {\n+    private synchronized TreeLocation getLocationInternal() {\n+        if (sessionDelegate.getRevision() != revision || !location.exists()) {\n             location = sessionDelegate.getLocation(location.getPath());\n             revision = sessionDelegate.getRevision();\n         }\n", "nb_test": 509, "linesAdd": 4, "jira_id": "606", "singleLine": false, "nb_skipped": 1, "commit": "f0fbacab", "nb_failure": 0, "linesRem": 5}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReindexAsync(org.apache.jackrabbit.oak.plugins.index.IndexUpdateTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/Oak.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/Oak.java\nindex 04020c1..9399ae9 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/Oak.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/Oak.java\n@@ -60,6 +61,7 @@\n import org.apache.jackrabbit.oak.plugins.commit.ConflictHook;\n import org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate;\n import org.apache.jackrabbit.oak.plugins.index.CompositeIndexEditorProvider;\n+import org.apache.jackrabbit.oak.plugins.index.IndexConstants;\n import org.apache.jackrabbit.oak.plugins.index.IndexEditorProvider;\n import org.apache.jackrabbit.oak.plugins.index.IndexUpdateProvider;\n import org.apache.jackrabbit.oak.plugins.index.property.jmx.PropertyIndexAsyncReindex;\n@@ -528,11 +530,11 @@ public ContentRepository createContentRepository() {\n                     task.getIndexStats(), IndexStatsMBean.TYPE, name));\n \n             PropertyIndexAsyncReindex asyncPI = new PropertyIndexAsyncReindex(\n-                    new AsyncIndexUpdate(\"async-reindex\", store, indexEditors,\n-                            true), getExecutor()\n-            );\n-            regs.add(registerMBean(whiteboard, PropertyIndexAsyncReindexMBean.class,\n-                    asyncPI, PropertyIndexAsyncReindexMBean.TYPE, name));\n+                    new AsyncIndexUpdate(IndexConstants.ASYNC_REINDEX_VALUE,\n+                            store, indexEditors, true), getExecutor());\n+            regs.add(registerMBean(whiteboard,\n+                    PropertyIndexAsyncReindexMBean.class, asyncPI,\n+                    PropertyIndexAsyncReindexMBean.TYPE, name));\n         }\n \n         regs.add(registerMBean(whiteboard, QueryEngineSettingsMBean.class,\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\nindex c8879d0..ea8dd80 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n@@ -357,9 +357,10 @@ private void updateIndex(\n                 } else {\n                     postAsyncRunStatsStatus(indexStats);\n                 }\n-            } else if (switchOnSync) {\n-                log.debug(\"No changes detected after diff; will try to\"\n-                        + \" switch to synchronous updates on {}\",\n+            } else {\n+                if (switchOnSync) {\n+                    log.debug(\n+                            \"No changes detected after diff; will try to switch to synchronous updates on {}\",\n                             reindexedDefinitions);\n \n                     // no changes after diff, switch to sync on the async defs\n@@ -374,12 +375,12 @@ private void updateIndex(\n                     }\n                     reindexedDefinitions.clear();\n                 }\n+                postAsyncRunStatsStatus(indexStats);\n+            }\n             mergeWithConcurrencyCheck(builder, beforeCheckpoint, callback.lease);\n         } finally {\n             callback.close();\n         }\n-\n-        postAsyncRunStatsStatus(indexStats);\n     }\n \n     private void mergeWithConcurrencyCheck(\n", "nb_test": 1936, "linesAdd": 12, "jira_id": "2174", "singleLine": false, "nb_skipped": 9, "commit": "5931a4a7", "nb_failure": 1, "linesRem": 10}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["cpCleanupNoChanges(org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdateTest): Expecting the initial checkpoint"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\nindex d52c430..74755fe 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n@@ -21,11 +21,9 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.MISSING_NODE;\n import static org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean.STATUS_DONE;\n-import static org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean.STATUS_RUNNING;\n import static org.apache.jackrabbit.oak.commons.PathUtils.elements;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_PROPERTY_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.ASYNC_PROPERTY_NAME;\n-import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFINITIONS_NAME;\n \n import java.util.Calendar;\n import java.util.HashSet;\n@@ -36,18 +34,15 @@\n \n import org.apache.jackrabbit.oak.api.CommitFailedException;\n import org.apache.jackrabbit.oak.api.PropertyState;\n-import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean;\n import org.apache.jackrabbit.oak.plugins.commit.AnnotatingConflictHandler;\n import org.apache.jackrabbit.oak.plugins.commit.ConflictHook;\n import org.apache.jackrabbit.oak.plugins.commit.ConflictValidatorProvider;\n-import org.apache.jackrabbit.oak.plugins.value.Conversions;\n import org.apache.jackrabbit.oak.spi.commit.CommitHook;\n import org.apache.jackrabbit.oak.spi.commit.CommitInfo;\n import org.apache.jackrabbit.oak.spi.commit.CompositeHook;\n import org.apache.jackrabbit.oak.spi.commit.EditorDiff;\n import org.apache.jackrabbit.oak.spi.commit.EditorHook;\n-import org.apache.jackrabbit.oak.spi.commit.EmptyHook;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n import org.apache.jackrabbit.oak.spi.state.NodeStateDiff;\n@@ -75,8 +70,9 @@\n             \"Async\", 1, \"Concurrent update detected\");\n \n     /**\n-     * Timeout in minutes after which an async job would be considered as timed out. Another\n-     * node in cluster would wait for timeout before taking over a running job\n+     * Timeout in minutes after which an async job would be considered as\n+     * timed out. Another node in cluster would wait for timeout before\n+     * taking over a running job\n      */\n     private static final int ASYNC_TIMEOUT = 15;\n \n@@ -125,13 +121,55 @@ public AsyncIndexUpdate(@Nonnull String name, @Nonnull NodeStore store,\n      */\n     private class AsyncUpdateCallback implements IndexUpdateCallback {\n \n-        private boolean dirty = false;\n+        /** The base checkpoint */\n+        private final String checkpoint;\n+\n+        /** Expiration time of the last lease we committed */\n+        private long lease;\n+\n+        private long updates = 0;\n+\n+        public AsyncUpdateCallback(String checkpoint)\n+                throws CommitFailedException {\n+            long now = System.currentTimeMillis();\n+            this.checkpoint = checkpoint;\n+            this.lease = now + 2 * ASYNC_TIMEOUT;\n+\n+            String leaseName = name + \"-lease\";\n+            NodeState root = store.getRoot();\n+            long beforeLease = root.getChildNode(ASYNC).getLong(leaseName);\n+            if (beforeLease > now) {\n+                throw CONCURRENT_UPDATE;\n+            }\n+\n+            NodeBuilder builder = root.builder();\n+            builder.child(ASYNC).setProperty(leaseName, lease);\n+            mergeWithConcurrencyCheck(builder, checkpoint, beforeLease);\n+        }\n+\n+        boolean isDirty() {\n+            return updates > 0;\n+        }\n+\n+        void close() throws CommitFailedException {\n+            NodeBuilder builder = store.getRoot().builder();\n+            NodeBuilder async = builder.child(ASYNC);\n+            async.removeProperty(name + \"-lease\");\n+            mergeWithConcurrencyCheck(builder, async.getString(name), lease);\n+        }\n \n         @Override\n         public void indexUpdate() throws CommitFailedException {\n-            if (!dirty) {\n-                dirty = true;\n-                preAsyncRun(store, name);\n+            updates++;\n+            if (updates % 100 == 0) {\n+                long now = System.currentTimeMillis();\n+                if (now + ASYNC_TIMEOUT > lease) {\n+                    long newLease = now + 2 * ASYNC_TIMEOUT;\n+                    NodeBuilder builder = store.getRoot().builder();\n+                    builder.child(ASYNC).setProperty(name + \"-lease\", newLease);\n+                    mergeWithConcurrencyCheck(builder, checkpoint, lease);\n+                    lease = newLease;\n+                }\n             }\n         }\n \n@@ -141,20 +179,26 @@ public void indexUpdate() throws CommitFailedException {\n     public synchronized void run() {\n         log.debug(\"Running background index task {}\", name);\n \n-        if (isAlreadyRunning(store, name)) {\n-            log.debug(\"The {} indexer is already running; skipping this update\", name);\n+        NodeState root = store.getRoot();\n+\n+        // check for concurrent updates\n+        NodeState async = root.getChildNode(ASYNC);\n+        if (async.getLong(name + \"-lease\") > System.currentTimeMillis()) {\n+            log.debug(\"Another copy of the {} index update is already running;\"\n+                    + \" skipping this update\", name);\n             return;\n         }\n \n+        // find the last indexed state, and check if there are recent changes\n         NodeState before;\n-        NodeState root = store.getRoot();\n-        String refCheckpoint = root.getChildNode(ASYNC).getString(name);\n-        if (refCheckpoint != null) {\n-            NodeState state = store.retrieve(refCheckpoint);\n+        String beforeCheckpoint = async.getString(name);\n+        if (beforeCheckpoint != null) {\n+            NodeState state = store.retrieve(beforeCheckpoint);\n             if (state == null) {\n                 log.warn(\"Failed to retrieve previously indexed checkpoint {};\"\n-                        + \" rerunning the initial {} index update\",\n-                        refCheckpoint, name);\n+                        + \" re-running the initial {} index update\",\n+                        beforeCheckpoint, name);\n+                beforeCheckpoint = null;\n                 before = MISSING_NODE;\n             } else if (noVisibleChanges(state, root)) {\n                 log.debug(\"No changes since last checkpoint;\"\n@@ -168,43 +212,84 @@ public synchronized void run() {\n             before = MISSING_NODE;\n         }\n \n-        String checkpoint = store.checkpoint(lifetime);\n-        NodeState after = store.retrieve(checkpoint);\n+        // there are some recent changes, so let's create a new checkpoint\n+        String afterCheckpoint = store.checkpoint(lifetime);\n+        NodeState after = store.retrieve(afterCheckpoint);\n         if (after == null) {\n             log.warn(\"Unable to retrieve newly created checkpoint {},\"\n-                    + \" skipping the {} index update\", checkpoint, name);\n+                    + \" skipping the {} index update\", afterCheckpoint, name);\n             return;\n         }\n \n-        NodeBuilder builder = store.getRoot().builder();\n-        NodeBuilder async = builder.child(ASYNC);\n-\n-        AsyncUpdateCallback callback = new AsyncUpdateCallback();\n-        preAsyncRunStatsStats(indexStats);\n-        IndexUpdate indexUpdate = new IndexUpdate(\n-                provider, name, after, builder, callback);\n-\n-        CommitFailedException exception = EditorDiff.process(\n-                indexUpdate, before, after);\n-        if (exception == null) {\n-            if (callback.dirty) {\n-                async.setProperty(name, checkpoint);\n+        String checkpointToRelease = afterCheckpoint;\n         try {\n-                    store.merge(builder, newCommitHook(name, refCheckpoint),\n-                            CommitInfo.EMPTY);\n+            updateIndex(before, beforeCheckpoint, after, afterCheckpoint);\n+\n+            // the update succeeded, i.e. it no longer fails\n+            if (failing) {\n+                log.info(\"Index update {} no longer fails\", name);\n+                failing = false;\n+            }\n+\n+            // the update succeeded, so we can release the earlier checkpoint\n+            // otherwise the new checkpoint associated with the failed update\n+            // will get released in the finally block\n+            checkpointToRelease = beforeCheckpoint;\n+\n         } catch (CommitFailedException e) {\n-                    if (e != CONCURRENT_UPDATE) {\n-                        exception = e;\n+            if (e == CONCURRENT_UPDATE) {\n+                log.debug(\"Concurrent update detected in the {} index update\", name);\n+            } else if (failing) {\n+                log.debug(\"The {} index update is still failing\", name, e);\n+            } else {\n+                log.warn(\"The {} index update failed\", name, e);\n+                failing = true;\n             }\n+\n+        } finally {\n+            if (checkpointToRelease != null) { // null during initial indexing\n+                store.release(checkpointToRelease);\n+            }\n+        }\n+    }\n+\n+    private void updateIndex(\n+            NodeState before, String beforeCheckpoint,\n+            NodeState after, String afterCheckpoint)\n+            throws CommitFailedException {\n+        // start collecting runtime statistics\n+        preAsyncRunStatsStats(indexStats);\n+\n+        // create an update callback for tracking index updates\n+        // and maintaining the update lease\n+        AsyncUpdateCallback callback =\n+                new AsyncUpdateCallback(beforeCheckpoint);\n+        try {\n+            NodeBuilder builder = store.getRoot().builder();\n+\n+            IndexUpdate indexUpdate =\n+                    new IndexUpdate(provider, name, after, builder, callback);\n+            CommitFailedException exception =\n+                    EditorDiff.process(indexUpdate, before, after);\n+            if (exception != null) {\n+                throw exception;\n             }\n+\n+            if (callback.isDirty() || before == MISSING_NODE) {\n+                builder.child(ASYNC).setProperty(name, afterCheckpoint);\n+                mergeWithConcurrencyCheck(\n+                        builder, beforeCheckpoint, callback.lease);\n+\n                 if (switchOnSync) {\n                     reindexedDefinitions.addAll(\n                             indexUpdate.getReindexedDefinitions());\n+                } else {\n+                    postAsyncRunStatsStatus(indexStats);\n                 }\n             } else if (switchOnSync) {\n-                log.debug(\"No changes detected after diff, will try to switch to synchronous updates on \"\n-                        + reindexedDefinitions);\n-                async.setProperty(name, checkpoint);\n+                log.debug(\"No changes detected after diff; will try to\"\n+                        + \" switch to synchronous updates on {}\",\n+                        reindexedDefinitions);\n \n                 // no changes after diff, switch to sync on the async defs\n                 for (String path : reindexedDefinitions) {\n@@ -217,125 +302,48 @@ public synchronized void run() {\n                     }\n                 }\n \n-                try {\n-                    store.merge(builder, newCommitHook(name, refCheckpoint),\n-                            CommitInfo.EMPTY);\n+                mergeWithConcurrencyCheck(\n+                        builder, beforeCheckpoint, callback.lease);\n                 reindexedDefinitions.clear();\n-                } catch (CommitFailedException e) {\n-                    if (e != CONCURRENT_UPDATE) {\n-                        exception = e;\n             }\n+        } finally {\n+            callback.close();\n         }\n-            }\n-        }\n-        postAsyncRunStatsStatus(indexStats);\n \n-        // checkpoints cleanup\n-        if (exception != null || (exception == null && !callback.dirty)) {\n-            log.debug(\"The {} index update failed; releasing the related checkpoint {}\",\n-                    name, checkpoint);\n-            store.release(checkpoint);\n-        } else {\n-            if (refCheckpoint != null) {\n-                log.debug(\n-                        \"The {} index update succeeded; releasing the previous checkpoint {}\",\n-                        name, refCheckpoint);\n-                store.release(refCheckpoint);\n-            }\n-        }\n-\n-        if (exception != null) {\n-            if (!failing) {\n-                log.warn(\"Index update {} failed\", name, exception);\n-            }\n-            failing = true;\n-        } else {\n-            if (failing) {\n-                log.info(\"Index update {} no longer fails\", name);\n-            }\n-            failing = false;\n-        }\n+        postAsyncRunStatsStatus(indexStats);\n     }\n \n-    private static CommitHook newCommitHook(\n-            final String name, final String checkpoint) {\n-        return new CompositeHook(\n-                new ConflictHook(new AnnotatingConflictHandler()),\n-                new EditorHook(new ConflictValidatorProvider()),\n-                new CommitHook() {\n+    private void mergeWithConcurrencyCheck(\n+            NodeBuilder builder, final String checkpoint, final long lease)\n+            throws CommitFailedException {\n+        CommitHook concurrentUpdateCheck = new CommitHook() {\n             @Override @Nonnull\n             public NodeState processCommit(\n                     NodeState before, NodeState after, CommitInfo info)\n                     throws CommitFailedException {\n                 // check for concurrent updates by this async task\n-                String checkpointAfterRebase =\n-                        before.getChildNode(ASYNC).getString(name);\n-                if (Objects.equal(checkpoint, checkpointAfterRebase)) {\n-                    return postAsyncRunNodeStatus(after.builder(), name)\n-                            .getNodeState();\n+                NodeState async = before.getChildNode(ASYNC);\n+                if (Objects.equal(checkpoint, async.getString(name))\n+                        && lease == async.getLong(name + \"-lease\")) {\n+                    return after;\n                 } else {\n+                    new Exception(checkpoint + \" - \" + async.getString(name)\n+                            + \" / \" + lease + \" - \" + async.getLong(name + \"-lease\")).printStackTrace();\n                     throw CONCURRENT_UPDATE;\n                 }\n             }\n-        });\n-    }\n-\n-    private static void preAsyncRun(NodeStore store, String name) throws CommitFailedException {\n-        NodeBuilder builder = store.getRoot().builder();\n-        preAsyncRunNodeStatus(builder, name);\n-        store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n-    }\n-\n-    private static boolean isAlreadyRunning(NodeStore store, String name) {\n-        NodeState indexState = store.getRoot().getChildNode(INDEX_DEFINITIONS_NAME);\n-\n-        //Probably the first run\n-        if (!indexState.exists()) {\n-            return false;\n-        }\n-\n-        //Check if already running or timed out\n-        if (STATUS_RUNNING.equals(indexState.getString(name + \"-status\"))) {\n-            PropertyState startTime = indexState.getProperty(name + \"-start\");\n-            Calendar start = Conversions.convert(startTime.getValue(Type.DATE)).toCalendar();\n-            Calendar now = Calendar.getInstance();\n-            long delta = now.getTimeInMillis() - start.getTimeInMillis();\n-\n-            //Check if the job has timed out and we need to take over\n-            if (TimeUnit.MILLISECONDS.toMinutes(delta) > ASYNC_TIMEOUT) {\n-                log.info(\"Async job found which stated on {} has timed out in {} minutes. \" +\n-                        \"This node would take over the job.\",\n-                        startTime.getValue(Type.DATE), ASYNC_TIMEOUT);\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n-    private static void preAsyncRunNodeStatus(NodeBuilder builder, String name) {\n-        String now = now();\n-        builder.getChildNode(INDEX_DEFINITIONS_NAME)\n-                .setProperty(name + \"-status\", STATUS_RUNNING)\n-                .setProperty(name + \"-start\", now, Type.DATE)\n-                .removeProperty(name + \"-done\");\n+        };\n+        CompositeHook hooks = new CompositeHook(\n+                new ConflictHook(new AnnotatingConflictHandler()),\n+                new EditorHook(new ConflictValidatorProvider()),\n+                concurrentUpdateCheck);\n+        store.merge(builder, hooks, CommitInfo.EMPTY);\n     }\n \n     private static void preAsyncRunStatsStats(AsyncIndexStats stats) {\n         stats.start(now());\n     }\n \n-    private static NodeBuilder postAsyncRunNodeStatus(\n-            NodeBuilder builder, String name) {\n-        String now = now();\n-        builder.getChildNode(INDEX_DEFINITIONS_NAME)\n-                .setProperty(name + \"-status\", STATUS_DONE)\n-                .setProperty(name + \"-done\", now, Type.DATE)\n-                .removeProperty(name + \"-start\");\n-        return builder;\n-    }\n-\n      private static void postAsyncRunStatsStatus(AsyncIndexStats stats) {\n         stats.done(now());\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\nindex 75f0f31..914f23f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n@@ -102,7 +102,7 @@ private IndexUpdate(IndexUpdate parent, String name) {\n         this.provider = parent.provider;\n         this.async = parent.async;\n         this.root = parent.root;\n-        this.builder = parent.builder.child(checkNotNull(name));\n+        this.builder = parent.builder.getChildNode(checkNotNull(name));\n         this.updateCallback = parent.updateCallback;\n     }\n \n", "nb_test": 1807, "linesAdd": 134, "jira_id": "1877", "singleLine": false, "nb_skipped": 9, "commit": "716e1237", "nb_failure": 1, "linesRem": 135}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 1, "classification": {"singleLine": true}, "failing_tests": ["sql2(org.apache.jackrabbit.oak.plugins.index.solr.query.SolrIndexQueryTest): org.apache.lucene.queryparser.classic.ParseException: Cannot parse 'path_exact:/test*': Lexical error at line 1, column 18.  Encountered: <EOF> after : \"/test*\""], "patch": "diff --git a/oak-solr-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/solr/index/SolrIndexUpdate.java b/oak-solr-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/solr/index/SolrIndexUpdate.java\nindex 3cdc05c..45cc00d 100644\n--- a/oak-solr-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/solr/index/SolrIndexUpdate.java\n+++ b/oak-solr-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/solr/index/SolrIndexUpdate.java\n@@ -152,6 +152,7 @@ private void deleteSubtreeWriter(SolrServer solrServer, String path)\n         if (!path.startsWith(\"/\")) {\n             path = \"/\" + path;\n         }\n+        path = path.replace(\"/\", \"\\\\/\");\n         solrServer.deleteByQuery(new StringBuilder(configuration.getPathField())\n                 .append(':').append(path).append(\"*\").toString());\n     }\n", "nb_test": 13, "linesAdd": 1, "jira_id": "740", "singleLine": true, "nb_skipped": 1, "commit": "35a7f014", "nb_failure": 0, "rtElixir": true, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["sql2(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): Results in target/sql2.txt don't match expected results in src/test/resources/sql2.txt; compare the files for details", "sql2(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): Results in target/sql2.txt don't match expected results in src/test/resources/sql2.txt; compare the files for details", "sql2(org.apache.jackrabbit.oak.plugins.index.old.QueryTest): Results in target/sql2.txt don't match expected results in src/test/resources/sql2.txt; compare the files for details"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java\nindex a31fd0a..4f70f1e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java\n@@ -525,6 +525,23 @@ private PropertyValueImpl parsePropertyValue(String name) throws ParseException\n     private StaticOperandImpl parseStaticOperand() throws ParseException {\n         if (currentTokenType == PLUS) {\n             read();\n+            if (currentTokenType != VALUE) {\n+                throw getSyntaxError(\"number\");\n+            }\n+            int valueType = currentValue.getType().tag();\n+            switch (valueType) {\n+            case PropertyType.LONG:\n+                currentValue = PropertyValues.newLong(currentValue.getValue(Type.LONG));\n+                break;\n+            case PropertyType.DOUBLE:\n+                currentValue = PropertyValues.newDouble(currentValue.getValue(Type.DOUBLE));\n+                break;\n+            case PropertyType.DECIMAL:\n+                currentValue = PropertyValues.newDecimal(currentValue.getValue(Type.DECIMAL).negate());\n+                break;\n+            default:\n+                throw getSyntaxError(\"Illegal operation: + \" + currentValue);\n+            }\n         } else if (currentTokenType == MINUS) {\n             read();\n             if (currentTokenType != VALUE) {\n@@ -923,7 +940,10 @@ private void read() throws ParseException {\n             if (types[i] == CHAR_SPECIAL_2) {\n                 i++;\n             }\n-            // fall through\n+            currentToken = statement.substring(start, i);\n+            currentTokenType = KEYWORD;\n+            parseIndex = i;\n+            return;\n         case CHAR_SPECIAL_1:\n             currentToken = statement.substring(start, i);\n             switch (c) {\n", "nb_test": 404, "linesAdd": 21, "jira_id": "499", "singleLine": false, "nb_skipped": 0, "commit": "61381ea2", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ignoreUncommitted(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest): expected:<0> but was:<1>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex f78ffed..b1b7de7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -966,8 +966,7 @@ public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore,\n \n             // check if there may be more recent values in a previous document\n             if (!getPreviousRanges().isEmpty()) {\n-                Revision newest = local.firstKey();\n-                if (isRevisionNewer(nodeStore, newest, value.revision)) {\n+                if (!isMostRecentCommitted(nodeStore, local, value.revision)) {\n                     // not reading the most recent value, we may need to\n                     // consider previous documents as well\n                     Revision newestPrev = getPreviousRanges().firstKey();\n@@ -1709,6 +1708,39 @@ public static void setHasBinary(@Nonnull UpdateOp op) {\n     //----------------------------< internal >----------------------------------\n \n     /**\n+     * Returns {@code true} if the given {@code revision} is more recent or\n+     * equal to the committed revision in {@code valueMap}. This method assumes\n+     * the given {@code revision} is committed.\n+     *\n+     * @param context the revision context.\n+     * @param valueMap the value map sorted most recent first.\n+     * @param revision a committed revision.\n+     * @return if {@code revision} is the most recent committed revision in the\n+     *          {@code valueMap}.\n+     */\n+    private boolean isMostRecentCommitted(RevisionContext context,\n+                                          SortedMap<Revision, String> valueMap,\n+                                          Revision revision) {\n+        if (valueMap.isEmpty()) {\n+            return true;\n+        }\n+        // shortcut when revision is the first key\n+        Revision first = valueMap.firstKey();\n+        if (!isRevisionNewer(context, first, revision)) {\n+            return true;\n+        }\n+        // need to check commit status\n+        for (Revision r : valueMap.keySet()) {\n+            Revision c = getCommitRevision(r);\n+            if (c != null) {\n+                return !isRevisionNewer(context, c, revision);\n+            }\n+        }\n+        // no committed revision found in valueMap\n+        return true;\n+    }\n+\n+    /**\n      * Returns {@code true} if the two revisions are ambiguous. That is, they\n      * are from different cluster nodes and the comparison of the two revision\n      * depends on the seen at revision and is different when just comparing the\n", "nb_test": 2651, "linesAdd": 20, "jira_id": "3474", "singleLine": false, "nb_skipped": 1, "commit": "ff81ef72", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["containsMapEntry(org.apache.jackrabbit.mongomk.MongoDocumentStoreTest)"], "patch": "diff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MemoryDocumentStore.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MemoryDocumentStore.java\nindex e984585..ad581b7 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MemoryDocumentStore.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MemoryDocumentStore.java\n@@ -178,14 +178,14 @@ private static boolean checkConditions(Map<String, Object> target,\n                         return false;\n                     }\n                 } else {\n-                    if (value instanceof java.util.Collection) {\n-                        java.util.Collection<?> col = (java.util.Collection<?>) value;\n+                    if (value instanceof Map) {\n+                        Map map = (Map) value;\n                         if (Boolean.TRUE.equals(op.value)) {\n-                            if (!col.contains(kv[1])) {\n+                            if (!map.containsKey(kv[1])) {\n                                 return false;\n                             }\n                         } else {\n-                            if (col.contains(kv[1])) {\n+                            if (map.containsKey(kv[1])) {\n                                 return false;\n                             }\n                         }\n", "nb_test": 186, "linesAdd": 4, "jira_id": "847", "singleLine": false, "nb_skipped": 4, "commit": "65aa40dd", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRefresh(org.apache.jackrabbit.oak.cache.CacheTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\nindex 52747ac..3356131 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n@@ -922,8 +922,12 @@ synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws Exec\n             V old = get(key, hash);\n             long start = System.nanoTime();\n             try {\n+                if (old == null) {\n+                    value = loader.load(key);\n+                } else {\n                     ListenableFuture<V> future = loader.reload(key, old);\n                     value = future.get();\n+                }\n                 loadSuccessCount++;\n             } catch (Exception e) {\n                 loadExceptionCount++;\n", "nb_test": 1519, "linesAdd": 4, "jira_id": "1094", "singleLine": false, "nb_skipped": 6, "commit": "2e20589f", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["namePropertyFromNameValue(org.apache.jackrabbit.oak.plugins.memory.PropertyStatesTest): expected:<name=oak-prefix:value> but was:<name=jcr-prefix:value>", "pathPropertyFromPathValue(org.apache.jackrabbit.oak.plugins.memory.PropertyStatesTest): expected:<path=oak-prefix:a/oak-prefix:b> but was:<path=jcr-prefix:a/jcr-prefix:b>"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java\nindex 3837e96..372ca23 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java\n@@ -32,6 +32,7 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.plugins.value.Conversions;\n+import org.apache.jackrabbit.oak.plugins.value.ValueImpl;\n \n import static org.apache.jackrabbit.oak.api.Type.STRINGS;\n \n@@ -55,7 +57,7 @@ public static PropertyState createProperty(String name, Value value) throws Repo\n         int type = value.getType();\n         switch (type) {\n             case PropertyType.STRING:\n-                return StringPropertyState.stringProperty(name, value.getString());\n+                return StringPropertyState.stringProperty(name, getString(value, type));\n             case PropertyType.BINARY:\n                 return BinaryPropertyState.binaryProperty(name, value);\n             case PropertyType.LONG:\n@@ -69,7 +71,7 @@ public static PropertyState createProperty(String name, Value value) throws Repo\n             case PropertyType.DECIMAL:\n                 return DecimalPropertyState.decimalProperty(name, value.getDecimal());\n             default:\n-                return new GenericPropertyState(name, value.getString(), Type.fromTag(type, false));\n+                return new GenericPropertyState(name, getString(value, type), Type.fromTag(type, false));\n         }\n     }\n \n@@ -96,7 +98,7 @@ public static PropertyState createProperty(String name, Iterable<Value> values)\n             case PropertyType.STRING:\n                 List<String> strings = Lists.newArrayList();\n                 for (Value value : values) {\n-                    strings.add(value.getString());\n+                    strings.add(getString(value, type));\n                 }\n                 return MultiStringPropertyState.stringProperty(name, strings);\n             case PropertyType.BINARY:\n@@ -138,12 +140,24 @@ public static PropertyState createProperty(String name, Iterable<Value> values)\n             default:\n                 List<String> vals = Lists.newArrayList();\n                 for (Value value : values) {\n-                    vals.add(value.getString());\n+                    vals.add(getString(value, type));\n                 }\n                 return new MultiGenericPropertyState(name, vals, Type.fromTag(type, true));\n         }\n     }\n \n+    private static String getString(Value value, int type) throws RepositoryException {\n+        if (value instanceof ValueImpl) {\n+            return ((ValueImpl) value).getOakString();\n+        }\n+        else if (type == PropertyType.NAME || type == PropertyType.PATH) {\n+            throw new IllegalArgumentException(\"Cannot create name of path property state from Value \" +\n+                    \"of class '\" + value.getClass() + '\\'');\n+        } else {\n+            return value.getString();\n+        }\n+    }\n+\n     /**\n      * Create a {@code PropertyState} from a string.\n      * @param name  The name of the property state\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java\nindex 59ea846..4f733eb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java\n@@ -73,6 +73,15 @@\n         this(checkSingleValued(property), 0, namePathMapper);\n     }\n \n+    /**\n+     * Same as {@link #getString()} unless that names and paths are returned in their\n+     * Oak representation instead of being mapped to their JCR representation.\n+     * @return  A String representation of the value of this property.\n+     */\n+    public String getOakString() {\n+        return propertyState.getValue(Type.STRING, index);\n+    }\n+\n     private static PropertyState checkSingleValued(PropertyState property) {\n         checkArgument(!property.isArray());\n         return property;\n@@ -208,9 +217,9 @@ public String getString() throws RepositoryException {\n \n         switch (getType()) {\n             case PropertyType.NAME:\n-                return namePathMapper.getJcrName(propertyState.getValue(Type.STRING, index));\n+                return namePathMapper.getJcrName(getOakString());\n             case PropertyType.PATH:\n-                String s = propertyState.getValue(Type.STRING, index);\n+                String s = getOakString();\n                 if (s.startsWith(\"[\") && s.endsWith(\"]\")) {\n                     // identifier paths are returned as-is (JCR 2.0, 3.4.3.1)\n                     return s;\n@@ -218,7 +227,7 @@ public String getString() throws RepositoryException {\n                     return namePathMapper.getJcrPath(s);\n                 }\n             default:\n-                return propertyState.getValue(Type.STRING, index);\n+                return getOakString();\n         }\n     }\n \n@@ -273,13 +282,13 @@ public int hashCode() {\n             return propertyState.getValue(Type.BINARY, index).hashCode();\n         }\n         else {\n-            return propertyState.getValue(Type.STRING, index).hashCode();\n+            return getOakString().hashCode();\n         }\n     }\n \n     @Override\n     public String toString() {\n-        return propertyState.getValue(Type.STRING, index);\n+        return getOakString();\n     }\n \n     private static int compare(PropertyState p1, int i1, PropertyState p2, int i2) {\n", "nb_test": 511, "linesAdd": 26, "jira_id": "554", "singleLine": false, "nb_skipped": 5, "commit": "3f51fb09", "nb_failure": 2, "linesRem": 9}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["checkpoint[0](org.apache.jackrabbit.oak.kernel.CheckpointTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex a46af36..c93221c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1383,7 +1383,12 @@ public String checkpoint(long lifetime) {\n     @CheckForNull\n     @Override\n     public NodeState retrieve(@Nonnull String checkpoint) {\n-        return getRoot(Revision.fromString(checkpoint));\n+        Revision r = Revision.fromString(checkpoint);\n+        if (checkpoints.getCheckpoints().containsKey(r)) {\n+            return getRoot(r);\n+        } else {\n+            return null;\n+        }\n     }\n \n     @Override\n", "nb_test": 2008, "linesAdd": 6, "jira_id": "2311", "singleLine": false, "nb_skipped": 1, "commit": "ca85ecce", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "jackrabbit-oak", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["inactiveClusterId(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest)"], "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 95a82d5..29a363e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1532,6 +1532,13 @@ void backgroundRead(boolean dispatchChange) {\n             Revision last = lastKnownRevision.get(machineId);\n             if (last == null || r.compareRevisionTime(last) > 0) {\n                 lastKnownRevision.put(machineId, r);\n+                // OAK-2345\n+                // only consider as external change if\n+                // - the revision changed for the machineId\n+                // or\n+                // - the revision is within the time frame we remember revisions\n+                if (last != null\n+                        || r.getTimestamp() > revisionPurgeMillis())\n                 externalChanges.put(r, otherSeen);\n             }\n         }\n@@ -1562,7 +1569,17 @@ void backgroundRead(boolean dispatchChange) {\n                 backgroundOperationLock.writeLock().unlock();\n             }\n         }\n-        revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);\n+        revisionComparator.purge(revisionPurgeMillis());\n+    }\n+\n+    /**\n+     * Returns the time in milliseconds when revisions can be purged from the\n+     * revision comparator.\n+     *\n+     * @return time in milliseconds.\n+     */\n+    private static long revisionPurgeMillis() {\n+        return Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS;\n     }\n \n     private void backgroundSplit() {\n", "nb_test": 2029, "linesAdd": 7, "jira_id": "2345", "singleLine": false, "nb_skipped": 9, "commit": "a0dc4c89", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testMath848(org.apache.commons.math3.linear.EigenDecompositionTest): Failed to create EigenDecomposition for matrix Array2DRowRealMatrix{{0.184944928,-0.0646971046,0.0774755812,-0.0969651755,-0.0692648806,0.3282344352,-0.0177423074,0.206313634},{-0.0742700134,-0.028906303,-0.001726946,-0.0375550146,-0.0487737922,-0.2616837868,-0.0821201295,-0.2530000167},{0.2549910127,0.0995733692,-0.0009718388,0.0149282808,0.1791878897,-0.0823182816,0.0582629256,0.3219545182},{-0.0694747557,-0.1880649148,-0.2740630911,0.0720096468,-0.1800836914,-0.3518996425,0.2486747833,0.6257938167},{0.0536360918,-0.1339297778,0.2241579764,-0.0195327484,-0.0054103808,0.0347564518,0.5120802482,-0.0329902864},{-0.5933332356,-0.2488721082,0.2357173629,0.0177285473,0.0856630593,-0.35671263,-0.1600668126,-0.1010899621},{-0.0514349819,-0.0854319435,0.1125050061,0.006345356,-0.2250000688,-0.220934309,0.1964623477,-0.1512329924},{0.0197395947,-0.1997170581,-0.1425959019,-0.274947791,-0.0969467073,0.060368852,-0.2826905192,0.1794315473}}, ex=org.apache.commons.math3.exception.MaxCountExceededException: illegal state: convergence failed", "testMath848(org.apache.commons.math3.linear.SchurTransformerTest): illegal state: convergence failed"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\nindex 584505d..a2ea88e 100644\n--- a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n@@ -140,69 +140,66 @@ private void transform() {\n \n         // Outer loop over eigenvalue index\n         int iteration = 0;\n-        int idx = n - 1;\n-        while (idx >= 0) {\n+        int iu = n - 1;\n+        while (iu >= 0) {\n \n             // Look for single small sub-diagonal element\n-            final int l = findSmallSubDiagonalElement(idx, norm);\n+            final int il = findSmallSubDiagonalElement(iu, norm);\n \n             // Check for convergence\n-            if (l == idx) {\n+            if (il == iu) {\n                 // One root found\n-                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n-                idx--;\n+                matrixT[iu][iu] = matrixT[iu][iu] + shift.exShift;\n+                iu--;\n                 iteration = 0;\n-            } else if (l == idx - 1) {\n+            } else if (il == iu - 1) {\n                 // Two roots found\n-                shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];\n-                double p = (matrixT[idx - 1][idx - 1] - matrixT[idx][idx]) / 2.0;\n-                double q = p * p + shift.w;\n-                double z = FastMath.sqrt(FastMath.abs(q));\n-                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n-                matrixT[idx - 1][idx - 1] = matrixT[idx - 1][idx - 1] + shift.exShift;\n-                shift.x = matrixT[idx][idx];\n+                double p = (matrixT[iu - 1][iu - 1] - matrixT[iu][iu]) / 2.0;\n+                double q = p * p + matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n+                matrixT[iu][iu] += shift.exShift;\n+                matrixT[iu - 1][iu - 1] += shift.exShift;\n \n                 if (q >= 0) {\n+                    double z = FastMath.sqrt(FastMath.abs(q));\n                     if (p >= 0) {\n                         z = p + z;\n                     } else {\n                         z = p - z;\n                     }\n-                    shift.x = matrixT[idx][idx - 1];\n-                    double s = FastMath.abs(shift.x) + FastMath.abs(z);\n-                    p = shift.x / s;\n+                    final double x = matrixT[iu][iu - 1];\n+                    final double s = FastMath.abs(x) + FastMath.abs(z);\n+                    p = x / s;\n                     q = z / s;\n-                    double r = FastMath.sqrt(p * p + q * q);\n+                    final double r = FastMath.sqrt(p * p + q * q);\n                     p = p / r;\n                     q = q / r;\n \n                     // Row modification\n-                    for (int j = idx - 1; j < n; j++) {\n-                        z = matrixT[idx - 1][j];\n-                        matrixT[idx - 1][j] = q * z + p * matrixT[idx][j];\n-                        matrixT[idx][j] = q * matrixT[idx][j] - p * z;\n+                    for (int j = iu - 1; j < n; j++) {\n+                        z = matrixT[iu - 1][j];\n+                        matrixT[iu - 1][j] = q * z + p * matrixT[iu][j];\n+                        matrixT[iu][j] = q * matrixT[iu][j] - p * z;\n                     }\n \n                     // Column modification\n-                    for (int i = 0; i <= idx; i++) {\n-                        z = matrixT[i][idx - 1];\n-                        matrixT[i][idx - 1] = q * z + p * matrixT[i][idx];\n-                        matrixT[i][idx] = q * matrixT[i][idx] - p * z;\n+                    for (int i = 0; i <= iu; i++) {\n+                        z = matrixT[i][iu - 1];\n+                        matrixT[i][iu - 1] = q * z + p * matrixT[i][iu];\n+                        matrixT[i][iu] = q * matrixT[i][iu] - p * z;\n                     }\n \n                     // Accumulate transformations\n                     for (int i = 0; i <= n - 1; i++) {\n-                        z = matrixP[i][idx - 1];\n-                        matrixP[i][idx - 1] = q * z + p * matrixP[i][idx];\n-                        matrixP[i][idx] = q * matrixP[i][idx] - p * z;\n+                        z = matrixP[i][iu - 1];\n+                        matrixP[i][iu - 1] = q * z + p * matrixP[i][iu];\n+                        matrixP[i][iu] = q * matrixP[i][iu] - p * z;\n                     }\n                 }\n-                idx -= 2;\n+                iu -= 2;\n                 iteration = 0;\n             } else {\n                 // No convergence yet\n-\n-                computeShift(l, idx, iteration, shift);\n+                computeShift(il, iu, iteration, shift);\n \n                 // stop transformation after too many iterations\n                 if (++iteration > MAX_ITERATIONS) {\n@@ -210,43 +207,11 @@ private void transform() {\n                                                         MAX_ITERATIONS);\n                 }\n \n-                // Look for two consecutive small sub-diagonal elements\n-                int m = idx - 2;\n-\n                 // the initial houseHolder vector for the QR step\n                 final double[] hVec = new double[3];\n \n-                while (m >= l) {\n-                    double z = matrixT[m][m];\n-                    hVec[2] = shift.x - z;\n-                    double s = shift.y - z;\n-                    hVec[0] = (hVec[2] * s - shift.w) / matrixT[m + 1][m] + matrixT[m][m + 1];\n-                    hVec[1] = matrixT[m + 1][m + 1] - z - hVec[2] - s;\n-                    hVec[2] = matrixT[m + 2][m + 1];\n-                    s = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);\n-\n-                    if (m == l) {\n-                        break;\n-                    }\n-\n-                    for (int i = 0; i < hVec.length; i++) {\n-                        hVec[i] /= s;\n-                    }\n-\n-                    final double lhs = FastMath.abs(matrixT[m][m - 1]) *\n-                            (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n-\n-                    final double rhs = FastMath.abs(hVec[0]) *\n-                            (FastMath.abs(matrixT[m - 1][m - 1]) + FastMath.abs(z) +\n-                             FastMath.abs(matrixT[m + 1][m + 1]));\n-\n-                    if (lhs < epsilon * rhs) {\n-                        break;\n-                    }\n-                    m--;\n-                }\n-\n-                performDoubleQRStep(l, m, idx, shift, hVec);\n+                final int im = initQRStep(il, iu, shift, hVec);\n+                performDoubleQRStep(il, im, iu, shift, hVec);\n             }\n         }\n     }\n@@ -278,7 +243,7 @@ private int findSmallSubDiagonalElement(final int startIdx, final double norm) {\n         int l = startIdx;\n         while (l > 0) {\n             double s = FastMath.abs(matrixT[l - 1][l - 1]) + FastMath.abs(matrixT[l][l]);\n-            if (Precision.equals(s, 0.0, epsilon)) {\n+            if (s == 0.0) {\n                 s = norm;\n             }\n             if (FastMath.abs(matrixT[l][l - 1]) < epsilon * s) {\n@@ -312,8 +277,9 @@ private void computeShift(final int l, final int idx, final int iteration, final\n             for (int i = 0; i <= idx; i++) {\n                 matrixT[i][i] -= shift.x;\n             }\n-            double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\n-            shift.x = shift.y = 0.75 * s;\n+            final double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\n+            shift.x = 0.75 * s;\n+            shift.y = 0.75 * s;\n             shift.w = -0.4375 * s * s;\n         }\n \n@@ -321,7 +287,7 @@ private void computeShift(final int l, final int idx, final int iteration, final\n         if (iteration == 30) {\n             double s = (shift.y - shift.x) / 2.0;\n             s = s * s + shift.w;\n-            if (Precision.compareTo(s, 0.0d, epsilon) > 0) {\n+            if (s > 0.0) {\n                 s = FastMath.sqrt(s);\n                 if (shift.y < shift.x) {\n                     s = -s;\n@@ -337,15 +303,53 @@ private void computeShift(final int l, final int idx, final int iteration, final\n     }\n \n     /**\n+     * Initialize the householder vectors for the QR step.\n+     *\n+     * @param il the index of the small sub-diagonal element\n+     * @param iu the current eigenvalue index\n+     * @param shift shift information holder\n+     * @param hVec the initial houseHolder vector\n+     * @return the start index for the QR step\n+     */\n+    private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec) {\n+        // Look for two consecutive small sub-diagonal elements\n+        int im = iu - 2;\n+        while (im >= il) {\n+            final double z = matrixT[im][im];\n+            final double r = shift.x - z;\n+            double s = shift.y - z;\n+            hVec[0] = (r * s - shift.w) / matrixT[im + 1][im] + matrixT[im][im + 1];\n+            hVec[1] = matrixT[im + 1][im + 1] - z - r - s;\n+            hVec[2] = matrixT[im + 2][im + 1];\n+\n+            if (im == il) {\n+                break;\n+            }\n+\n+            final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n+            final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n+                                                        FastMath.abs(z) +\n+                                                        FastMath.abs(matrixT[im + 1][im + 1]));\n+\n+            if (lhs < epsilon * rhs) {\n+                break;\n+            }\n+            im--;\n+        }\n+\n+        return im;\n+    }\n+\n+    /**\n      * Perform a double QR step involving rows l:idx and columns m:n\n      *\n-     * @param l the index of the small sub-diagonal element\n-     * @param m the start index for the QR step\n-     * @param idx the current eigenvalue index\n+     * @param il the index of the small sub-diagonal element\n+     * @param im the start index for the QR step\n+     * @param iu the current eigenvalue index\n      * @param shift shift information holder\n      * @param hVec the initial houseHolder vector\n      */\n-    private void performDoubleQRStep(final int l, final int m, final int idx,\n+    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                      final ShiftInfo shift, final double[] hVec) {\n \n         final int n = matrixT.length;\n@@ -353,9 +357,9 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n         double q = hVec[1];\n         double r = hVec[2];\n \n-        for (int k = m; k <= idx - 1; k++) {\n-            boolean notlast = k != idx - 1;\n-            if (k != m) {\n+        for (int k = im; k <= iu - 1; k++) {\n+            boolean notlast = k != (iu - 1);\n+            if (k != im) {\n                 p = matrixT[k][k - 1];\n                 q = matrixT[k + 1][k - 1];\n                 r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n@@ -366,17 +370,17 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n                     r = r / shift.x;\n                 }\n             }\n-            if (Precision.equals(shift.x, 0.0, epsilon)) {\n+            if (shift.x == 0.0) {\n                 break;\n             }\n             double s = FastMath.sqrt(p * p + q * q + r * r);\n             if (p < 0.0) {\n                 s = -s;\n             }\n-            if (!Precision.equals(s, 0.0, epsilon)) {\n-                if (k != m) {\n+            if (s != 0.0) {\n+                if (k != im) {\n                     matrixT[k][k - 1] = -s * shift.x;\n-                } else if (l != m) {\n+                } else if (il != im) {\n                     matrixT[k][k - 1] = -matrixT[k][k - 1];\n                 }\n                 p = p + s;\n@@ -398,7 +402,7 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n                 }\n \n                 // Column modification\n-                for (int i = 0; i <= FastMath.min(idx, k + 3); i++) {\n+                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                     p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                     if (notlast) {\n                         p = p + z * matrixT[i][k + 2];\n@@ -423,9 +427,9 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n         }  // k loop\n \n         // clean up pollution due to round-off errors\n-        for (int i = m+2; i <= idx; i++) {\n+        for (int i = im + 2; i <= iu; i++) {\n             matrixT[i][i-2] = 0.0;\n-            if (i > m+2) {\n+            if (i > im + 2) {\n                 matrixT[i][i-3] = 0.0;\n             }\n         }\n", "nb_test": 4156, "linesAdd": 75, "jira_id": "848", "singleLine": false, "nb_skipped": 4, "commit": "ad252a8c", "nb_failure": 1, "linesRem": 80}, {"files": 2, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["AbstractRandomGeneratorTest>RandomGeneratorAbstractTest.testNextBytesChunks:372->RandomGeneratorAbstractTest.checkNextBytesChunks:483 chunkSize=4 numChunks=2: arrays first differed at element [0]; expected:<-109> but was:<70>", "BitsStreamGeneratorTest>RandomGeneratorAbstractTest.testNextBytesChunks:372->RandomGeneratorAbstractTest.checkNextBytesChunks:483 chunkSize=4 numChunks=2: arrays first differed at element [0]; expected:<-98> but was:<25>", "ISAACTest>RandomGeneratorAbstractTest.testNextBytesChunks:372->RandomGeneratorAbstractTest.checkNextBytesChunks:483 chunkSize=4 numChunks=2: arrays first differed at element [0]; expected:<-80> but was:<32>", "MersenneTwisterTest>RandomGeneratorAbstractTest.testNextBytesChunks:372->RandomGeneratorAbstractTest.checkNextBytesChunks:483 chunkSize=4 numChunks=2: arrays first differed at element [0]; expected:<82> but was:<69>", "Well1024aTest>RandomGeneratorAbstractTest.testNextBytesChunks:372->RandomGeneratorAbstractTest.checkNextBytesChunks:483 chunkSize=4 numChunks=2: arrays first differed at element [0]; expected:<110> but was:<-24>", "Well19937aTest>RandomGeneratorAbstractTest.testNextBytesChunks:372->RandomGeneratorAbstractTest.checkNextBytesChunks:483 chunkSize=4 numChunks=2: arrays first differed at element [0]; expected:<21> but was:<94>", "Well19937cTest>RandomGeneratorAbstractTest.testNextBytesChunks:372->RandomGeneratorAbstractTest.checkNextBytesChunks:483 chunkSize=4 numChunks=2: arrays first differed at element [0]; expected:<21> but was:<94>", "Well44497aTest>RandomGeneratorAbstractTest.testNextBytesChunks:372->RandomGeneratorAbstractTest.checkNextBytesChunks:483 chunkSize=4 numChunks=2: arrays first differed at element [0]; expected:<-108> but was:<-95>", "Well44497bTest>RandomGeneratorAbstractTest.testNextBytesChunks:372->RandomGeneratorAbstractTest.checkNextBytesChunks:483 chunkSize=4 numChunks=2: arrays first differed at element [0]; expected:<-108> but was:<-95>", "Well512aTest>RandomGeneratorAbstractTest.testNextBytesChunks:372->RandomGeneratorAbstractTest.checkNextBytesChunks:483 chunkSize=4 numChunks=2: arrays first differed at element [0]; expected:<-14> but was:<37>"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/random/AbstractRandomGenerator.java b/src/main/java/org/apache/commons/math4/random/AbstractRandomGenerator.java\nindex 1b9cead..173f4ee 100644\n--- a/src/main/java/org/apache/commons/math4/random/AbstractRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math4/random/AbstractRandomGenerator.java\n@@ -114,6 +114,8 @@ public void nextBytes(byte[] bytes) {\n                 if (i > 0) {\n                     randInt >>= 8;\n                 }\n+            }\n+            if (bytesOut < bytes.length) {\n                 bytes[bytesOut++] = (byte) randInt;\n                 if (bytesOut == bytes.length) {\n                     return;\ndiff --git a/src/main/java/org/apache/commons/math4/random/BitsStreamGenerator.java b/src/main/java/org/apache/commons/math4/random/BitsStreamGenerator.java\nindex 81968e2..7c89b60 100644\n--- a/src/main/java/org/apache/commons/math4/random/BitsStreamGenerator.java\n+++ b/src/main/java/org/apache/commons/math4/random/BitsStreamGenerator.java\n@@ -82,12 +82,14 @@ public void nextBytes(byte[] bytes) {\n             bytes[i + 3] = (byte) ((random >> 24) & 0xff);\n             i += 4;\n         }\n+        if (i < bytes.length) {\n             int random = next(32);\n             while (i < bytes.length) {\n                 bytes[i++] = (byte) (random & 0xff);\n                 random >>= 8;\n             }\n         }\n+    }\n \n     /** {@inheritDoc} */\n     @Override\n", "nb_test": 5907, "linesAdd": 4, "jira_id": "1300", "singleLine": false, "nb_skipped": 4, "commit": "1d635088", "nb_failure": 10, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDivideZero(org.apache.commons.math.complex.ComplexTest): expected:<(Infinity, Infinity)> but was:<(NaN, NaN)>", "testAtanI(org.apache.commons.math.complex.ComplexTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex 137765c..dd0b00a 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -256,7 +256,8 @@ public Complex divide(Complex divisor)\n         }\n \n         if (divisor.isZero) {\n-            return isZero ? NaN : INF;\n+            // return isZero ? NaN : INF; // See MATH-657\n+            return NaN;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n@@ -292,7 +293,8 @@ public Complex divide(double divisor) {\n             return NaN;\n         }\n         if (divisor == 0d) {\n-            return isZero ? NaN : INF;\n+            // return isZero ? NaN : INF; // See MATH-657\n+            return NaN;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n", "nb_test": 2949, "linesAdd": 2, "jira_id": "657", "singleLine": false, "nb_skipped": 1, "commit": "97b440fc", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testMath290(org.apache.commons.math.optimization.linear.SimplexSolverTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex b387767..97d8061 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -69,7 +69,7 @@\n     private final LinearObjectiveFunction f;\n \n     /** Linear constraints. */\n-    private final Collection<LinearConstraint> constraints;\n+    private final List<LinearConstraint> constraints;\n \n     /** Whether to restrict the variables to non-negative values. */\n     private final boolean restrictToNonNegative;\n@@ -103,7 +103,7 @@\n                    final GoalType goalType, final boolean restrictToNonNegative,\n                    final double epsilon) {\n         this.f                      = f;\n-        this.constraints            = constraints;\n+        this.constraints            = normalizeConstraints(constraints);\n         this.restrictToNonNegative  = restrictToNonNegative;\n         this.epsilon                = epsilon;\n         this.numDecisionVariables   = getNumVariables() + (restrictToNonNegative ? 0 : 1);\n@@ -123,7 +123,6 @@\n     protected double[][] createTableau(final boolean maximize) {\n \n         // create a matrix of the correct size\n-        List<LinearConstraint> constraints = getNormalizedConstraints();\n         int width = numDecisionVariables + numSlackVariables +\n         numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n         int height = constraints.size() + getNumObjectiveFunctions();\n@@ -192,9 +191,10 @@ public int getNumVariables() {\n \n     /**\n      * Get new versions of the constraints which have positive right hand sides.\n+     * @param constraints original (not normalized) constraints\n      * @return new versions of the constraints\n      */\n-    public List<LinearConstraint> getNormalizedConstraints() {\n+    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> constraints) {\n         List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n         for (LinearConstraint constraint : constraints) {\n             normalized.add(normalize(constraint));\n", "nb_test": 2042, "linesAdd": 3, "jira_id": "290", "singleLine": false, "nb_skipped": 0, "commit": "b01fcc31", "nb_failure": 0, "linesRem": 4}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testQuinticMin(org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizerTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\nindex aa14ce6..952e565 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n@@ -143,18 +143,22 @@ public UnivariateRealPointValuePair optimize(final FUNC f,\n                                                  final GoalType goal,\n                                                  final double min, final double max)\n         throws FunctionEvaluationException {\n+        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n+    }\n \n+    /** {@inheritDoc} */\n+    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n+                                                 final double min, final double max,\n+                                                 final double startValue)\n+        throws FunctionEvaluationException {\n         optima = new UnivariateRealPointValuePair[starts];\n         totalEvaluations = 0;\n \n         // Multi-start loop.\n         for (int i = 0; i < starts; ++i) {\n             try {\n-                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n-                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal,\n-                                               FastMath.min(bound1, bound2),\n-                                               FastMath.max(bound1, bound2));\n+                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n+                optima[i] = optimizer.optimize(f, goal, min, max, s);\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {\n@@ -177,16 +181,6 @@ public UnivariateRealPointValuePair optimize(final FUNC f,\n         return optima[0];\n     }\n \n-    /** {@inheritDoc} */\n-    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goalType,\n-                                                 final double min, final double max,\n-                                                 final double startValue)\n-            throws FunctionEvaluationException {\n-        // XXX Main code should be here, using \"startValue\" for the first start.\n-        // XXX This method should set \"startValue\" to min + 0.5 * (max - min)\n-        return optimize(f, goalType, min, max);\n-    }\n-\n     /**\n      * Sort the optima from best to worst, followed by {@code null} elements.\n      *\n", "nb_test": 2356, "linesAdd": 8, "jira_id": "413", "singleLine": false, "nb_skipped": 1, "commit": "51aa6e6c", "nb_failure": 1, "linesRem": 12}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath904(org.apache.commons.math3.util.FastMathTest): expected:<-1.0> but was:<1.0>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/FastMath.java b/src/main/java/org/apache/commons/math3/util/FastMath.java\nindex fd1ce2d..9dc84c6 100644\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -309,6 +309,8 @@\n \n     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n     private static final double TWO_POWER_52 = 4503599627370496.0;\n+    /** 2^53 - double numbers this large must be even. */\n+    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;\n \n     /** Constant: {@value}. */\n     private static final double F_1_3 = 1d / 3d;\n@@ -1537,7 +1539,7 @@ public static double pow(double x, double y) {\n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n+            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n                 return pow(-x, y);\n             }\n \n", "nb_test": 4252, "linesAdd": 2, "jira_id": "904", "singleLine": false, "nb_skipped": 4, "commit": "6844aba9", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["PolyhedronsSetTest.testTooThinBox:290 \u00bb MathInternal illegal state: internal e..."], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java\nindex 31b78a6..0c5a9a7 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java\n@@ -59,6 +59,16 @@ public PolyhedronsSet(final double tolerance) {\n      * cells). In order to avoid building too many small objects, it is\n      * recommended to use the predefined constants\n      * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n+     * <p>\n+     * This constructor is aimed at expert use, as building the tree may\n+     * be a difficult taks. It is not intended for general use and for\n+     * performances reasons does not check thoroughly its input, as this would\n+     * require walking the full tree each time. Failing to provide a tree with\n+     * the proper attributes, <em>will</em> therefore generate problems like\n+     * {@link NullPointerException} or {@link ClassCastException} only later on.\n+     * This limitation is known and explains why this constructor is for expert\n+     * use only. The caller does have the responsibility to provided correct arguments.\n+     * </p>\n      * @param tree inside/outside BSP tree representing the region\n      * @param tolerance tolerance below which points are considered identical\n      * @since 3.3\n@@ -190,6 +200,10 @@ public PolyhedronsSet(final double xMin, final double xMax,\n                                                       final double yMin, final double yMax,\n                                                       final double zMin, final double zMax,\n                                                       final double tolerance) {\n+        if ((xMin >= xMax - tolerance) || (yMin >= yMax - tolerance) || (zMin >= zMax - tolerance)) {\n+            // too thin box, build an empty polygons set\n+            return new BSPTree<Euclidean3D>(Boolean.FALSE);\n+        }\n         final Plane pxMin = new Plane(new Vector3D(xMin, 0,    0),   Vector3D.MINUS_I, tolerance);\n         final Plane pxMax = new Plane(new Vector3D(xMax, 0,    0),   Vector3D.PLUS_I,  tolerance);\n         final Plane pyMin = new Plane(new Vector3D(0,    yMin, 0),   Vector3D.MINUS_J, tolerance);\n", "nb_test": 5960, "linesAdd": 3, "jira_id": "1115", "singleLine": false, "nb_skipped": 3, "commit": "2a6c6409", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testMath293(org.apache.commons.math.optimization.linear.SimplexSolverTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 1cb45cc..23dc90c 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -74,6 +74,9 @@\n     /** Whether to restrict the variables to non-negative values. */\n     private final boolean restrictToNonNegative;\n \n+    /** The variables each column represents */\n+    private final List<String> columnLabels = new ArrayList<String>();\n+\n     /** Simple tableau. */\n     private transient RealMatrix tableau;\n \n@@ -113,6 +116,27 @@\n         this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                       getConstraintTypeCounts(Relationship.GEQ);\n         this.tableau = createTableau(goalType == GoalType.MAXIMIZE);\n+        initializeColumnLabels();\n+    }\n+\n+    protected void initializeColumnLabels() {\n+      if (getNumObjectiveFunctions() == 2) {\n+        columnLabels.add(\"W\");\n+      }\n+      columnLabels.add(\"Z\");\n+      for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {\n+        columnLabels.add(\"x\" + i);\n+      }\n+      if (!restrictToNonNegative) {\n+        columnLabels.add(\"x-\");\n+      }\n+      for (int i = 0; i < getNumSlackVariables(); i++) {\n+        columnLabels.add(\"s\" + i);\n+      }\n+      for (int i = 0; i < getNumArtificialVariables(); i++) {\n+        columnLabels.add(\"a\" + i);\n+      }\n+      columnLabels.add(\"RHS\");\n     }\n \n     /**\n@@ -301,6 +325,10 @@ protected void dropPhase1Objective() {\n           }\n         }\n \n+        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n+          columnLabels.remove((int) columnsToDrop.get(i));\n+        }\n+\n         this.tableau = new Array2DRowRealMatrix(matrix);\n         this.numArtificialVariables = 0;\n     }\n@@ -332,12 +360,19 @@ boolean isOptimal() {\n      * @return current solution\n      */\n     protected RealPointValuePair getSolution() {\n-      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n+      int negativeVarColumn = columnLabels.indexOf(\"x-\");\n+      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n+\n       Set<Integer> basicRows = new HashSet<Integer>();\n+      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n       for (int i = 0; i < coefficients.length; i++) {\n-          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n+          int colIndex = columnLabels.indexOf(\"x\" + i);\n+          if (colIndex < 0) {\n+            coefficients[i] = 0;\n+            continue;\n+          }\n+          Integer basicRow = getBasicRow(colIndex);\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n@@ -443,15 +478,6 @@ protected final int getRhsOffset() {\n     }\n \n     /**\n-     * Returns the offset of the extra decision variable added when there is a\n-     * negative decision variable in the original problem.\n-     * @return the offset of x-\n-     */\n-    protected final int getNegativeDecisionVariableOffset() {\n-      return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();\n-    }\n-\n-    /**\n      * Get the number of decision variables.\n      * <p>\n      * If variables are not restricted to positive values, this will include 1\n@@ -471,7 +497,7 @@ protected final int getNumDecisionVariables() {\n      * @see #getNumDecisionVariables()\n      */\n     protected final int getOriginalNumDecisionVariables() {\n-        return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;\n+        return f.getCoefficients().getDimension();\n     }\n \n     /**\n", "nb_test": 2068, "linesAdd": 38, "jira_id": "293", "singleLine": false, "nb_skipped": 0, "commit": "59a0da9c", "nb_failure": 0, "linesRem": 8}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath855(org.apache.commons.math3.optimization.univariate.BrentOptimizerTest): Best point not reported"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex ee2227c..cff5bfd 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -85,7 +86,7 @@ public BrentOptimizer(double rel,\n     }\n \n     /**\n-     * The arguments are used implement the original stopping criterion\n+     * The arguments are used for implementing the original stopping criterion\n      * of Brent's algorithm.\n      * {@code abs} and {@code rel} define a tolerance\n      * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n@@ -226,7 +227,7 @@ protected UnivariatePointValuePair doOptimize() {\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return current;\n+                        return best(current, previous, isMinim);\n                     }\n                 }\n \n@@ -263,9 +264,36 @@ protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return current;\n+                return best(current, previous, isMinim);\n             }\n             ++iter;\n         }\n     }\n+\n+    /**\n+     * Selects the best of two points.\n+     *\n+     * @param a Point and value.\n+     * @param b Point and value.\n+     * @param isMinim {@code true} if the selected point must be the one with\n+     * the lowest value.\n+     * @return the best point, or {@code null} if {@code a} and {@code b} are\n+     * both {@code null}.\n+     */\n+    private UnivariatePointValuePair best(UnivariatePointValuePair a,\n+                                          UnivariatePointValuePair b,\n+                                          boolean isMinim) {\n+        if (a == null) {\n+            return b;\n+        }\n+        if (b == null) {\n+            return a;\n+        }\n+\n+        if (isMinim) {\n+            return a.getValue() < b.getValue() ? a : b;\n+        } else {\n+            return a.getValue() > b.getValue() ? a : b;\n+        }\n+    }\n }\n", "nb_test": 4083, "linesAdd": 19, "jira_id": "855", "singleLine": false, "nb_skipped": 4, "commit": "350f726c", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAtan2SpecialCases(org.apache.commons.math3.analysis.differentiation.DerivativeStructureTest): expected:<0.0> but was:<NaN>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\nindex 9d08555..d5a3c18 100644\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n@@ -1415,6 +1415,9 @@ public void atan2(final double[] y, final int yOffset,\n \n         }\n \n+        // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n+        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n+\n     }\n \n     /** Compute hyperbolic cosine of a derivative structure.\n", "nb_test": 4550, "linesAdd": 2, "jira_id": "935", "singleLine": false, "nb_skipped": 4, "commit": "48dde378", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMinpackFreudensteinRoth(org.apache.commons.math.optimization.general.MinpackTest)", "testMinpackJennrichSampson(org.apache.commons.math.optimization.general.MinpackTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 152c30c..c4b1985 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -247,12 +247,7 @@ public double getRMS() {\n      * @return chi-square value\n      */\n     public double getChiSquare() {\n-        double chiSquare = 0;\n-        for (int i = 0; i < rows; ++i) {\n-            final double residual = residuals[i];\n-            chiSquare += residual * residual * residualsWeights[i];\n-        }\n-        return chiSquare;\n+        return cost*cost;\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\nindex 4cf4ee0..b41456e 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n@@ -255,6 +255,8 @@ protected VectorialPointValuePair doOptimize()\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n+        double[] oldObj  = new double[rows];\n+        double[] qtf     = new double[rows];\n         double[] work1   = new double[cols];\n         double[] work2   = new double[cols];\n         double[] work3   = new double[cols];\n@@ -267,7 +269,9 @@ protected VectorialPointValuePair doOptimize()\n         boolean firstIteration = true;\n         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n-\n+            for (int i=0;i<rows;i++) {\n+                qtf[i]=residuals[i];\n+            }\n             incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n@@ -276,8 +280,7 @@ protected VectorialPointValuePair doOptimize()\n             qrDecomposition();\n \n             // compute Qt.res\n-            qTy(residuals);\n-\n+            qTy(qtf);\n             // now we don't need Q anymore,\n             // so let jacobian contain the R matrix with its diagonal elements\n             for (int k = 0; k < solvedCols; ++k) {\n@@ -315,7 +318,7 @@ protected VectorialPointValuePair doOptimize()\n                     if (s != 0) {\n                         double sum = 0;\n                         for (int i = 0; i <= j; ++i) {\n-                            sum += jacobian[i][pj] * residuals[i];\n+                            sum += jacobian[i][pj] * qtf[i];\n                         }\n                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                     }\n@@ -323,6 +326,8 @@ protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n+            \tupdateResidualsAndCost();\n+            \tcurrent = new VectorialPointValuePair(point, objective);\n                 return current;\n             }\n \n@@ -343,9 +348,12 @@ protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n+                tmpVec    = objective;\n+                objective = oldObj;\n+                oldObj    = tmpVec;\n \n                 // determine the Levenberg-Marquardt parameter\n-                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n+                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n \n                 // compute the new point and the norm of the evolution direction\n                 double lmNorm = 0;\n@@ -365,7 +372,6 @@ protected VectorialPointValuePair doOptimize()\n \n                 // evaluate the function at x + p and calculate its norm\n                 updateResidualsAndCost();\n-                current = new VectorialPointValuePair(point, objective);\n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n@@ -421,6 +427,15 @@ protected VectorialPointValuePair doOptimize()\n                         xNorm    += xK * xK;\n                     }\n                     xNorm = Math.sqrt(xNorm);\n+                    current = new VectorialPointValuePair(point, objective);\n+\n+                    // tests for convergence.\n+                    if (checker != null) {\n+                    // we use the vectorial convergence checker\n+                    \tif (checker.converged(getIterations(), previous, current)) {\n+                    \t\treturn current;\n+                    \t}\n+                    }\n                 } else {\n                     // failed iteration, reset the previous values\n                     cost = previousCost;\n@@ -431,16 +446,11 @@ protected VectorialPointValuePair doOptimize()\n                     tmpVec    = residuals;\n                     residuals = oldRes;\n                     oldRes    = tmpVec;\n+                    tmpVec    = objective;\n+                    objective = oldObj;\n+                    oldObj    = tmpVec;\n                 }\n-\n-                // tests for convergence.\n-                if (checker != null) {\n-                    // we use the vectorial convergence checker\n-                    if (checker.converged(getIterations(), previous, current)) {\n-                        return current;\n-                    }\n-                } else {\n-                    // we use the Levenberg-Marquardt specific convergence parameters\n+                if (checker==null) {\n                 \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                         (preRed <= costRelativeTolerance) &&\n                         (ratio <= 2.0)) ||\n", "nb_test": 2264, "linesAdd": 25, "jira_id": "405", "singleLine": false, "nb_skipped": 0, "commit": "784e4f69", "nb_failure": 2, "linesRem": 18}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAtanI(org.apache.commons.math.complex.ComplexTest)", "testDivideZero(org.apache.commons.math.complex.ComplexTest): expected:<(NaN, NaN)> but was:<(Infinity, Infinity)>"], "patch": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex ac31e4b..137765c 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -78,6 +78,8 @@\n     private final transient boolean isNaN;\n     /** Record whether this complex number is infinite. */\n     private final transient boolean isInfinite;\n+    /** Record whether this complex number is zero. */\n+    private final transient boolean isZero;\n \n     /**\n      * Create a complex number given only the real part.\n@@ -101,6 +103,7 @@ public Complex(double real, double imaginary) {\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n+        isZero = real == 0 && imaginary == 0;\n     }\n \n     /**\n@@ -222,7 +225,10 @@ public Complex conjugate() {\n      *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n      *   in either part, {@link #NaN} is returned.\n      *  </li>\n-     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n+     *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},\n+     *   {@link #NaN} is returned.\n+     *  </li>\n+     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.\n      *  </li>\n      *  <li>If {@code this} and {@code divisor} are both infinite,\n      *   {@link #NaN} is returned.\n@@ -249,16 +255,17 @@ public Complex divide(Complex divisor)\n             return NaN;\n         }\n \n-        final double c = divisor.getReal();\n-        final double d = divisor.getImaginary();\n-        if (c == 0.0 && d == 0.0) {\n-            return NaN;\n+        if (divisor.isZero) {\n+            return isZero ? NaN : INF;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n             return ZERO;\n         }\n \n+        final double c = divisor.getReal();\n+        final double d = divisor.getImaginary();\n+\n         if (FastMath.abs(c) < FastMath.abs(d)) {\n             double q = c / d;\n             double denominator = c * q + d;\n@@ -285,7 +292,7 @@ public Complex divide(double divisor) {\n             return NaN;\n         }\n         if (divisor == 0d) {\n-            return NaN;\n+            return isZero ? NaN : INF;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n", "nb_test": 2949, "linesAdd": 8, "jira_id": "657", "singleLine": false, "nb_skipped": 1, "commit": "32b0f733", "nb_failure": 2, "linesRem": 5}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRootEndpoints(org.apache.commons.math.analysis.solvers.BrentSolverTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb427..7fc090e 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -112,7 +112,7 @@ public double solve(final UnivariateRealFunction f,\n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n+            setResult(min, 0);\n             return result;\n         }\n \n@@ -124,7 +124,7 @@ public double solve(final UnivariateRealFunction f,\n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+            setResult(max, 0);\n             return result;\n         }\n \n", "nb_test": 2130, "linesAdd": 2, "jira_id": "344", "singleLine": false, "nb_skipped": 0, "commit": "a0b4b4b7", "nb_failure": 1, "linesRem": 2}, {"files": 2, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testLargeSample(org.apache.commons.math3.optimization.fitting.PolynomialFitterTest): Java heap space"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/Weight.java b/src/main/java/org/apache/commons/math3/optimization/Weight.java\nindex 8e7538f..28c1619 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/Weight.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/Weight.java\n@@ -18,7 +18,7 @@\n package org.apache.commons.math3.optimization;\n \n import org.apache.commons.math3.linear.RealMatrix;\n-import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math3.linear.DiagonalMatrix;\n import org.apache.commons.math3.linear.NonSquareMatrixException;\n \n /**\n@@ -41,11 +41,7 @@\n      * @param weight List of the values of the diagonal.\n      */\n     public Weight(double[] weight) {\n-        final int dim = weight.length;\n-        weightMatrix = new Array2DRowRealMatrix(dim, dim);\n-        for (int i = 0; i < dim; i++) {\n-            weightMatrix.setEntry(i, i, weight[i]);\n-        }\n+        weightMatrix = new DiagonalMatrix(weight);\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex b6c97e7..982e559 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -26,6 +26,7 @@\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.ArrayRealVector;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.linear.DiagonalMatrix;\n import org.apache.commons.math3.linear.DecompositionSolver;\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.QRDecomposition;\n@@ -558,7 +559,16 @@ protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n+        if (m instanceof DiagonalMatrix) {\n+            final int dim = m.getRowDimension();\n+            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n+            for (int i = 0; i < dim; i++) {\n+               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n+            }\n+            return sqrtM;\n+        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n         }\n     }\n+}\n", "nb_test": 4502, "linesAdd": 12, "jira_id": "924", "singleLine": false, "nb_skipped": 4, "commit": "2836a6f9", "nb_failure": 0, "linesRem": 6}, {"files": 3, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["GaussNewtonOptimizerWithLUTest>AbstractLeastSquaresOptimizerAbstractTest.testPointCopy:556", "Expected: not sameInstance(<{1; 2; 3}>)", "but: was <{1; 2; 3}>", "LevenbergMarquardtOptimizerTest>AbstractLeastSquaresOptimizerAbstractTest.testPointCopy:556 arrays first differed at element [0]; expected:<0.0> but was:<0.9999999999999996>", "GaussNewtonOptimizerWithCholeskyTest>AbstractLeastSquaresOptimizerAbstractTest.testPointCopy:556", "Expected: not sameInstance(<{1; 2; 3}>)", "but: was <{1; 2; 3}>", "EvaluationTest.testEvaluateCopiesPoint:215 expected not same", "GaussNewtonOptimizerWithQRTest>AbstractLeastSquaresOptimizerAbstractTest.testPointCopy:556", "Expected: not sameInstance(<{1; 2; 3}>)", "but: was <{1; 2; 3}>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/fitting/leastsquares/GaussNewtonOptimizer.java b/src/main/java/org/apache/commons/math3/fitting/leastsquares/GaussNewtonOptimizer.java\nindex 9240856..c17c870 100644\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/GaussNewtonOptimizer.java\n@@ -197,9 +197,7 @@ public Optimum optimize(final LeastSquaresProblem lsp) {\n             throw new NullArgumentException();\n         }\n \n-        final int nC = lsp.getParameterSize();\n-\n-        final RealVector currentPoint = lsp.getStart();\n+        RealVector currentPoint = lsp.getStart();\n \n         // iterate until convergence is reached\n         Evaluation current = null;\n@@ -227,9 +225,7 @@ public Optimum optimize(final LeastSquaresProblem lsp) {\n             // solve the linearized least squares problem\n             final RealVector dX = this.decomposition.solve(weightedJacobian, currentResiduals);\n             // update the estimated parameters\n-            for (int i = 0; i < nC; ++i) {\n-                currentPoint.setEntry(i, currentPoint.getEntry(i) + dX.getEntry(i));\n-            }\n+            currentPoint = currentPoint.add(dX);\n         }\n     }\n \ndiff --git a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LeastSquaresFactory.java b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LeastSquaresFactory.java\nindex 0853d03..16ac659 100644\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LeastSquaresFactory.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LeastSquaresFactory.java\n@@ -332,7 +332,8 @@ public Evaluation evaluate(final RealVector point) {\n                     value.getFirst(),\n                     value.getSecond(),\n                     this.target,\n-                    point);\n+                    // copy so optimizer can change point without changing our instance\n+                    point.copy());\n         }\n \n         /**\ndiff --git a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\nindex 1cd4e51..5f0527c 100644\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\n@@ -328,7 +328,7 @@ public Optimum optimize(final LeastSquaresProblem problem) {\n         // Evaluate the function at the starting point and calculate its norm.\n         evaluationCounter.incrementCount();\n         //value will be reassigned in the loop\n-        Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint, false));\n+        Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint));\n         double[] currentResiduals = current.getResiduals().toArray();\n         double currentCost = current.getCost();\n \n@@ -445,7 +445,7 @@ public Optimum optimize(final LeastSquaresProblem problem) {\n \n                 // Evaluate the function at x + p and calculate its norm.\n                 evaluationCounter.incrementCount();\n-                current = problem.evaluate(new ArrayRealVector(currentPoint,false));\n+                current = problem.evaluate(new ArrayRealVector(currentPoint));\n                 currentResiduals = current.getResiduals().toArray();\n                 currentCost = current.getCost();\n \n", "nb_test": 5909, "linesAdd": 5, "jira_id": "1103", "singleLine": false, "nb_skipped": 3, "commit": "a6f96306", "nb_failure": 5, "linesRem": 9}, {"files": 2, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test434PivotRowSelection(org.apache.commons.math.optimization.linear.SimplexSolverTest)", "test434NegativeVariable(org.apache.commons.math.optimization.linear.SimplexSolverTest): expected:<5.0> but was:<15.0>", "test434UnfeasibleSolution(org.apache.commons.math.optimization.linear.SimplexSolverTest): Expected exception: org.apache.commons.math.optimization.linear.NoFeasibleSolutionException"], "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 5c25548..b9afc0a 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -22,6 +22,7 @@\n \n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n \n@@ -32,25 +33,33 @@\n  */\n public class SimplexSolver extends AbstractLinearOptimizer {\n     \n-    /** Default amount of error to accept in floating point comparisons. */\n+    /** Default amount of error to accept for algorithm convergence. */\n     private static final double DEFAULT_EPSILON = 1.0e-6;\n      \n-    /** Amount of error to accept in floating point comparisons. */\n+    /** Amount of error to accept for algorithm convergence. */\n     protected final double epsilon;\n \n+    /** Default amount of error to accept in floating point comparisons (as ulps). */\n+    private static final int DEFAULT_ULPS = 10;\n+\n+    /** Amount of error to accept in floating point comparisons (as ulps). */\n+    protected final int maxUlps;\n+\n     /**\n      * Build a simplex solver with default settings.\n      */\n     public SimplexSolver() {\n-        this(DEFAULT_EPSILON);\n+        this(DEFAULT_EPSILON, DEFAULT_ULPS);\n     }\n \n     /**\n      * Build a simplex solver with a specified accepted amount of error\n-     * @param epsilon the amount of error to accept in floating point comparisons\n+     * @param epsilon the amount of error to accept for algorithm convergence\n+     * @param maxUlps amount of error to accept in floating point comparisons \n      */\n-    public SimplexSolver(final double epsilon) {\n+    public SimplexSolver(final double epsilon, final int maxUlps) {\n         this.epsilon = epsilon;\n+        this.maxUlps = maxUlps;\n     }\n \n     /**\n@@ -62,8 +71,9 @@ private Integer getPivotColumn(SimplexTableau tableau) {\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, minValue, getEpsilon(entry)) < 0) {\n+                minValue = entry;\n                 minPos = i;\n             }\n         }\n@@ -83,11 +93,13 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n+            \n+            if (MathUtils.compareTo(entry, 0d, getEpsilon(entry)) > 0) {\n                 final double ratio = rhs / entry;\n-                if (MathUtils.equals(ratio, minRatio, epsilon)) {\n+                final int cmp = MathUtils.compareTo(ratio, minRatio, getEpsilon(ratio));\n+                if (cmp == 0) {\n                     minRatioPositions.add(i);\n-                } else if (ratio < minRatio) {\n+                } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n                     minRatioPositions.add(i);\n@@ -103,7 +115,8 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n           for (Integer row : minRatioPositions) {\n             for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n               int column = i + tableau.getArtificialVariableOffset();\n-              if (MathUtils.equals(tableau.getEntry(row, column), 1, epsilon) &&\n+              final double entry = tableau.getEntry(row, column);\n+              if (MathUtils.equals(entry, 1d, getEpsilon(entry)) &&\n                   row.equals(tableau.getBasicRow(column))) {\n                 return row;\n               }\n@@ -162,7 +175,7 @@ protected void solvePhase1(final SimplexTableau tableau) throws OptimizationExce\n         }\n \n         // if W is not zero then we have no feasible solution\n-        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n+        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {\n             throw new NoFeasibleSolutionException();\n         }\n     }\n@@ -171,7 +184,8 @@ protected void solvePhase1(final SimplexTableau tableau) throws OptimizationExce\n     @Override\n     public RealPointValuePair doOptimize() throws OptimizationException {\n         final SimplexTableau tableau =\n-            new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);\n+            new SimplexTableau(function, linearConstraints, goal, nonNegative, \n+                               epsilon, maxUlps);\n \n         solvePhase1(tableau);\n         tableau.dropPhase1Objective();\n@@ -182,4 +196,12 @@ public RealPointValuePair doOptimize() throws OptimizationException {\n         return tableau.getSolution();\n     }\n \n+    /**\n+     * Get an epsilon that is adjusted to the magnitude of the given value.\n+     * @param value the value for which to get the epsilon\n+     * @return magnitude-adjusted epsilon using {@link FastMath.ulp}\n+     */\n+    private double getEpsilon(double value) {\n+        return FastMath.ulp(value) * (double) maxUlps;\n+    }\n }\ndiff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 647d6be..0d1d911 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -33,6 +33,7 @@\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n@@ -65,6 +66,9 @@\n     /** Column label for negative vars. */\n     private static final String NEGATIVE_VAR_COLUMN_LABEL = \"x-\";\n \n+    /** Default amount of error to accept in floating point comparisons (as ulps). */\n+    private static final int DEFAULT_ULPS = 10;\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -1369660067587938365L;\n \n@@ -92,9 +96,12 @@\n     /** Number of artificial variables. */\n     private int numArtificialVariables;\n \n-    /** Amount of error to accept in floating point comparisons. */\n+    /** Amount of error to accept when checking for optimality. */\n     private final double epsilon;\n \n+    /** Amount of error to accept in floating point comparisons. */\n+    private final int maxUlps;\n+\n     /**\n      * Build a tableau for a linear problem.\n      * @param f linear objective function\n@@ -102,16 +109,35 @@\n      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n      * or {@link GoalType#MINIMIZE}\n      * @param restrictToNonNegative whether to restrict the variables to non-negative values\n-     * @param epsilon amount of error to accept in floating point comparisons\n+     * @param epsilon amount of error to accept when checking for optimality\n      */\n     SimplexTableau(final LinearObjectiveFunction f,\n                    final Collection<LinearConstraint> constraints,\n                    final GoalType goalType, final boolean restrictToNonNegative,\n                    final double epsilon) {\n+        this(f, constraints, goalType, restrictToNonNegative, epsilon, DEFAULT_ULPS);\n+    }\n+    \n+    /**\n+     * Build a tableau for a linear problem.\n+     * @param f linear objective function\n+     * @param constraints linear constraints\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n+     * @param epsilon amount of error to accept when checking for optimality\n+     * @param maxUlps amount of error to accept in floating point comparisons \n+     */\n+    SimplexTableau(final LinearObjectiveFunction f,\n+                   final Collection<LinearConstraint> constraints,\n+                   final GoalType goalType, final boolean restrictToNonNegative,\n+                   final double epsilon,\n+                   final int maxUlps) {\n         this.f                      = f;\n         this.constraints            = normalizeConstraints(constraints);\n         this.restrictToNonNegative  = restrictToNonNegative;\n         this.epsilon                = epsilon;\n+        this.maxUlps                = maxUlps;\n         this.numDecisionVariables   = f.getCoefficients().getDimension() +\n                                       (restrictToNonNegative ? 0 : 1);\n         this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n@@ -172,7 +198,7 @@ protected RealMatrix createTableau(final boolean maximize) {\n \n         if (!restrictToNonNegative) {\n             matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n-                getInvertedCoeffiecientSum(objectiveCoefficients));\n+                getInvertedCoefficientSum(objectiveCoefficients));\n         }\n \n         // initialize the constraint rows\n@@ -188,7 +214,7 @@ protected RealMatrix createTableau(final boolean maximize) {\n             // x-\n             if (!restrictToNonNegative) {\n                 matrix.setEntry(row, getSlackVariableOffset() - 1,\n-                    getInvertedCoeffiecientSum(constraint.getCoefficients()));\n+                    getInvertedCoefficientSum(constraint.getCoefficients()));\n             }\n \n             // RHS\n@@ -269,7 +295,7 @@ private int getConstraintTypeCounts(final Relationship relationship) {\n      * @param coefficients coefficients to sum\n      * @return the -1 times the sum of all coefficients in the given array.\n      */\n-    protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {\n+    protected static double getInvertedCoefficientSum(final RealVector coefficients) {\n         double sum = 0;\n         for (double coefficient : coefficients.getData()) {\n             sum -= coefficient;\n@@ -285,9 +311,10 @@ protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     protected Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = 0; i < getHeight(); i++) {\n-            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n+            final double entry = getEntry(i, col);\n+            if (MathUtils.equals(entry, 1d, getEpsilon(entry)) && (row == null)) {\n                 row = i;\n-            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n+            } else if (!MathUtils.equals(entry, 0d, getEpsilon(entry))) {\n                 return null;\n             }\n         }\n@@ -308,7 +335,8 @@ protected void dropPhase1Objective() {\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n-          if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) > 0) {\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, 0d, getEpsilon(entry)) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n@@ -353,7 +381,8 @@ private void copyArray(final double[] src, final double[] dest) {\n      */\n     boolean isOptimal() {\n         for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, 0d, epsilon) < 0) {\n                 return false;\n             }\n         }\n@@ -382,7 +411,7 @@ protected RealPointValuePair getSolution() {\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n-              coefficients[i] = 0;\n+              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n               coefficients[i] =\n@@ -545,6 +574,7 @@ public boolean equals(Object other) {\n                  (numSlackVariables      == rhs.numSlackVariables) &&\n                  (numArtificialVariables == rhs.numArtificialVariables) &&\n                  (epsilon                == rhs.epsilon) &&\n+                 (maxUlps                == rhs.maxUlps) &&\n                  f.equals(rhs.f) &&\n                  constraints.equals(rhs.constraints) &&\n                  tableau.equals(rhs.tableau);\n@@ -560,6 +590,7 @@ public int hashCode() {\n                numSlackVariables ^\n                numArtificialVariables ^\n                Double.valueOf(epsilon).hashCode() ^\n+               maxUlps ^\n                f.hashCode() ^\n                constraints.hashCode() ^\n                tableau.hashCode();\n@@ -586,4 +617,12 @@ private void readObject(ObjectInputStream ois)\n         MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n     }\n     \n+    /**\n+     * Get an epsilon that is adjusted to the magnitude of the given value.\n+     * @param value the value for which to get the epsilon\n+     * @return magnitude-adjusted epsilon using {@link FastMath.ulp}\n+     */\n+    private double getEpsilon(double value) {\n+        return FastMath.ulp(value) * (double) maxUlps;\n+    }    \n }\n", "nb_test": 2377, "linesAdd": 54, "jira_id": "434", "singleLine": false, "nb_skipped": 1, "commit": "133cbc2d", "nb_failure": 3, "linesRem": 18}, {"files": 7, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PowellOptimizerTest.testSumSinc:75->doTest:266 null", "SimplexOptimizerMultiDirectionalTest.testMinimize1:66 null", "SimplexOptimizerMultiDirectionalTest.testMinimize2:87 null", "SimplexOptimizerMultiDirectionalTest.testMaximize1:108 null", "SimplexOptimizerMultiDirectionalTest.testMaximize2:129 null", "SimplexOptimizerNelderMeadTest.testMinimize1:71 null", "SimplexOptimizerNelderMeadTest.testMinimize2:92 null", "SimplexOptimizerNelderMeadTest.testMaximize1:113 null", "SimplexOptimizerNelderMeadTest.testMaximize2:134 null", "CMAESOptimizerTest.testSphere:258->doTest:514 null", "CMAESOptimizerTest.testRosen:132->doTest:514 null", "CMAESOptimizerTest.testMaximize:148->doTest:514 null", "CMAESOptimizerTest.testEllipse:168->doTest:514 null", "CMAESOptimizerTest.testElliRotated:183->doTest:514 null", "CMAESOptimizerTest.testCigar:198->doTest:514 null", "CMAESOptimizerTest.testCigarWithBoundaries:213->doTest:514 null", "CMAESOptimizerTest.testTwoAxes:228->doTest:514 null", "CMAESOptimizerTest.testCigTab:243->doTest:514 null", "CMAESOptimizerTest.testTablet:273->doTest:514 null", "CMAESOptimizerTest.testDiffPow:288->doTest:514 null", "CMAESOptimizerTest.testSsDiffPow:303->doTest:514 null", "CMAESOptimizerTest.testAckley:318->doTest:514 null", "CMAESOptimizerTest.testRastrigin:333->doTest:514 null", "CMAESOptimizerTest.testConstrainedRosen:348->doTest:514 null", "CMAESOptimizerTest.testDiagonalRosen:363->doTest:514 null", "NonLinearConjugateGradientOptimizerTest.testTrivial:141 null", "LevenbergMarquardtOptimizerTest>AbstractLeastSquaresOptimizerAbstractTest.testGetIterations:131 null", "GaussNewtonOptimizerTest>AbstractLeastSquaresOptimizerAbstractTest.testGetIterations:131 null"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\nindex 75c9757..927e17f 100644\n--- a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n@@ -48,7 +48,7 @@ protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n         this.checker = checker;\n \n         evaluations = new Incrementor(0, new MaxEvalCallback());\n-        iterations = new Incrementor(0, new MaxIterCallback());\n+        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\nindex e010781..bd12b54 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n@@ -211,16 +211,15 @@ protected PointValuePair doOptimize() {\n         }\n \n         PointValuePair current = null;\n-        int iter = 0;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n \n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n-                if (checker.converged(iter, previous, current)) {\n+                if (checker.converged(getIterations(), previous, current)) {\n                     // We have found an optimum.\n                     return current;\n                 }\n@@ -274,7 +273,7 @@ protected PointValuePair doOptimize() {\n             steepestDescent = newSteepestDescent;\n \n             // Compute conjugate search direction.\n-            if (iter % n == 0 ||\n+            if (getIterations() % n == 0 ||\n                 beta < 0) {\n                 // Break conjugation: reset search direction.\n                 searchDirection = steepestDescent.clone();\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\nindex c7216f9..fed67b1 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n@@ -385,6 +385,8 @@ protected PointValuePair doOptimize() {\n \n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n+            incrementIterationCount();\n+\n             // Generate and evaluate lambda offspring\n             final RealMatrix arz = randn1(dimension, lambda);\n             final RealMatrix arx = zeros(dimension, lambda);\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\nindex 9572820..afe8d2f 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n@@ -188,9 +188,8 @@ protected PointValuePair doOptimize() {\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n-        int iter = 0;\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n \n             double fX = fVal;\n             double fX2 = 0;\n@@ -224,7 +223,7 @@ protected PointValuePair doOptimize() {\n             final PointValuePair current = new PointValuePair(x, fVal);\n             if (!stop) { // User-defined stopping criteria.\n                 if (checker != null) {\n-                    stop = checker.converged(iter, previous, current);\n+                    stop = checker.converged(getIterations(), previous, current);\n                 }\n             }\n             if (stop) {\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\nindex 3d16aa8..0dd644e 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n@@ -155,7 +155,7 @@ public int compare(final PointValuePair o1,\n         int iteration = 0;\n         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            if (iteration > 0) {\n+            if (getIterations() > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.getSize(); i++) {\n                     PointValuePair prev = previous[i];\n@@ -171,7 +171,8 @@ public int compare(final PointValuePair o1,\n             // We still need to search.\n             previous = simplex.getPoints();\n             simplex.iterate(evalFunc, comparator);\n-            ++iteration;\n+\n+            incrementIterationCount();\n         }\n     }\n \ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\nindex a2834f2..844ed22 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n@@ -103,9 +103,8 @@ public PointVectorValuePair doOptimize() {\n \n         // iterate until convergence is reached\n         PointVectorValuePair current = null;\n-        int iter = 0;\n         for (boolean converged = false; !converged;) {\n-            ++iter;\n+            incrementIterationCount();\n \n             // evaluate the objective function and its jacobian\n             PointVectorValuePair previous = current;\n@@ -157,7 +156,7 @@ public PointVectorValuePair doOptimize() {\n \n             // Check convergence.\n             if (previous != null) {\n-                converged = checker.converged(iter, previous, current);\n+                converged = checker.converged(getIterations(), previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\nindex ca2d138..4016131 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n@@ -319,10 +319,10 @@ protected PointVectorValuePair doOptimize() {\n         // Outer loop.\n         lmPar = 0;\n         boolean firstIteration = true;\n-        int iter = 0;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n+\n             final PointVectorValuePair previous = current;\n \n             // QR decomposition of the jacobian matrix\n@@ -486,7 +486,7 @@ protected PointVectorValuePair doOptimize() {\n                     // tests for convergence.\n                     if (checker != null) {\n                         // we use the vectorial convergence checker\n-                        if (checker.converged(iter, previous, current)) {\n+                        if (checker.converged(getIterations(), previous, current)) {\n                             setCost(currentCost);\n                             return current;\n                         }\n", "nb_test": 4903, "linesAdd": 16, "jira_id": "949", "singleLine": false, "nb_skipped": 4, "commit": "f83bbc1d", "nb_failure": 28, "linesRem": 16}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["EigenSolverTest.testNonInvertibleMath1045 Expected exception: org.apache.commons.math3.linear.SingularMatrixException"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\nindex 4652f61..b5e93ce 100644\n--- a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n@@ -513,9 +513,16 @@ public RealMatrix solve(RealMatrix b) {\n          * @return true if the decomposed matrix is non-singular.\n          */\n         public boolean isNonSingular() {\n+            // The eigenvalues are sorted by size, descending\n+            double largestEigenvalueNorm = eigenvalueNorm(0);\n+            // Corner case: zero matrix, all exactly 0 eigenvalues\n+            if (largestEigenvalueNorm == 0.0) {\n+                return false;\n+            }\n             for (int i = 0; i < realEigenvalues.length; ++i) {\n-                if (realEigenvalues[i] == 0 &&\n-                    imagEigenvalues[i] == 0) {\n+                // Looking for eigenvalues that are 0, where we consider anything much much smaller\n+                // than the largest eigenvalue to be effectively 0.\n+                if (Precision.equals(eigenvalueNorm(i) / largestEigenvalueNorm, 0, EPSILON)) {\n                     return false;\n                 }\n             }\n@@ -523,6 +530,16 @@ public boolean isNonSingular() {\n         }\n \n         /**\n+         * @param i which eigenvalue to find the norm of\n+         * @return the norm of ith (complex) eigenvalue.\n+         */\n+        private double eigenvalueNorm(int i) {\n+            final double re = realEigenvalues[i];\n+            final double im = imagEigenvalues[i];\n+            return FastMath.sqrt(re * re + im * im);\n+        }\n+\n+        /**\n          * Get the inverse of the decomposed matrix.\n          *\n          * @return the inverse matrix.\n", "nb_test": 5392, "linesAdd": 11, "jira_id": "1045", "singleLine": false, "nb_skipped": 4, "commit": "a4ffd393", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["NormalDistributionTest.testCumulativeProbability:122 expected:<1.0> but was:<0.0>"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/distribution/NormalDistribution.java b/src/main/java/org/apache/commons/math4/distribution/NormalDistribution.java\nindex 6313ef0..5216867 100644\n--- a/src/main/java/org/apache/commons/math4/distribution/NormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math4/distribution/NormalDistribution.java\n@@ -193,7 +193,7 @@ public double cumulativeProbability(double x)  {\n         if (FastMath.abs(dev) > 40 * standardDeviation) {\n             return dev < 0 ? 0.0d : 1.0d;\n         }\n-        return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));\n+        return 0.5 * Erf.erfc(-dev / (standardDeviation * SQRT2));\n     }\n \n     /** {@inheritDoc}\n", "nb_test": 5823, "linesAdd": 1, "jira_id": "1257", "singleLine": false, "nb_skipped": 3, "commit": "03178c8b", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["UnivariateSolverUtilsTest.testBracketLoopConditionForB:182 \u00bb NoBracketing func..."], "patch": "diff --git a/src/main/java/org/apache/commons/math4/analysis/solvers/UnivariateSolverUtils.java b/src/main/java/org/apache/commons/math4/analysis/solvers/UnivariateSolverUtils.java\nindex 2521c9b..49742d8 100644\n--- a/src/main/java/org/apache/commons/math4/analysis/solvers/UnivariateSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math4/analysis/solvers/UnivariateSolverUtils.java\n@@ -314,7 +314,7 @@ public static double forceSide(final int maxEval, final UnivariateFunction f,\n         double delta = 0;\n \n         for (int numIterations = 0;\n-             (numIterations < maximumIterations) && (a > lowerBound || b > upperBound);\n+             (numIterations < maximumIterations) && (a > lowerBound || b < upperBound);\n              ++numIterations) {\n \n             final double previousA  = a;\n", "nb_test": 6185, "linesAdd": 1, "jira_id": "1204", "singleLine": false, "nb_skipped": 3, "commit": "a56d4998", "nb_failure": 0, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath835(org.apache.commons.math3.fraction.FractionTest): expected:<2.1691754E9> but was:<-2.125791896E9>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/fraction/Fraction.java b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\nindex f84218e..f81ff0a 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -594,7 +594,7 @@ public Fraction divide(final int i) {\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+        return 100 * doubleValue();\n     }\n \n     /**\n", "nb_test": 3968, "linesAdd": 1, "jira_id": "835", "singleLine": false, "nb_skipped": 4, "commit": "63a48705", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOverrideVarianceWithMathClass(org.apache.commons.math.stat.descriptive.SummaryStatisticsTest): expected:<1.25> but was:<NaN>", "testOverrideMeanWithMathClass(org.apache.commons.math.stat.descriptive.SummaryStatisticsTest): expected:<2.5> but was:<NaN>", "testOverrideGeoMeanWithMathClass(org.apache.commons.math.stat.descriptive.SummaryStatisticsTest): expected:<2.213363839400643> but was:<NaN>", "testOverrideVarianceWithMathClass(org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest): expected:<1.25> but was:<NaN>", "testOverrideMeanWithMathClass(org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest): expected:<2.5> but was:<NaN>", "testOverrideGeoMeanWithMathClass(org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest): expected:<2.213363839400643> but was:<NaN>"], "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\nindex 1203d51..da987cd 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n@@ -155,13 +155,13 @@ public void addValue(double value) {\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n+        if (meanImpl != mean) {\n             meanImpl.increment(value);\n         }\n-        if (!(varianceImpl instanceof Variance)) {\n+        if (varianceImpl != variance) {\n             varianceImpl.increment(value);\n         }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+        if (geoMeanImpl != geoMean) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n", "nb_test": 3104, "linesAdd": 3, "jira_id": "691", "singleLine": false, "nb_skipped": 1, "commit": "118f0cc0", "nb_failure": 6, "linesRem": 3}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["UniformRealDistributionTest.testInverseCumulativeDistribution:122 expected:<2.5E-10> but was:<5.0E-10>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\nindex 0d279de..62ccb0c 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n@@ -18,6 +18,7 @@\n package org.apache.commons.math3.distribution;\n \n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.random.RandomGenerator;\n import org.apache.commons.math3.random.Well19937c;\n@@ -32,7 +33,10 @@\n  * @since 3.0\n  */\n public class UniformRealDistribution extends AbstractRealDistribution {\n-    /** Default inverse cumulative probability accuracy. */\n+    /** Default inverse cumulative probability accuracy.\n+     * @deprecated as of 3.2 not used anymore, will be removed in 4.0\n+     */\n+    @Deprecated\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 20120109L;\n@@ -40,8 +44,6 @@\n     private final double lower;\n     /** Upper bound of this distribution (exclusive). */\n     private final double upper;\n-    /** Inverse cumulative probability accuracy. */\n-    private final double solverAbsoluteAccuracy;\n \n     /**\n      * Create a standard uniform real distribution with lower bound (inclusive)\n@@ -61,7 +63,7 @@ public UniformRealDistribution() {\n      */\n     public UniformRealDistribution(double lower, double upper)\n         throws NumberIsTooLargeException {\n-        this(lower, upper, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+        this(new  Well19937c(), lower, upper);\n     }\n \n     /**\n@@ -71,10 +73,13 @@ public UniformRealDistribution(double lower, double upper)\n      * @param upper Upper bound of this distribution (exclusive).\n      * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n      * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     * @deprecated as of 3.2, inverse CDF is now calculated analytically, use\n+     *             {@link #UniformRealDistribution(double, double)} instead.\n      */\n+    @Deprecated\n     public UniformRealDistribution(double lower, double upper, double inverseCumAccuracy)\n         throws NumberIsTooLargeException {\n-        this(new  Well19937c(), lower, upper, inverseCumAccuracy);\n+        this(new  Well19937c(), lower, upper);\n     }\n \n     /**\n@@ -86,11 +91,30 @@ public UniformRealDistribution(double lower, double upper, double inverseCumAccu\n      * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n      * @throws NumberIsTooLargeException if {@code lower >= upper}.\n      * @since 3.1\n+     * @deprecated as of 3.2, inverse CDF is now calculated analytically, use\n+     *             {@link #UniformRealDistribution(RandomGenerator, double, double)}\n+     *             instead.\n      */\n+    @Deprecated\n     public UniformRealDistribution(RandomGenerator rng,\n                                    double lower,\n                                    double upper,\n-                                   double inverseCumAccuracy)\n+                                   double inverseCumAccuracy){\n+        this(rng, lower, upper);\n+    }\n+\n+    /**\n+     * Creates a uniform distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param lower Lower bound of this distribution (inclusive).\n+     * @param upper Upper bound of this distribution (exclusive).\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     * @since 3.1\n+     */\n+    public UniformRealDistribution(RandomGenerator rng,\n+                                   double lower,\n+                                   double upper)\n         throws NumberIsTooLargeException {\n         super(rng);\n         if (lower >= upper) {\n@@ -101,7 +125,6 @@ public UniformRealDistribution(RandomGenerator rng,\n \n         this.lower = lower;\n         this.upper = upper;\n-        solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /** {@inheritDoc} */\n@@ -123,10 +146,13 @@ public double cumulativeProbability(double x)  {\n         return (x - lower) / (upper - lower);\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n-    protected double getSolverAbsoluteAccuracy() {\n-        return solverAbsoluteAccuracy;\n+    public double inverseCumulativeProbability(final double p)\n+            throws OutOfRangeException {\n+        if (p < 0.0 || p > 1.0) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        }\n+        return p * (upper - lower) + lower;\n     }\n \n     /**\n", "nb_test": 4934, "linesAdd": 19, "jira_id": "957", "singleLine": false, "nb_skipped": 4, "commit": "9aabf587", "nb_failure": 1, "linesRem": 7}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["CovarianceTest.testOneColumn:170 \u00bb MathIllegalArgument insufficient data: only..."], "patch": "diff --git a/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java b/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java\nindex ba62463..ace3205 100644\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java\n@@ -17,6 +17,7 @@\n package org.apache.commons.math3.stat.correlation;\n \n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n@@ -70,16 +71,18 @@ public Covariance() {\n      * <p>The <code>biasCorrected</code> parameter determines whether or not\n      * covariance estimates are bias-corrected.</p>\n      *\n-     * <p>The input array must be rectangular with at least two columns\n+     * <p>The input array must be rectangular with at least one column\n      * and two rows.</p>\n      *\n      * @param data rectangular array with columns representing covariates\n      * @param biasCorrected true means covariances are bias-corrected\n      * @throws MathIllegalArgumentException if the input data array is not\n-     * rectangular with at least two rows and two columns.\n+     * rectangular with at least two rows and one column.\n+     * @throws NotStrictlyPositiveException if the input data array is not\n+     * rectangular with at least one row and one column.\n      */\n     public Covariance(double[][] data, boolean biasCorrected)\n-    throws MathIllegalArgumentException {\n+    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n         this(new BlockRealMatrix(data), biasCorrected);\n     }\n \n@@ -87,14 +90,17 @@ public Covariance(double[][] data, boolean biasCorrected)\n      * Create a Covariance matrix from a rectangular array\n      * whose columns represent covariates.\n      *\n-     * <p>The input array must be rectangular with at least two columns\n+     * <p>The input array must be rectangular with at least one column\n      * and two rows</p>\n      *\n      * @param data rectangular array with columns representing covariates\n      * @throws MathIllegalArgumentException if the input data array is not\n-     * rectangular with at least two rows and two columns.\n+     * rectangular with at least two rows and one column.\n+     * @throws NotStrictlyPositiveException if the input data array is not\n+     * rectangular with at least one row and one column.\n      */\n-    public Covariance(double[][] data) throws MathIllegalArgumentException {\n+    public Covariance(double[][] data)\n+    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n         this(data, true);\n     }\n \n@@ -105,12 +111,12 @@ public Covariance(double[][] data) throws MathIllegalArgumentException {\n      * <p>The <code>biasCorrected</code> parameter determines whether or not\n      * covariance estimates are bias-corrected.</p>\n      *\n-     * <p>The matrix must have at least two columns and two rows</p>\n+     * <p>The matrix must have at least one column and two rows</p>\n      *\n      * @param matrix matrix with columns representing covariates\n      * @param biasCorrected true means covariances are bias-corrected\n      * @throws MathIllegalArgumentException if the input matrix does not have\n-     * at least two rows and two columns\n+     * at least two rows and one column\n      */\n     public Covariance(RealMatrix matrix, boolean biasCorrected)\n     throws MathIllegalArgumentException {\n@@ -123,11 +129,11 @@ public Covariance(RealMatrix matrix, boolean biasCorrected)\n      * Create a covariance matrix from a matrix whose columns\n      * represent covariates.\n      *\n-     * <p>The matrix must have at least two columns and two rows</p>\n+     * <p>The matrix must have at least one column and two rows</p>\n      *\n      * @param matrix matrix with columns representing covariates\n      * @throws MathIllegalArgumentException if the input matrix does not have\n-     * at least two rows and two columns\n+     * at least two rows and one column\n      */\n     public Covariance(RealMatrix matrix) throws MathIllegalArgumentException {\n         this(matrix, true);\n@@ -154,7 +160,7 @@ public int getN() {\n     /**\n      * Compute a covariance matrix from a matrix whose columns represent\n      * covariates.\n-     * @param matrix input matrix (must have at least two columns and two rows)\n+     * @param matrix input matrix (must have at least one column and two rows)\n      * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n      * @return covariance matrix\n      * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n@@ -178,7 +184,7 @@ protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorr\n     /**\n      * Create a covariance matrix from a matrix whose columns represent\n      * covariates. Covariances are computed using the bias-corrected formula.\n-     * @param matrix input matrix (must have at least two columns and two rows)\n+     * @param matrix input matrix (must have at least one column and two rows)\n      * @return covariance matrix\n      * @throws MathIllegalArgumentException if matrix does not contain sufficient data\n      * @see #Covariance\n@@ -191,26 +197,31 @@ protected RealMatrix computeCovarianceMatrix(RealMatrix matrix)\n     /**\n      * Compute a covariance matrix from a rectangular array whose columns represent\n      * covariates.\n-     * @param data input array (must have at least two columns and two rows)\n+     * @param data input array (must have at least one column and two rows)\n      * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n      * @return covariance matrix\n      * @throws MathIllegalArgumentException if the data array does not contain sufficient\n      * data\n+     * @throws NotStrictlyPositiveException if the input data array is not\n+     * rectangular with at least one row and one column.\n      */\n     protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n-    throws MathIllegalArgumentException {\n+    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n         return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\n     }\n \n     /**\n      * Create a covariance matrix from a rectangular array whose columns represent\n      * covariates. Covariances are computed using the bias-corrected formula.\n-     * @param data input array (must have at least two columns and two rows)\n+     * @param data input array (must have at least one column and two rows)\n      * @return covariance matrix\n      * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n+     * @throws NotStrictlyPositiveException if the input data array is not\n+     * rectangular with at least one row and one column.\n      * @see #Covariance\n      */\n-    protected RealMatrix computeCovarianceMatrix(double[][] data) throws MathIllegalArgumentException {\n+    protected RealMatrix computeCovarianceMatrix(double[][] data)\n+    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n         return computeCovarianceMatrix(data, true);\n     }\n \n@@ -268,7 +279,7 @@ public double covariance(final double[] xArray, final double[] yArray)\n \n     /**\n      * Throws MathIllegalArgumentException if the matrix does not have at least\n-     * two columns and two rows.\n+     * one column and two rows.\n      * @param matrix matrix to check\n      * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n      * to compute covariance\n@@ -276,7 +287,7 @@ public double covariance(final double[] xArray, final double[] yArray)\n     private void checkSufficientData(final RealMatrix matrix) throws MathIllegalArgumentException {\n         int nRows = matrix.getRowDimension();\n         int nCols = matrix.getColumnDimension();\n-        if (nRows < 2 || nCols < 2) {\n+        if (nRows < 2 || nCols < 1) {\n             throw new MathIllegalArgumentException(\n                     LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS,\n                     nRows, nCols);\n", "nb_test": 4795, "linesAdd": 8, "jira_id": "939", "singleLine": false, "nb_skipped": 4, "commit": "49444ee6", "nb_failure": 0, "linesRem": 5}, {"files": 3, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testIsSupportLowerBoundInclusive(org.apache.commons.math3.distribution.FDistributionTest): expected:<false> but was:<true>", "testIsSupportUpperBoundInclusive(org.apache.commons.math3.distribution.UniformRealDistributionTest): expected:<true> but was:<false>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\nindex 8b0993c..e301e2e 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n@@ -272,7 +272,7 @@ public double getSupportUpperBound() {\n \n     /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n-        return true;\n+        return false;\n     }\n \n     /** {@inheritDoc} */\ndiff --git a/src/main/java/org/apache/commons/math3/distribution/RealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/RealDistribution.java\nindex f09c5ac..90dc8fd 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/RealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/RealDistribution.java\n@@ -137,18 +137,26 @@\n     double getSupportUpperBound();\n \n     /**\n-     * Use this method to get information about whether the lower bound\n-     * of the support is inclusive or not.\n+     * Whether or not the lower bound of support is in the domain of the density\n+     * function.  Returns true iff {@code getSupporLowerBound()} is finite and\n+     * {@code density(getSupportLowerBound())} returns a non-NaN, non-infinite\n+     * value.\n      *\n-     * @return whether the lower bound of the support is inclusive or not\n+     * @return true if the lower bound of support is finite and the density \n+     * function returns a non-NaN, non-infinite value there\n+     * @deprecated to be removed in 4.0\n      */\n     boolean isSupportLowerBoundInclusive();\n \n     /**\n-     * Use this method to get information about whether the upper bound\n-     * of the support is inclusive or not.\n+     * Whether or not the upper bound of support is in the domain of the density\n+     * function.  Returns true iff {@code getSupportUpperBound()} is finite and\n+     * {@code density(getSupportUpperBound())} returns a non-NaN, non-infinite\n+     * value.\n      *\n-     * @return whether the upper bound of the support is inclusive or not\n+     * @return true if the upper bound of support is finite and the density \n+     * function returns a non-NaN, non-infinite value there\n+     * @deprecated to be removed in 4.0\n      */\n     boolean isSupportUpperBoundInclusive();\n \ndiff --git a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\nindex 5d32f6e..0d279de 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n@@ -181,7 +181,7 @@ public boolean isSupportLowerBoundInclusive() {\n \n     /** {@inheritDoc} */\n     public boolean isSupportUpperBoundInclusive() {\n-        return false;\n+        return true;\n     }\n \n     /**\n", "nb_test": 4106, "linesAdd": 2, "jira_id": "859", "singleLine": false, "nb_skipped": 4, "commit": "66dece12", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMultiply(org.apache.commons.math3.dfp.DfpTest): assersion failed Multiply #37 x = NaN flags = 1"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/dfp/Dfp.java b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\nindex d278a31..3a91982 100644\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1595,12 +1595,24 @@ public Dfp multiply(final Dfp x) {\n \n     }\n \n-    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n-     * There are speed advantages in this special case\n+    /** Multiply this by a single digit x.\n      * @param x multiplicand\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n+        if (x >= 0 && x < RADIX) {\n+            return multiplyFast(x);\n+        } else {\n+            return multiply(newInstance(x));\n+        }\n+    }\n+\n+    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n+     * There are speed advantages in this special case.\n+     * @param x multiplicand\n+     * @return product of this and x\n+     */\n+    private Dfp multiplyFast(final int x) {\n         Dfp result = newInstance(this);\n \n         /* handle special cases */\n", "nb_test": 4164, "linesAdd": 8, "jira_id": "778", "singleLine": false, "nb_skipped": 4, "commit": "5b9302d5", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FastMathTest.testMath1269:226 exp(709.8125) is NaN instead of Infinity"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/util/FastMath.java b/src/main/java/org/apache/commons/math4/util/FastMath.java\nindex 3d6d27d..2532c62 100644\n--- a/src/main/java/org/apache/commons/math4/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math4/util/FastMath.java\n@@ -968,6 +968,13 @@ full double precision (52 bits).  Since z < 2^-10, we will have\n        much larger than the others.  If there are extra bits specified from the\n        pow() function, use them. */\n         final double tempC = tempB + tempA;\n+\n+        // If tempC is positive infinite, the evaluation below could result in NaN,\n+        // because z could be negative at the same time.\n+        if (tempC == Double.POSITIVE_INFINITY) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+\n         final double result;\n         if (extra != 0.0) {\n             result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n", "nb_test": 5866, "linesAdd": 5, "jira_id": "1269", "singleLine": false, "nb_skipped": 3, "commit": "a94ff90a", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath286(org.apache.commons.math.optimization.linear.SimplexSolverTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex c228ad6..b387767 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -270,8 +270,27 @@ protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n+        return getBasicRow(col, true);\n+    }\n+\n+    /**\n+     * Checks whether the given column is basic.\n+     * @param col index of the column to check\n+     * @return the row that the variable is basic in.  null if the column is not basic\n+     */\n+    private Integer getBasicRowForSolution(final int col) {\n+        return getBasicRow(col, false);\n+    }\n+    \n+    /**\n+     * Checks whether the given column is basic.\n+     * @param col index of the column to check\n+     * @return the row that the variable is basic in.  null if the column is not basic\n+     */\n+    private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n-        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n+        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;\n+        for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n             } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n@@ -319,12 +338,11 @@ private void copyArray(final double[] src, final double[] dest,\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-        Integer basicRow =\n-            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n-        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n+      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n+      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n-            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n+          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value \n               // then we choose the first and set the rest equal to 0\n@@ -432,6 +450,15 @@ protected final int getRhsOffset() {\n     }\n     \n     /**\n+     * Returns the offset of the extra decision variable added when there is a\n+     * negative decision variable in the original problem.\n+     * @return the offset of x-\n+     */\n+    protected final int getNegativeDecisionVariableOffset() {\n+      return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();\n+    }\n+\n+    /**\n      * Get the number of decision variables.\n      * <p>\n      * If variables are not restricted to positive values, this will include 1\n", "nb_test": 2040, "linesAdd": 17, "jira_id": "286", "singleLine": false, "nb_skipped": 0, "commit": "dbdff075", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["DiscreteRealDistributionTest.testIssue942:212 \u00bb ArrayStore org.apache.commons...."], "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\nindex 8c08dbe..879eb2a 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n@@ -16,9 +16,9 @@\n  */\n package org.apache.commons.math3.distribution;\n \n-import java.lang.reflect.Array;\n import java.util.ArrayList;\n import java.util.List;\n+\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NotPositiveException;\n@@ -178,13 +178,13 @@ public T sample() {\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n+    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                     sampleSize);\n         }\n-        @SuppressWarnings(\"unchecked\")\n-        final T[]out = (T[]) Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+\n+        final Object[] out = new Object[sampleSize];\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n", "nb_test": 4818, "linesAdd": 4, "jira_id": "942", "singleLine": false, "nb_skipped": 4, "commit": "0d057fc6", "nb_failure": 0, "linesRem": 4}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEvaluateArraySegmentWeighted(org.apache.commons.math.stat.descriptive.moment.VarianceTest): expected:<1.6644508338125354> but was:<0.31909161062727365>"], "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\nindex e5518e3..1de139f 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n@@ -517,7 +517,7 @@ public double evaluate(final double[] values, final double[] weights,\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+                for (int i = begin; i < begin + length; i++) {\n                     sumWts += weights[i];\n                 }\n \n", "nb_test": 3145, "linesAdd": 1, "jira_id": "704", "singleLine": false, "nb_skipped": 1, "commit": "3f645310", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testMath320A(org.apache.commons.math.linear.SingularValueSolverTest)", "testMath320B(org.apache.commons.math.linear.SingularValueSolverTest)", "testLeastSquareSolve(org.apache.commons.math.linear.SingularValueSolverTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\nindex 5f91636..bbb2057 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n@@ -24,9 +24,17 @@\n  * Singular Value Decomposition of a real matrix.\n  * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n  * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n- * Let A be an m &times; n matrix, then U is an m &times; n orthogonal matrix,\n- * &Sigma; is a n &times; n diagonal matrix with positive diagonal elements,\n- * and V is an n &times; n orthogonal matrix.</p>\n+ * Let A be a m &times; n matrix, then U is a m &times; p orthogonal matrix,\n+ * &Sigma; is a p &times; p diagonal matrix with positive diagonal elements,\n+ * V is a n &times; p orthogonal matrix (hence V<sup>T</sup> is a p &times; n\n+ * orthogonal matrix). The size p depends on the chosen algorithm:\n+ * <ul>\n+ *   <li>for full SVD, p is n,</li>\n+ *   <li>for compact SVD, p is the rank r of the matrix\n+ *       (i. e. the number of positive singular values),</li>\n+ *   <li>for truncated SVD p is min(r, t) where t is user-specified.</li>\n+ * </ul>\n+ * </p>\n  * <p>This interface is similar to the class with similar name from the\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n  * following changes:</p>\ndiff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\nindex 0da87ab..6003ed6 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n@@ -21,12 +21,24 @@\n import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Calculates the Singular Value Decomposition of a matrix.\n+ * Calculates the compact or truncated Singular Value Decomposition of a matrix.\n  * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n  * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n- * Let A be an m &times; n matrix, then U is an m &times; n orthogonal matrix,\n- * &Sigma; is a n &times; n diagonal matrix with positive diagonal elements,\n- * and V is an n &times; n orthogonal matrix.</p>\n+ * Let A be a m &times; n matrix, then U is a m &times; p orthogonal matrix,\n+ * &Sigma; is a p &times; p diagonal matrix with positive diagonal elements,\n+ * V is a n &times; p orthogonal matrix (hence V<sup>T</sup> is a p &times; n\n+ * orthogonal matrix). The size p depends on the chosen algorithm:\n+ * <ul>\n+ *   <li>for full SVD, p would be n, but this is not supported by this implementation,</li>\n+ *   <li>for compact SVD, p is the rank r of the matrix\n+ *       (i. e. the number of positive singular values),</li>\n+ *   <li>for truncated SVD p is min(r, t) where t is user-specified.</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Note that since this class computes only the compact or truncated SVD and not\n+ * the full SVD, the singular values computed are always positive.\n+ * </p>\n  *\n  * @version $Revision$ $Date$\n  * @since 2.0\n@@ -76,12 +88,24 @@\n     private RealMatrix cachedVt;\n \n     /**\n+     * Calculates the compact Singular Value Decomposition of the given matrix.\n+     * @param matrix The matrix to decompose.\n+     * @exception InvalidMatrixException (wrapping a {@link\n+     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n+     */\n+    public SingularValueDecompositionImpl(final RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));\n+    }\n+\n+    /**\n      * Calculates the Singular Value Decomposition of the given matrix.\n      * @param matrix The matrix to decompose.\n+     * @param max maximal number of singular values to compute\n      * @exception InvalidMatrixException (wrapping a {@link\n      * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n      */\n-    public SingularValueDecompositionImpl(RealMatrix matrix)\n+    public SingularValueDecompositionImpl(final RealMatrix matrix, final int max)\n         throws InvalidMatrixException {\n \n         m = matrix.getRowDimension();\n@@ -113,10 +137,14 @@ public SingularValueDecompositionImpl(RealMatrix matrix)\n         eigenDecomposition =\n             new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,\n                                        MathUtils.SAFE_MIN);\n-        singularValues = eigenDecomposition.getRealEigenvalues();\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si = singularValues[i];\n-            singularValues[i] = (si < 0) ? 0.0 : Math.sqrt(si);\n+        final double[] eigenValues = eigenDecomposition.getRealEigenvalues();\n+        int p = Math.min(max, eigenValues.length);\n+        while ((p > 0) && (eigenValues[p - 1] <= 0)) {\n+            --p;\n+        }\n+        singularValues = new double[p];\n+        for (int i = 0; i < p; ++i) {\n+            singularValues[i] = Math.sqrt(eigenValues[i]);\n         }\n \n     }\n@@ -127,37 +155,41 @@ public RealMatrix getU()\n \n         if (cachedU == null) {\n \n+            final int p = singularValues.length;\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n-                final double[][] eData = eigenDecomposition.getV().getData();\n-                final double[][] iData = new double[m][];\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                final double[][] eData = e.getData();\n+                final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n-                iData[0] = ei1;\n-                for (int i = 0; i < n - 1; ++i) {\n-                    // compute B.E.S^(-1) where E is the eigenvectors matrix\n-                    // we reuse the array from matrix E to store the result\n+                for (int i = 0; i < p - 1; ++i) {\n+                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                     final double mi = mainBidiagonal[i];\n                     final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n+                    final double[] wi  = wData[i];\n                     ei1 = eData[i + 1];\n-                    iData[i + 1] = ei1;\n-                    for (int j = 0; j < n; ++j) {\n-                        ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                    for (int j = 0; j < p; ++j) {\n+                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                     }\n                 }\n                 // last row\n-                final double lastMain = mainBidiagonal[n - 1];\n-                for (int j = 0; j < n; ++j) {\n-                    ei1[j] *= lastMain / singularValues[j];\n+                final double lastMain = mainBidiagonal[p - 1];\n+                final double[] wr1  = wData[p - 1];\n+                for (int j = 0; j < p; ++j) {\n+                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n                 }\n-                for (int i = n; i < m; ++i) {\n-                    iData[i] = new double[n];\n+                for (int i = p; i < m; ++i) {\n+                    wData[i] = new double[p];\n                 }\n                 cachedU =\n-                    transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));\n+                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n             } else {\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n-                cachedU = transformer.getU().multiply(eigenDecomposition.getV());\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n+                cachedU = transformer.getU().multiply(e);\n             }\n \n         }\n@@ -205,37 +237,41 @@ public RealMatrix getV()\n \n         if (cachedV == null) {\n \n+            final int p = singularValues.length;\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n-                cachedV = transformer.getV().multiply(eigenDecomposition.getV());\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n+                cachedV = transformer.getV().multiply(e);\n             } else {\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n-                final double[][] eData = eigenDecomposition.getV().getData();\n-                final double[][] iData = new double[n][];\n+                // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                final double[][] eData = e.getData();\n+                final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n-                iData[0] = ei1;\n-                for (int i = 0; i < m - 1; ++i) {\n-                    // compute Bt.E.S^(-1) where E is the eigenvectors matrix\n-                    // we reuse the array from matrix E to store the result\n+                for (int i = 0; i < p - 1; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n+                    final double[] wi  = wData[i];\n                     ei1 = eData[i + 1];\n-                    iData[i + 1] = ei1;\n-                    for (int j = 0; j < m; ++j) {\n-                        ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                    for (int j = 0; j < p; ++j) {\n+                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                     }\n                 }\n                 // last row\n-                final double lastMain = mainBidiagonal[m - 1];\n-                for (int j = 0; j < m; ++j) {\n-                    ei1[j] *= lastMain / singularValues[j];\n+                final double lastMain = mainBidiagonal[p - 1];\n+                final double[] wr1  = wData[p - 1];\n+                for (int j = 0; j < p; ++j) {\n+                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n                 }\n-                for (int i = m; i < n; ++i) {\n-                    iData[i] = new double[m];\n+                for (int i = p; i < n; ++i) {\n+                    wData[i] = new double[p];\n                 }\n                 cachedV =\n-                    transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));\n+                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n             }\n \n         }\n@@ -262,8 +298,9 @@ public RealMatrix getVT()\n     public RealMatrix getCovariance(final double minSingularValue) {\n \n         // get the number of singular values to consider\n+        final int p = singularValues.length;\n         int dimension = 0;\n-        while ((dimension < n) && (singularValues[dimension] >= minSingularValue)) {\n+        while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {\n             ++dimension;\n         }\n \n@@ -273,14 +310,14 @@ public RealMatrix getCovariance(final double minSingularValue) {\n                   minSingularValue, singularValues[0]);\n         }\n \n-        final double[][] data = new double[dimension][n];\n+        final double[][] data = new double[dimension][p];\n         getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n             /** {@inheritDoc} */\n             @Override\n             public void visit(final int row, final int column, final double value) {\n                 data[row][column] = value / singularValues[row];\n             }\n-        }, 0, dimension - 1, 0, n - 1);\n+        }, 0, dimension - 1, 0, p - 1);\n \n         RealMatrix jv = new Array2DRowRealMatrix(data, false);\n         return jv.transpose().multiply(jv);\n@@ -317,20 +354,14 @@ public int getRank()\n     /** {@inheritDoc} */\n     public DecompositionSolver getSolver() {\n         return new Solver(singularValues, getUT(), getV(),\n-                          getRank() == singularValues.length);\n+                          getRank() == Math.max(m, n));\n     }\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n \n-        /** Singular values. */\n-        private final double[] singularValues;\n-\n-        /** U<sup>T</sup> matrix of the decomposition. */\n-        private final RealMatrix uT;\n-\n-        /** V matrix of the decomposition. */\n-        private final RealMatrix v;\n+        /** Pseudo-inverse of the initial matrix. */\n+        private final RealMatrix pseudoInverse;\n \n         /** Singularity indicator. */\n         private boolean nonSingular;\n@@ -344,9 +375,15 @@ public DecompositionSolver getSolver() {\n          */\n         private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v,\n                        final boolean nonSingular) {\n-            this.singularValues = singularValues;\n-            this.uT             = uT;\n-            this.v              = v;\n+            double[][] suT      = uT.getData();\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double a      = 1.0 / singularValues[i];\n+                final double[] suTi = suT[i];\n+                for (int j = 0; j < suTi.length; ++j) {\n+                    suTi[j] *= a;\n+                }\n+            }\n+            pseudoInverse    = v.multiply(new Array2DRowRealMatrix(suT, false));\n             this.nonSingular = nonSingular;\n         }\n \n@@ -356,27 +393,10 @@ private Solver(final double[] singularValues, final RealMatrix uT, final RealMat\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public double[] solve(final double[] b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.length != uT.getColumnDimension()) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n-                        b.length, uT.getColumnDimension());\n-            }\n-\n-            final double[] w = uT.operate(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                w[i] /= si;\n-            }\n-            return v.operate(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.operate(b);\n         }\n \n         /** Solve the linear equation A &times; X = B in least square sense.\n@@ -385,27 +405,10 @@ private Solver(final double[] singularValues, final RealMatrix uT, final RealMat\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public RealVector solve(final RealVector b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.getDimension() != uT.getColumnDimension()) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n-                         b.getDimension(), uT.getColumnDimension());\n-            }\n-\n-            final RealVector w = uT.operate(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                w.setEntry(i, w.getEntry(i) / si);\n-            }\n-            return v.operate(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.operate(b);\n         }\n \n         /** Solve the linear equation A &times; X = B in least square sense.\n@@ -414,31 +417,10 @@ public RealVector solve(final RealVector b)\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a matrix X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public RealMatrix solve(final RealMatrix b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.getRowDimension() != singularValues.length) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                        b.getRowDimension(), b.getColumnDimension(),\n-                        singularValues.length, \"n\");\n-            }\n-\n-            final RealMatrix w = uT.multiply(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si  = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                final double inv = 1.0 / si;\n-                for (int j = 0; j < b.getColumnDimension(); ++j) {\n-                    w.multiplyEntry(i, j, inv);\n-                }\n-            }\n-            return v.multiply(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.multiply(b);\n         }\n \n         /**\n@@ -451,17 +433,9 @@ public boolean isNonSingular() {\n \n         /** Get the pseudo-inverse of the decomposed matrix.\n          * @return inverse matrix\n-         * @throws InvalidMatrixException if decomposed matrix is singular\n          */\n-        public RealMatrix getInverse()\n-            throws InvalidMatrixException {\n-\n-            if (!isNonSingular()) {\n-                throw new SingularMatrixException();\n-            }\n-\n-            return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\n-\n+        public RealMatrix getInverse() {\n+            return pseudoInverse;\n         }\n \n     }\n", "nb_test": 2124, "linesAdd": 75, "jira_id": "320", "singleLine": false, "nb_skipped": 0, "commit": "c06cc933", "nb_failure": 2, "linesRem": 112}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMinMaxFloat(org.apache.commons.math.util.FastMathTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/util/FastMath.java b/src/main/java/org/apache/commons/math/util/FastMath.java\nindex 8cba4d4..4f7d447 100644\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -3479,7 +3479,7 @@ public static long max(final long a, final long b) {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n     }\n \n     /** Compute the maximum of two values\n", "nb_test": 2226, "linesAdd": 1, "jira_id": "482", "singleLine": false, "nb_skipped": 1, "commit": "6d6649ef", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testIntegerOverflow(org.apache.commons.math3.fraction.FractionTest): an exception should have been thrown"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/fraction/Fraction.java b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\nindex f81ff0a..08d3b95 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -178,7 +178,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n-        if (a0 > overflow) {\n+        if (FastMath.abs(a0) > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }\n \n@@ -206,7 +206,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n-            if ((p2 > overflow) || (q2 > overflow)) {\n+            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n", "nb_test": 3968, "linesAdd": 2, "jira_id": "836", "singleLine": false, "nb_skipped": 4, "commit": "d7c0f27e", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PrecisionTest.testRoundDouble:397 expected:<[-]0.0> but was:<[]0.0>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/Precision.java b/src/main/java/org/apache/commons/math3/util/Precision.java\nindex f0b0c4f..441e015 100644\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n@@ -392,10 +392,11 @@ public static double round(double x, int scale) {\n      */\n     public static double round(double x, int scale, int roundingMethod) {\n         try {\n-            return (new BigDecimal\n-                   (Double.toString(x))\n+            final double rounded = (new BigDecimal(Double.toString(x))\n                    .setScale(scale, roundingMethod))\n                    .doubleValue();\n+            // MATH-1089: negative values rounded to zero should result in negative zero\n+            return rounded == 0.0 ? rounded * FastMath.copySign(1d, x) : rounded;\n         } catch (NumberFormatException ex) {\n             if (Double.isInfinite(x)) {\n                 return x;\n", "nb_test": 5603, "linesAdd": 2, "jira_id": "1089", "singleLine": false, "nb_skipped": 5, "commit": "e91d0f05", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["MonotoneChainTest>ConvexHullGenerator2DAbstractTest.testIssue1123:287 \u00bb NullPointer", "AklToussaintHeuristicTest>ConvexHullGenerator2DAbstractTest.testIssue1123:287 \u00bb NullPointer"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java b/src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java\nindex c81832b..5aec175 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java\n@@ -294,7 +294,7 @@ public void visit(final BSPTreeVisitor<S> visitor) {\n      */\n     private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {\n         SubHyperplane<S> s = sub;\n-        for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\n+        for (BSPTree<S> tree = this; tree.parent != null && s != null; tree = tree.parent) {\n             if (tree == tree.parent.plus) {\n                 s = s.split(tree.parent.cut.getHyperplane()).getPlus();\n             } else {\n", "nb_test": 5964, "linesAdd": 1, "jira_id": "1123", "singleLine": false, "nb_skipped": 3, "commit": "a197ba85", "nb_failure": 0, "linesRem": 1}, {"files": 2, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["LocalizedFormatsTest.testAllPropertiesCorrespondToKeys:66 unknown key \"MULTISTEP_STARTER_STOPPED_EARLY\" in language fr", "LocalizedFormatsTest.testMessageNumber:32 expected:<328> but was:<327>", "AdamsBashforthIntegratorTest.testStartFailure \u00bb  Unexpected exception, expecte..."], "patch": "diff --git a/src/main/java/org/apache/commons/math4/exception/util/LocalizedFormats.java b/src/main/java/org/apache/commons/math4/exception/util/LocalizedFormats.java\nindex 1b589f1..dabe9a7 100644\n--- a/src/main/java/org/apache/commons/math4/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math4/exception/util/LocalizedFormats.java\n@@ -162,6 +162,7 @@\n     LOWER_BOUND_NOT_BELOW_UPPER_BOUND(\"lower bound ({0}) must be strictly less than upper bound ({1})\"), /* keep */\n     LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT(\"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\"),\n     MAP_MODIFIED_WHILE_ITERATING(\"map has been modified while iterating\"),\n+    MULTISTEP_STARTER_STOPPED_EARLY(\"multistep integrator starter stopped early, maybe too large step size\"),\n     EVALUATIONS(\"evaluations\"), /* keep */\n     MAX_COUNT_EXCEEDED(\"maximal count ({0}) exceeded\"), /* keep */\n     MAX_ITERATIONS_EXCEEDED(\"maximal number of iterations ({0}) exceeded\"),\ndiff --git a/src/main/java/org/apache/commons/math4/ode/MultistepIntegrator.java b/src/main/java/org/apache/commons/math4/ode/MultistepIntegrator.java\nindex b415dd1..354db49 100644\n--- a/src/main/java/org/apache/commons/math4/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math4/ode/MultistepIntegrator.java\n@@ -18,6 +18,7 @@\n package org.apache.commons.math4.ode;\n \n import org.apache.commons.math4.exception.DimensionMismatchException;\n+import org.apache.commons.math4.exception.MathIllegalStateException;\n import org.apache.commons.math4.exception.MaxCountExceededException;\n import org.apache.commons.math4.exception.NoBracketingException;\n import org.apache.commons.math4.exception.NumberIsTooSmallException;\n@@ -248,6 +249,9 @@ public void computeDerivatives(double t, double[] y, double[] yDot) {\n                 }, t0, y0, t, new double[y0.length]);\n             }\n \n+            // we should not reach this step\n+            throw new MathIllegalStateException(LocalizedFormats.MULTISTEP_STARTER_STOPPED_EARLY);\n+\n         } catch (InitializationCompletedMarkerException icme) { // NOPMD\n             // this is the expected nominal interruption of the start integrator\n \n", "nb_test": 6005, "linesAdd": 4, "jira_id": "1297", "singleLine": false, "nb_skipped": 4, "commit": "56434517", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath713NegativeVariable(org.apache.commons.math.optimization.linear.SimplexSolverTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex fd89432..d96c916 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -407,7 +407,12 @@ protected RealPointValuePair getSolution() {\n             continue;\n           }\n           Integer basicRow = getBasicRow(colIndex);\n-          if (basicRows.contains(basicRow)) {\n+          if (basicRow != null && basicRow == 0) {\n+              // if the basic row is found to be the objective function row\n+              // set the coefficient to 0 -> this case handles unconstrained \n+              // variables that are still part of the objective function\n+              coefficients[i] = 0;\n+          } else if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n", "nb_test": 3124, "linesAdd": 3, "jira_id": "713", "singleLine": false, "nb_skipped": 1, "commit": "f656676e", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath781(org.apache.commons.math3.optimization.linear.SimplexSolverTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\nindex 9a6993a..327b2ae 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ protected void dropPhase1Objective() {\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n", "nb_test": 3524, "linesAdd": 1, "jira_id": "781", "singleLine": false, "nb_skipped": 1, "commit": "3c4cb189", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["MonotoneChainTest>ConvexHullGenerator2DAbstractTest.testCollinearPointOnExistingBoundary:223 \u00bb Convergence", "AklToussaintHeuristicTest>ConvexHullGenerator2DAbstractTest.testCollinearPointOnExistingBoundary:223 \u00bb Convergence"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\nindex 2ade7a6..50fd6b7 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\n@@ -160,9 +160,9 @@ private void updateHull(final Vector2D point, final List<Vector2D> hull) {\n                 } else {\n                     if (distanceToCurrent > distanceToLast) {\n                         hull.remove(size - 1);\n-                    }\n                         hull.add(point);\n                     }\n+                }\n                 return;\n             } else if (offset > 0) {\n                 hull.remove(size - 1);\n", "nb_test": 6075, "linesAdd": 1, "jira_id": "1135", "singleLine": false, "nb_skipped": 3, "commit": "a7363a2a", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTooLargeFirstStep(org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27..d2bbf67 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,15 @@ public void integrate(final ExpandableStatefulODE equations, final double t)\n         }\n \n         stepSize = hNew;\n+        if (forward) {\n+            if (stepStart + stepSize >= t) {\n+                stepSize = t - stepStart;\n+            }\n+        } else {\n+            if (stepStart + stepSize <= t) {\n+                stepSize = t - stepStart;\n+            }\n+        }\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {\n", "nb_test": 3209, "linesAdd": 9, "jira_id": "727", "singleLine": false, "nb_skipped": 1, "commit": "d2777388", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["DormandPrince853IntegratorTest.testEventsScheduling:365 null"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex 00827db..6e0237f 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -338,11 +338,15 @@ public int compare(EventState es0, EventState es1) {\n                 interpolator.setSoftPreviousTime(previousT);\n                 interpolator.setSoftCurrentTime(eventT);\n \n-                // trigger the event\n+                // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+\n+                // advance all event states to current time\n+                for (final EventState state : eventsStates) {\n+                    state.stepAccepted(eventT, eventY);\n+                    isLastStep = isLastStep || state.stop();\n+                }\n \n                 // handle the first part of the step, up to the event\n                 for (final StepHandler handler : stepHandlers) {\n@@ -352,21 +356,19 @@ public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n-                if (currentEvent.reset(eventT, eventY)) {\n+                boolean needReset = false;\n+                for (final EventState state : eventsStates) {\n+                    needReset =  needReset || state.reset(eventT, eventY);\n+                }\n+                if (needReset) {\n                     // some event handler has triggered changes that\n                     // invalidate the derivatives, we need to recompute them\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n@@ -383,6 +385,7 @@ public int compare(EventState es0, EventState es1) {\n \n             }\n \n+            // last part of the step, after the last event\n             interpolator.setInterpolatedTime(currentT);\n             final double[] currentY = interpolator.getInterpolatedState();\n             for (final EventState state : eventsStates) {\n", "nb_test": 4901, "linesAdd": 10, "jira_id": "950", "singleLine": false, "nb_skipped": 4, "commit": "424cbd20", "nb_failure": 1, "linesRem": 9}, {"files": 11, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDormandPrince(org.apache.commons.math.ode.events.ReappearingEventTest): expected:<10.0> but was:<6.000000000000002>", "serialization(org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest)", "serialization(org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest)", "serialization(org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest)", "serialization(org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest)", "serialization(org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest)", "serialization(org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest)", "serialization(org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\nindex 42796c7..baf236a 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n@@ -48,7 +48,7 @@\n     extends RungeKuttaStepInterpolator {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n     /** Simple constructor.\n      * This constructor builds an instance that is not usable yet, the\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\nindex af32c4c..1dac8ab 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n@@ -72,7 +72,7 @@\n     private static final double D6 =      69997945.0 /     29380423.0;\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n     /** First vector for interpolation. */\n     private double[] v1;\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\nindex 91442bb..64dd7d7 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n@@ -39,7 +39,7 @@\n   extends RungeKuttaStepInterpolator {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n     /** Propagation weights, element 1. */\n     private static final double B_01 =         104257.0 / 1920240.0;\n@@ -368,6 +368,21 @@ protected void computeInterpolatedStateAndDerivatives(final double theta,\n     final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\n     final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\n \n+    if ((previousState != null) && (theta <= 0.5)) {\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            interpolatedState[i] = previousState[i] +\n+                    theta * h * (v[0][i] +\n+                            eta * (v[1][i] +\n+                                    theta * (v[2][i] +\n+                                            eta * (v[3][i] +\n+                                                    theta * (v[4][i] +\n+                                                            eta * (v[5][i] +\n+                                                                    theta * (v[6][i])))))));\n+            interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n+                    dot3 * v[3][i] + dot4 * v[4][i] +\n+                    dot5 * v[5][i] + dot6 * v[6][i];\n+        }\n+    } else {\n         for (int i = 0; i < interpolatedState.length; ++i) {\n             interpolatedState[i] = currentState[i] -\n                     oneMinusThetaH * (v[0][i] -\n@@ -381,6 +396,7 @@ protected void computeInterpolatedStateAndDerivatives(final double theta,\n                     dot3 * v[3][i] + dot4 * v[4][i] +\n                     dot5 * v[5][i] + dot6 * v[6][i];\n         }\n+    }\n \n   }\n \ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 87fd716..34d2c00 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -202,7 +202,7 @@ public void integrate(final ExpandableStatefulODE equations, final double t)\n     final double[] y = y0.clone();\n     final int stages = c.length + 1;\n     final double[][] yDotK = new double[stages][y.length];\n-    final double[] yTmp    = new double[y.length];\n+    final double[] yTmp    = y0.clone();\n     final double[] yDotTmp = new double[y.length];\n \n     // set up an interpolator sharing the integrator arrays\n@@ -294,6 +294,7 @@ public void integrate(final ExpandableStatefulODE equations, final double t)\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n       System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n       stepStart = acceptStep(interpolator, y, yDotTmp, t);\n+      System.arraycopy(y, 0, yTmp, 0, y.length);\n \n       if (!isLastStep) {\n \ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\nindex 99a604f..d2807a4 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n@@ -42,7 +42,7 @@\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\nindex e956b20..5377755 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n@@ -54,7 +54,7 @@\n     private static final double TWO_PLUS_SQRT_2 = 2 + FastMath.sqrt(2.0);\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\nindex ba112d4..b928b53 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n@@ -33,7 +33,7 @@\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\nindex 1c76483..25f77c5 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n@@ -44,7 +44,7 @@\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\nindex fb82d0c..c51620c 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -107,7 +107,7 @@ public void integrate(final ExpandableStatefulODE equations, final double t)\n     for (int i = 0; i < stages; ++i) {\n       yDotK [i] = new double[y0.length];\n     }\n-    final double[] yTmp    = new double[y0.length];\n+    final double[] yTmp    = y0.clone();\n     final double[] yDotTmp = new double[y0.length];\n \n     // set up an interpolator sharing the integrator arrays\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\nindex 987dfb1..55146c3 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n@@ -38,6 +38,9 @@\n abstract class RungeKuttaStepInterpolator\n   extends AbstractStepInterpolator {\n \n+    /** Previous state. */\n+    protected double[] previousState;\n+\n     /** Slopes at the intermediate points */\n     protected double[][] yDotK;\n \n@@ -55,7 +58,7 @@\n    * uninitialized model and latter initializing the copy.\n    */\n   protected RungeKuttaStepInterpolator() {\n-    super();\n+    previousState = null;\n     yDotK         = null;\n     integrator    = null;\n   }\n@@ -82,16 +85,16 @@ public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator)\n     super(interpolator);\n \n     if (interpolator.currentState != null) {\n-      final int dimension = currentState.length;\n+\n+      previousState = interpolator.previousState.clone();\n \n       yDotK = new double[interpolator.yDotK.length][];\n       for (int k = 0; k < interpolator.yDotK.length; ++k) {\n-        yDotK[k] = new double[dimension];\n-        System.arraycopy(interpolator.yDotK[k], 0,\n-                         yDotK[k], 0, dimension);\n+        yDotK[k] = interpolator.yDotK[k].clone();\n       }\n \n     } else {\n+      previousState = null;\n       yDotK = null;\n     }\n \n@@ -129,12 +132,20 @@ public void reinitialize(final AbstractIntegrator rkIntegrator,\n                            final EquationsMapper primaryMapper,\n                            final EquationsMapper[] secondaryMappers) {\n     reinitialize(y, forward, primaryMapper, secondaryMappers);\n+    this.previousState = null;\n     this.yDotK = yDotArray;\n     this.integrator = rkIntegrator;\n   }\n \n   /** {@inheritDoc} */\n   @Override\n+  public void shift() {\n+    previousState = currentState.clone();\n+    super.shift();\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n   public void writeExternal(final ObjectOutput out)\n     throws IOException {\n \n@@ -143,6 +154,10 @@ public void writeExternal(final ObjectOutput out)\n \n     // save the local attributes\n     final int n = (currentState == null) ? -1 : currentState.length;\n+    for (int i = 0; i < n; ++i) {\n+      out.writeDouble(previousState[i]);\n+    }\n+\n     final int kMax = (yDotK == null) ? -1 : yDotK.length;\n     out.writeInt(kMax);\n     for (int k = 0; k < kMax; ++k) {\n@@ -165,6 +180,15 @@ public void readExternal(final ObjectInput in)\n \n     // read the local attributes\n     final int n = (currentState == null) ? -1 : currentState.length;\n+    if (n < 0) {\n+      previousState = null;\n+    } else {\n+      previousState = new double[n];\n+      for (int i = 0; i < n; ++i) {\n+        previousState[i] = in.readDouble();\n+      }\n+    }\n+\n     final int kMax = in.readInt();\n     yDotK = (kMax < 0) ? null : new double[kMax][];\n     for (int k = 0; k < kMax; ++k) {\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\nindex 731ec44..fdc9d75 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n@@ -49,7 +49,7 @@\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n", "nb_test": 3095, "linesAdd": 54, "jira_id": "705", "singleLine": false, "nb_skipped": 1, "commit": "645d642b", "nb_failure": 8, "linesRem": 15}, {"files": 2, "project": "commons-math", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["SubLineTest.testIntersectionNotIntersecting:160 \u00bb NullPointer", "SubLineTest.testIntersectionParallel:151 \u00bb NullPointer"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\nindex a146cb6..aad7b65 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n@@ -111,6 +111,9 @@ public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin\n \n         // compute the intersection on infinite line\n         Vector3D v1D = line.intersection(subLine.line);\n+        if (v1D == null) {\n+            return null;\n+        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\nindex a9d621a..ea9e96a 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n@@ -115,6 +115,9 @@ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin\n \n         // compute the intersection on infinite line\n         Vector2D v2D = line1.intersection(line2);\n+        if (v2D == null) {\n+            return null;\n+        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n", "nb_test": 4990, "linesAdd": 6, "jira_id": "988", "singleLine": false, "nb_skipped": 4, "commit": "d270055e", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["JacobianMatricesTest.testWrongParameterName:113 null"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/ode/UnknownParameterException.java b/src/main/java/org/apache/commons/math4/ode/UnknownParameterException.java\nindex 75c6210..bbbaa4a 100644\n--- a/src/main/java/org/apache/commons/math4/ode/UnknownParameterException.java\n+++ b/src/main/java/org/apache/commons/math4/ode/UnknownParameterException.java\n@@ -38,7 +38,7 @@\n      * @param name parameter name.\n      */\n     public UnknownParameterException(final String name) {\n-        super(LocalizedFormats.UNKNOWN_PARAMETER);\n+        super(LocalizedFormats.UNKNOWN_PARAMETER, name);\n         this.name = name;\n     }\n \n", "nb_test": 5809, "linesAdd": 1, "jira_id": "1232", "singleLine": false, "nb_skipped": 3, "commit": "8f35fcb8", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["KendallsCorrelationTest.testMath1277:279 null"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/stat/correlation/KendallsCorrelation.java b/src/main/java/org/apache/commons/math4/stat/correlation/KendallsCorrelation.java\nindex 77b7d22..125083e 100644\n--- a/src/main/java/org/apache/commons/math4/stat/correlation/KendallsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math4/stat/correlation/KendallsCorrelation.java\n@@ -201,7 +201,7 @@ public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {\n         tiedXPairs += sum(consecutiveXTies - 1);\n         tiedXYPairs += sum(consecutiveXYTies - 1);\n \n-        int swaps = 0;\n+        long swaps = 0;\n         @SuppressWarnings(\"unchecked\")\n         Pair<Double, Double>[] pairsDestination = new Pair[n];\n         for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {\n", "nb_test": 5859, "linesAdd": 1, "jira_id": "1277", "singleLine": false, "nb_skipped": 3, "commit": "fb007815", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 2, "project": "commons-math", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["FractionTest.testDigitLimitConstructor:134 \u00bb FractionConversion illegal state:...", "BigFractionTest.testDigitLimitConstructor:159 \u00bb FractionConversion illegal sta..."], "patch": "diff --git a/src/main/java/org/apache/commons/math3/fraction/BigFraction.java b/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\nindex 5b0a6b4..4ca33eb 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\n@@ -301,6 +301,11 @@ private BigFraction(final double value, final double epsilon,\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n             if ((p2 > overflow) || (q2 > overflow)) {\n+                // in maxDenominator mode, if the last fraction was very close to the actual value\n+                // q2 may overflow in the next iteration; in this case return the last one.\n+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n+                    break;\n+                }\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \ndiff --git a/src/main/java/org/apache/commons/math3/fraction/Fraction.java b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\nindex 08d3b95..002dae9 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -83,6 +83,9 @@\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 3698073679419233275L;\n \n+    /** The default epsilon used for convergence. */\n+    private static final double DEFAULT_EPSILON = 1e-5;\n+\n     /** The denominator. */\n     private final int denominator;\n \n@@ -96,7 +99,7 @@\n      *         converge.\n      */\n     public Fraction(double value) throws FractionConversionException {\n-        this(value, 1.0e-5, 100);\n+        this(value, DEFAULT_EPSILON, 100);\n     }\n \n     /**\n@@ -182,8 +185,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             throw new FractionConversionException(value, a0, 1l);\n         }\n \n-        // check for (almost) integer arguments, which should not go\n-        // to iterations.\n+        // check for (almost) integer arguments, which should not go to iterations.\n         if (FastMath.abs(a0 - value) < epsilon) {\n             this.numerator = (int) a0;\n             this.denominator = 1;\n@@ -206,7 +208,13 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n+\n             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n+                // in maxDenominator mode, if the last fraction was very close to the actual value\n+                // q2 may overflow in the next iteration; in this case return the last one.\n+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n+                    break;\n+                }\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n", "nb_test": 5196, "linesAdd": 10, "jira_id": "996", "singleLine": false, "nb_skipped": 4, "commit": "86545dab", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testKeepInitIfBest(org.apache.commons.math3.optimization.univariate.BrentOptimizerTest): Best point not reported"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex cff5bfd..25f2f50 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -24,13 +24,19 @@\n import org.apache.commons.math3.optimization.GoalType;\n \n /**\n- * Implements Richard Brent's algorithm (from his book \"Algorithms for\n+ * For a function defined on some interval {@code (lo, hi)}, this class\n+ * finds an approximation {@code x} to the point at which the function\n+ * attains its minimum.\n+ * It implements Richard Brent's algorithm (from his book \"Algorithms for\n  * Minimization without Derivatives\", p. 79) for finding minima of real\n- * univariate functions. This implementation is an adaptation partly\n- * based on the Python code from SciPy (module \"optimize.py\" v0.5).\n- * If the function is defined on some interval {@code (lo, hi)}, then\n- * this method finds an approximation {@code x} to the point at which\n- * the function attains its minimum.\n+ * univariate functions.\n+ * <br/>\n+ * This code is an adaptation, partly based on the Python code from SciPy\n+ * (module \"optimize.py\" v0.5); the original algorithm is also modified\n+ * <ul>\n+ *  <li>to use an initial guess provided by the user,</li>\n+ *  <li>to ensure that the best point encountered is the one returned.</li>\n+ * </ul>\n  *\n  * @version $Id$\n  * @since 2.0\n@@ -141,6 +147,8 @@ protected UnivariatePointValuePair doOptimize() {\n         UnivariatePointValuePair previous = null;\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n+        // Best point encountered so far (which is the initial guess).\n+        UnivariatePointValuePair best = current;\n \n         int iter = 0;\n         while (true) {\n@@ -224,10 +232,15 @@ protected UnivariatePointValuePair doOptimize() {\n                 // User-defined convergence checker.\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+                best = best(best,\n+                            best(current,\n+                                 previous,\n+                                 isMinim),\n+                            isMinim);\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return best(current, previous, isMinim);\n+                        return best;\n                     }\n                 }\n \n@@ -264,7 +277,11 @@ protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return best(current, previous, isMinim);\n+                return best(best,\n+                            best(current,\n+                                 previous,\n+                                 isMinim),\n+                            isMinim);\n             }\n             ++iter;\n         }\n@@ -278,7 +295,8 @@ protected UnivariatePointValuePair doOptimize() {\n      * @param isMinim {@code true} if the selected point must be the one with\n      * the lowest value.\n      * @return the best point, or {@code null} if {@code a} and {@code b} are\n-     * both {@code null}.\n+     * both {@code null}. When {@code a} and {@code b} have the same function\n+     * value, {@code a} is returned.\n      */\n     private UnivariatePointValuePair best(UnivariatePointValuePair a,\n                                           UnivariatePointValuePair b,\n@@ -291,9 +309,9 @@ private UnivariatePointValuePair best(UnivariatePointValuePair a,\n         }\n \n         if (isMinim) {\n-            return a.getValue() < b.getValue() ? a : b;\n+            return a.getValue() <= b.getValue() ? a : b;\n         } else {\n-            return a.getValue() > b.getValue() ? a : b;\n+            return a.getValue() >= b.getValue() ? a : b;\n         }\n     }\n }\n", "nb_test": 4084, "linesAdd": 14, "jira_id": "855", "singleLine": false, "nb_skipped": 4, "commit": "ac597cc1", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSmallDistances(org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d..e09bbc3 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,7 +172,7 @@ public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n", "nb_test": 2354, "linesAdd": 1, "jira_id": "546", "singleLine": false, "nb_skipped": 1, "commit": "b6bf8f41", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testUnivariateDistribution(org.apache.commons.math3.distribution.MultivariateNormalDistributionTest): expected:<2.8901320810991885E-8> but was:<7.244486791901361E-8>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\nindex 1570681..fd18c28 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n@@ -180,7 +180,7 @@ public double density(final double[] vals) throws DimensionMismatchException {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n", "nb_test": 4528, "linesAdd": 1, "jira_id": "929", "singleLine": false, "nb_skipped": 4, "commit": "cedf0d27", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testIssue631(org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest): Expected exception: org.apache.commons.math.exception.TooManyEvaluationsException"], "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex b3a23a1..c781a90 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -183,14 +183,7 @@ protected final double doSolve() {\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n-                    if (x == x1) {\n-                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n-                                                          atol);\n-                        // Update formula cannot make any progress: Update the\n-                        // search interval.\n-                        x0 = 0.5 * (x0 + x1 - delta);\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+                    // Nothing.\n                     break;\n                 default:\n                     // Should never happen.\n", "nb_test": 2902, "linesAdd": 0, "jira_id": "631", "singleLine": false, "nb_skipped": 1, "commit": "ebc61de9", "nb_failure": 1, "linesRem": 6}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["EventStateTest.testEventsCloserThanThreshold:239 \u00bb NumberIsTooLarge endpoints ..."], "patch": "diff --git a/src/main/java/org/apache/commons/math4/ode/events/EventState.java b/src/main/java/org/apache/commons/math4/ode/events/EventState.java\nindex fe3039a..1908440 100644\n--- a/src/main/java/org/apache/commons/math4/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math4/ode/events/EventState.java\n@@ -296,7 +296,18 @@ public double value(final double t) throws LocalMaxCountExceededException {\n                             ta = forward ? ta + convergence : ta - convergence;\n                             ga = f.value(ta);\n                         } while ((g0Positive ^ (ga >= 0)) && (forward ^ (ta >= tb)));\n+\n+                        if (forward ^ (ta >= tb)) {\n+                            // we were able to skip this spurious root\n                             --i;\n+                        } else {\n+                            // we can't avoid this root before the end of the step,\n+                            // we have to handle it despite it is close to the former one\n+                            // maybe we have two very close roots\n+                            pendingEventTime = root;\n+                            pendingEvent = true;\n+                            return true;\n+                        }\n                     } else if (Double.isNaN(previousEventTime) ||\n                                (FastMath.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n", "nb_test": 5808, "linesAdd": 7, "jira_id": "1226", "singleLine": false, "nb_skipped": 3, "commit": "c44bfe00", "nb_failure": 0, "linesRem": 0}, {"files": 3, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDotProductMixedTypes(org.apache.commons.math3.linear.ArrayRealVectorTest): NaN * 0.0 expected:<NaN> but was:<0.0>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java b/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java\nindex ee67e03..ef02a75 100644\n--- a/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java\n@@ -455,16 +455,8 @@ public double dotProduct(RealVector v) {\n                 dot += data[i] * vData[i];\n             }\n             return dot;\n-        } else {\n-            checkVectorDimensions(v);\n-            double dot = 0;\n-            Iterator<Entry> it = v.sparseIterator();\n-            while (it.hasNext()) {\n-                final Entry e = it.next();\n-                dot += data[e.getIndex()] * e.getValue();\n-            }\n-            return dot;\n         }\n+        return super.dotProduct(v);\n     }\n \n     /** {@inheritDoc} */\ndiff --git a/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\nindex 49e22c2..b3e04be 100644\n--- a/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n@@ -304,38 +304,6 @@ public OpenMapRealVector copy() {\n         return new OpenMapRealVector(this);\n     }\n \n-    /**\n-     * Optimized method to compute the dot product with an OpenMapRealVector.\n-     * It iterates over the smallest of the two.\n-     *\n-     * @param v Cector to compute the dot product with.\n-     * @return the dot product of {@code this} and {@code v}.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if the dimensions do not match.\n-     */\n-    public double dotProduct(OpenMapRealVector v) {\n-        checkVectorDimensions(v.getDimension());\n-        boolean thisIsSmaller  = entries.size() < v.entries.size();\n-        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n-        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n-        double d = 0;\n-        while(iter.hasNext()) {\n-            iter.advance();\n-            d += iter.value() * larger.get(iter.key());\n-        }\n-        return d;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double dotProduct(RealVector v) {\n-        if(v instanceof OpenMapRealVector) {\n-            return dotProduct((OpenMapRealVector)v);\n-        } else {\n-            return super.dotProduct(v);\n-        }\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public OpenMapRealVector ebeDivide(RealVector v) {\ndiff --git a/src/main/java/org/apache/commons/math3/linear/RealVector.java b/src/main/java/org/apache/commons/math3/linear/RealVector.java\nindex 5dc8ddf..89611c3 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVector.java\n@@ -303,10 +303,9 @@ public RealVector mapAddToSelf(double d) {\n     public double dotProduct(RealVector v) {\n         checkVectorDimensions(v);\n         double d = 0;\n-        Iterator<Entry> it = sparseIterator();\n-        while (it.hasNext()) {\n-            final Entry e = it.next();\n-            d += e.getValue() * v.getEntry(e.getIndex());\n+        final int n = getDimension();\n+        for (int i = 0; i < n; i++) {\n+            d += getEntry(i) * v.getEntry(i);\n         }\n         return d;\n     }\n", "nb_test": 3646, "linesAdd": 4, "jira_id": "812", "singleLine": false, "nb_skipped": 7, "commit": "6eb46555", "nb_failure": 1, "linesRem": 35}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBadEndpoints(org.apache.commons.math.analysis.solvers.BrentSolverTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 4e95ed5..e0cb427 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -32,6 +32,11 @@\n  */\n public class BrentSolver extends UnivariateRealSolverImpl {\n \n+    /** Error message for non-bracketing interval. */\n+    private static final String NON_BRACKETING_MESSAGE =\n+        \"function values at endpoints do not have different signs.  \" +\n+        \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\";\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 7694577816772532779L;\n \n@@ -128,6 +133,11 @@ public double solve(final UnivariateRealFunction f,\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        if (yMin * yMax > 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+        }\n+\n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n@@ -176,9 +186,7 @@ public double solve(final UnivariateRealFunction f,\n             } else {\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"function values at endpoints do not have different signs.  \" +\n-                        \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n-                        min, max, yMin, yMax);\n+                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n", "nb_test": 2130, "linesAdd": 10, "jira_id": "343", "singleLine": false, "nb_skipped": 0, "commit": "f6dd42b4", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ClassicalRungeKuttaIntegratorTest.testTooLargeFirstStep:333 null"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaIntegrator.java\nindex 68bd8b0..5f7d5d8 100644\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -119,7 +119,19 @@ public void integrate(final ExpandableStatefulODE equations, final double t)\n \n     // set up integration control objects\n     stepStart = equations.getTime();\n-    stepSize  = forward ? step : -step;\n+    if (forward) {\n+        if (stepStart + step >= t) {\n+            stepSize = t - stepStart;\n+        } else {\n+            stepSize = step;\n+        }\n+    } else {\n+        if (stepStart - step <= t) {\n+            stepSize = t - stepStart;\n+        } else {\n+            stepSize = -step;\n+        }\n+    }\n     initIntegration(equations.getTime(), y0, t);\n \n     // main integration loop\n", "nb_test": 6153, "linesAdd": 13, "jira_id": "727", "singleLine": false, "nb_skipped": 3, "commit": "69273dca", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["testSeeding(org.apache.commons.math.random.ISAACTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/random/ISAACRandom.java b/src/main/java/org/apache/commons/math/random/ISAACRandom.java\nindex 3db6de1..011a704 100644\n--- a/src/main/java/org/apache/commons/math/random/ISAACRandom.java\n+++ b/src/main/java/org/apache/commons/math/random/ISAACRandom.java\n@@ -235,6 +235,7 @@ private void initState() {\n         }\n         isaac();\n         count = SIZE - 1;\n+        clear();\n     }\n \n     /** Shuffle array. */\n", "nb_test": 3197, "linesAdd": 1, "jira_id": "723", "singleLine": true, "nb_skipped": 1, "commit": "1352a70f", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SimplexSolverTest.testSolutionCallback:789 null"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optim/linear/LinearConstraintSet.java b/src/main/java/org/apache/commons/math3/optim/linear/LinearConstraintSet.java\nindex cf5279a..b2a1209 100644\n--- a/src/main/java/org/apache/commons/math3/optim/linear/LinearConstraintSet.java\n+++ b/src/main/java/org/apache/commons/math3/optim/linear/LinearConstraintSet.java\n@@ -16,10 +16,11 @@\n  */\n package org.apache.commons.math3.optim.linear;\n \n+import java.util.LinkedHashSet;\n import java.util.Set;\n-import java.util.HashSet;\n import java.util.Collection;\n import java.util.Collections;\n+\n import org.apache.commons.math3.optim.OptimizationData;\n \n /**\n@@ -30,8 +31,7 @@\n  */\n public class LinearConstraintSet implements OptimizationData {\n     /** Set of constraints. */\n-    private final Set<LinearConstraint> linearConstraints\n-        = new HashSet<LinearConstraint>();\n+    private final Set<LinearConstraint> linearConstraints = new LinkedHashSet<LinearConstraint>();\n \n     /**\n      * Creates a set containing the given constraints.\n", "nb_test": 5478, "linesAdd": 3, "jira_id": "1080", "singleLine": false, "nb_skipped": 5, "commit": "b285f170", "nb_failure": 1, "linesRem": 3}, {"files": 2, "project": "commons-math", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["KohonenUpdateActionTest.testUpdate:85 expected:<0.0> but was:<5.551115123125783E-17>", "MonotoneChainTest>ConvexHullGenerator2DAbstractTest.testCollinearPointsInAnyOrder:242 \u00bb Convergence", "AklToussaintHeuristicTest>ConvexHullGenerator2DAbstractTest.testCollinearPointsInAnyOrder:242 \u00bb Convergence"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java\nindex 1e0eec3..5d9734b 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java\n@@ -28,8 +28,8 @@\n import org.apache.commons.math3.geometry.hull.ConvexHull;\n import org.apache.commons.math3.geometry.partitioning.Region;\n import org.apache.commons.math3.geometry.partitioning.RegionFactory;\n-import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.Precision;\n \n /**\n  * This class represents a convex hull in an two-dimensional euclidean space.\n@@ -62,12 +62,14 @@\n     public ConvexHull2D(final Vector2D[] vertices, final double tolerance)\n         throws MathIllegalArgumentException {\n \n+        // assign tolerance as it will be used by the isConvex method\n+        this.tolerance = tolerance;\n+\n         if (!isConvex(vertices)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NOT_CONVEX);\n         }\n \n         this.vertices = vertices.clone();\n-        this.tolerance = tolerance;\n     }\n \n     /**\n@@ -80,7 +82,7 @@ private boolean isConvex(final Vector2D[] hullVertices) {\n             return true;\n         }\n \n-        double sign = 0.0;\n+        int sign = 0;\n         for (int i = 0; i < hullVertices.length; i++) {\n             final Vector2D p1 = hullVertices[i == 0 ? hullVertices.length - 1 : i - 1];\n             final Vector2D p2 = hullVertices[i];\n@@ -89,14 +91,14 @@ private boolean isConvex(final Vector2D[] hullVertices) {\n             final Vector2D d1 = p2.subtract(p1);\n             final Vector2D d2 = p3.subtract(p2);\n \n-            final double cross = FastMath.signum(MathArrays.linearCombination( d1.getX(), d2.getY(),\n-                                                                              -d1.getY(), d2.getX()));\n+            final double crossProduct = MathArrays.linearCombination(d1.getX(), d2.getY(), -d1.getY(), d2.getX());\n+            final int cmp = Precision.compareTo(crossProduct, 0.0, tolerance);\n             // in case of collinear points the cross product will be zero\n-            if (cross != 0.0) {\n-                if (sign != 0.0 && cross != sign) {\n+            if (cmp != 0.0) {\n+                if (sign != 0.0 && cmp != sign) {\n                     return false;\n                 }\n-                sign = cross;\n+                sign = cmp;\n             }\n         }\n \ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\nindex 6e56fc6..a811dda 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\n@@ -25,6 +25,7 @@\n import org.apache.commons.math3.geometry.euclidean.twod.Line;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Precision;\n \n /**\n  * Implements Andrew's monotone chain method to generate the convex hull of a finite set of\n@@ -80,9 +81,12 @@ public MonotoneChain(final boolean includeCollinearPoints, final double toleranc\n         // sort the points in increasing order on the x-axis\n         Collections.sort(pointsSortedByXAxis, new Comparator<Vector2D>() {\n             public int compare(final Vector2D o1, final Vector2D o2) {\n-                final int diff = (int) FastMath.signum(o1.getX() - o2.getX());\n+                final double tolerance = getTolerance();\n+                // need to take the tolerance value into account, otherwise collinear points\n+                // will not be handled correctly when building the upper/lower hull\n+                final int diff = Precision.compareTo(o1.getX(), o2.getX(), tolerance);\n                 if (diff == 0) {\n-                    return (int) FastMath.signum(o1.getY() - o2.getY());\n+                    return Precision.compareTo(o1.getY(), o2.getY(), tolerance);\n                 } else {\n                     return diff;\n                 }\n", "nb_test": 6081, "linesAdd": 13, "jira_id": "1148", "singleLine": false, "nb_skipped": 3, "commit": "4080feff", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["UniformIntegerDistributionTest.testPreconditionUpperBoundInclusive:111 \u00bb NumberIsTooLarge"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/UniformIntegerDistribution.java b/src/main/java/org/apache/commons/math3/distribution/UniformIntegerDistribution.java\nindex 3c26fdf..c3a55b0 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformIntegerDistribution.java\n@@ -59,7 +59,7 @@ public UniformIntegerDistribution(int lower, int upper)\n      * @param rng Random number generator.\n      * @param lower Lower bound (inclusive) of this distribution.\n      * @param upper Upper bound (inclusive) of this distribution.\n-     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     * @throws NumberIsTooLargeException if {@code lower > upper}.\n      * @since 3.1\n      */\n     public UniformIntegerDistribution(RandomGenerator rng,\n@@ -68,10 +68,10 @@ public UniformIntegerDistribution(RandomGenerator rng,\n         throws NumberIsTooLargeException {\n         super(rng);\n \n-        if (lower >= upper) {\n+        if (lower > upper) {\n             throw new NumberIsTooLargeException(\n                             LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                            lower, upper, false);\n+                            lower, upper, true);\n         }\n         this.lower = lower;\n         this.upper = upper;\n", "nb_test": 6076, "linesAdd": 2, "jira_id": "1141", "singleLine": false, "nb_skipped": 3, "commit": "2f2a2dda", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["LevenbergMarquardtOptimizerTest.testEvaluationCount:288", "Expected: is <1>", "but: was <2>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\nindex 5f0527c..864faae 100644\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\n@@ -506,7 +506,7 @@ public Optimum optimize(final LeastSquaresProblem problem) {\n \n                     // tests for convergence.\n                     if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {\n-                        return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n+                        return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\n                     }\n                 } else {\n                     // failed iteration, reset the previous values\n@@ -527,7 +527,7 @@ public Optimum optimize(final LeastSquaresProblem problem) {\n                      preRed <= costRelativeTolerance &&\n                      ratio <= 2.0) ||\n                     delta <= parRelativeTolerance * xNorm) {\n-                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n+                    return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\n                 }\n \n                 // tests for termination and stringent tolerances\n", "nb_test": 5905, "linesAdd": 2, "jira_id": "1106", "singleLine": false, "nb_skipped": 3, "commit": "e2dc384d", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testArrayEquals(org.apache.commons.math.util.MathUtilsTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 887dc66..ab0fe33 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -407,20 +407,14 @@ public static double cosh(double x) {\n \n     /**\n      * Returns true iff they are equal as defined by\n-     * {@link #equals(double,double,int) this method}.\n+     * {@link #equals(double,double,int) equals(x, y, 1)}.\n      *\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n-     * @deprecated This method considers that {@code NaN == NaN}. In release\n-     * 3.0, the semantics will change in order to comply with IEEE754 where it\n-     * is specified that {@code NaN != NaN}.\n-     * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link #equalsIncludingNaN(double,double)\n-     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return equals(x, y, 1);\n     }\n \n     /**\n@@ -524,12 +518,6 @@ public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n      * @param y second array\n      * @return true if the values are both null or have same dimension\n      * and equal elements.\n-     * @deprecated This method considers that {@code NaN == NaN}. In release\n-     * 3.0, the semantics will change in order to comply with IEEE754 where it\n-     * is specified that {@code NaN != NaN}.\n-     * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])\n-     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double[] x, double[] y) {\n         if ((x == null) || (y == null)) {\n@@ -1102,29 +1090,6 @@ public static long mulAndCheck(long a, long b) {\n     }\n \n     /**\n-     * Get the next machine representable number after a number, moving\n-     * in the direction of another number.\n-     * <p>\n-     * If <code>direction</code> is greater than or equal to<code>d</code>,\n-     * the smallest machine representable number strictly greater than\n-     * <code>d</code> is returned; otherwise the largest representable number\n-     * strictly less than <code>d</code> is returned.</p>\n-     * <p>\n-     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>\n-     *\n-     * @param d base number\n-     * @param direction (the only important thing is whether\n-     * direction is greater or smaller than d)\n-     * @return the next machine representable number in the specified direction\n-     * @since 1.2\n-     * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}\n-     */\n-    @Deprecated\n-    public static double nextAfter(double d, double direction) {\n-        return FastMath.nextAfter(d, direction);\n-    }\n-\n-    /**\n      * Scale a number by 2<sup>scaleFactor</sup>.\n      * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>\n      *\n@@ -1318,23 +1283,23 @@ private static double roundUnscaled(double unscaled, double sign,\n         switch (roundingMethod) {\n         case BigDecimal.ROUND_CEILING :\n             if (sign == -1) {\n-                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             } else {\n-                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_DOWN :\n-            unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             break;\n         case BigDecimal.ROUND_FLOOR :\n             if (sign == -1) {\n-                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             } else {\n-                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_HALF_DOWN : {\n-            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n+            unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n             double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction > 0.5) {\n                 unscaled = FastMath.ceil(unscaled);\n@@ -1361,7 +1326,7 @@ private static double roundUnscaled(double unscaled, double sign,\n             break;\n         }\n         case BigDecimal.ROUND_HALF_UP : {\n-            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n+            unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\n             double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction >= 0.5) {\n                 unscaled = FastMath.ceil(unscaled);\n@@ -1376,7 +1341,7 @@ private static double roundUnscaled(double unscaled, double sign,\n             }\n             break;\n         case BigDecimal.ROUND_UP :\n-            unscaled = FastMath.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n+            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n             break;\n         default :\n             throw MathRuntimeException.createIllegalArgumentException(\n@@ -1905,24 +1870,6 @@ public static void checkOrder(double[] val) {\n     }\n \n     /**\n-     * Checks that the given array is sorted.\n-     *\n-     * @param val Values\n-     * @param dir Order direction (-1 for decreasing, 1 for increasing)\n-     * @param strict Whether the order should be strict\n-     * @throws NonMonotonousSequenceException if the array is not sorted.\n-     * @deprecated as of 2.2 (please use the new {@link #checkOrder(double[],OrderDirection,boolean)\n-     * checkOrder} method). To be removed in 3.0.\n-     */\n-    public static void checkOrder(double[] val, int dir, boolean strict) {\n-        if (dir > 0) {\n-            checkOrder(val, OrderDirection.INCREASING, strict);\n-        } else {\n-            checkOrder(val, OrderDirection.DECREASING, strict);\n-        }\n-    }\n-\n-    /**\n      * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n      * Translation of the minpack enorm subroutine.\n      *\n", "nb_test": 2272, "linesAdd": 9, "jira_id": "370", "singleLine": false, "nb_skipped": 0, "commit": "495f04bc", "nb_failure": 1, "linesRem": 22}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCompareToMaxUlps(org.apache.commons.math.util.MathUtilsTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 06c87c6..e061a35 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -515,10 +515,6 @@ public static boolean equalsIncludingNaN(float x, float y, float eps) {\n      * @since 2.2\n      */\n     public static boolean equals(float x, float y, int maxUlps) {\n-        // Check that \"maxUlps\" is non-negative and small enough so that\n-        // NaN won't compare as equal to anything (except another NaN).\n-        assert maxUlps > 0 && maxUlps < NAN_GAP;\n-\n         int xInt = Float.floatToIntBits(x);\n         int yInt = Float.floatToIntBits(y);\n \n@@ -675,10 +671,6 @@ public static boolean equalsIncludingNaN(double x, double y, double eps) {\n      * point values between {@code x} and {@code y}.\n      */\n     public static boolean equals(double x, double y, int maxUlps) {\n-        // Check that \"maxUlps\" is non-negative and small enough so that\n-        // NaN won't compare as equal to anything (except another NaN).\n-        assert maxUlps > 0 && maxUlps < NAN_GAP;\n-\n         long xInt = Double.doubleToLongBits(x);\n         long yInt = Double.doubleToLongBits(y);\n \n", "nb_test": 2378, "linesAdd": 0, "jira_id": "559", "singleLine": false, "nb_skipped": 1, "commit": "fc409e88", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["KohonenTrainingTaskTest.testTravellerSalesmanSquareTourParallelSolver:125 expected:<1.0> but was:<0.8686291501015241>", "EmpiricalDistributionTest.testNoBinVariance:443 \u00bb NotStrictlyPositive standard..."], "patch": "diff --git a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\nindex 9458289..3b3a864 100644\n--- a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n+++ b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n@@ -799,7 +799,7 @@ private double cumBinP(int binIndex) {\n      * @return within-bin kernel parameterized by bStats\n      */\n     protected RealDistribution getKernel(SummaryStatistics bStats) {\n-        if (bStats.getN() == 1) {\n+        if (bStats.getN() == 1 || bStats.getVariance() == 0) {\n             return new ConstantRealDistribution(bStats.getMean());\n         } else {\n             return new NormalDistribution(randomData.getRandomGenerator(),\n", "nb_test": 5851, "linesAdd": 1, "jira_id": "1203", "singleLine": false, "nb_skipped": 3, "commit": "4aa4c6d3", "nb_failure": 1, "linesRem": 1}, {"files": 4, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSpecialValues(org.apache.commons.math.stat.descriptive.summary.SumTest)", "testIncrementation(org.apache.commons.math.stat.descriptive.summary.SumTest)", "testSerialization(org.apache.commons.math.stat.descriptive.summary.SumTest)", "testSpecialValues(org.apache.commons.math.stat.descriptive.summary.SumSqTest)", "testIncrementation(org.apache.commons.math.stat.descriptive.summary.SumSqTest)", "testSerialization(org.apache.commons.math.stat.descriptive.summary.SumSqTest)", "testSpecialValues(org.apache.commons.math.stat.descriptive.summary.ProductTest)", "testIncrementation(org.apache.commons.math.stat.descriptive.summary.ProductTest)", "testSerialization(org.apache.commons.math.stat.descriptive.summary.ProductTest)", "testSumSq(org.apache.commons.math.stat.StatUtilsTest)", "testProduct(org.apache.commons.math.stat.StatUtilsTest)", "testSumLog(org.apache.commons.math.stat.StatUtilsTest)", "testSpecialValues(org.apache.commons.math.stat.descriptive.summary.SumLogTest)", "testIncrementation(org.apache.commons.math.stat.descriptive.summary.SumLogTest)", "testSerialization(org.apache.commons.math.stat.descriptive.summary.SumLogTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\nindex da6e380..f9796b4 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n@@ -25,7 +25,8 @@\n /**\n  * Returns the product of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are\n+ * If there are no values in the dataset, then 1 is returned.\n+ *  If any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n  * <strong>Note that this implementation is not synchronized.</strong> If\n@@ -53,7 +54,7 @@\n      */\n     public Product() {\n         n = 0;\n-        value = Double.NaN;\n+        value = 1;\n     }\n \n     /**\n@@ -71,11 +72,7 @@ public Product(Product original) {\n      */\n     @Override\n     public void increment(final double d) {\n-        if (n == 0) {\n-            value = d;\n-        } else {\n         value *= d;\n-        }\n         n++;\n     }\n \n@@ -99,7 +96,7 @@ public long getN() {\n      */\n     @Override\n     public void clear() {\n-        value = Double.NaN;\n+        value = 1;\n         n = 0;\n     }\n \n@@ -113,14 +110,14 @@ public void clear() {\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the product of the values or Double.NaN if length = 0\n+     * @return the product of the values or 1 if length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double product = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             product = 1.0;\n             for (int i = begin; i < begin + length; i++) {\n                 product *= values[i];\n@@ -153,14 +150,14 @@ public double evaluate(final double[] values, final int begin, final int length)\n      * @param weights the weights array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the product of the values or Double.NaN if length = 0\n+     * @return the product of the values or 1 if length = 0\n      * @throws IllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n     public double evaluate(final double[] values, final double[] weights,\n                            final int begin, final int length) {\n         double product = Double.NaN;\n-        if (test(values, weights, begin, length)) {\n+        if (test(values, weights, begin, length, true)) {\n             product = 1.0;\n             for (int i = begin; i < begin + length; i++) {\n                 product *= FastMath.pow(values[i], weights[i]);\ndiff --git a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\nindex 2b0fd9b..3543575 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n@@ -24,7 +24,8 @@\n /**\n   * Returns the sum of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are\n+ * If there are no values in the dataset, then 0 is returned. \n+ * If any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n  * <strong>Note that this implementation is not synchronized.</strong> If\n@@ -52,7 +53,7 @@\n      */\n     public Sum() {\n         n = 0;\n-        value = Double.NaN;\n+        value = 0;\n     }\n \n     /**\n@@ -70,11 +71,7 @@ public Sum(Sum original) {\n      */\n     @Override\n     public void increment(final double d) {\n-        if (n == 0) {\n-            value = d;\n-        } else {\n         value += d;\n-        }\n         n++;\n     }\n \n@@ -98,13 +95,13 @@ public long getN() {\n      */\n     @Override\n     public void clear() {\n-        value = Double.NaN;\n+        value = 0;\n         n = 0;\n     }\n \n     /**\n      * The sum of the entries in the specified portion of\n-     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * the input array, or 0 if the designated subarray\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n@@ -112,14 +109,14 @@ public void clear() {\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the values or Double.NaN if length = 0\n+     * @return the sum of the values or 0 if length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double sum = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             sum = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sum += values[i];\n@@ -130,7 +127,7 @@ public double evaluate(final double[] values, final int begin, final int length)\n \n     /**\n      * The weighted sum of the entries in the specified portion of\n-     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * the input array, or 0 if the designated subarray\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if any of the following are true:\n@@ -151,14 +148,14 @@ public double evaluate(final double[] values, final int begin, final int length)\n      * @param weights the weights array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the values or Double.NaN if length = 0\n+     * @return the sum of the values or 0 if length = 0\n      * @throws IllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n     public double evaluate(final double[] values, final double[] weights,\n                            final int begin, final int length) {\n         double sum = Double.NaN;\n-        if (test(values, weights, begin, length)) {\n+        if (test(values, weights, begin, length, true)) {\n             sum = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sum += values[i] * weights[i];\ndiff --git a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\nindex b4280cc..24960e3 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n@@ -24,7 +24,7 @@\n /**\n  * Returns the sum of the natural logs for this collection of values.\n  * <p>\n- * Uses {@link java.lang.Math#log(double)} to compute the logs.  Therefore,\n+ * Uses {@link org.apache.commons.Math.util.FastMath#log(double)} to compute the logs.  Therefore,\n  * <ul>\n  * <li>If any of values are < 0, the result is <code>NaN.</code></li>\n  * <li>If all values are non-negative and less than\n@@ -87,11 +87,7 @@ public void increment(final double d) {\n      */\n     @Override\n     public double getResult() {\n-        if (n > 0) {\n         return value;\n-        } else {\n-            return Double.NaN;\n-        }\n     }\n \n     /**\n@@ -122,7 +118,7 @@ public void clear() {\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the natural logs of the values or Double.NaN if\n+     * @return the sum of the natural logs of the values or 0 if\n      * length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n@@ -130,7 +126,7 @@ public void clear() {\n     @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double sumLog = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             sumLog = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sumLog += FastMath.log(values[i]);\ndiff --git a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\nindex a1429f9..36a2168 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n@@ -23,7 +23,8 @@\n /**\n  * Returns the sum of the squares of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are\n+ * If there are no values in the dataset, then 0 is returned.\n+ * If any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n  * <strong>Note that this implementation is not synchronized.</strong> If\n@@ -51,7 +52,7 @@\n      */\n     public SumOfSquares() {\n         n = 0;\n-        value = Double.NaN;\n+        value = 0;\n     }\n \n     /**\n@@ -69,11 +70,7 @@ public SumOfSquares(SumOfSquares original) {\n      */\n     @Override\n     public void increment(final double d) {\n-        if (n == 0) {\n-            value = d * d;\n-        } else {\n         value += d * d;\n-        }\n         n++;\n     }\n \n@@ -97,7 +94,7 @@ public long getN() {\n      */\n     @Override\n     public void clear() {\n-        value = Double.NaN;\n+        value = 0;\n         n = 0;\n     }\n \n@@ -111,14 +108,14 @@ public void clear() {\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the squares of the values or Double.NaN if length = 0\n+     * @return the sum of the squares of the values or 0 if length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n     public double evaluate(final double[] values,final int begin, final int length) {\n         double sumSq = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             sumSq = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sumSq += values[i] * values[i];\n", "nb_test": 2272, "linesAdd": 12, "jira_id": "373", "singleLine": false, "nb_skipped": 0, "commit": "bfe4623c", "nb_failure": 15, "linesRem": 28}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testNextInt2(org.apache.commons.math.random.AbstractRandomGeneratorTest): Walked too far astray: 10000", "testNextLong2(org.apache.commons.math.random.AbstractRandomGeneratorTest): Walked too far astray: 1000"], "patch": "diff --git a/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java b/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\nindex 8576847..10c8f38 100644\n--- a/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n@@ -134,7 +134,7 @@ public void nextBytes(byte[] bytes) {\n      *  value from this random number generator's sequence\n      */\n     public int nextInt() {\n-        return (int) (nextDouble() * Integer.MAX_VALUE);\n+        return (int) ((2d * nextDouble() - 1d) * Integer.MAX_VALUE);\n     }\n \n     /**\n@@ -176,7 +176,7 @@ public int nextInt(int n) {\n      *value from this random number generator's sequence\n      */\n     public long nextLong() {\n-        return (long) (nextDouble() * Long.MAX_VALUE);\n+        return (long) ((2d * nextDouble() - 1d) * Long.MAX_VALUE);\n     }\n \n     /**\n", "nb_test": 2883, "linesAdd": 2, "jira_id": "640", "singleLine": false, "nb_skipped": 1, "commit": "98556fed", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testPerformClusterAnalysisDegenerate(org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 46368dc..ad77a56 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -1621,9 +1621,9 @@ public static double distance(double[] p1, double[] p2) {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n+      double sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+          final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n", "nb_test": 2091, "linesAdd": 2, "jira_id": "305", "singleLine": false, "nb_skipped": 0, "commit": "ef9b639a", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSampleWithZeroCovariance(org.apache.commons.math3.random.CorrelatedRandomVectorGeneratorTest): Array comparison failure(..)", "testFullRank(org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest)", "testMath789(org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest): expected:<0.0> but was:<0.0180652917341963>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex 38584d4..aba7b98 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -62,11 +62,10 @@\n     public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         throws NonPositiveDefiniteMatrixException {\n \n-        int order = matrix.getRowDimension();\n-        double[][] c = matrix.getData();\n-        double[][] b = new double[order][order];\n+        final int order = matrix.getRowDimension();\n+        final double[][] c = matrix.getData();\n+        final double[][] b = new double[order][order];\n \n-        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -76,21 +75,24 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            swap[r] = r;\n+            int swapR = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isi = index[swap[i]];\n-                if (c[ii][ii] > c[isi][isi]) {\n-                    swap[r] = i;\n+                int isr = index[swapR];\n+                if (c[ii][ii] > c[isr][isr]) {\n+                    swapR = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swap[r] != r) {\n-                int tmp = index[r];\n-                index[r] = index[swap[r]];\n-                index[swap[r]] = tmp;\n+            if (swapR != r) {\n+                final int tmpIndex    = index[r];\n+                index[r]              = index[swapR];\n+                index[swapR]          = tmpIndex;\n+                final double[] tmpRow = b[r];\n+                b[r]                  = b[swapR];\n+                b[swapR]              = tmpRow;\n             }\n \n             // check diagonal element\n@@ -118,17 +120,18 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n             } else {\n \n                 // transform the matrix\n-                double sqrt = FastMath.sqrt(c[ir][ir]);\n+                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n-                double inverse = 1 / sqrt;\n+                final double inverse  = 1 / sqrt;\n+                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n-                    int ii = index[i];\n-                    double e = inverse * c[ii][ir];\n+                    final int ii = index[i];\n+                    final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= e * e;\n+                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n                     for (int j = r + 1; j < i; ++j) {\n-                        int ij = index[j];\n-                        double f = c[ii][ij] - e * b[j][r];\n+                        final int ij = index[j];\n+                        final double f = c[ii][ij] - e * b[j][r];\n                         c[ii][ij] = f;\n                         c[ij][ii] = f;\n                     }\n", "nb_test": 4114, "linesAdd": 22, "jira_id": "789", "singleLine": false, "nb_skipped": 4, "commit": "621bbb8f", "nb_failure": 3, "linesRem": 19}, {"files": 1, "project": "commons-math", "nb_error": 28, "classification": {"singleLine": false}, "failing_tests": ["testLogBeta(org.apache.commons.math3.special.BetaTest): org.apache.commons.math3.special.Beta.logGammaSum(double, double)", "testRegularizedBetaNanPositivePositive(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testRegularizedBetaPositiveNanPositive(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testRegularizedBetaPositivePositiveNan(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testRegularizedBetaNegativePositivePositive(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testRegularizedBetaPositiveNegativePositive(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testRegularizedBetaPositivePositiveNegative(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testRegularizedBetaZeroPositivePositive(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testRegularizedBetaPositiveZeroPositive(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testRegularizedBetaPositivePositiveZero(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testRegularizedBetaPositivePositivePositive(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogBetaNanPositive(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogBetaPositiveNan(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogBetaNegativePositive(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogBetaPositiveNegative(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogBetaZeroPositive(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogBetaPositiveZero(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogBetaPositivePositive(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogGammaSum(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogGammaSumPrecondition1(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogGammaSumPrecondition2(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogGammaSumPrecondition3(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogGammaSumPrecondition4(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogGammaMinusLogGammaSum(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogGammaMinusLogGammaSumPrecondition1(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testLogGammaMinusLogGammaSumPrecondition2(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testSumDeltaMinusDeltaSum(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testSumDeltaMinusDeltaSumPrecondition1(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest", "testSumDeltaMinusDeltaSumPrecondition2(org.apache.commons.math3.special.BetaTest): Could not initialize class org.apache.commons.math3.special.BetaTest"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/special/Beta.java b/src/main/java/org/apache/commons/math3/special/Beta.java\nindex 2420791..6e15fa3 100644\n--- a/src/main/java/org/apache/commons/math3/special/Beta.java\n+++ b/src/main/java/org/apache/commons/math3/special/Beta.java\n@@ -16,12 +16,38 @@\n  */\n package org.apache.commons.math3.special;\n \n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.util.ContinuedFraction;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n+ * <p>\n  * This is a utility class that provides computation methods related to the\n  * Beta family of functions.\n+ * </p>\n+ * <p>\n+ * Implementation of {@link #logBeta(double, double)} is based on the\n+ * algorithms described in\n+ * <ul>\n+ * <li><a href=\"http://dx.doi.org/10.1145/22721.23109\">Didonato and Morris\n+ *     (1986)</a>, <em>Computation of the Incomplete Gamma Function Ratios\n+ *     and their Inverse</em>, TOMS 12(4), 377-393,</li>\n+ * <li><a href=\"http://dx.doi.org/10.1145/131766.131776\">Didonato and Morris\n+ *     (1992)</a>, <em>Algorithm 708: Significant Digit Computation of the\n+ *     Incomplete Beta Function Ratios</em>, TOMS 18(3), 360-373,</li>\n+ * </ul>\n+ * and implemented in the\n+ * <a href=\"http://www.dtic.mil/docs/citations/ADA476840\">NSWC Library of Mathematical Functions</a>,\n+ * available\n+ * <a href=\"http://www.ualberta.ca/CNS/RESEARCH/Software/NumericalNSWC/site.html\">here</a>.\n+ * This library is \"approved for public release\", and the\n+ * <a href=\"http://www.dtic.mil/dtic/pdf/announcements/CopyrightGuidance.pdf\">Copyright guidance</a>\n+ * indicates that unless otherwise stated in the code, all FORTRAN functions in\n+ * this library are license free. Since no such notice appears in the code these\n+ * functions can safely be ported to Commons-Math.\n+ * </p>\n+ *\n  *\n  * @version $Id$\n  */\n@@ -29,6 +55,47 @@\n     /** Maximum allowed numerical error. */\n     private static final double DEFAULT_EPSILON = 1E-14;\n \n+    /** The constant value of \u00bdlog 2\u03c0. */\n+    private static final double HALF_LOG_TWO_PI = .9189385332046727;\n+\n+    /**\n+     * <p>\n+     * The coefficients of the series expansion of the \u0394 function. This function\n+     * is defined as follows\n+     * </p>\n+     * <center>\u0394(x) = log \u0393(x) - (x - 0.5) log a + a - 0.5 log 2\u03c0,</center>\n+     * <p>\n+     * see equation (23) in Didonato and Morris (1992). The series expansion,\n+     * which applies for x \u2265 10, reads\n+     * </p>\n+     * <pre>\n+     *                 14\n+     *                ====\n+     *             1  \\                2 n\n+     *     \u0394(x) = ---  >    d  (10 / x)\n+     *             x  /      n\n+     *                ====\n+     *                n = 0\n+     * <pre>\n+     */\n+    private static final double[] DELTA = {\n+        .833333333333333333333333333333E-01,\n+        -.277777777777777777777777752282E-04,\n+        .793650793650793650791732130419E-07,\n+        -.595238095238095232389839236182E-09,\n+        .841750841750832853294451671990E-11,\n+        -.191752691751854612334149171243E-12,\n+        .641025640510325475730918472625E-14,\n+        -.295506514125338232839867823991E-15,\n+        .179643716359402238723287696452E-16,\n+        -.139228964661627791231203060395E-17,\n+        .133802855014020915603275339093E-18,\n+        -.154246009867966094273710216533E-19,\n+        .197701992980957427278370133333E-20,\n+        -.234065664793997056856992426667E-21,\n+        .171348014966398575409015466667E-22\n+    };\n+\n     /**\n      * Default constructor.  Prohibit instantiation.\n      */\n@@ -162,17 +229,6 @@ protected double getA(int n, double x) {\n     /**\n      * Returns the natural logarithm of the beta function B(a, b).\n      *\n-     * @param a Parameter {@code a}.\n-     * @param b Parameter {@code b}.\n-     * @return log(B(a, b)).\n-     */\n-    public static double logBeta(double a, double b) {\n-        return logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n-    }\n-\n-    /**\n-     * Returns the natural logarithm of the beta function B(a, b).\n-     *\n      * The implementation of this method is based on:\n      * <ul>\n      * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n@@ -181,27 +237,272 @@ public static double logBeta(double a, double b) {\n      *\n      * @param a Parameter {@code a}.\n      * @param b Parameter {@code b}.\n-     * @param epsilon When the absolute value of the nth item in the\n-     * series is less than epsilon the approximation ceases to calculate\n-     * further elements in the series.\n-     * @param maxIterations Maximum number of \"iterations\" to complete.\n+     * @param epsilon This parameter is ignored.\n+     * @param maxIterations This parameter is ignored.\n      * @return log(B(a, b)).\n+     * @deprecated as of version 3.1, this method is deprecated as the\n+     * computation of the beta function is no longer iterative. This method\n+     * internally calls {@link #logBeta(double, double)}.\n      */\n+    @Deprecated\n     public static double logBeta(double a, double b,\n                                  double epsilon,\n                                  int maxIterations) {\n-        double ret;\n \n-        if (Double.isNaN(a) ||\n-            Double.isNaN(b) ||\n-            a <= 0.0 ||\n-            b <= 0.0) {\n-            ret = Double.NaN;\n+        return logBeta(a, b);\n+    }\n+\n+\n+    /**\n+     * Returns the value of log \u0393(a + b) for 1 \u2264 a, b \u2264 2. Based on the\n+     * <em>NSWC Library of Mathematics Subroutines</em> double precision\n+     * implementation, {@code DGSMLN}.\n+     *\n+     * @param a First argument.\n+     * @param b Second argument.\n+     * @return the value of {@code log(Gamma(a + b))}.\n+     * @throws OutOfRangeException if {@code a} or {@code b} is lower than\n+     * {@code 1.0} or greater than {@code 2.0}.\n+     */\n+    private static double logGammaSum(final double a, final double b)\n+        throws OutOfRangeException {\n+\n+        if ((a < 1.0) || (a > 2.0)) {\n+            throw new OutOfRangeException(a, 1.0, 2.0);\n+        }\n+        if ((b < 1.0) || (b > 2.0)) {\n+            throw new OutOfRangeException(b, 1.0, 2.0);\n+        }\n+\n+        final double x = (a - 1.0) + (b - 1.0);\n+        if (x <= 0.5) {\n+            return Gamma.logGamma1p(1.0 + x);\n+        } else if (x <= 1.5) {\n+            return Gamma.logGamma1p(x) + FastMath.log1p(x);\n         } else {\n-            ret = Gamma.logGamma(a) + Gamma.logGamma(b) -\n-                Gamma.logGamma(a + b);\n+            return Gamma.logGamma1p(x - 1.0) + FastMath.log(x * (1.0 + x));\n+        }\n     }\n \n-        return ret;\n+    /**\n+     * Returns the value of log[\u0393(b) / \u0393(a + b)] for a \u2265 0 and b \u2265 10. Based on\n+     * the <em>NSWC Library of Mathematics Subroutines</em> double precision\n+     * implementation, {@code DLGDIV}.\n+     *\n+     * @param a First argument.\n+     * @param b Second argument.\n+     * @return the value of {@code log(Gamma(b) / Gamma(a + b))}.\n+     * @throws NumberIsTooSmallException if {@code a < 0.0} or {@code b < 10.0}.\n+     */\n+    private static double logGammaMinusLogGammaSum(final double a,\n+                                                   final double b)\n+        throws NumberIsTooSmallException {\n+\n+        if (a < 0.0) {\n+            throw new NumberIsTooSmallException(a, 0.0, true);\n+        }\n+        if (b < 10.0) {\n+            throw new NumberIsTooSmallException(b, 10.0, true);\n+        }\n+\n+        /*\n+         * p = a / (a + b), q = b / (a + b), d = a + b - 0.5\n+         */\n+        final double p;\n+        final double q;\n+        final double d;\n+        final double w;\n+        if (a <= b) {\n+            d = b + (a - 0.5);\n+            w = deltaMinusDeltaSum(a, b);\n+        } else {\n+            d = a + (b - 0.5);\n+            w = deltaMinusDeltaSum(b, a);\n+        }\n+\n+        final double u = d * FastMath.log1p(a / b);\n+        final double v = a * (FastMath.log(b) - 1.0);\n+\n+        return u <= v ? (w - u) - v : (w - v) - u;\n+    }\n+\n+    /**\n+     * Returns the value of \u0394(b) - \u0394(a + b), with 0 \u2264 a \u2264 b and b \u2265 10. Based\n+     * on equations (26), (27) and (28) in Didonato and Morris (1992).\n+     *\n+     * @param a First argument.\n+     * @param b Second argument.\n+     * @return the value of {@code Delta(b) - Delta(a + b)}\n+     * @throws OutOfRangeException if {@code a < 0} or {@code a > b}\n+     * @throws NumberIsTooSmallException if {@code b < 10}\n+     */\n+    private static double deltaMinusDeltaSum(final double a,\n+                                             final double b)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n+\n+        if ((a < 0) || (a > b)) {\n+            throw new OutOfRangeException(a, 0, b);\n+        }\n+        if (b < 10) {\n+            throw new NumberIsTooSmallException(b, 10, true);\n+        }\n+\n+        final double h = a / b;\n+        final double p = h / (1.0 + h);\n+        final double q = 1.0 / (1.0 + h);\n+        final double q2 = q * q;\n+        /*\n+         * s[i] = 1 + q + ... - q**(2 * i)\n+         */\n+        final double[] s = new double[DELTA.length];\n+        s[0] = 1.0;\n+        for (int i = 1; i < s.length; i++) {\n+            s[i] = 1.0 + (q + q2 * s[i - 1]);\n+        }\n+        /*\n+         * w = Delta(b) - Delta(a + b)\n+         */\n+        final double sqrtT = 10.0 / b;\n+        final double t = sqrtT * sqrtT;\n+        double w = DELTA[DELTA.length - 1] * s[s.length - 1];\n+        for (int i = DELTA.length - 2; i >= 0; i--) {\n+            w = t * w + DELTA[i] * s[i];\n+        }\n+        return w * p / b;\n+    }\n+\n+    /**\n+     * Returns the value of \u0394(p) + \u0394(q) - \u0394(p + q), with p, q \u2265 10. Based on\n+     * the <em>NSWC Library of Mathematics Subroutines</em> double precision\n+     * implementation, {@code DBCORR}.\n+     *\n+     * @param p First argument.\n+     * @param q Second argument.\n+     * @return the value of {@code Delta(p) + Delta(q) - Delta(p + q)}.\n+     * @throws NumberIsTooSmallException if {@code p < 10.0} or {@code q < 10.0}.\n+     */\n+    private static double sumDeltaMinusDeltaSum(final double p,\n+                                                final double q) {\n+\n+        if (p < 10.0) {\n+            throw new NumberIsTooSmallException(p, 10.0, true);\n+        }\n+        if (q < 10.0) {\n+            throw new NumberIsTooSmallException(q, 10.0, true);\n+        }\n+\n+        final double a = FastMath.min(p, q);\n+        final double b = FastMath.max(p, q);\n+        final double sqrtT = 10.0 / a;\n+        final double t = sqrtT * sqrtT;\n+        double z = DELTA[DELTA.length - 1];\n+        for (int i = DELTA.length - 2; i >= 0; i--) {\n+            z = t * z + DELTA[i];\n+        }\n+        return z / a + deltaMinusDeltaSum(a, b);\n+    }\n+\n+    /**\n+     * Returns the value of log B(p, q) for 0 \u2264 x \u2264 1 and p, q > 0. Based on the\n+     * <em>NSWC Library of Mathematics Subroutines</em> implementation,\n+     * {@code DBETLN}.\n+     *\n+     * @param p First argument.\n+     * @param q Second argument.\n+     * @return the value of {@code log(Beta(p, q))}, {@code NaN} if\n+     * {@code p <= 0} or {@code q <= 0}.\n+     */\n+    public static final double logBeta(final double p, final double q) {\n+\n+        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n+            return Double.NaN;\n+        }\n+\n+        final double a = FastMath.min(p, q);\n+        final double b = FastMath.max(p, q);\n+        if (a >= 10.0) {\n+            final double w = sumDeltaMinusDeltaSum(a, b);\n+            final double h = a / b;\n+            final double c = h / (1.0 + h);\n+            final double u = -(a - 0.5) * FastMath.log(c);\n+            final double v = b * FastMath.log1p(h);\n+            if (u <= v) {\n+                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;\n+            } else {\n+                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n+            }\n+        } else if (a > 2.0) {\n+            if (b > 1000.0) {\n+                final int n = (int) FastMath.floor(a - 1.0);\n+                double prod = 1.0;\n+                double ared = a;\n+                for (int i = 0; i < n; i++) {\n+                    ared -= 1.0;\n+                    prod *= ared / (1.0 + ared / b);\n+                }\n+                return (FastMath.log(prod) - n * FastMath.log(b)) +\n+                        (Gamma.logGamma(ared) +\n+                         logGammaMinusLogGammaSum(ared, b));\n+            } else {\n+                double prod1 = 1.0;\n+                double ared = a;\n+                while (ared > 2.0) {\n+                    ared -= 1.0;\n+                    final double h = ared / b;\n+                    prod1 *= h / (1.0 + h);\n+                }\n+                if (b < 10.0) {\n+                    double prod2 = 1.0;\n+                    double bred = b;\n+                    while (bred > 2.0) {\n+                        bred -= 1.0;\n+                        prod2 *= bred / (ared + bred);\n+                    }\n+                    return FastMath.log(prod1) +\n+                           FastMath.log(prod2) +\n+                           (Gamma.logGamma(ared) +\n+                           (Gamma.logGamma(bred) -\n+                            logGammaSum(ared, bred)));\n+                } else {\n+                    return FastMath.log(prod1) +\n+                           Gamma.logGamma(ared) +\n+                           logGammaMinusLogGammaSum(ared, b);\n+                }\n+            }\n+        } else if (a >= 1.0) {\n+            if (b > 2.0) {\n+                if (b < 10.0) {\n+                    double prod = 1.0;\n+                    double bred = b;\n+                    while (bred > 2.0) {\n+                        bred -= 1.0;\n+                        prod *= bred / (a + bred);\n+                    }\n+                    return FastMath.log(prod) +\n+                           (Gamma.logGamma(a) +\n+                            (Gamma.logGamma(bred) -\n+                             logGammaSum(a, bred)));\n+                } else {\n+                    return Gamma.logGamma(a) +\n+                           logGammaMinusLogGammaSum(a, b);\n+                }\n+            } else {\n+                return Gamma.logGamma(a) +\n+                       Gamma.logGamma(b) -\n+                       logGammaSum(a, b);\n+            }\n+        } else {\n+            if (b >= 10.0) {\n+                return Gamma.logGamma(a) +\n+                       logGammaMinusLogGammaSum(a, b);\n+            } else {\n+                // The following command is the original NSWC implementation.\n+                // return Gamma.logGamma(a) +\n+                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n+                // The following command turns out to be more accurate.\n+                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n+                                    Gamma.gamma(a + b));\n+            }\n+        }\n     }\n }\n", "nb_test": 4261, "linesAdd": 211, "jira_id": "738", "singleLine": false, "nb_skipped": 4, "commit": "f64b6a90", "nb_failure": 1, "linesRem": 13}, {"files": 4, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testIssue631(org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest): Unexpected exception, expected<org.apache.commons.math.exception.ConvergenceException> but was<org.apache.commons.math.exception.TooManyEvaluationsException>"], "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex c781a90..0347525 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -19,6 +19,7 @@\n \n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.MathInternalError;\n \n /**\n@@ -61,8 +62,8 @@\n     /**\n      * Construct a solver.\n      *\n-     * @param absoluteAccuracy absolute accuracy\n-     * @param method <em>Secant</em>-based root-finding method to use\n+     * @param absoluteAccuracy Absolute accuracy.\n+     * @param method <em>Secant</em>-based root-finding method to use.\n      */\n     protected BaseSecantSolver(final double absoluteAccuracy, final Method method) {\n         super(absoluteAccuracy);\n@@ -73,9 +74,9 @@ protected BaseSecantSolver(final double absoluteAccuracy, final Method method) {\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n-     * @param method <em>Secant</em>-based root-finding method to use\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     * @param method <em>Secant</em>-based root-finding method to use.\n      */\n     protected BaseSecantSolver(final double relativeAccuracy,\n                                final double absoluteAccuracy,\n@@ -183,7 +184,11 @@ protected final double doSolve() {\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n-                    // Nothing.\n+                    // Detect early that algorithm is stuck, instead of waiting\n+                    // for the maximum number of iterations to be exceeded.\n+                    if (x == x1) {\n+                        throw new ConvergenceException();\n+                    }\n                     break;\n                 default:\n                     // Should never happen.\ndiff --git a/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java\nindex ede0c27..47c340c 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java\n@@ -26,7 +26,9 @@\n  * <p>Like the <em>Regula Falsi</em> method, convergence is guaranteed by\n  * maintaining a bracketed solution. The <em>Illinois</em> method however,\n  * should converge much faster than the original <em>Regula Falsi</em>\n- * method.</p>\n+ * method. Furthermore, this implementation of the <em>Illinois</em> method\n+ * should not suffer from the same implementation issues as the <em>Regula\n+ * Falsi</em> method, which may fail to convergence in certain cases.</p>\n  *\n  * <p>The <em>Illinois</em> method assumes that the function is continuous,\n  * but not necessarily smooth.</p>\n@@ -49,7 +51,7 @@ public IllinoisSolver() {\n     /**\n      * Construct a solver.\n      *\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public IllinoisSolver(final double absoluteAccuracy) {\n         super(absoluteAccuracy, Method.ILLINOIS);\n@@ -58,8 +60,8 @@ public IllinoisSolver(final double absoluteAccuracy) {\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public IllinoisSolver(final double relativeAccuracy,\n                           final double absoluteAccuracy) {\n@@ -69,8 +71,8 @@ public IllinoisSolver(final double relativeAccuracy,\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      * @param functionValueAccuracy Maximum function value error.\n      */\n     public IllinoisSolver(final double relativeAccuracy,\ndiff --git a/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java\nindex 08fb0c7..457c958 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java\n@@ -24,10 +24,13 @@\n  *\n  * <p>Like the <em>Regula Falsi</em> method, convergence is guaranteed by\n  * maintaining a bracketed solution. The <em>Pegasus</em> method however,\n- * should converge much faster than the original <em>Regula Falsi</em> method.\n- * Furthermore, it should converge faster than the\n- * {@link IllinoisSolver <em>Illinois</em>} method, another\n- * <em>Regula Falsi</em>-based method.</p>\n+ * should converge much faster than the original <em>Regula Falsi</em>\n+ * method. Furthermore, this implementation of the <em>Pegasus</em> method\n+ * should not suffer from the same implementation issues as the <em>Regula\n+ * Falsi</em> method, which may fail to convergence in certain cases. Also,\n+ * the <em>Pegasus</em> method should converge faster than the\n+ * {@link IllinoisSolver <em>Illinois</em>} method, another <em>Regula\n+ * Falsi</em>-based method.</p>\n  *\n  * <p>The <em>Pegasus</em> method assumes that the function is continuous,\n  * but not necessarily smooth.</p>\n@@ -50,7 +53,7 @@ public PegasusSolver() {\n     /**\n      * Construct a solver.\n      *\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public PegasusSolver(final double absoluteAccuracy) {\n         super(absoluteAccuracy, Method.PEGASUS);\n@@ -59,8 +62,8 @@ public PegasusSolver(final double absoluteAccuracy) {\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public PegasusSolver(final double relativeAccuracy,\n                          final double absoluteAccuracy) {\n@@ -70,8 +73,8 @@ public PegasusSolver(final double relativeAccuracy,\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      * @param functionValueAccuracy Maximum function value error.\n      */\n     public PegasusSolver(final double relativeAccuracy,\ndiff --git a/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\nindex 89c50df..71224a0 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\n@@ -21,9 +20,27 @@\n /**\n  * Implements the <em>Regula Falsi</em> or <em>False position</em> method for\n  * root-finding (approximating a zero of a univariate real function). It is a\n- * modified {@link SecantSolver <em>Secant</em>} method. Unlike the\n- * <em>Secant</em> method, convergence is guaranteed by maintaining a\n- * bracketed solution.\n+ * modified {@link SecantSolver <em>Secant</em>} method.\n+ *\n+ * <p>The <em>Regula Falsi</em> method is included for completeness, for\n+ * testing purposes, for educational purposes, for comparison to other\n+ * algorithms, etc. It is however <strong>not</strong> intended to be used\n+ * for actual problems, as one of the bounds often remains fixed, resulting\n+ * in very slow convergence. Instead, one of the well-known modified\n+ * <em>Regula Falsi</em> algorithms can be used ({@link IllinoisSolver\n+ * <em>Illinois</em>} or {@link PegasusSolver <em>Pegasus</em>}). These two\n+ * algorithms solve the fundamental issues of the original <em>Regula\n+ * Falsi</em> algorithm, and greatly out-performs it for most, if not all,\n+ * (practical) functions.\n+ *\n+ * <p>Unlike the <em>Secant</em> method, the <em>Regula Falsi</em> guarantees\n+ * convergence, by maintaining a bracketed solution. Note however, that due to\n+ * the finite/limited precision of Java's {@link Double double} type, which is\n+ * used in this implementation, the algorithm may get stuck in a situation\n+ * where it no longer makes any progress. Such cases are detected and result\n+ * in a {@code ConvergenceException} exception being thrown. In other words,\n+ * the algorithm theoretically guarantees convergence, but the implementation\n+ * does not.</p>\n  *\n  * <p>The <em>Regula Falsi</em> method assumes that the function is continuous,\n  * but not necessarily smooth.</p>\n@@ -46,7 +63,7 @@ public RegulaFalsiSolver() {\n     /**\n      * Construct a solver.\n      *\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public RegulaFalsiSolver(final double absoluteAccuracy) {\n         super(absoluteAccuracy, Method.REGULA_FALSI);\n@@ -55,8 +72,8 @@ public RegulaFalsiSolver(final double absoluteAccuracy) {\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public RegulaFalsiSolver(final double relativeAccuracy,\n                              final double absoluteAccuracy) {\n@@ -66,8 +83,8 @@ public RegulaFalsiSolver(final double relativeAccuracy,\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      * @param functionValueAccuracy Maximum function value error.\n      */\n     public RegulaFalsiSolver(final double relativeAccuracy,\n", "nb_test": 2947, "linesAdd": 4, "jira_id": "631", "singleLine": false, "nb_skipped": 1, "commit": "c0b49542", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ComplexTest.testReciprocalZero:334 expected:<(NaN, NaN)> but was:<(Infinity, Infinity)>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/complex/Complex.java b/src/main/java/org/apache/commons/math3/complex/Complex.java\nindex 22b23f2..ac8185b 100644\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -302,7 +302,7 @@ public Complex reciprocal() {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return INF;\n         }\n \n         if (isInfinite) {\n", "nb_test": 4919, "linesAdd": 1, "jira_id": "934", "singleLine": false, "nb_skipped": 4, "commit": "724795b5", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testIssue780(org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest): org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\nindex 6ba72be..add24ac 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -132,7 +132,9 @@ protected void computeGeometricalProperties() {\n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n-            if ((Boolean) getTree(false).getAttribute()) {\n+            final BSPTree<Euclidean2D> tree = getTree(false);\n+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n+                // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n", "nb_test": 3542, "linesAdd": 2, "jira_id": "780", "singleLine": false, "nb_skipped": 1, "commit": "dd6cefb0", "nb_failure": 0, "linesRem": 1}, {"files": 2, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testMean(org.apache.commons.math.distribution.PoissonDistributionTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\nindex 6aca509..d20eb53 100644\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n@@ -41,18 +40,6 @@\n     double getMean();\n \n     /**\n-     * Set the mean for the distribution.\n-     * The parameter value must be positive; otherwise an\n-     * <code>IllegalArgument</code> is thrown.\n-     *\n-     * @param p the mean\n-     * @throws IllegalArgumentException if p &le; 0\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setMean(double p);\n-\n-    /**\n      * Calculates the Poisson distribution function using a normal approximation.\n      *\n      * @param x the upper bound, inclusive\ndiff --git a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\nindex 64f792b..0a81233 100644\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n@@ -19,7 +19,7 @@\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.util.MathUtils;\n@@ -77,7 +77,7 @@\n      * @throws IllegalArgumentException if p &le; 0\n      */\n     public PoissonDistributionImpl(double p) {\n-        this(p, new NormalDistributionImpl());\n+        this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);\n     }\n \n     /**\n@@ -90,7 +90,11 @@ public PoissonDistributionImpl(double p) {\n      * @since 2.1\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n-        setMean(p);\n+        if (p <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n+        }\n+        mean = p;\n+        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n         this.epsilon = epsilon;\n         this.maxIterations = maxIterations;\n     }\n@@ -103,8 +107,7 @@ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n      * @since 2.1\n      */\n     public PoissonDistributionImpl(double p, double epsilon) {\n-        setMean(p);\n-        this.epsilon = epsilon;\n+        this(p, epsilon, DEFAULT_MAX_ITERATIONS);\n     }\n \n     /**\n@@ -115,26 +118,7 @@ public PoissonDistributionImpl(double p, double epsilon) {\n      * @since 2.1\n      */\n     public PoissonDistributionImpl(double p, int maxIterations) {\n-        setMean(p);\n-        this.maxIterations = maxIterations;\n-    }\n-\n-\n-    /**\n-     * Create a new Poisson distribution with the given the mean. The mean value\n-     * must be positive; otherwise an <code>IllegalArgument</code> is thrown.\n-     *\n-     * @param p the Poisson mean\n-     * @param z a normal distribution used to compute normal approximations.\n-     * @throws IllegalArgumentException if p &le; 0\n-     * @since 1.2\n-     * @deprecated as of 2.1 (to avoid possibly inconsistent state, the\n-     * \"NormalDistribution\" will be instantiated internally)\n-     */\n-    @Deprecated\n-    public PoissonDistributionImpl(double p, NormalDistribution z) {\n-        super();\n-        setNormalAndMeanInternal(z, p);\n+        this(p, DEFAULT_EPSILON, maxIterations);\n     }\n \n     /**\n@@ -147,38 +131,6 @@ public double getMean() {\n     }\n \n     /**\n-     * Set the Poisson mean for the distribution. The mean value must be\n-     * positive; otherwise an <code>IllegalArgument</code> is thrown.\n-     *\n-     * @param p the Poisson mean value\n-     * @throws IllegalArgumentException if p &le; 0\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setMean(double p) {\n-        setNormalAndMeanInternal(normal, p);\n-    }\n-    /**\n-     * Set the Poisson mean for the distribution. The mean value must be\n-     * positive; otherwise an <code>IllegalArgument</code> is thrown.\n-     *\n-     * @param z the new distribution\n-     * @param p the Poisson mean value\n-     * @throws IllegalArgumentException if p &le; 0\n-     */\n-    private void setNormalAndMeanInternal(NormalDistribution z,\n-                                          double p) {\n-        if (p <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n-        }\n-        mean = p;\n-        normal = z;\n-        normal.setMean(p);\n-        normal.setStandardDeviation(FastMath.sqrt(p));\n-    }\n-\n-    /**\n      * The probability mass function P(X = x) for a Poisson distribution.\n      *\n      * @param x the value at which the probability density function is\n@@ -286,18 +238,4 @@ protected int getDomainLowerBound(double p) {\n     protected int getDomainUpperBound(double p) {\n         return Integer.MAX_VALUE;\n     }\n-\n-    /**\n-     * Modify the normal distribution used to compute normal approximations. The\n-     * caller is responsible for insuring the normal distribution has the proper\n-     * parameter settings.\n-     *\n-     * @param value the new distribution\n-     * @since 1.2\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setNormal(NormalDistribution value) {\n-        setNormalAndMeanInternal(value, mean);\n-    }\n }\n", "nb_test": 2357, "linesAdd": 9, "jira_id": "349", "singleLine": false, "nb_skipped": 1, "commit": "4cc9a49d", "nb_failure": 0, "linesRem": 38}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRank(org.apache.commons.math.linear.SingularValueDecompositionImplTest): expected:<2> but was:<3>", "testStability1(org.apache.commons.math.linear.SingularValueDecompositionImplTest): Exception whilst constructing SVD"], "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\nindex 5e27413..c2c655e 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n@@ -35,23 +34,38 @@\n  * @since 2.0\n  */\n public class SingularValueDecompositionImpl implements SingularValueDecomposition {\n-    /** Number of rows of the initial matrix. */\n+\n+    /** Relative threshold for small singular values. */\n+    private static final double EPS = 0x1.0p-52;\n+\n+    /** Absolute threshold for small singular values. */\n+    private static final double TINY = 0x1.0p-966;\n+\n+    /** Computed singular values. */\n+    private double[] singularValues;\n+\n+    /** Row dimension. */\n     private int m;\n-    /** Number of columns of the initial matrix. */\n+\n+    /** Column dimension. */\n     private int n;\n-    /** Eigen decomposition of the tridiagonal matrix. */\n-    private EigenDecomposition eigenDecomposition;\n-    /** Singular values. */\n-    private double[] singularValues;\n-    /** Cached value of U. */\n+\n+    /** Indicator for transposed matrix. */\n+    private boolean transposed;\n+\n+    /** Cached value of U matrix. */\n     private RealMatrix cachedU;\n-    /** Cached value of U<sup>T</sup>. */\n+\n+    /** Cached value of transposed U matrix. */\n     private RealMatrix cachedUt;\n-    /** Cached value of S. */\n+\n+    /** Cached value of S (diagonal) matrix. */\n     private RealMatrix cachedS;\n-    /** Cached value of V. */\n+\n+    /** Cached value of V matrix. */\n     private RealMatrix cachedV;\n-    /** Cached value of V<sup>T</sup>. */\n+\n+    /** Cached value of transposed V matrix. */\n     private RealMatrix cachedVt;\n \n     /**\n@@ -60,80 +74,397 @@\n      * @param matrix Matrix to decompose.\n      */\n     public SingularValueDecompositionImpl(final RealMatrix matrix) {\n+\n+        // Derived from LINPACK code.\n+        // Initialize.\n+        double[][] A;\n+        m = matrix.getRowDimension();\n+        n = matrix.getColumnDimension();\n+        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n+            transposed = true;\n+            A = matrix.transpose().getData();\n+            m = matrix.getColumnDimension();\n+            n = matrix.getRowDimension();\n+        } else {\n+            transposed = false;\n+            A = matrix.getData();\n             m = matrix.getRowDimension();\n             n = matrix.getColumnDimension();\n-\n-        cachedU = null;\n-        cachedS = null;\n-        cachedV = null;\n-        cachedVt = null;\n-\n-        double[][] localcopy = matrix.getData();\n-        double[][] matATA = new double[n][n];\n-        //\n-        // create A^T*A\n-        //\n-        for (int i = 0; i < n; i++) {\n-            for (int j = i; j < n; j++) {\n-                matATA[i][j] = 0.0;\n-                for (int k = 0; k < m; k++) {\n-                    matATA[i][j] += localcopy[k][i] * localcopy[k][j];\n         }\n-                matATA[j][i] = matATA[i][j];\n+        int nu = FastMath.min(m, n);\n+        singularValues = new double[FastMath.min(m + 1, n)];\n+        double[][] U = new double[m][nu];\n+        double[][] V = new double[n][n];\n+        double[] e = new double[n];\n+        double[] work = new double[m];\n+        boolean wantu = true;\n+        boolean wantv = true;\n+        // Reduce A to bidiagonal form, storing the diagonal elements\n+        // in s and the super-diagonal elements in e.\n+        int nct = FastMath.min(m - 1, n);\n+        int nrt = FastMath.max(0, FastMath.min(n - 2, m));\n+        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n+            if (k < nct) {\n+                // Compute the transformation for the k-th column and\n+                // place the k-th diagonal in s[k].\n+                // Compute 2-norm of k-th column without under/overflow.\n+                singularValues[k] = 0;\n+                for (int i = k; i < m; i++) {\n+                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                 }\n+                if (singularValues[k] != 0.0) {\n+                    if (A[k][k] < 0.0) {\n+                        singularValues[k] = -singularValues[k];\n                     }\n-\n-        double[][] matAAT = new double[m][m];\n-        //\n-        // create A*A^T\n-        //\n+                    for (int i = k; i < m; i++) {\n+                        A[i][k] /= singularValues[k];\n+                    }\n+                    A[k][k] += 1.0;\n+                }\n+                singularValues[k] = -singularValues[k];\n+            }\n+            for (int j = k + 1; j < n; j++) {\n+                if ((k < nct) & (singularValues[k] != 0.0)) {\n+                    // Apply the transformation.\n+                    double t = 0;\n+                    for (int i = k; i < m; i++) {\n+                        t += A[i][k] * A[i][j];\n+                    }\n+                    t = -t / A[k][k];\n+                    for (int i = k; i < m; i++) {\n+                        A[i][j] += t * A[i][k];\n+                    }\n+                }\n+                // Place the k-th row of A into e for the\n+                // subsequent calculation of the row transformation.\n+                e[j] = A[k][j];\n+            }\n+            if (wantu & (k < nct)) {\n+                // Place the transformation in U for subsequent back\n+                // multiplication.\n+                for (int i = k; i < m; i++) {\n+                    U[i][k] = A[i][k];\n+                }\n+            }\n+            if (k < nrt) {\n+                // Compute the k-th row transformation and place the\n+                // k-th super-diagonal in e[k].\n+                // Compute 2-norm without under/overflow.\n+                e[k] = 0;\n+                for (int i = k + 1; i < n; i++) {\n+                    e[k] = FastMath.hypot(e[k], e[i]);\n+                }\n+                if (e[k] != 0.0) {\n+                    if (e[k + 1] < 0.0) {\n+                        e[k] = -e[k];\n+                    }\n+                    for (int i = k + 1; i < n; i++) {\n+                        e[i] /= e[k];\n+                    }\n+                    e[k + 1] += 1.0;\n+                }\n+                e[k] = -e[k];\n+                if ((k + 1 < m) & (e[k] != 0.0)) {\n+                    // Apply the transformation.\n+                    for (int i = k + 1; i < m; i++) {\n+                        work[i] = 0.0;\n+                    }\n+                    for (int j = k + 1; j < n; j++) {\n+                        for (int i = k + 1; i < m; i++) {\n+                            work[i] += e[j] * A[i][j];\n+                        }\n+                    }\n+                    for (int j = k + 1; j < n; j++) {\n+                        double t = -e[j] / e[k + 1];\n+                        for (int i = k + 1; i < m; i++) {\n+                            A[i][j] += t * work[i];\n+                        }\n+                    }\n+                }\n+                if (wantv) {\n+                    // Place the transformation in V for subsequent\n+                    // back multiplication.\n+                    for (int i = k + 1; i < n; i++) {\n+                        V[i][k] = e[i];\n+                    }\n+                }\n+            }\n+        }\n+        // Set up the final bidiagonal matrix or order p.\n+        int p = FastMath.min(n, m + 1);\n+        if (nct < n) {\n+            singularValues[nct] = A[nct][nct];\n+        }\n+        if (m < p) {\n+            singularValues[p - 1] = 0.0;\n+        }\n+        if (nrt + 1 < p) {\n+            e[nrt] = A[nrt][p - 1];\n+        }\n+        e[p - 1] = 0.0;\n+        // If required, generate U.\n+        if (wantu) {\n+            for (int j = nct; j < nu; j++) {\n                 for (int i = 0; i < m; i++) {\n-            for (int j = i; j < m; j++) {\n-                matAAT[i][j] = 0.0;\n-                for (int k = 0; k < n; k++) {\n-                    matAAT[i][j] += localcopy[i][k] * localcopy[j][k];\n-                }\n-                 matAAT[j][i] = matAAT[i][j];\n-            }\n-        }\n-        int p;\n-        if (m >= n) {\n-            p = n;\n-            // compute eigen decomposition of A^T*A\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matATA), 1);\n-            singularValues = eigenDecomposition.getRealEigenvalues();\n-            cachedV = eigenDecomposition.getV();\n-            // compute eigen decomposition of A*A^T\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matAAT), 1);\n-            cachedU = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n+                    U[i][j] = 0.0;\n+                }\n+                U[j][j] = 1.0;\n+            }\n+            for (int k = nct - 1; k >= 0; k--) {\n+                if (singularValues[k] != 0.0) {\n+                    for (int j = k + 1; j < nu; j++) {\n+                        double t = 0;\n+                        for (int i = k; i < m; i++) {\n+                            t += U[i][k] * U[i][j];\n+                        }\n+                        t = -t / U[k][k];\n+                        for (int i = k; i < m; i++) {\n+                            U[i][j] += t * U[i][k];\n+                        }\n+                    }\n+                    for (int i = k; i < m; i++) {\n+                        U[i][k] = -U[i][k];\n+                    }\n+                    U[k][k] = 1.0 + U[k][k];\n+                    for (int i = 0; i < k - 1; i++) {\n+                        U[i][k] = 0.0;\n+                    }\n                 } else {\n-            p = m;\n-            // compute eigen decomposition of A*A^T\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matAAT), 1);\n-            singularValues = eigenDecomposition.getRealEigenvalues();\n-            cachedU = eigenDecomposition.getV();\n-\n-            // compute eigen decomposition of A^T*A\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matATA), 1);\n-            cachedV = eigenDecomposition.getV().getSubMatrix(0, n - 1 , 0, p - 1);\n+                    for (int i = 0; i < m; i++) {\n+                        U[i][k] = 0.0;\n+                    }\n+                    U[k][k] = 1.0;\n                 }\n-        for (int i = 0; i < p; i++) {\n-            singularValues[i] = FastMath.sqrt(FastMath.abs(singularValues[i]));\n             }\n-        // Up to this point, U and V are computed independently of each other.\n-        // There still a sign indetermination of each column of, say, U.\n-        // The sign is set such that A.V_i=sigma_i.U_i (i<=p)\n-        // The right sign corresponds to a positive dot product of A.V_i and U_i\n-        for (int i = 0; i < p; i++) {\n-            RealVector tmp = cachedU.getColumnVector(i);\n-            double product=matrix.operate(cachedV.getColumnVector(i)).dotProduct(tmp);\n-            if (product < 0) {\n-                cachedU.setColumnVector(i, tmp.mapMultiply(-1));\n         }\n+        // If required, generate V.\n+        if (wantv) {\n+            for (int k = n - 1; k >= 0; k--) {\n+                if ((k < nrt) & (e[k] != 0.0)) {\n+                    for (int j = k + 1; j < nu; j++) {\n+                        double t = 0;\n+                        for (int i = k + 1; i < n; i++) {\n+                            t += V[i][k] * V[i][j];\n+                        }\n+                        t = -t / V[k + 1][k];\n+                        for (int i = k + 1; i < n; i++) {\n+                            V[i][j] += t * V[i][k];\n+                        }\n+                    }\n+                }\n+                for (int i = 0; i < n; i++) {\n+                    V[i][k] = 0.0;\n+                }\n+                V[k][k] = 1.0;\n+            }\n+        }\n+        // Main iteration loop for the singular values.\n+        int pp = p - 1;\n+        int iter = 0;\n+        while (p > 0) {\n+            int k, kase;\n+            // Here is where a test for too many iterations would go.\n+            // This section of the program inspects for\n+            // negligible elements in the s and e arrays.  On\n+            // completion the variables kase and k are set as follows.\n+            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n+            // kase = 2     if s(k) is negligible and k<p\n+            // kase = 3     if e[k-1] is negligible, k<p, and\n+            //              s(k), ..., s(p) are not negligible (qr step).\n+            // kase = 4     if e(p-1) is negligible (convergence).\n+            for (k = p - 2; k >= -1; k--) {\n+                if (k == -1) {\n+                    break;\n+                }\n+                final double threshold =\n+                        TINY + EPS * (FastMath.abs(singularValues[k]) + FastMath.abs(singularValues[k + 1]));\n+                if (FastMath.abs(e[k]) <= threshold) {\n+                    e[k] = 0.0;\n+                    break;\n+                }\n+            }\n+            if (k == p - 2) {\n+                kase = 4;\n+            } else {\n+                int ks;\n+                for (ks = p - 1; ks >= k; ks--) {\n+                    if (ks == k) {\n+                        break;\n+                    }\n+                    double t = (ks != p ? FastMath.abs(e[ks]) : 0.0) +\n+                               (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0.0);\n+                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n+                        singularValues[ks] = 0.0;\n+                        break;\n+                    }\n+                }\n+                if (ks == k) {\n+                    kase = 3;\n+                } else if (ks == p - 1) {\n+                    kase = 1;\n+                } else {\n+                    kase = 2;\n+                    k = ks;\n+                }\n+            }\n+            k++;\n+            // Perform the task indicated by kase.\n+            switch (kase) {\n+                // Deflate negligible s(p).\n+                case 1: {\n+                    double f = e[p - 2];\n+                    e[p - 2] = 0.0;\n+                    for (int j = p - 2; j >= k; j--) {\n+                        double t = FastMath.hypot(singularValues[j], f);\n+                        double cs = singularValues[j] / t;\n+                        double sn = f / t;\n+                        singularValues[j] = t;\n+                        if (j != k) {\n+                            f = -sn * e[j - 1];\n+                            e[j - 1] = cs * e[j - 1];\n+                        }\n+                        if (wantv) {\n+                            for (int i = 0; i < n; i++) {\n+                                t = cs * V[i][j] + sn * V[i][p - 1];\n+                                V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n+                                V[i][j] = t;\n+                            }\n+                        }\n+                    }\n+                }\n+                break;\n+                // Split at negligible s(k).\n+                case 2: {\n+                    double f = e[k - 1];\n+                    e[k - 1] = 0.0;\n+                    for (int j = k; j < p; j++) {\n+                        double t = FastMath.hypot(singularValues[j], f);\n+                        double cs = singularValues[j] / t;\n+                        double sn = f / t;\n+                        singularValues[j] = t;\n+                        f = -sn * e[j];\n+                        e[j] = cs * e[j];\n+                        if (wantu) {\n+                            for (int i = 0; i < m; i++) {\n+                                t = cs * U[i][j] + sn * U[i][k - 1];\n+                                U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n+                                U[i][j] = t;\n+                            }\n+                        }\n+                    }\n+                }\n+                break;\n+                // Perform one qr step.\n+                case 3: {\n+                    // Calculate the shift.\n+                    double scale = FastMath.max(FastMath.max(FastMath.max(FastMath.max(\n+                            FastMath.abs(singularValues[p - 1]), FastMath.abs(singularValues[p - 2])), FastMath.abs(e[p - 2])),\n+                            FastMath.abs(singularValues[k])), FastMath.abs(e[k]));\n+                    double sp = singularValues[p - 1] / scale;\n+                    double spm1 = singularValues[p - 2] / scale;\n+                    double epm1 = e[p - 2] / scale;\n+                    double sk = singularValues[k] / scale;\n+                    double ek = e[k] / scale;\n+                    double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n+                    double c = (sp * epm1) * (sp * epm1);\n+                    double shift = 0.0;\n+                    if ((b != 0.0) | (c != 0.0)) {\n+                        shift = FastMath.sqrt(b * b + c);\n+                        if (b < 0.0) {\n+                            shift = -shift;\n+                        }\n+                        shift = c / (b + shift);\n+                    }\n+                    double f = (sk + sp) * (sk - sp) + shift;\n+                    double g = sk * ek;\n+                    // Chase zeros.\n+                    for (int j = k; j < p - 1; j++) {\n+                        double t = FastMath.hypot(f, g);\n+                        double cs = f / t;\n+                        double sn = g / t;\n+                        if (j != k) {\n+                            e[j - 1] = t;\n+                        }\n+                        f = cs * singularValues[j] + sn * e[j];\n+                        e[j] = cs * e[j] - sn * singularValues[j];\n+                        g = sn * singularValues[j + 1];\n+                        singularValues[j + 1] = cs * singularValues[j + 1];\n+                        if (wantv) {\n+                            for (int i = 0; i < n; i++) {\n+                                t = cs * V[i][j] + sn * V[i][j + 1];\n+                                V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n+                                V[i][j] = t;\n+                            }\n+                        }\n+                        t = FastMath.hypot(f, g);\n+                        cs = f / t;\n+                        sn = g / t;\n+                        singularValues[j] = t;\n+                        f = cs * e[j] + sn * singularValues[j + 1];\n+                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n+                        g = sn * e[j + 1];\n+                        e[j + 1] = cs * e[j + 1];\n+                        if (wantu && (j < m - 1)) {\n+                            for (int i = 0; i < m; i++) {\n+                                t = cs * U[i][j] + sn * U[i][j + 1];\n+                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n+                                U[i][j] = t;\n+                            }\n+                        }\n+                    }\n+                    e[p - 2] = f;\n+                    iter = iter + 1;\n+                }\n+                break;\n+                // Convergence.\n+                default: {\n+                    // Make the singular values positive.\n+                    if (singularValues[k] <= 0.0) {\n+                        singularValues[k] = singularValues[k] < 0.0 ? -singularValues[k] : 0.0;\n+                        if (wantv) {\n+                            for (int i = 0; i <= pp; i++) {\n+                                V[i][k] = -V[i][k];\n+                            }\n+                        }\n+                    }\n+                    // Order the singular values.\n+                    while (k < pp) {\n+                        if (singularValues[k] >= singularValues[k + 1]) {\n+                            break;\n+                        }\n+                        double t = singularValues[k];\n+                        singularValues[k] = singularValues[k + 1];\n+                        singularValues[k + 1] = t;\n+                        if (wantv && (k < n - 1)) {\n+                            for (int i = 0; i < n; i++) {\n+                                t = V[i][k + 1];\n+                                V[i][k + 1] = V[i][k];\n+                                V[i][k] = t;\n+                            }\n+                        }\n+                        if (wantu && (k < m - 1)) {\n+                            for (int i = 0; i < m; i++) {\n+                                t = U[i][k + 1];\n+                                U[i][k + 1] = U[i][k];\n+                                U[i][k] = t;\n+                            }\n+                        }\n+                        k++;\n+                    }\n+                    iter = 0;\n+                    p--;\n+                }\n+                break;\n+            }\n+        }\n+\n+        if (!transposed) {\n+            cachedU = MatrixUtils.createRealMatrix(U);\n+            cachedV = MatrixUtils.createRealMatrix(V);\n+        } else {\n+            cachedU = MatrixUtils.createRealMatrix(V);\n+            cachedV = MatrixUtils.createRealMatrix(U);\n+\n         }\n     }\n \n@@ -217,19 +548,19 @@ public double getNorm() {\n \n     /** {@inheritDoc} */\n     public double getConditionNumber() {\n-        return singularValues[0] / singularValues[singularValues.length - 1];\n+        return singularValues[0] / singularValues[FastMath.min(m, n) - 1];\n     }\n \n     /** {@inheritDoc} */\n     public int getRank() {\n-        final double threshold = FastMath.max(m, n) * FastMath.ulp(singularValues[0]);\n-\n-        for (int i = singularValues.length - 1; i >= 0; --i) {\n-            if (singularValues[i] > threshold) {\n-                return i + 1;\n+        double tol = FastMath.max(m, n) * singularValues[0] * EPS;\n+        int r = 0;\n+        for (int i = 0; i < singularValues.length; i++) {\n+            if (singularValues[i] > tol) {\n+                r++;\n             }\n         }\n-        return 0;\n+        return r;\n     }\n \n     /** {@inheritDoc} */\n", "nb_test": 2516, "linesAdd": 363, "jira_id": "327", "singleLine": false, "nb_skipped": 1, "commit": "262fe4c0", "nb_failure": 2, "linesRem": 59}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testConstructorTooLow(org.apache.commons.math3.genetics.ElitisticListPopulationTest): Expected exception: org.apache.commons.math3.exception.OutOfRangeException", "testConstructorTooHigh(org.apache.commons.math3.genetics.ElitisticListPopulationTest): Expected exception: org.apache.commons.math3.exception.OutOfRangeException", "testChromosomeListConstructorTooLow(org.apache.commons.math3.genetics.ElitisticListPopulationTest): Expected exception: org.apache.commons.math3.exception.OutOfRangeException", "testChromosomeListConstructorTooHigh(org.apache.commons.math3.genetics.ElitisticListPopulationTest): Expected exception: org.apache.commons.math3.exception.OutOfRangeException"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\nindex a309080..829c97d 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n@@ -24,7 +24,7 @@\n import org.apache.commons.math3.util.FastMath;\n \n /**\n- * Population of chromosomes which uses elitism (certain percentace of the best\n+ * Population of chromosomes which uses elitism (certain percentage of the best\n  * chromosomes is directly copied to the next generation).\n  *\n  * @version $Id$\n@@ -42,12 +42,13 @@\n      * @param populationLimit maximal size of the population\n      * @param elitismRate how many best chromosomes will be directly transferred to the\n      *                    next generation [in %]\n+     * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n     public ElitisticListPopulation(final List<Chromosome> chromosomes,\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n-        this.elitismRate = elitismRate;\n+        setElitismRate(elitismRate);\n     }\n \n     /**\n@@ -57,10 +58,11 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,\n      * @param populationLimit maximal size of the population\n      * @param elitismRate how many best chromosomes will be directly transferred to the\n      *                    next generation [in %]\n+     * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n-        this.elitismRate = elitismRate;\n+        setElitismRate(elitismRate);\n     }\n \n     /**\n", "nb_test": 3499, "linesAdd": 2, "jira_id": "776", "singleLine": false, "nb_skipped": 1, "commit": "b9ca51f0", "nb_failure": 4, "linesRem": 2}, {"files": 2, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SimplexSolverTest.testDimensionMatch Expected exception: org.apache.commons.math4.exception.DimensionMismatchException"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/optim/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math4/optim/linear/SimplexSolver.java\nindex d4b4259..743fe9b 100644\n--- a/src/main/java/org/apache/commons/math4/optim/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math4/optim/linear/SimplexSolver.java\n@@ -19,6 +19,7 @@\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math4.exception.DimensionMismatchException;\n import org.apache.commons.math4.exception.TooManyIterationsException;\n import org.apache.commons.math4.optim.OptimizationData;\n import org.apache.commons.math4.optim.PointValuePair;\n@@ -146,6 +147,8 @@ public SimplexSolver(final double epsilon, final int maxUlps, final double cutOf\n      *\n      * @return {@inheritDoc}\n      * @throws TooManyIterationsException if the maximal number of iterations is exceeded.\n+     * @throws DimensionMismatchException if the dimension of the constraints does not match the\n+     *   dimension of the objective function\n      */\n     @Override\n     public PointValuePair optimize(OptimizationData... optData)\ndiff --git a/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java\nindex e869a74..f0a842f 100644\n--- a/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java\n@@ -28,6 +28,7 @@\n import java.util.Set;\n import java.util.TreeSet;\n \n+import org.apache.commons.math4.exception.DimensionMismatchException;\n import org.apache.commons.math4.linear.Array2DRowRealMatrix;\n import org.apache.commons.math4.linear.MatrixUtils;\n import org.apache.commons.math4.linear.RealVector;\n@@ -112,6 +113,8 @@\n      * or {@link GoalType#MINIMIZE}.\n      * @param restrictToNonNegative Whether to restrict the variables to non-negative values.\n      * @param epsilon Amount of error to accept when checking for optimality.\n+     * @throws DimensionMismatchException if the dimension of the constraints does not match the\n+     *   dimension of the objective function\n      */\n     SimplexTableau(final LinearObjectiveFunction f,\n                    final Collection<LinearConstraint> constraints,\n@@ -129,13 +132,16 @@\n      * @param restrictToNonNegative whether to restrict the variables to non-negative values\n      * @param epsilon amount of error to accept when checking for optimality\n      * @param maxUlps amount of error to accept in floating point comparisons\n+     * @throws DimensionMismatchException if the dimension of the constraints does not match the\n+     *   dimension of the objective function\n      */\n     SimplexTableau(final LinearObjectiveFunction f,\n                    final Collection<LinearConstraint> constraints,\n                    final GoalType goalType,\n                    final boolean restrictToNonNegative,\n                    final double epsilon,\n-                   final int maxUlps) {\n+                   final int maxUlps) throws DimensionMismatchException {\n+        checkDimensions(f, constraints);\n         this.f                      = f;\n         this.constraints            = normalizeConstraints(constraints);\n         this.restrictToNonNegative  = restrictToNonNegative;\n@@ -154,6 +160,23 @@\n     }\n \n     /**\n+     * Checks that the dimensions of the objective function and the constraints match.\n+     * @param f the objective function\n+     * @param constraints the set of constraints\n+     * @throws DimensionMismatchException if the constraint dimensions do not match with the\n+     *   dimension of the objective function\n+     */\n+    private void checkDimensions(final LinearObjectiveFunction f,\n+                                 final Collection<LinearConstraint> constraints) {\n+        final int dimension = f.getCoefficients().getDimension();\n+        for (final LinearConstraint constraint : constraints) {\n+            final int constraintDimension = constraint.getCoefficients().getDimension();\n+            if (constraintDimension != dimension) {\n+                throw new DimensionMismatchException(constraintDimension, dimension);\n+            }\n+        }\n+    }\n+    /**\n      * Initialize the labels for the columns.\n      */\n     protected void initializeColumnLabels() {\n", "nb_test": 5808, "linesAdd": 14, "jira_id": "1230", "singleLine": false, "nb_skipped": 3, "commit": "96eb80ef", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["testNextPoissionConistency(org.apache.commons.math.random.AbstractRandomGeneratorTest)", "testNextPoissionConistency(org.apache.commons.math.random.RandomAdaptorTest)", "testNextPoissionConistency(org.apache.commons.math.random.RandomDataTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\nindex 18097bc..d5d2474 100644\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n@@ -322,30 +322,17 @@ public long nextSecureLong(long lower, long upper) {\n     /**\n      * {@inheritDoc}\n      * <p>\n-     * <strong>Algorithm Description</strong>: For small means, uses simulation\n-     * of a Poisson process using Uniform deviates, as described <a\n-     * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n-     * </p>\n-     * <p>\n-     * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n-     * </p>\n-     *\n-     * <p>\n-     * For large means, uses a reject method as described in <a\n-     * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n-     * Variate Generation</a>\n-     * </p>\n+     * <strong>Algorithm Description</strong>:\n+     * <ul><li> For small means, uses simulation of a Poisson process\n+     * using Uniform deviates, as described\n+     * <a href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n+     * The Poisson process (and hence value returned) is bounded by 1000 * mean.</li>\n      *\n-     * <p>\n-     * References:\n-     * <ul>\n-     * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n-     * New York, NY. Springer-Verlag</li>\n-     * </ul>\n-     * </p>\n+     * <li> For large means, uses the rejection algorithm described in <br/>\n+     * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n+     * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>\n      *\n-     * @param mean\n-     *            mean of the Poisson distribution.\n+     * @param mean mean of the Poisson distribution.\n      * @return the random Poisson value.\n      */\n     public long nextPoisson(double mean) {\n@@ -356,7 +343,7 @@ public long nextPoisson(double mean) {\n \n         final RandomGenerator generator = getRan();\n \n-        double pivot = 6.0;\n+        final double pivot = 40.0d;\n         if (mean < pivot) {\n             double p = Math.exp(-mean);\n             long n = 0;\n@@ -374,68 +361,70 @@ public long nextPoisson(double mean) {\n             }\n             return n;\n         } else {\n-            double mu = Math.floor(mean);\n-            double delta = Math.floor(pivot + (mu - pivot) / 2.0); // integer\n-            // between 6\n-            // and mean\n-            double mu2delta = 2.0 * mu + delta;\n-            double muDeltaHalf = mu + delta / 2.0;\n-            double logMeanMu = Math.log(mean / mu);\n-\n-            double muFactorialLog = MathUtils.factorialLog((int) mu);\n-\n-            double c1 = Math.sqrt(Math.PI * mu / 2.0);\n-            double c2 = c1 +\n-                        Math.sqrt(Math.PI * muDeltaHalf /\n-                                  (2.0 * Math.exp(1.0 / mu2delta)));\n-            double c3 = c2 + 2.0;\n-            double c4 = c3 + Math.exp(1.0 / 78.0);\n-            double c = c4 + 2.0 / delta * mu2delta *\n-                       Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n-\n-            double y = 0.0;\n-            double x = 0.0;\n-            double w = Double.POSITIVE_INFINITY;\n-\n-            boolean accept = false;\n-            while (!accept) {\n-                double u = nextUniform(0.0, c);\n-                double e = nextExponential(mean);\n-\n-                if (u <= c1) {\n-                    double z = nextGaussian(0.0, 1.0);\n-                    y = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n-                    x = Math.floor(y);\n-                    w = -z * z / 2.0 - e - x * logMeanMu;\n-                    if (x < -mu) {\n-                        w = Double.POSITIVE_INFINITY;\n-                    }\n-                } else if (c1 < u && u <= c2) {\n-                    double z = nextGaussian(0.0, 1.0);\n-                    y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n-                    x = Math.ceil(y);\n-                    w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n-                    if (x > delta) {\n-                        w = Double.POSITIVE_INFINITY;\n-                    }\n-                } else if (c2 < u && u <= c3) {\n-                    x = 0.0;\n-                    w = -e;\n-                } else if (c3 < u && u <= c4) {\n-                    x = 1.0;\n-                    w = -e - logMeanMu;\n-                } else if (c4 < u) {\n-                    double v = nextExponential(mean);\n-                    y = delta + v * 2.0 / delta * mu2delta;\n-                    x = Math.ceil(y);\n-                    w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n-                }\n-                accept = w <= x * Math.log(mu) -\n-                         MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;\n-            }\n-            // cast to long is acceptable because both x and mu are whole\n-            // numbers.\n-            return (long) (x + mu);\n+            final double lambda = Math.floor(mean);\n+            final double lambdaFractional = mean - lambda;\n+            final double logLambda = Math.log(lambda);\n+            final double logLambdaFactorial = MathUtils.factorialLog((int) lambda);\n+            final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);\n+            final double delta = Math.sqrt(lambda * Math.log(32 * lambda / Math.PI + 1));\n+            final double halfDelta = delta / 2;\n+            final double twolpd = 2 * lambda + delta;\n+            final double a1 = Math.sqrt(Math.PI * twolpd) * Math.exp(1 / 8 * lambda);\n+            final double a2 = (twolpd / delta) * Math.exp(-delta * (1 + delta) / twolpd);\n+            final double aSum = a1 + a2 + 1;\n+            final double p1 = a1 / aSum;\n+            final double p2 = a2 / aSum;\n+            final double c1 = 1 / (8 * lambda);\n+\n+            double x = 0;\n+            double y = 0;\n+            double v = 0;\n+            int a = 0;\n+            double t = 0;\n+            double qr = 0;\n+            double qa = 0;\n+            for (;;) {\n+                final double u = nextUniform(0.0, 1);\n+                if (u <= p1) {\n+                    final double n = nextGaussian(0d, 1d);\n+                    x = n * Math.sqrt(lambda + halfDelta) - 0.5d;\n+                    if (x > delta || x < -lambda) {\n+                        continue;\n+                    }\n+                    y = x < 0 ? Math.floor(x) : Math.ceil(x);\n+                    final double e = nextExponential(1d);\n+                    v = -e - (n * n / 2) + c1;\n+                } else {\n+                    if (u > p1 + p2) {\n+                        y = lambda;\n+                        break;\n+                    } else {\n+                        x = delta + (twolpd / delta) * nextExponential(1d);\n+                        y = Math.ceil(x);\n+                        v = -nextExponential(1d) - delta * (x + 1) / twolpd;\n+                    }\n+                }\n+                a = x < 0 ? 1 : 0;\n+                t = y * (y + 1) / (2 * lambda);\n+                if (v < -t && a == 0) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+                qr = t * ((2 * y + 1) / (6 * lambda) - 1);\n+                qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));\n+                if (v < qa) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+                if (v > qr) {\n+                    continue;\n+                }\n+                if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+            }\n+            return y2 + (long) y;\n         }\n     }\n \n", "nb_test": 2081, "linesAdd": 65, "jira_id": "294", "singleLine": false, "nb_skipped": 0, "commit": "2c8a114f", "nb_failure": 0, "linesRem": 59}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["CorrelatedRandomVectorGeneratorTest.testSampleWithZeroCovariance:173->testSampler:197 Array comparison failure", "Elements at index 1 differ.  expected = 0.023006616 observed = 0.02403206694829596", "ResizableDoubleArrayTest.testConstructors:57 expected:<MULTIPLICATIVE> but was:<0>"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java b/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\nindex b0dd132..09fd748 100644\n--- a/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\n@@ -21,21 +21,15 @@\n \n import org.apache.commons.math4.exception.MathIllegalArgumentException;\n import org.apache.commons.math4.exception.MathIllegalStateException;\n-import org.apache.commons.math4.exception.MathInternalError;\n import org.apache.commons.math4.exception.NotStrictlyPositiveException;\n import org.apache.commons.math4.exception.NullArgumentException;\n import org.apache.commons.math4.exception.NumberIsTooSmallException;\n import org.apache.commons.math4.exception.util.LocalizedFormats;\n \n /**\n- * <p>\n  * A variable length {@link DoubleArray} implementation that automatically\n  * handles expanding and contracting its internal storage array as elements\n  * are added and removed.\n- * </p>\n- * <h3>Important note: Usage should not assume that this class is thread-safe\n- * even though some of the methods are {@code synchronized}.\n- * This qualifier will be dropped in the next major release (4.0).</h3>\n  * <p>\n  * The internal storage array starts with capacity determined by the\n  * {@code initialCapacity} property, which can be set by the constructor.\n@@ -51,7 +45,6 @@\n  * locations added).\n  * The default {@code expansionMode} is {@code MULTIPLICATIVE} and the default\n  * {@code expansionFactor} is 2.\n- * </p>\n  * <p>\n  * The {@link #addElementRolling(double)} method adds a new element to the end\n  * of the internal storage array and adjusts the \"usable window\" of the\n@@ -71,26 +64,16 @@\n  * {@code contractionFactor.}  If the {@code expansionMode}\n  * is {@code ADDITIVE}, the number of excess storage locations\n  * is compared to {@code contractionFactor}.\n- * </p>\n  * <p>\n  * To avoid cycles of expansions and contractions, the\n  * {@code expansionFactor} must not exceed the {@code contractionFactor}.\n  * Constructors and mutators for both of these properties enforce this\n  * requirement, throwing a {@code MathIllegalArgumentException} if it is\n  * violated.\n- * </p>\n+ * <p>\n+ * <b>Note:</b> this class is <b>NOT</b> thread-safe.\n  */\n public class ResizableDoubleArray implements DoubleArray, Serializable {\n-    /** Additive expansion mode.\n-     * @deprecated As of 3.1. Please use {@link ExpansionMode#ADDITIVE} instead.\n-     */\n-    @Deprecated\n-    public static final int ADDITIVE_MODE = 1;\n-    /** Multiplicative expansion mode.\n-     * @deprecated As of 3.1. Please use {@link ExpansionMode#MULTIPLICATIVE} instead.\n-     */\n-    @Deprecated\n-    public static final int MULTIPLICATIVE_MODE = 0;\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -3485529955529426875L;\n \n@@ -98,6 +81,8 @@\n     private static final int DEFAULT_INITIAL_CAPACITY = 16;\n     /** Default value for array size modifier. */\n     private static final double DEFAULT_EXPANSION_FACTOR = 2.0;\n+    /** Default value for expansion mode. */\n+    private static final ExpansionMode DEFAULT_EXPANSION_MODE = ExpansionMode.MULTIPLICATIVE;\n     /**\n      * Default value for the difference between {@link #contractionCriterion}\n      * and {@link #expansionFactor}.\n@@ -109,23 +94,22 @@\n      * contracted to fit the number of elements contained in the element\n      *  array + 1.\n      */\n-    private double contractionCriterion = 2.5;\n+    private final double contractionCriterion;\n \n     /**\n      * The expansion factor of the array.  When the array needs to be expanded,\n-     * the new array size will be\n-     * {@code internalArray.length * expansionFactor}\n-     * if {@code expansionMode} is set to MULTIPLICATIVE_MODE, or\n+     * the new array size will be {@code internalArray.length * expansionFactor}\n+     * if {@code expansionMode} is set to MULTIPLICATIVE, or\n      * {@code internalArray.length + expansionFactor} if\n-     * {@code expansionMode} is set to ADDITIVE_MODE.\n+     * {@code expansionMode} is set to ADDITIVE.\n      */\n-    private double expansionFactor = 2.0;\n+    private final double expansionFactor;\n \n     /**\n      * Determines whether array expansion by {@code expansionFactor}\n      * is additive or multiplicative.\n      */\n-    private ExpansionMode expansionMode = ExpansionMode.MULTIPLICATIVE;\n+    private final ExpansionMode expansionMode;\n \n     /**\n      * The internal storage array.\n@@ -171,6 +155,7 @@ public ResizableDoubleArray() {\n \n     /**\n      * Creates an instance with the specified initial capacity.\n+     * <p>\n      * Other properties take default values:\n      * <ul>\n      *  <li>{@code expansionMode = MULTIPLICATIVE}</li>\n@@ -180,8 +165,7 @@ public ResizableDoubleArray() {\n      * @param initialCapacity Initial size of the internal storage array.\n      * @throws MathIllegalArgumentException if {@code initialCapacity <= 0}.\n      */\n-    public ResizableDoubleArray(int initialCapacity)\n-        throws MathIllegalArgumentException {\n+    public ResizableDoubleArray(int initialCapacity) throws MathIllegalArgumentException {\n         this(initialCapacity, DEFAULT_EXPANSION_FACTOR);\n     }\n \n@@ -189,6 +173,7 @@ public ResizableDoubleArray(int initialCapacity)\n      * Creates an instance from an existing {@code double[]} with the\n      * initial capacity and numElements corresponding to the size of\n      * the supplied {@code double[]} array.\n+     * <p>\n      * If the supplied array is null, a new empty array with the default\n      * initial capacity will be created.\n      * The input array is copied, not referenced.\n@@ -207,177 +192,66 @@ public ResizableDoubleArray(double[] initialArray) {\n         this(DEFAULT_INITIAL_CAPACITY,\n              DEFAULT_EXPANSION_FACTOR,\n              DEFAULT_CONTRACTION_DELTA + DEFAULT_EXPANSION_FACTOR,\n-             ExpansionMode.MULTIPLICATIVE,\n+             DEFAULT_EXPANSION_MODE,\n              initialArray);\n     }\n \n     /**\n      * Creates an instance with the specified initial capacity\n      * and expansion factor.\n+     * <p>\n      * The remaining properties take default values:\n      * <ul>\n      *  <li>{@code expansionMode = MULTIPLICATIVE}</li>\n      *  <li>{@code contractionCriterion = 0.5 + expansionFactor}</li>\n      * </ul>\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n-     * <ul>\n-     *  <li>{@code initialCapacity > 0}</li>\n-     *  <li>{@code expansionFactor > 1}</li>\n-     * </ul>\n-     *\n-     * @param initialCapacity Initial size of the internal storage array.\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n-     * @throws MathIllegalArgumentException if parameters are not valid.\n-     * @deprecated As of 3.1. Please use\n-     * {@link #ResizableDoubleArray(int,double)} instead.\n-     */\n-    @Deprecated\n-    public ResizableDoubleArray(int initialCapacity,\n-                                float expansionFactor)\n-        throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             (double) expansionFactor);\n-    }\n-\n-    /**\n-     * Creates an instance with the specified initial capacity\n-     * and expansion factor.\n-     * The remaining properties take default values:\n-     * <ul>\n-     *  <li>{@code expansionMode = MULTIPLICATIVE}</li>\n-     *  <li>{@code contractionCriterion = 0.5 + expansionFactor}</li>\n-     * </ul>\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n+     * <p>\n+     * Throws MathIllegalArgumentException if the following conditions\n+     * are not met:\n      * <ul>\n      *  <li>{@code initialCapacity > 0}</li>\n      *  <li>{@code expansionFactor > 1}</li>\n      * </ul>\n      *\n      * @param initialCapacity Initial size of the internal storage array.\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n+     * @param expansionFactor The array will be expanded based on this parameter.\n      * @throws MathIllegalArgumentException if parameters are not valid.\n      * @since 3.1\n      */\n-    public ResizableDoubleArray(int initialCapacity,\n-                                double expansionFactor)\n-        throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             expansionFactor,\n-             DEFAULT_CONTRACTION_DELTA + expansionFactor);\n-    }\n-\n-    /**\n-     * Creates an instance with the specified initialCapacity,\n-     * expansionFactor, and contractionCriterion.\n-     * The expansion mode will default to {@code MULTIPLICATIVE}.\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n-     * <ul>\n-     *  <li>{@code initialCapacity > 0}</li>\n-     *  <li>{@code expansionFactor > 1}</li>\n-     *  <li>{@code contractionCriterion >= expansionFactor}</li>\n-     * </ul>\n-     *\n-     * @param initialCapacity Initial size of the internal storage array..\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n-     * @param contractionCriteria Contraction criteria.\n-     * @throws MathIllegalArgumentException if parameters are not valid.\n-     * @deprecated As of 3.1. Please use\n-     * {@link #ResizableDoubleArray(int,double,double)} instead.\n-     */\n-    @Deprecated\n-    public ResizableDoubleArray(int initialCapacity,\n-                                float expansionFactor,\n-                                float contractionCriteria)\n-        throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             (double) expansionFactor,\n-             (double) contractionCriteria);\n+    public ResizableDoubleArray(int initialCapacity, double expansionFactor) throws MathIllegalArgumentException {\n+        this(initialCapacity, expansionFactor, DEFAULT_CONTRACTION_DELTA + expansionFactor);\n     }\n \n     /**\n      * Creates an instance with the specified initial capacity,\n      * expansion factor, and contraction criteria.\n+     * <p>\n      * The expansion mode will default to {@code MULTIPLICATIVE}.\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n+     * <p>\n+     * Throws MathIllegalArgumentException if the following conditions\n+     * are not met:\n      * <ul>\n      *  <li>{@code initialCapacity > 0}</li>\n      *  <li>{@code expansionFactor > 1}</li>\n      *  <li>{@code contractionCriterion >= expansionFactor}</li>\n      * </ul>\n      *\n-     * @param initialCapacity Initial size of the internal storage array..\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n+     * @param initialCapacity Initial size of the internal storage array.\n+     * @param expansionFactor The array will be expanded based on this parameter.\n      * @param contractionCriterion Contraction criterion.\n      * @throws MathIllegalArgumentException if the parameters are not valid.\n      * @since 3.1\n      */\n-    public ResizableDoubleArray(int initialCapacity,\n-                                double expansionFactor,\n-                                double contractionCriterion)\n+    public ResizableDoubleArray(int initialCapacity, double expansionFactor, double contractionCriterion)\n         throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             expansionFactor,\n-             contractionCriterion,\n-             ExpansionMode.MULTIPLICATIVE,\n-             null);\n-    }\n-\n-    /**\n-     * <p>\n-     * Create a ResizableArray with the specified properties.</p>\n-     * <p>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n-     * <ul>\n-     * <li><code>initialCapacity > 0</code></li>\n-     * <li><code>expansionFactor > 1</code></li>\n-     * <li><code>contractionFactor >= expansionFactor</code></li>\n-     * <li><code>expansionMode in {MULTIPLICATIVE_MODE, ADDITIVE_MODE}</code>\n-     * </li>\n-     * </ul></p>\n-     *\n-     * @param initialCapacity the initial size of the internal storage array\n-     * @param expansionFactor the array will be expanded based on this\n-     *                        parameter\n-     * @param contractionCriteria the contraction Criteria\n-     * @param expansionMode  the expansion mode\n-     * @throws MathIllegalArgumentException if parameters are not valid\n-     * @deprecated As of 3.1. Please use\n-     * {@link #ResizableDoubleArray(int,double,double,ExpansionMode,double[])}\n-     * instead.\n-     */\n-    @Deprecated\n-    public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n-            float contractionCriteria, int expansionMode) throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             expansionFactor,\n-             contractionCriteria,\n-             expansionMode == ADDITIVE_MODE ?\n-             ExpansionMode.ADDITIVE :\n-             ExpansionMode.MULTIPLICATIVE,\n-             null);\n-        // XXX Just ot retain the expected failure in a unit test.\n-        // With the new \"enum\", that test will become obsolete.\n-        setExpansionMode(expansionMode);\n+        this(initialCapacity, expansionFactor, contractionCriterion, DEFAULT_EXPANSION_MODE, null);\n     }\n \n     /**\n      * Creates an instance with the specified properties.\n      * <br/>\n-     * Throws MathIllegalArgumentException if the following conditions are\n-     * not met:\n+     * Throws MathIllegalArgumentException if the following conditions\n+     * are not met:\n      * <ul>\n      *  <li>{@code initialCapacity > 0}</li>\n      *  <li>{@code expansionFactor > 1}</li>\n@@ -385,12 +259,12 @@ public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n      * </ul>\n      *\n      * @param initialCapacity Initial size of the internal storage array.\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n+     * @param expansionFactor The array will be expanded based on this parameter.\n      * @param contractionCriterion Contraction criteria.\n      * @param expansionMode Expansion mode.\n      * @param data Initial contents of the array.\n      * @throws MathIllegalArgumentException if the parameters are not valid.\n+     * @throws NullArgumentException if expansionMode is null\n      */\n     public ResizableDoubleArray(int initialCapacity,\n                                 double expansionFactor,\n@@ -403,6 +277,7 @@ public ResizableDoubleArray(int initialCapacity,\n                                                    initialCapacity);\n         }\n         checkContractExpand(contractionCriterion, expansionFactor);\n+        MathUtils.checkNotNull(expansionMode);\n \n         this.expansionFactor = expansionFactor;\n         this.contractionCriterion = contractionCriterion;\n@@ -417,19 +292,25 @@ public ResizableDoubleArray(int initialCapacity,\n     }\n \n     /**\n-     * Copy constructor.  Creates a new ResizableDoubleArray that is a deep,\n-     * fresh copy of the original. Needs to acquire synchronization lock\n-     * on original.  Original may not be null; otherwise a {@link NullArgumentException}\n-     * is thrown.\n+     * Copy constructor.\n+     * <p>\n+     * Creates a new ResizableDoubleArray that is a deep, fresh copy of the original.\n+     * Original may not be null; otherwise a {@link NullArgumentException} is thrown.\n      *\n      * @param original array to copy\n      * @exception NullArgumentException if original is null\n      * @since 2.0\n      */\n-    public ResizableDoubleArray(ResizableDoubleArray original)\n+    public ResizableDoubleArray(final ResizableDoubleArray original)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(original);\n-        copy(original, this);\n+        this.contractionCriterion = original.contractionCriterion;\n+        this.expansionFactor = original.expansionFactor;\n+        this.expansionMode = original.expansionMode;\n+        this.internalArray = new double[original.internalArray.length];\n+        System.arraycopy(original.internalArray, 0, this.internalArray, 0, this.internalArray.length);\n+        this.numElements = original.numElements;\n+        this.startIndex = original.startIndex;\n     }\n \n     /**\n@@ -438,7 +319,7 @@ public ResizableDoubleArray(ResizableDoubleArray original)\n      * @param value Value to be added to end of array.\n      */\n     @Override\n-    public synchronized void addElement(double value) {\n+    public void addElement(final double value) {\n         if (internalArray.length <= startIndex + numElements) {\n             expand();\n         }\n@@ -452,7 +333,7 @@ public synchronized void addElement(double value) {\n      * @since 2.2\n      */\n     @Override\n-    public synchronized void addElements(double[] values) {\n+    public void addElements(final double[] values) {\n         final double[] tempArray = new double[numElements + values.length + 1];\n         System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\n         System.arraycopy(values, 0, tempArray, numElements, values.length);\n@@ -462,23 +343,21 @@ public synchronized void addElements(double[] values) {\n     }\n \n     /**\n-     * <p>\n      * Adds an element to the end of the array and removes the first\n      * element in the array.  Returns the discarded first element.\n+     * <p>\n      * The effect is similar to a push operation in a FIFO queue.\n-     * </p>\n      * <p>\n      * Example: If the array contains the elements 1, 2, 3, 4 (in that order)\n      * and addElementRolling(5) is invoked, the result is an array containing\n      * the entries 2, 3, 4, 5 and the value returned is 1.\n-     * </p>\n      *\n      * @param value Value to be added to the array.\n      * @return the value which has been discarded or \"pushed\" out of the array\n      * by this rolling insert.\n      */\n     @Override\n-    public synchronized double addElementRolling(double value) {\n+    public double addElementRolling(double value) {\n         double discarded = internalArray[startIndex];\n \n         if ((startIndex + (numElements + 1)) > internalArray.length) {\n@@ -498,20 +377,19 @@ public synchronized double addElementRolling(double value) {\n     }\n \n     /**\n-     * Substitutes <code>value</code> for the most recently added value.\n+     * Substitutes {@code value} for the most recently added value.\n+     * <p>\n      * Returns the value that has been replaced. If the array is empty (i.e.\n-     * if {@link #numElements} is zero), an IllegalStateException is thrown.\n+     * if {@link #numElements} is zero), an MathIllegalStateException is thrown.\n      *\n      * @param value New value to substitute for the most recently added value\n      * @return the value that has been replaced in the array.\n      * @throws MathIllegalStateException if the array is empty\n      * @since 2.0\n      */\n-    public synchronized double substituteMostRecentElement(double value)\n-        throws MathIllegalStateException {\n+    public double substituteMostRecentElement(double value) throws MathIllegalStateException {\n         if (numElements < 1) {\n-            throw new MathIllegalStateException(\n-                    LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY);\n+            throw new MathIllegalStateException(LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY);\n         }\n \n         final int substIndex = startIndex + (numElements - 1);\n@@ -523,25 +401,6 @@ public synchronized double substituteMostRecentElement(double value)\n     }\n \n     /**\n-     * Checks the expansion factor and the contraction criterion and throws an\n-     * IllegalArgumentException if the contractionCriteria is less than the\n-     * expansionCriteria\n-     *\n-     * @param expansion factor to be checked\n-     * @param contraction criteria to be checked\n-     * @throws MathIllegalArgumentException if the contractionCriteria is less than\n-     * the expansionCriteria.\n-     * @deprecated As of 3.1. Please use\n-     * {@link #checkContractExpand(double,double)} instead.\n-     */\n-    @Deprecated\n-    protected void checkContractExpand(float contraction, float expansion)\n-        throws MathIllegalArgumentException {\n-        checkContractExpand((double) contraction,\n-                            (double) expansion);\n-    }\n-\n-    /**\n      * Checks the expansion factor and the contraction criterion and raises\n      * an exception if the contraction criterion is smaller than the\n      * expansion criterion.\n@@ -553,9 +412,7 @@ protected void checkContractExpand(float contraction, float expansion)\n      * @throws NumberIsTooSmallException if {@code expansion <= 1 }.\n      * @since 3.1\n      */\n-    protected void checkContractExpand(double contraction,\n-                                       double expansion)\n-        throws NumberIsTooSmallException {\n+    protected void checkContractExpand(double contraction, double expansion) throws NumberIsTooSmallException {\n         if (contraction < expansion) {\n             final NumberIsTooSmallException e = new NumberIsTooSmallException(contraction, 1, true);\n             e.getContext().addMessage(LocalizedFormats.CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR,\n@@ -582,17 +439,16 @@ protected void checkContractExpand(double contraction,\n      * Clear the array contents, resetting the number of elements to zero.\n      */\n     @Override\n-    public synchronized void clear() {\n+    public void clear() {\n         numElements = 0;\n         startIndex = 0;\n     }\n \n     /**\n-     * Contracts the storage array to the (size of the element set) + 1 - to\n-     * avoid a zero length array. This function also resets the startIndex to\n-     * zero.\n+     * Contracts the storage array to the (size of the element set) + 1 - to avoid\n+     * a zero length array. This function also resets the startIndex to zero.\n      */\n-    public synchronized void contract() {\n+    public void contract() {\n         final double[] tempArray = new double[numElements + 1];\n \n         // Copy and swap - copy only the element array from the src array.\n@@ -604,48 +460,45 @@ public synchronized void contract() {\n     }\n \n     /**\n-     * Discards the <code>i</code> initial elements of the array.  For example,\n-     * if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardFrontElements(2)</code> will cause the first two elements\n-     * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException\n-     * if i exceeds numElements.\n+     * Discards the {@code i} initial elements of the array.\n+     * <p>\n+     * For example, if the array contains the elements 1,2,3,4, invoking\n+     * {@code discardFrontElements(2)} will cause the first two elements\n+     * to be discarded, leaving 3,4 in the array.\n      *\n      * @param i  the number of elements to discard from the front of the array\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    public synchronized void discardFrontElements(int i)\n-        throws MathIllegalArgumentException {\n+    public void discardFrontElements(int i) throws MathIllegalArgumentException {\n         discardExtremeElements(i,true);\n     }\n \n     /**\n-     * Discards the <code>i</code> last elements of the array.  For example,\n-     * if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardMostRecentElements(2)</code> will cause the last two elements\n-     * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException\n-     * if i exceeds numElements.\n+     * Discards the {@code i} last elements of the array.\n+     * <p>\n+     * For example, if the array contains the elements 1,2,3,4, invoking\n+     * {@code discardMostRecentElements(2)} will cause the last two elements\n+     * to be discarded, leaving 1,2 in the array.\n      *\n      * @param i  the number of elements to discard from the end of the array\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    public synchronized void discardMostRecentElements(int i)\n-        throws MathIllegalArgumentException {\n+    public void discardMostRecentElements(int i) throws MathIllegalArgumentException {\n         discardExtremeElements(i,false);\n     }\n \n     /**\n-     * Discards the <code>i</code> first or last elements of the array,\n-     * depending on the value of <code>front</code>.\n+     * Discards the {@code i} first or last elements of the array,\n+     * depending on the value of {@code front}.\n+     * <p>\n      * For example, if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardExtremeElements(2,false)</code> will cause the last two elements\n+     * {@code discardExtremeElements(2,false)} will cause the last two elements\n      * to be discarded, leaving 1,2 in the array.\n      * For example, if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardExtremeElements(2,true)</code> will cause the first two elements\n+     * {@code discardExtremeElements(2,true)} will cause the first two elements\n      * to be discarded, leaving 3,4 in the array.\n-     * Throws illegalArgumentException\n-     * if i exceeds numElements.\n      *\n      * @param i  the number of elements to discard from the front/end of the array\n      * @param front true if elements are to be discarded from the front\n@@ -654,9 +507,7 @@ public synchronized void discardMostRecentElements(int i)\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    private synchronized void discardExtremeElements(int i,\n-                                                     boolean front)\n-        throws MathIllegalArgumentException {\n+    private void discardExtremeElements(int i, boolean front) throws MathIllegalArgumentException {\n         if (i > numElements) {\n             throw new MathIllegalArgumentException(\n                     LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY,\n@@ -680,13 +531,12 @@ private synchronized void discardExtremeElements(int i,\n     /**\n      * Expands the internal storage array using the expansion factor.\n      * <p>\n-     * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,\n-     * the new array size will be <code>internalArray.length * expansionFactor.</code>\n-     * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length\n-     * after expansion will be <code>internalArray.length + expansionFactor</code>\n-     * </p>\n+     * If {@code expansionMode} is set to MULTIPLICATIVE,\n+     * the new array size will be {@code internalArray.length * expansionFactor}.\n+     * If {@code expansionMode} is set to ADDITIVE, the length\n+     * after expansion will be {@code internalArray.length + expansionFactor}.\n      */\n-    protected synchronized void expand() {\n+    protected void expand() {\n         // notice the use of FastMath.ceil(), this guarantees that we will always\n         // have an array of at least currentSize + 1.   Assume that the\n         // current initial capacity is 1 and the expansion factor\n@@ -710,7 +560,7 @@ protected synchronized void expand() {\n      *\n      * @param size Size of the new internal storage array.\n      */\n-    private synchronized void expandTo(int size) {\n+    private void expandTo(int size) {\n         final double[] tempArray = new double[size];\n         // Copy and swap\n         System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n@@ -718,33 +568,14 @@ private synchronized void expandTo(int size) {\n     }\n \n     /**\n-     * The contraction criteria defines when the internal array will contract\n-     * to store only the number of elements in the element array.\n-     * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,\n-     * contraction is triggered when the ratio between storage array length\n-     * and <code>numElements</code> exceeds <code>contractionFactor</code>.\n-     * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the\n-     * number of excess storage locations is compared to\n-     * <code>contractionFactor.</code>\n-     *\n-     * @return the contraction criteria used to reclaim memory.\n-     * @deprecated As of 3.1. Please use {@link #getContractionCriterion()}\n-     * instead.\n-     */\n-    @Deprecated\n-    public float getContractionCriteria() {\n-        return (float) getContractionCriterion();\n-    }\n-\n-    /**\n      * The contraction criterion defines when the internal array will contract\n      * to store only the number of elements in the element array.\n-     * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,\n+     * <p>\n+     * If the {@code expansionMode} is {@code MULTIPLICATIVE},\n      * contraction is triggered when the ratio between storage array length\n-     * and <code>numElements</code> exceeds <code>contractionFactor</code>.\n-     * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the\n-     * number of excess storage locations is compared to\n-     * <code>contractionFactor.</code>\n+     * and {@code numElements} exceeds {@code contractionFactor}.\n+     * If the {@code expansionMode} is {@code ADDITIVE}, the\n+     * number of excess storage locations is compared to {@code contractionFactor}.\n      *\n      * @return the contraction criterion used to reclaim memory.\n      * @since 3.1\n@@ -754,15 +585,15 @@ public double getContractionCriterion() {\n     }\n \n     /**\n-     * Returns the element at the specified index\n+     * Returns the element at the specified index.\n      *\n      * @param index index to fetch a value from\n      * @return value stored at the specified index\n-     * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n-     * zero or is greater than <code>getNumElements() - 1</code>.\n+     * @throws ArrayIndexOutOfBoundsException if {@code index} is less than\n+     * zero or is greater than {@code getNumElements() - 1}.\n      */\n     @Override\n-    public synchronized double getElement(int index) {\n+    public double getElement(int index) {\n         if (index >= numElements) {\n             throw new ArrayIndexOutOfBoundsException(index);\n         } else if (index >= 0) {\n@@ -773,14 +604,15 @@ public synchronized double getElement(int index) {\n     }\n \n      /**\n-     * Returns a double array containing the elements of this\n-     * <code>ResizableArray</code>.  This method returns a copy, not a\n-     * reference to the underlying array, so that changes made to the returned\n-     *  array have no effect on this <code>ResizableArray.</code>\n+     * Returns a double array containing the elements of this ResizableArray.\n+     * <p>\n+     * This method returns a copy, not a reference to the underlying array,\n+     * so that changes made to the returned array have no effect on this ResizableArray.\n+     *\n      * @return the double array.\n      */\n     @Override\n-    public synchronized double[] getElements() {\n+    public double[] getElements() {\n         final double[] elementArray = new double[numElements];\n         System.arraycopy(internalArray, startIndex, elementArray, 0, numElements);\n         return elementArray;\n@@ -788,20 +620,18 @@ public synchronized double getElement(int index) {\n \n     /**\n      * The expansion factor controls the size of a new array when an array\n-     * needs to be expanded.  The <code>expansionMode</code>\n-     * determines whether the size of the array is multiplied by the\n-     * <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if\n-     * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor</code>\n-     * storage locations added).  The default <code>expansionMode</code> is\n-     * MULTIPLICATIVE_MODE and the default <code>expansionFactor</code>\n-     * is 2.0.\n+     * needs to be expanded.\n+     * <p>\n+     * The {@code expansionMode} determines whether the size of the array\n+     * is multiplied by the {@code expansionFactor} (MULTIPLICATIVE) or if\n+     * the expansion is additive (ADDITIVE -- {@code expansionFactor}\n+     * storage locations added).  The default {@code expansionMode} is\n+     * MULTIPLICATIVE and the default {@code expansionFactor} is 2.0.\n      *\n      * @return the expansion factor of this expandable double array\n-     * @deprecated As of 3.1. Return type will be changed to \"double\" in 4.0.\n      */\n-    @Deprecated\n-    public float getExpansionFactor() {\n-        return (float) expansionFactor;\n+    public double getExpansionFactor() {\n+        return expansionFactor;\n     }\n \n     /**\n@@ -809,33 +639,9 @@ public float getExpansionFactor() {\n      * array grows additively or multiplicatively when it is expanded.\n      *\n      * @return the expansion mode.\n-     * @deprecated As of 3.1. Return value to be changed to\n-     * {@link ExpansionMode} in 4.0.\n-     */\n-    @Deprecated\n-    public int getExpansionMode() {\n-        switch (expansionMode) {\n-        case MULTIPLICATIVE:\n-            return MULTIPLICATIVE_MODE;\n-        case ADDITIVE:\n-            return ADDITIVE_MODE;\n-        default:\n-            throw new MathInternalError(); // Should never happen.\n-        }\n-    }\n-\n-    /**\n-     * Notice the package scope on this method.   This method is simply here\n-     * for the JUnit test, it allows us check if the expansion is working\n-     * properly after a number of expansions.  This is not meant to be a part\n-     * of the public interface of this class.\n-     *\n-     * @return the length of the internal storage array.\n-     * @deprecated As of 3.1. Please use {@link #getCapacity()} instead.\n      */\n-    @Deprecated\n-    synchronized int getInternalLength() {\n-        return internalArray.length;\n+    public ExpansionMode getExpansionMode() {\n+        return expansionMode;\n     }\n \n     /**\n@@ -858,41 +664,23 @@ public int getCapacity() {\n      * @return the number of elements.\n      */\n     @Override\n-    public synchronized int getNumElements() {\n+    public int getNumElements() {\n         return numElements;\n     }\n \n     /**\n-     * Returns the internal storage array.  Note that this method returns\n-     * a reference to the internal storage array, not a copy, and to correctly\n-     * address elements of the array, the <code>startIndex</code> is\n-     * required (available via the {@link #start} method).  This method should\n-     * only be used in cases where copying the internal array is not practical.\n-     * The {@link #getElements} method should be used in all other cases.\n-     *\n-     *\n-     * @return the internal storage array used by this object\n-     * @since 2.0\n-     * @deprecated As of 3.1.\n-     */\n-    @Deprecated\n-    public synchronized double[] getInternalValues() {\n-        return internalArray;\n-    }\n-\n-    /**\n      * Provides <em>direct</em> access to the internal storage array.\n      * Please note that this method returns a reference to this object's\n      * storage array, not a copy.\n-     * <br/>\n+     * <p>\n      * To correctly address elements of the array, the \"start index\" is\n      * required (available via the {@link #getStartIndex() getStartIndex}\n      * method.\n-     * <br/>\n+     * <p>\n      * This method should only be used to avoid copying the internal array.\n      * The returned value <em>must</em> be used for reading only; other\n      * uses could lead to this object becoming inconsistent.\n-     * <br/>\n+     * <p>\n      * The {@link #getElements} method has no such limitation since it\n      * returns a copy of this array's addressable elements.\n      *\n@@ -907,6 +695,7 @@ public synchronized int getNumElements() {\n      * Returns the \"start index\" of the internal array.\n      * This index is the position of the first addressable element in the\n      * internal storage array.\n+     * <p>\n      * The addressable elements in the array are at indices contained in\n      * the interval [{@link #getStartIndex()},\n      *               {@link #getStartIndex()} + {@link #getNumElements()} - 1].\n@@ -919,23 +708,6 @@ protected int getStartIndex() {\n     }\n \n     /**\n-     * Sets the contraction criteria.\n-     *\n-     * @param contractionCriteria contraction criteria\n-     * @throws MathIllegalArgumentException if the contractionCriteria is less than\n-     *         the expansionCriteria.\n-     * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n-     */\n-    @Deprecated\n-    public void setContractionCriteria(float contractionCriteria)\n-        throws MathIllegalArgumentException {\n-        checkContractExpand(contractionCriteria, getExpansionFactor());\n-        synchronized(this) {\n-            this.contractionCriterion = contractionCriteria;\n-        }\n-    }\n-\n-    /**\n      * Performs an operation on the addressable elements of the array.\n      *\n      * @param f Function to be applied on this array.\n@@ -943,30 +715,24 @@ public void setContractionCriteria(float contractionCriteria)\n      * @since 3.1\n      */\n     public double compute(MathArrays.Function f) {\n-        final double[] array;\n-        final int start;\n-        final int num;\n-        synchronized(this) {\n-            array = internalArray;\n-            start = startIndex;\n-            num   = numElements;\n-        }\n-        return f.evaluate(array, start, num);\n+        return f.evaluate(internalArray, startIndex, numElements);\n     }\n \n     /**\n-     * Sets the element at the specified index.  If the specified index is greater than\n-     * <code>getNumElements() - 1</code>, the <code>numElements</code> property\n-     * is increased to <code>index +1</code> and additional storage is allocated\n-     * (if necessary) for the new element and all  (uninitialized) elements\n-     * between the new element and the previous end of the array).\n+     * Sets the element at the specified index.\n+     * <p>\n+     * If the specified index is greater than {@code getNumElements() - 1},\n+     * the {@code numElements} property is increased to {@code index +1}\n+     * and additional storage is allocated (if necessary) for the new element and\n+     * all (uninitialized) elements between the new element and the previous end\n+     * of the array).\n      *\n      * @param index index to store a value in\n      * @param value value to store at the specified index\n      * @throws ArrayIndexOutOfBoundsException if {@code index < 0}.\n      */\n     @Override\n-    public synchronized void setElement(int index, double value) {\n+    public void setElement(int index, double value) {\n         if (index < 0) {\n             throw new ArrayIndexOutOfBoundsException(index);\n         }\n@@ -980,92 +746,17 @@ public synchronized void setElement(int index, double value) {\n     }\n \n     /**\n-     * Sets the expansionFactor.  Throws IllegalArgumentException if the\n-     * the following conditions are not met:\n-     * <ul>\n-     * <li><code>expansionFactor > 1</code></li>\n-     * <li><code>contractionFactor >= expansionFactor</code></li>\n-     * </ul>\n-     * @param expansionFactor the new expansion factor value.\n-     * @throws MathIllegalArgumentException if expansionFactor is <= 1 or greater\n-     * than contractionFactor\n-     * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n-     */\n-    @Deprecated\n-    public void setExpansionFactor(float expansionFactor) throws MathIllegalArgumentException {\n-        checkContractExpand(getContractionCriterion(), expansionFactor);\n-        // The check above verifies that the expansion factor is > 1.0;\n-        synchronized(this) {\n-            this.expansionFactor = expansionFactor;\n-        }\n-    }\n-\n-    /**\n-     * Sets the <code>expansionMode</code>. The specified value must be one of\n-     * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\n-     *\n-     * @param expansionMode The expansionMode to set.\n-     * @throws MathIllegalArgumentException if the specified mode value is not valid.\n-     * @deprecated As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.\n-     */\n-    @Deprecated\n-    public void setExpansionMode(int expansionMode)\n-        throws MathIllegalArgumentException {\n-        if (expansionMode != MULTIPLICATIVE_MODE &&\n-            expansionMode != ADDITIVE_MODE) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.UNSUPPORTED_EXPANSION_MODE, expansionMode,\n-                                                   MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\",\n-                                                   ADDITIVE_MODE, \"ADDITIVE_MODE\");\n-        }\n-        synchronized(this) {\n-            if (expansionMode == MULTIPLICATIVE_MODE) {\n-                setExpansionMode(ExpansionMode.MULTIPLICATIVE);\n-            } else if (expansionMode == ADDITIVE_MODE) {\n-                setExpansionMode(ExpansionMode.ADDITIVE);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Sets the {@link ExpansionMode expansion mode}.\n-     *\n-     * @param expansionMode Expansion mode to use for resizing the array.\n-     * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n-     */\n-    @Deprecated\n-    public void setExpansionMode(ExpansionMode expansionMode) {\n-        this.expansionMode = expansionMode;\n-    }\n-\n-    /**\n-     * Sets the initial capacity.  Should only be invoked by constructors.\n-     *\n-     * @param initialCapacity of the array\n-     * @throws MathIllegalArgumentException if <code>initialCapacity</code> is not\n-     * positive.\n-     * @deprecated As of 3.1, this is a no-op.\n-     */\n-    @Deprecated\n-    protected void setInitialCapacity(int initialCapacity)\n-        throws MathIllegalArgumentException {\n-        // Body removed in 3.1.\n-    }\n-\n-    /**\n      * This function allows you to control the number of elements contained\n      * in this array, and can be used to \"throw out\" the last n values in an\n      * array. This function will also expand the internal array as needed.\n      *\n      * @param i a new number of elements\n-     * @throws MathIllegalArgumentException if <code>i</code> is negative.\n+     * @throws MathIllegalArgumentException if {@code i} is negative.\n      */\n-    public synchronized void setNumElements(int i)\n-        throws MathIllegalArgumentException {\n+    public void setNumElements(int i) throws MathIllegalArgumentException {\n         // If index is negative thrown an error.\n         if (i < 0) {\n-            throw new MathIllegalArgumentException(\n-                    LocalizedFormats.INDEX_NOT_POSITIVE,\n-                    i);\n+            throw new MathIllegalArgumentException(LocalizedFormats.INDEX_NOT_POSITIVE, i);\n         }\n \n         // Test the new num elements, check to see if the array needs to be\n@@ -1085,7 +776,7 @@ public synchronized void setNumElements(int i)\n      *\n      * @return true if array satisfies the contraction criteria\n      */\n-    private synchronized boolean shouldContract() {\n+    private boolean shouldContract() {\n         if (expansionMode == ExpansionMode.MULTIPLICATIVE) {\n             return (internalArray.length / ((float) numElements)) > contractionCriterion;\n         } else {\n@@ -1094,57 +785,6 @@ private synchronized boolean shouldContract() {\n     }\n \n     /**\n-     * Returns the starting index of the internal array.  The starting index is\n-     * the position of the first addressable element in the internal storage\n-     * array.  The addressable elements in the array are <code>\n-     * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\n-     * </code>\n-     *\n-     * @return the starting index.\n-     * @deprecated As of 3.1.\n-     */\n-    @Deprecated\n-    public synchronized int start() {\n-        return startIndex;\n-    }\n-\n-    /**\n-     * <p>Copies source to dest, copying the underlying data, so dest is\n-     * a new, independent copy of source.  Does not contract before\n-     * the copy.</p>\n-     *\n-     * <p>Obtains synchronization locks on both source and dest\n-     * (in that order) before performing the copy.</p>\n-     *\n-     * <p>Neither source nor dest may be null; otherwise a {@link NullArgumentException}\n-     * is thrown</p>\n-     *\n-     * @param source ResizableDoubleArray to copy\n-     * @param dest ResizableArray to replace with a copy of the source array\n-     * @exception NullArgumentException if either source or dest is null\n-     * @since 2.0\n-     *\n-     */\n-    public static void copy(ResizableDoubleArray source,\n-                            ResizableDoubleArray dest)\n-        throws NullArgumentException {\n-        MathUtils.checkNotNull(source);\n-        MathUtils.checkNotNull(dest);\n-        synchronized(source) {\n-           synchronized(dest) {\n-               dest.contractionCriterion = source.contractionCriterion;\n-               dest.expansionFactor = source.expansionFactor;\n-               dest.expansionMode = source.expansionMode;\n-               dest.internalArray = new double[source.internalArray.length];\n-               System.arraycopy(source.internalArray, 0, dest.internalArray,\n-                       0, dest.internalArray.length);\n-               dest.numElements = source.numElements;\n-               dest.startIndex = source.startIndex;\n-           }\n-       }\n-    }\n-\n-    /**\n      * Returns a copy of the ResizableDoubleArray.  Does not contract before\n      * the copy, so the returned object is an exact copy of this.\n      *\n@@ -1152,10 +792,8 @@ public static void copy(ResizableDoubleArray source,\n      * properties as this\n      * @since 2.0\n      */\n-    public synchronized ResizableDoubleArray copy() {\n-        final ResizableDoubleArray result = new ResizableDoubleArray();\n-        copy(this, result);\n-        return result;\n+    public ResizableDoubleArray copy() {\n+        return new ResizableDoubleArray(this);\n     }\n \n     /**\n@@ -1175,8 +813,6 @@ public boolean equals(Object object) {\n         if (object instanceof ResizableDoubleArray == false) {\n             return false;\n         }\n-        synchronized(this) {\n-            synchronized(object) {\n         boolean result = true;\n         final ResizableDoubleArray other = (ResizableDoubleArray) object;\n         result = result && (other.contractionCriterion == contractionCriterion);\n@@ -1190,8 +826,6 @@ public boolean equals(Object object) {\n             return Arrays.equals(internalArray, other.internalArray);\n         }\n     }\n-        }\n-    }\n \n     /**\n      * Returns a hash code consistent with equals.\n@@ -1200,7 +834,7 @@ public boolean equals(Object object) {\n      * @since 2.0\n      */\n     @Override\n-    public synchronized int hashCode() {\n+    public int hashCode() {\n         final int[] hashData = new int[6];\n         hashData[0] = Double.valueOf(expansionFactor).hashCode();\n         hashData[1] = Double.valueOf(contractionCriterion).hashCode();\n", "nb_test": 5850, "linesAdd": 47, "jira_id": "757", "singleLine": false, "nb_skipped": 3, "commit": "76b7413d", "nb_failure": 2, "linesRem": 211}, {"files": 3, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBasicFunctions(org.apache.commons.math.linear.ArrayRealVectorTest)", "testBasicFunctions(org.apache.commons.math.linear.SparseRealVectorTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\nindex cf103c0..ace4b8d 100644\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n@@ -206,6 +206,40 @@ public double getDistance(RealVector v) throws IllegalArgumentException {\n     }\n \n     /** {@inheritDoc} */\n+    public double getNorm() {\n+        double sum = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final double value = e.getValue();\n+            sum += value * value;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Norm() {\n+        double norm = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            norm += Math.abs(e.getValue());\n+        }\n+        return norm;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfNorm() {\n+        double norm = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            norm = Math.max(norm, Math.abs(e.getValue()));\n+        }\n+        return norm;\n+    }\n+\n+    /** {@inheritDoc} */\n     public double getDistance(double[] v) throws IllegalArgumentException {\n         return getDistance(new ArrayRealVector(v,false));\n     }\ndiff --git a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\nindex 45c0919..22d0a28 100644\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n@@ -694,6 +694,7 @@ public double dotProduct(ArrayRealVector v)\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getNorm() {\n         double sum = 0;\n         for (double a : data) {\n@@ -703,6 +704,7 @@ public double getNorm() {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getL1Norm() {\n         double sum = 0;\n         for (double a : data) {\n@@ -712,10 +714,11 @@ public double getL1Norm() {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n-            max += Math.max(max, Math.abs(a));\n+            max = Math.max(max, Math.abs(a));\n         }\n         return max;\n     }\ndiff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\nindex febea7a..eb5be1b 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -495,17 +495,6 @@ public double getL1Distance(double[] v) throws IllegalArgumentException {\n         return max;\n     }\n \n-    /** {@inheritDoc} */\n-    public double getL1Norm() {\n-        double res = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            res += Math.abs(iter.value());\n-        }\n-        return res;\n-    }\n-\n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from\n@@ -557,28 +546,6 @@ public double getLInfDistance(double[] v) throws IllegalArgumentException {\n     }\n \n     /** {@inheritDoc} */\n-    public double getLInfNorm() {\n-        double max = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            max += iter.value();\n-        }\n-        return max;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getNorm() {\n-        double res = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            res += iter.value() * iter.value();\n-        }\n-        return Math.sqrt(res);\n-    }\n-\n-    /** {@inheritDoc} */\n     public boolean isInfinite() {\n         boolean infiniteFound = false;\n         Iterator iter = entries.iterator();\n", "nb_test": 2119, "linesAdd": 35, "jira_id": "326", "singleLine": false, "nb_skipped": 0, "commit": "ce185345", "nb_failure": 2, "linesRem": 31}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["SpearmansRankCorrelationTest.testMath891Array:132 expected:<0.5> but was:<0.1054092553389458>", "SpearmansRankCorrelationTest.testMath891Matrix:148 \u00bb MatrixDimensionMismatch g..."], "patch": "diff --git a/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java b/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\nindex 2cd4151..14c48c6 100644\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\n@@ -17,22 +17,28 @@\n \n package org.apache.commons.math3.stat.correlation;\n \n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.stat.ranking.NaNStrategy;\n import org.apache.commons.math3.stat.ranking.NaturalRanking;\n import org.apache.commons.math3.stat.ranking.RankingAlgorithm;\n \n /**\n- * <p>Spearman's rank correlation. This implementation performs a rank\n+ * Spearman's rank correlation. This implementation performs a rank\n  * transformation on the input data and then computes {@link PearsonsCorrelation}\n- * on the ranked data.</p>\n- *\n- * <p>By default, ranks are computed using {@link NaturalRanking} with default\n+ * on the ranked data.\n+ * <p>\n+ * By default, ranks are computed using {@link NaturalRanking} with default\n  * strategies for handling NaNs and ties in the data (NaNs maximal, ties averaged).\n- * The ranking algorithm can be set using a constructor argument.</p>\n+ * The ranking algorithm can be set using a constructor argument.\n  *\n  * @since 2.0\n  * @version $Id$\n@@ -58,6 +63,9 @@ public SpearmansCorrelation() {\n \n     /**\n      * Create a SpearmansCorrelation with the given ranking algorithm.\n+     * <p>\n+     * From version 4.0 onwards this constructor will throw an exception\n+     * if the provided {@link NaturalRanking} uses a {@link NaNStrategy#REMOVED} strategy.\n      *\n      * @param rankingAlgorithm ranking algorithm\n      * @since 3.1\n@@ -81,15 +89,17 @@ public SpearmansCorrelation(final RealMatrix dataMatrix) {\n     /**\n      * Create a SpearmansCorrelation with the given input data matrix\n      * and ranking algorithm.\n+     * <p>\n+     * From version 4.0 onwards this constructor will throw an exception\n+     * if the provided {@link NaturalRanking} uses a {@link NaNStrategy#REMOVED} strategy.\n      *\n      * @param dataMatrix matrix of data with columns representing\n      * variables to correlate\n      * @param rankingAlgorithm ranking algorithm\n      */\n     public SpearmansCorrelation(final RealMatrix dataMatrix, final RankingAlgorithm rankingAlgorithm) {\n-        this.data = dataMatrix.copy();\n         this.rankingAlgorithm = rankingAlgorithm;\n-        rankTransform(data);\n+        this.data = rankTransform(dataMatrix);\n         rankCorrelation = new PearsonsCorrelation(data);\n     }\n \n@@ -125,9 +135,8 @@ public PearsonsCorrelation getRankCorrelation() {\n      * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n-    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n-        RealMatrix matrixCopy = matrix.copy();\n-        rankTransform(matrixCopy);\n+    public RealMatrix computeCorrelationMatrix(final RealMatrix matrix) {\n+        final RealMatrix matrixCopy = rankTransform(matrix);\n         return new PearsonsCorrelation().computeCorrelationMatrix(matrixCopy);\n     }\n \n@@ -139,7 +148,7 @@ public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n      * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n-    public RealMatrix computeCorrelationMatrix(double[][] matrix) {\n+    public RealMatrix computeCorrelationMatrix(final double[][] matrix) {\n        return computeCorrelationMatrix(new BlockRealMatrix(matrix));\n     }\n \n@@ -159,20 +168,93 @@ public double correlation(final double[] xArray, final double[] yArray) {\n             throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                                    xArray.length, 2);\n         } else {\n-            return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(xArray),\n-                    rankingAlgorithm.rank(yArray));\n+            double[] x = xArray;\n+            double[] y = yArray;\n+            if (rankingAlgorithm instanceof NaturalRanking &&\n+                NaNStrategy.REMOVED == ((NaturalRanking) rankingAlgorithm).getNanStrategy()) {\n+                final Set<Integer> nanPositions = new HashSet<Integer>();\n+\n+                nanPositions.addAll(getNaNPositions(xArray));\n+                nanPositions.addAll(getNaNPositions(yArray));\n+\n+                x = removeValues(xArray, nanPositions);\n+                y = removeValues(yArray, nanPositions);\n+            }\n+            return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(x), rankingAlgorithm.rank(y));\n         }\n     }\n \n     /**\n      * Applies rank transform to each of the columns of <code>matrix</code>\n-     * using the current <code>rankingAlgorithm</code>\n+     * using the current <code>rankingAlgorithm</code>.\n      *\n      * @param matrix matrix to transform\n+     * @return a rank-transformed matrix\n      */\n-    private void rankTransform(RealMatrix matrix) {\n+    private RealMatrix rankTransform(final RealMatrix matrix) {\n+        RealMatrix transformed = null;\n+\n+        if (rankingAlgorithm instanceof NaturalRanking &&\n+                ((NaturalRanking) rankingAlgorithm).getNanStrategy() == NaNStrategy.REMOVED) {\n+            final Set<Integer> nanPositions = new HashSet<Integer>();\n             for (int i = 0; i < matrix.getColumnDimension(); i++) {\n-            matrix.setColumn(i, rankingAlgorithm.rank(matrix.getColumn(i)));\n+                nanPositions.addAll(getNaNPositions(matrix.getColumn(i)));\n+            }\n+\n+            // if we have found NaN values, we have to update the matrix size\n+            if (!nanPositions.isEmpty()) {\n+                transformed = new BlockRealMatrix(matrix.getRowDimension() - nanPositions.size(),\n+                                                  matrix.getColumnDimension());\n+                for (int i = 0; i < transformed.getColumnDimension(); i++) {\n+                    transformed.setColumn(i, removeValues(matrix.getColumn(i), nanPositions));\n+                }\n+            }\n+        }\n+\n+        if (transformed == null) {\n+            transformed = matrix.copy();\n+        }\n+\n+        for (int i = 0; i < transformed.getColumnDimension(); i++) {\n+            transformed.setColumn(i, rankingAlgorithm.rank(transformed.getColumn(i)));\n+        }\n+\n+        return transformed;\n+    }\n+\n+    /**\n+     * Returns a list containing the indices of NaN values in the input array.\n+     *\n+     * @param input the input array\n+     * @return a list of NaN positions in the input array\n+     */\n+    private List<Integer> getNaNPositions(final double[] input) {\n+        final List<Integer> positions = new ArrayList<Integer>();\n+        for (int i = 0; i < input.length; i++) {\n+            if (Double.isNaN(input[i])) {\n+                positions.add(i);\n+            }\n+        }\n+        return positions;\n+    }\n+\n+    /**\n+     * Removes all values from the input array at the specified indices.\n+     *\n+     * @param input the input array\n+     * @param indices a set containing the indices to be removed\n+     * @return the input array without the values at the specified indices\n+     */\n+    private double[] removeValues(final double[] input, final Set<Integer> indices) {\n+        if (indices.isEmpty()) {\n+            return input;\n+        }\n+        final double[] result = new double[input.length - indices.size()];\n+        for (int i = 0, j = 0; i < input.length; i++) {\n+            if (!indices.contains(i)) {\n+                result[j++] = input[i];\n+            }\n         }\n+        return result;\n     }\n }\n", "nb_test": 4921, "linesAdd": 72, "jira_id": "891", "singleLine": false, "nb_skipped": 4, "commit": "2b852d79", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTan(org.apache.commons.math.complex.ComplexTest): expected:<1.0> but was:<NaN>", "testTanInf(org.apache.commons.math.complex.ComplexTest): expected:<1.0> but was:<NaN>", "testTanh(org.apache.commons.math.complex.ComplexTest): expected:<1.0> but was:<NaN>", "testTanhInf(org.apache.commons.math.complex.ComplexTest): expected:<1.0> but was:<NaN>"], "patch": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex 3822a89..ed76a29 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -993,8 +993,8 @@ public Complex sqrt1z() {\n      *  </code>\n      * </pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n+     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n+     * {@link FastMath#sinh}.\n      * <br/>\n      * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is {@code NaN}.\n@@ -1004,8 +1004,8 @@ public Complex sqrt1z() {\n      * <pre>\n      *  Examples:\n      *  <code>\n-     *   tan(1 &plusmn; INFINITY i) = 0 + NaN i\n-     *   tan(&plusmn;INFINITY + i) = NaN + NaN i\n+     *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\n+     *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\n      *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n      *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n      *  </code>\n@@ -1015,9 +1015,15 @@ public Complex sqrt1z() {\n      * @since 1.2\n      */\n     public Complex tan() {\n-        if (isNaN) {\n+        if (isNaN || Double.isInfinite(real)) {\n             return NaN;\n         }\n+        if (imaginary > 20.0) {\n+            return createComplex(0.0, 1.0);\n+        }\n+        if (imaginary < -20.0) {\n+            return createComplex(0.0, -1.0);\n+        }\n \n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n@@ -1038,8 +1044,8 @@ public Complex tan() {\n      *  </code>\n      * </pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n+     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n+     * {@link FastMath#sinh}.\n      * <br/>\n      * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is {@code NaN}.\n@@ -1049,8 +1055,8 @@ public Complex tan() {\n      * <pre>\n      *  Examples:\n      *  <code>\n-     *   tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n-     *   tanh(&plusmn;INFINITY + i) = NaN + 0 i\n+     *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\n+     *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\n      *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n      *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i\n      *  </code>\n@@ -1060,10 +1066,15 @@ public Complex tan() {\n      * @since 1.2\n      */\n     public Complex tanh() {\n-        if (isNaN) {\n+        if (isNaN || Double.isInfinite(imaginary)) {\n             return NaN;\n         }\n-\n+        if (real > 20.0) {\n+            return createComplex(1.0, 0.0);\n+        }\n+        if (real < -20.0) {\n+            return createComplex(-1.0, 0.0);\n+        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n", "nb_test": 3531, "linesAdd": 14, "jira_id": "722", "singleLine": false, "nb_skipped": 1, "commit": "95d15eff", "nb_failure": 4, "linesRem": 3}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["EigenSolverTest.testIsNonSingularTinyOutOfOrderEigenvalue:117 Singular matrix not detected"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\nindex 4d4d794..2bb8fd7 100644\n--- a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n@@ -513,8 +513,12 @@ public RealMatrix solve(RealMatrix b) {\n          * @return true if the decomposed matrix is non-singular.\n          */\n         public boolean isNonSingular() {\n-            // The eigenvalues are sorted by size, descending\n-            double largestEigenvalueNorm = eigenvalueNorm(0);\n+            double largestEigenvalueNorm = 0.0;\n+            // Looping over all values (in case they are not sorted in decreasing\n+            // order of their norm).\n+            for (int i = 0; i < realEigenvalues.length; ++i) {\n+                largestEigenvalueNorm = FastMath.max(largestEigenvalueNorm, eigenvalueNorm(i));\n+            }\n             // Corner case: zero matrix, all exactly 0 eigenvalues\n             if (largestEigenvalueNorm == 0.0) {\n                 return false;\n", "nb_test": 5393, "linesAdd": 4, "jira_id": "1045", "singleLine": false, "nb_skipped": 4, "commit": "c979a6f0", "nb_failure": 1, "linesRem": 1}, {"files": 3, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSinMin(org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest)", "testQuinticMin(org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest)", "testSinMin(org.apache.commons.math.optimization.univariate.BrentOptimizerTest)", "testQuinticMinStatistics(org.apache.commons.math.optimization.univariate.BrentOptimizerTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java b/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\nindex 883578b..0c4eabe 100644\n--- a/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n@@ -139,14 +139,14 @@ protected void resetIterationsCounter() {\n     /**\n      * Increment the iterations counter by 1.\n      *\n-     * @throws OptimizationException if the maximal number\n+     * @throws MaxIterationsExceededException if the maximal number\n      * of iterations is exceeded.\n      * @since 2.2\n      */\n     protected void incrementIterationsCounter()\n-        throws ConvergenceException {\n+        throws MaxIterationsExceededException {\n         if (++iterationCount > maximalIterationCount) {\n-            throw new ConvergenceException(new MaxIterationsExceededException(maximalIterationCount));\n+            throw new MaxIterationsExceededException(maximalIterationCount);\n         }\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\nindex d312243..c6eeb53 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n@@ -260,5 +260,6 @@ public double optimize(UnivariateRealFunction f, GoalType goal,\n      *\n      * @return the optimum.\n      */\n-    protected abstract double doOptimize();\n+    protected abstract double doOptimize()\n+        throws MaxIterationsExceededException, FunctionEvaluationException;\n }\ndiff --git a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\nindex 62f2fcb..46c4afa 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n@@ -41,39 +41,37 @@\n      * Construct a solver.\n      */\n     public BrentOptimizer() {\n-        super(100, 1E-10);\n+        setMaxEvaluations(1000);\n+        setMaximalIterationCount(100);\n+        setAbsoluteAccuracy(1e-11);\n+        setRelativeAccuracy(1e-9);\n     }\n \n-    /** {@inheritDoc} */\n-    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n-                           final double min, final double max, final double startValue)\n+    /**\n+     * Perform the optimization.\n+     *\n+     * @return the optimum.\n+     */\n+    protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        clearResult();\n-        return localMin(f, goalType, min, startValue, max,\n+        return localMin(getGoalType() == GoalType.MINIMIZE,\n+                        getMin(), getStartValue(), getMax(),\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n \n-    /** {@inheritDoc} */\n-    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n-                           final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n-    }\n-\n     /**\n-     * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\n+     * Find the minimum of the function within the interval {@code (lo, hi)}.\n      *\n-     * If the function {@code f} is defined on the interval {@code (a, b)}, then\n-     * this method finds an approximation {@code x} to the point at which {@code f}\n-     * attains its minimum.<br/>\n-     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and\n-     * {@code f} is never evaluated at two points closer together than {@code tol}.\n-     * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not\n-     * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative\n-     * machine precision. {@code t} should be positive.\n-     * @param f the function to solve.\n-     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}.\n+     * If the function is defined on the interval {@code (lo, hi)}, then\n+     * this method finds an approximation {@code x} to the point at which\n+     * the function attains its minimum.<br/>\n+     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n+     * and the function is never evaluated at two points closer together than\n+     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n+     * preferable not much less than <em>sqrt(macheps)</em>, where\n+     * <em>macheps</em> is the relative machine precision. {@code t} should be\n+     * positive.\n+     * @param isMinim {@code true} when minimizing the function.\n      * @param lo Lower bound of the interval.\n      * @param mid Point inside the interval {@code [lo, hi]}.\n      * @param hi Higher bound of the interval.\n@@ -85,8 +83,7 @@ public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n      * @throws FunctionEvaluationException if an error occurs evaluating\n      * the function.\n      */\n-    private double localMin(UnivariateRealFunction f,\n-                            GoalType goalType,\n+    private double localMin(boolean isMinim,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n@@ -108,16 +105,16 @@ private double localMin(UnivariateRealFunction f,\n         double x = mid;\n         double v = x;\n         double w = x;\n+        double d = 0;\n         double e = 0;\n-        double fx = computeObjectiveValue(f, x);\n-        if (goalType == GoalType.MAXIMIZE) {\n+        double fx = computeObjectiveValue(x);\n+        if (!isMinim) {\n             fx = -fx;\n         }\n         double fv = fx;\n         double fw = fx;\n \n-        int count = 0;\n-        while (count < maximalIterationCount) {\n+        while (true) {\n             double m = 0.5 * (a + b);\n             final double tol1 = eps * Math.abs(x) + t;\n             final double tol2 = 2 * tol1;\n@@ -127,7 +124,6 @@ private double localMin(UnivariateRealFunction f,\n                 double p = 0;\n                 double q = 0;\n                 double r = 0;\n-                double d = 0;\n                 double u = 0;\n \n                 if (Math.abs(e) > tol1) { // Fit parabola.\n@@ -191,8 +187,8 @@ private double localMin(UnivariateRealFunction f,\n                     u = x + d;\n                 }\n \n-                double fu = computeObjectiveValue(f, u);\n-                if (goalType == GoalType.MAXIMIZE) {\n+                double fu = computeObjectiveValue(u);\n+                if (!isMinim) {\n                     fu = -fu;\n                 }\n \n@@ -229,16 +225,10 @@ private double localMin(UnivariateRealFunction f,\n                     }\n                 }\n             } else { // termination\n-                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n+                setFunctionValue(isMinim ? fx : -fx);\n                 return x;\n             }\n-            ++count;\n+            incrementIterationsCounter();\n         }\n-        throw new MaxIterationsExceededException(maximalIterationCount);\n-    }\n-\n-    /** Temporary workaround. */\n-    protected double doOptimize() {\n-        throw new UnsupportedOperationException();\n     }\n }\n", "nb_test": 2251, "linesAdd": 20, "jira_id": "395", "singleLine": false, "nb_skipped": 0, "commit": "962315ba", "nb_failure": 4, "linesRem": 30}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCrossProductCancellation(org.apache.commons.math.geometry.Vector3DTest): expected:<1.0> but was:<0.0>"], "patch": "diff --git a/src/main/java/org/apache/commons/math/geometry/Vector3D.java b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\nindex 0a4adb8..2d915e5 100644\n--- a/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n@@ -454,10 +454,41 @@ public static double dotProduct(Vector3D v1, Vector3D v2) {\n    * @param v2 second vector\n    * @return the cross product v1 ^ v2 as a new Vector\n    */\n-  public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {\n-    return new Vector3D(v1.y * v2.z - v1.z * v2.y,\n-                        v1.z * v2.x - v1.x * v2.z,\n-                        v1.x * v2.y - v1.y * v2.x);\n+  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n+\n+      final double n1 = v1.getNormSq();\n+      final double n2 = v2.getNormSq();\n+      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n+          return ZERO;\n+      }\n+\n+      // rescale both vectors without losing precision,\n+      // to ensure their norm are the same order of magnitude\n+      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n+      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n+      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n+      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n+      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n+      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n+      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n+\n+      // we reduce cancellation errors by preconditioning,\n+      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n+      // v3 without loss of precision. See Kahan lecture\n+      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n+      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n+\n+      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n+      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n+      final double rho   = FastMath.rint(256 * ratio) / 256;\n+\n+      final double x3 = x1 - rho * x2;\n+      final double y3 = y1 - rho * y2;\n+      final double z3 = z1 - rho * z2;\n+\n+      // compute cross product from v3 and v2 instead of v1 and v2\n+      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n+\n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n", "nb_test": 2372, "linesAdd": 26, "jira_id": "554", "singleLine": false, "nb_skipped": 1, "commit": "fbbb96eb", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testIssue716(org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest): illegal state: maximal count (100) exceeded: evaluations"], "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bb..59dc461 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -232,10 +232,16 @@ protected double doSolve() {\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n+                final int p = agingA - MAXIMAL_AGING;\n+                final double weightA = (1 << p) - 1;\n+                final double weightB = p + 1;\n+                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n             } else if (agingB >= MAXIMAL_AGING) {\n                 // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+                final int p = agingB - MAXIMAL_AGING;\n+                final double weightA = p + 1;\n+                final double weightB = (1 << p) - 1;\n+                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n", "nb_test": 3150, "linesAdd": 8, "jira_id": "716", "singleLine": false, "nb_skipped": 1, "commit": "faa77857", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testMath519(org.apache.commons.math.optimization.fitting.GaussianFitterTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\nindex 725b5ca..e1b54f4 100644\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n@@ -21,10 +21,12 @@\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.function.Gaussian;\n+import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n@@ -61,25 +62,63 @@\n     /**\n      * Constructs an instance using the specified optimizer.\n      *\n-     * @param optimizer optimizer to use for the fitting\n+     * @param optimizer Optimizer to use for the fitting.\n      */\n     public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\n-        super(optimizer);;\n+        super(optimizer);\n     }\n \n+    /**\n+     * Fits a Gaussian function to the observed points.\n+     *\n+     * @param initialGuess First guess values in the following order:\n+     * <ul>\n+     *  <li>Norm</li>\n+     *  <li>Mean</li>\n+     *  <li>Sigma</li>\n+     * </ul>\n+     * @return the parameters of the Gaussian function that best fits the\n+     * observed points (in the same order as above).\n+     */\n+    public double[] fit(double[] initialGuess) {\n+        final ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n+                private final ParametricUnivariateRealFunction g = new Gaussian.Parametric();\n+\n+                public double value(double x, double[] p) {\n+                    double v = Double.POSITIVE_INFINITY;\n+                    try {\n+                        v = g.value(x, p);\n+                    } catch (NotStrictlyPositiveException e) {\n+                        // Do nothing.\n+                    }\n+                    return v;\n+                }\n+\n+                public double[] gradient(double x, double[] p) {\n+                    double[] v = { Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY };\n+                    try {\n+                        v = g.gradient(x, p);\n+                    } catch (NotStrictlyPositiveException e) {\n+                        // Do nothing.\n+                    }\n+                    return v;\n+                }\n+            };\n+\n+        return fit(f, initialGuess);\n+    }\n \n     /**\n-     * Fits Gaussian function to the observed points.\n-     * It will call the base class\n-     * {@link CurveFitter#fit(\n-     * org.apache.commons.math.analysis.ParametricUnivariateRealFunction,\n-     * double[]) fit} method.\n+     * Fits a Gaussian function to the observed points.\n      *\n-     * @return the Gaussian function that best fits the observed points.\n+     * @return the parameters of the Gaussian function that best fits the\n+     * observed points (in the same order as above).\n      */\n     public double[] fit() {\n-        return fit(new Gaussian.Parametric(),\n-                   (new ParameterGuesser(getObservations())).guess());\n+        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n+        return fit(guess);\n     }\n \n     /**\n@@ -112,7 +150,7 @@ public ParameterGuesser(WeightedObservedPoint[] observations) {\n         /**\n          * Guesses the parameters based on the observed points.\n          *\n-         * @return guessed parameters array <code>{norm, mean, sigma}</code>\n+         * @return the guessed parameters: norm, mean and sigma.\n          */\n         public double[] guess() {\n             if (parameters == null) {\n@@ -124,9 +162,8 @@ public ParameterGuesser(WeightedObservedPoint[] observations) {\n         /**\n          * Guesses the parameters based on the specified observed points.\n          *\n-         * @param points observed points upon which should base guess\n-         *\n-         * @return guessed parameters array <code>{norm, mean, sigma}</code>\n+         * @param points Observed points upon which should base guess.\n+         * @return the guessed parameters: norm, mean and sigma.\n          */\n         private double[] basicGuess(WeightedObservedPoint[] points) {\n             Arrays.sort(points, createWeightedObservedPointComparator());\n@@ -154,9 +190,8 @@ public ParameterGuesser(WeightedObservedPoint[] observations) {\n         /**\n          * Finds index of point in specified points with the largest Y.\n          *\n-         * @param points points to search\n-         *\n-         * @return index in specified points array\n+         * @param points Points to search.\n+         * @return the index in specified points array.\n          */\n         private int findMaxY(WeightedObservedPoint[] points) {\n             int maxYIdx = 0;\n@@ -169,20 +204,18 @@ private int findMaxY(WeightedObservedPoint[] points) {\n         }\n \n         /**\n-         * Interpolates using the specified points to determine X at the specified\n-         * Y.\n+         * Interpolates using the specified points to determine X at the\n+         * specified Y.\n          *\n-         * @param points points to use for interpolation\n-         * @param startIdx index within points from which to start search for\n-         *        interpolation bounds points\n-         * @param idxStep index step for search for interpolation bounds points\n-         * @param y Y value for which X should be determined\n-         *\n-         * @return value of X at the specified Y\n-         *\n-         * @throws IllegalArgumentException if idxStep is 0\n-         * @throws OutOfRangeException if specified <code>y</code> is not within the\n-         *         range of the specified <code>points</code>\n+         * @param points Points to use for interpolation.\n+         * @param startIdx Index within points from which to start search for\n+         *  interpolation bounds points.\n+         * @param idxStep Index step for search for interpolation bounds points.\n+         * @param y Y value for which X should be determined.\n+         * @return the value of X at the specified Y.\n+         * @throws ZeroException if {@code idxStep} is 0.\n+         * @throws OutOfRangeException if specified {@code y} is not within the\n+         * range of the specified {@code points}.\n          */\n         private double interpolateXAtY(WeightedObservedPoint[] points,\n                                        int startIdx, int idxStep, double y)\n@@ -208,18 +241,16 @@ private double interpolateXAtY(WeightedObservedPoint[] points,\n          * Gets the two bounding interpolation points from the specified points\n          * suitable for determining X at the specified Y.\n          *\n-         * @param points points to use for interpolation\n-         * @param startIdx index within points from which to start search for\n-         *        interpolation bounds points\n-         * @param idxStep index step for search for interpolation bounds points\n-         * @param y Y value for which X should be determined\n-         *\n-         * @return array containing two points suitable for determining X at the\n-         *         specified Y\n-         *\n-         * @throws IllegalArgumentException if idxStep is 0\n-         * @throws OutOfRangeException if specified <code>y</code> is not within the\n-         *         range of the specified <code>points</code>\n+         * @param points Points to use for interpolation.\n+         * @param startIdx Index within points from which to start search for\n+         * interpolation bounds points.\n+         * @param idxStep Index step for search for interpolation bounds points.\n+         * @param y Y value for which X should be determined.\n+         * @return the array containing two points suitable for determining X at\n+         * the specified Y.\n+         * @throws ZeroException if {@code idxStep} is 0.\n+         * @throws OutOfRangeException if specified {@code y} is not within the\n+         * range of the specified {@code points}.\n          */\n         private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points,\n                                                                    int startIdx, int idxStep, double y)\n@@ -250,13 +280,12 @@ private double interpolateXAtY(WeightedObservedPoint[] points,\n         /**\n          * Determines whether a value is between two other values.\n          *\n-         * @param value value to determine whether is between <code>boundary1</code>\n-         *        and <code>boundary2</code>\n-         * @param boundary1 one end of the range\n-         * @param boundary2 other end of the range\n-         *\n-         * @return true if <code>value</code> is between <code>boundary1</code> and\n-         *         <code>boundary2</code> (inclusive); false otherwise\n+         * @param value Value to determine whether is between {@code boundary1}\n+         * and {@code boundary2}.\n+         * @param boundary1 One end of the range.\n+         * @param boundary2 Other end of the range.\n+         * @return {@code true} if {@code value} is between {@code boundary1} and\n+         * {@code boundary2} (inclusive), {@code false} otherwise.\n          */\n         private boolean isBetween(double value, double boundary1, double boundary2) {\n             return (value >= boundary1 && value <= boundary2) ||\n@@ -264,10 +293,10 @@ private boolean isBetween(double value, double boundary1, double boundary2) {\n         }\n \n         /**\n-         * Factory method creating <code>Comparator</code> for comparing\n-         * <code>WeightedObservedPoint</code> instances.\n+         * Factory method creating {@code Comparator} for comparing\n+         * {@code WeightedObservedPoint} instances.\n          *\n-         * @return new <code>Comparator</code> instance\n+         * @return the new {@code Comparator} instance.\n          */\n         private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\n             return new Comparator<WeightedObservedPoint>() {\n", "nb_test": 2325, "linesAdd": 32, "jira_id": "519", "singleLine": false, "nb_skipped": 1, "commit": "26a61077", "nb_failure": 0, "linesRem": 3}, {"files": 3, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCircleFitting(org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex d1531a8..468dca7 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -561,7 +561,7 @@ private void findEigenVectors(double[][] householderMatrix) {\n                             z[ia][i] = c * z[ia][i] - s * p;\n                         }\n                     }\n-                    if (e[i + 1] == 0.0 && i >= j)\n+                    if (t == 0.0 && i >= j)\n                         continue;\n                     realEigenvalues[j] -= u;\n                     e[j] = q;\ndiff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\nindex 3abf3f0..597f6c4 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n@@ -141,7 +140,7 @@ public SingularValueDecompositionImpl(final RealMatrix matrix)\n             singularValues[i] = Math.sqrt(Math.abs(singularValues[i]));\n         }\n         // Up to this point, U and V are computed independently of each other.\n-        // There still an sign indetermination of each column of, say, U.\n+        // There still a sign indetermination of each column of, say, U.\n         // The sign is set such that A.V_i=sigma_i.U_i (i<=p)\n         // The right sign corresponds to a positive dot product of A.V_i and U_i\n         for (int i = 0; i < p; i++) {\ndiff --git a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 10f7762..5a60da8 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -237,23 +237,20 @@ protected void updateResidualsAndCost()\n      * @return RMS value\n      */\n     public double getRMS() {\n-        double criterion = 0;\n-        for (int i = 0; i < rows; ++i) {\n-            final double residual = residuals[i];\n-            criterion += residualsWeights[i] * residual * residual;\n-        }\n-        return Math.sqrt(criterion / rows);\n+        return Math.sqrt(getChiSquare() / rows);\n     }\n \n     /**\n-     * Get the Chi-Square value.\n+     * Get a Chi-Square-like value assuming the N residuals follow N\n+     * distinct normal distributions centered on 0 and whose variances are\n+     * the reciprocal of the weights.\n      * @return chi-square value\n      */\n     public double getChiSquare() {\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n-            chiSquare += residual * residual / residualsWeights[i];\n+            chiSquare += residual * residual * residualsWeights[i];\n         }\n         return chiSquare;\n     }\n", "nb_test": 2263, "linesAdd": 3, "jira_id": "377", "singleLine": false, "nb_skipped": 0, "commit": "c640932d", "nb_failure": 1, "linesRem": 8}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["EmpiricalDistributionTest.testKernelOverrideConstant:489 expected:<0.2> but was:<0.0>", "EmpiricalDistributionTest.testNoBinVariance:446 expected:<0.5> but was:<NaN>"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\nindex 3b3a864..61bb65b 100644\n--- a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n+++ b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n@@ -593,7 +593,9 @@ public double density(double x) {\n      * <li>Compute K(B) = the probability mass of B with respect to the within-bin kernel\n      * and K(B-) = the kernel distribution evaluated at the lower endpoint of B</li>\n      * <li>Return P(B-) + P(B) * [K(x) - K(B-)] / K(B) where\n-     * K(x) is the within-bin kernel distribution function evaluated at x.</li></ol></p>\n+     * K(x) is the within-bin kernel distribution function evaluated at x.</li></ol>\n+     * If K is a constant distribution, we return P(B-) + P(B) (counting the full\n+     * mass of B).</p>\n      *\n      * @since 3.1\n      */\n@@ -606,10 +608,13 @@ public double cumulativeProbability(double x) {\n         final int binIndex = findBin(x);\n         final double pBminus = pBminus(binIndex);\n         final double pB = pB(binIndex);\n+        final RealDistribution kernel = k(x);\n+        if (kernel instanceof ConstantRealDistribution) {\n+            return pBminus + pB;\n+        }\n         final double[] binBounds = getUpperBounds();\n         final double kB = kB(binIndex);\n         final double lower = binIndex == 0 ? min : binBounds[binIndex - 1];\n-        final RealDistribution kernel = k(x);\n         final double withinBinCum =\n             (kernel.cumulativeProbability(x) -  kernel.cumulativeProbability(lower)) / kB;\n         return pBminus + pB * withinBinCum;\n", "nb_test": 5851, "linesAdd": 4, "jira_id": "1203", "singleLine": false, "nb_skipped": 3, "commit": "b148046a", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testContinuous(org.apache.commons.math.distribution.AbstractRealDistributionTest)", "testDiscontinuous(org.apache.commons.math.distribution.AbstractRealDistributionTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\nindex a37d2d2..d83837d 100644\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n@@ -20,7 +20,6 @@\n \n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n-import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.OutOfRangeException;\n@@ -74,45 +72,76 @@ public double inverseCumulativeProbability(final double p) throws OutOfRangeExce\n             throw new OutOfRangeException(p, 0, 1);\n         }\n \n-        // by default, do simple root finding using bracketing and default solver.\n-        // subclasses can override if there is a better method.\n-        UnivariateFunction rootFindingFunction =\n-            new UnivariateFunction() {\n-            public double value(double x) {\n+        double lowerBound = getSupportLowerBound();\n+        if (p == 0.0) {\n+            return lowerBound;\n+        }\n+\n+        double upperBound = getSupportUpperBound();\n+        if (p == 1.0) {\n+            return upperBound;\n+        }\n+\n+        final double mu = getNumericalMean();\n+        final double sig = FastMath.sqrt(getNumericalVariance());\n+        final boolean chebyshevApplies;\n+        chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n+                             Double.isInfinite(sig) || Double.isNaN(sig));\n+\n+        if (lowerBound == Double.NEGATIVE_INFINITY) {\n+            if (chebyshevApplies) {\n+                lowerBound = mu - sig * FastMath.sqrt((1. - p) / p);\n+            } else {\n+                lowerBound = -1.0;\n+                while (cumulativeProbability(lowerBound) >= p) {\n+                    lowerBound *= 2.0;\n+                }\n+            }\n+        }\n+\n+        if (upperBound == Double.POSITIVE_INFINITY) {\n+            if (chebyshevApplies) {\n+                upperBound = mu + sig * FastMath.sqrt(p / (1. - p));\n+            } else {\n+                upperBound = 1.0;\n+                while (cumulativeProbability(upperBound) < p) {\n+                    upperBound *= 2.0;\n+                }\n+            }\n+        }\n+\n+        final UnivariateFunction toSolve = new UnivariateFunction() {\n+\n+            public double value(final double x) {\n                 return cumulativeProbability(x) - p;\n             }\n         };\n \n-        // Try to bracket root, test domain endpoints if this fails\n-        double lowerBound = getDomainLowerBound(p);\n-        double upperBound = getDomainUpperBound(p);\n-        double[] bracket = null;\n-        try {\n-            bracket = UnivariateRealSolverUtils.bracket(\n-                    rootFindingFunction, getInitialDomain(p),\n-                    lowerBound, upperBound);\n-        } catch (NumberIsTooLargeException ex) {\n-            /*\n-             * Check domain endpoints to see if one gives value that is within\n-             * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n-             * case if density has bounded support and p is 0 or 1).\n-             */\n-            if (FastMath.abs(rootFindingFunction.value(lowerBound)) < getSolverAbsoluteAccuracy()) {\n-                return lowerBound;\n+        double x = UnivariateRealSolverUtils.solve(toSolve,\n+                                                   lowerBound,\n+                                                   upperBound,\n+                                                   getSolverAbsoluteAccuracy());\n+\n+        if (!isSupportConnected()) {\n+            /* Test for plateau. */\n+            final double dx = getSolverAbsoluteAccuracy();\n+            if (x - dx >= getSupportLowerBound()) {\n+                double px = cumulativeProbability(x);\n+                if (cumulativeProbability(x - dx) == px) {\n+                    upperBound = x;\n+                    while (upperBound - lowerBound > dx) {\n+                        final double midPoint = 0.5 * (lowerBound + upperBound);\n+                        if (cumulativeProbability(midPoint) < px) {\n+                            lowerBound = midPoint;\n+                        } else {\n+                            upperBound = midPoint;\n+                        }\n                     }\n-            if (FastMath.abs(rootFindingFunction.value(upperBound)) < getSolverAbsoluteAccuracy()) {\n                     return upperBound;\n                 }\n-            // Failed bracket convergence was not because of corner solution\n-            throw new MathInternalError(ex);\n             }\n-\n-        // find root\n-        double root = UnivariateRealSolverUtils.solve(rootFindingFunction,\n-                // override getSolverAbsoluteAccuracy() to use a Brent solver with\n-                // absolute accuracy different from the default.\n-                bracket[0],bracket[1], getSolverAbsoluteAccuracy());\n-        return root;\n+        }\n+        return x;\n     }\n \n     /**\n", "nb_test": 3145, "linesAdd": 61, "jira_id": "699", "singleLine": false, "nb_skipped": 1, "commit": "b2e24119", "nb_failure": 0, "linesRem": 20}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath864(org.apache.commons.math3.optimization.direct.CMAESOptimizerTest): Out of bounds (0.5551955155096948 > 0.5)"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex d01cd15..b54cb37 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -24,9 +24,11 @@\n import org.apache.commons.math3.analysis.MultivariateFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n+import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.linear.EigenDecomposition;\n import org.apache.commons.math3.linear.MatrixUtils;\n@@ -414,7 +416,7 @@ protected PointValuePair doOptimize() {\n                     bestValue = bestFitness;\n                     lastResult = optimum;\n                     optimum = new PointValuePair(\n-                            fitfun.decode(bestArx.getColumn(0)),\n+                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                             isMinimize ? bestFitness : -bestFitness);\n                     if (getConvergenceChecker() != null && lastResult != null) {\n                         if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n@@ -913,6 +915,16 @@ public FitnessFunction() {\n \n         /**\n          * @param x Normalized objective variables.\n+         * @return the original objective variables, possibly repaired.\n+         */\n+        public double[] repairAndDecode(final double[] x) {\n+            return boundaries != null && isRepairMode ?\n+                decode(repair(x)) :\n+                decode(x);\n+        }\n+\n+        /**\n+         * @param x Normalized objective variables.\n          * @return the original objective variables.\n          */\n         public double[] decode(final double[] x) {\n", "nb_test": 4152, "linesAdd": 9, "jira_id": "864", "singleLine": false, "nb_skipped": 4, "commit": "abe53a53", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testRoundDouble(org.apache.commons.math.util.MathUtilsTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 85d9a04..52ebeb6 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -33,7 +33,6 @@\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-import org.apache.commons.math.exception.MathRuntimeException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.NotFiniteNumberException;\n \n@@ -1333,15 +1332,22 @@ public static double round(double x, int scale) {\n     }\n \n     /**\n-     * Round the given value to the specified number of decimal places. The\n+     * <p>Round the given value to the specified number of decimal places. The\n      * value is rounded using the given method which is any method defined in\n-     * {@link BigDecimal}.\n+     * {@link BigDecimal}.</p>\n+     *\n+     * <p>If {@code x} is infinite or NaN, then the value of {@code x} is\n+     * returned unchanged, regardless of the other parameters.</p>\n      *\n      * @param x the value to round.\n      * @param scale the number of digits to the right of the decimal point.\n      * @param roundingMethod the rounding method as defined in\n      *        {@link BigDecimal}.\n      * @return the rounded value.\n+     * @throws ArithmeticException if roundingMethod==ROUND_UNNECESSARY and the\n+     * specified scaling operation would require rounding.\n+     * @throws IllegalArgumentException if roundingMethod does not represent a\n+     * valid rounding mode.\n      * @since 1.1\n      */\n     public static double round(double x, int scale, int roundingMethod) {\n@@ -1356,8 +1362,6 @@ public static double round(double x, int scale, int roundingMethod) {\n             } else {\n                 return Double.NaN;\n             }\n-        } catch (RuntimeException ex) {\n-            throw new MathRuntimeException(ex);\n         }\n     }\n \n", "nb_test": 2372, "linesAdd": 0, "jira_id": "555", "singleLine": false, "nb_skipped": 1, "commit": "328513f3", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["IntervalTest.testStrictOrdering Expected exception: org.apache.commons.math4.exception.NumberIsTooSmallException"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Interval.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Interval.java\nindex 9785776..87dbba1 100644\n--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Interval.java\n+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Interval.java\n@@ -17,6 +17,8 @@\n package org.apache.commons.math4.geometry.euclidean.oned;\n \n import org.apache.commons.math4.geometry.partitioning.Region.Location;\n+import org.apache.commons.math4.exception.NumberIsTooSmallException;\n+import org.apache.commons.math4.exception.util.LocalizedFormats;\n \n \n /** This class represents a 1D interval.\n@@ -36,6 +38,10 @@\n      * @param upper upper bound of the interval\n      */\n     public Interval(final double lower, final double upper) {\n+        if (upper < lower) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n+                                                upper, lower, true);\n+        }\n         this.lower = lower;\n         this.upper = upper;\n     }\n", "nb_test": 5822, "linesAdd": 6, "jira_id": "1256", "singleLine": false, "nb_skipped": 3, "commit": "41f29780", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["PolygonsSetTest.testTooThinBox:1071 \u00bb NullPointer"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\nindex 3c1b26c..4d0c9d8 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -64,6 +64,16 @@ public PolygonsSet(final double tolerance) {\n      * cells). In order to avoid building too many small objects, it is\n      * recommended to use the predefined constants\n      * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n+     * <p>\n+     * This constructor is aimed at expert use, as building the tree may\n+     * be a difficult taks. It is not intended for general use and for\n+     * performances reasons does not check thoroughly its input, as this would\n+     * require walking the full tree each time. Failing to provide a tree with\n+     * the proper attributes, <em>will</em> therefore generate problems like\n+     * {@link NullPointerException} or {@link ClassCastException} only later on.\n+     * This limitation is known and explains why this constructor is for expert\n+     * use only. The caller does have the responsibility to provided correct arguments.\n+     * </p>\n      * @param tree inside/outside BSP tree representing the region\n      * @param tolerance tolerance below which points are considered identical\n      * @since 3.3\n@@ -219,6 +229,10 @@ public PolygonsSet(final double xMin, final double xMax,\n     private static Line[] boxBoundary(final double xMin, final double xMax,\n                                       final double yMin, final double yMax,\n                                       final double tolerance) {\n+        if ((xMin >= xMax - tolerance) || (yMin >= yMax - tolerance)) {\n+            // too thin box, build an empty polygons set\n+            return null;\n+        }\n         final Vector2D minMin = new Vector2D(xMin, yMin);\n         final Vector2D minMax = new Vector2D(xMin, yMax);\n         final Vector2D maxMin = new Vector2D(xMax, yMin);\n", "nb_test": 5958, "linesAdd": 3, "jira_id": "1117", "singleLine": false, "nb_skipped": 3, "commit": "f4c926ea", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["BinomialDistributionTest.testDegenerate2:141->IntegerDistributionAbstractTest.verifyDensities:158 Incorrect density value returned for 0 expected:<1.0> but was:<NaN>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java b/src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java\nindex 15747e1..9a882a0 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java\n@@ -106,6 +106,9 @@ public double probability(int x) {\n     /** {@inheritDoc} **/\n     @Override\n     public double logProbability(int x) {\n+        if (numberOfTrials == 0) {\n+            return (x == 0) ? 0. : Double.NEGATIVE_INFINITY;\n+        }\n         double ret;\n         if (x < 0 || x > numberOfTrials) {\n             ret = Double.NEGATIVE_INFINITY;\n", "nb_test": 6076, "linesAdd": 3, "jira_id": "1136", "singleLine": false, "nb_skipped": 3, "commit": "cc4ab51e", "nb_failure": 1, "rtElixir": true, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFloatEqualsWithAllowedUlps(org.apache.commons.math.util.MathUtilsTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex bd68523..f015cdb 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -82,6 +82,9 @@\n     /** Offset to order signed double numbers lexicographically. */\n     private static final long SGN_MASK = 0x8000000000000000L;\n \n+    /** Offset to order signed double numbers lexicographically. */\n+    private static final int SGN_MASK_FLOAT = 0x80000000;\n+\n     /** All long-representable factorials */\n     private static final long[] FACTORIALS = new long[] {\n                        1l,                  1l,                   2l,\n@@ -416,6 +419,160 @@ public static double cosh(double x) {\n \n     /**\n      * Returns true iff they are equal as defined by\n+     * {@link #equals(float,float,int) equals(x, y, 1)}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @return {@code true} if the values are equal.\n+     */\n+    public static boolean equals(float x, float y) {\n+        return equals(x, y, 1);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or neither is NaN and they are\n+     * equal as defined by {@link #equals(float,float) this method}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @return {@code true} if the values are equal or both are NaN.\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y) {\n+        return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, 1);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow.\n+     * @return {@code true} if the values are equal or within range of each other.\n+     */\n+    public static boolean equals(float x, float y, float eps) {\n+        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or are equal or within the range\n+     * of allowed error (inclusive).\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow.\n+     * @return {@code true} if the values are equal or within range of each other,\n+     * or both are NaN.\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y, float eps) {\n+        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n+     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n+     * point numbers are considered equal.\n+     * Adapted from <a\n+     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * Bruce Dawson</a>\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if there are fewer than {@code maxUlps} floating\n+     * point values between {@code x} and {@code y}.\n+     */\n+    public static boolean equals(float x, float y, int maxUlps) {\n+        // Check that \"maxUlps\" is non-negative and small enough so that\n+        // NaN won't compare as equal to anything (except another NaN).\n+        assert maxUlps > 0 && maxUlps < NAN_GAP;\n+\n+        int xInt = Float.floatToIntBits(x);\n+        int yInt = Float.floatToIntBits(y);\n+\n+        // Make lexicographically ordered as a two's-complement integer.\n+        if (xInt < 0) {\n+            xInt = SGN_MASK_FLOAT - xInt;\n+        }\n+        if (yInt < 0) {\n+            yInt = SGN_MASK_FLOAT - yInt;\n+        }\n+\n+        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+\n+        return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or if they are equal as defined\n+     * by {@link #equals(float,float,int) this method}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if both arguments are NaN or if there are less than\n+     * {@code maxUlps} floating point values between {@code x} and {@code y}.\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n+        return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, maxUlps);\n+    }\n+\n+    /**\n+     * Returns true iff both arguments are null or have same dimensions and all\n+     * their elements are equal as defined by\n+     * {@link #equals(float,float) this method}.\n+     *\n+     * @param x first array\n+     * @param y second array\n+     * @return true if the values are both null or have same dimension\n+     * and equal elements.\n+     */\n+    public static boolean equals(float[] x, float[] y) {\n+        if ((x == null) || (y == null)) {\n+            return !((x == null) ^ (y == null));\n+        }\n+        if (x.length != y.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < x.length; ++i) {\n+            if (!equals(x[i], y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true iff both arguments are null or have same dimensions and all\n+     * their elements are equal as defined by\n+     * {@link #equalsIncludingNaN(double,double) this method}.\n+     *\n+     * @param x first array\n+     * @param y second array\n+     * @return true if the values are both null or have same dimension and\n+     * equal elements\n+     */\n+    public static boolean equalsIncludingNaN(float[] x, float[] y) {\n+        if ((x == null) || (y == null)) {\n+            return !((x == null) ^ (y == null));\n+        }\n+        if (x.length != y.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < x.length; ++i) {\n+            if (!equalsIncludingNaN(x[i], y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true iff they are equal as defined by\n      * {@link #equals(double,double,int) equals(x, y, 1)}.\n      *\n      * @param x first value\n", "nb_test": 2225, "linesAdd": 70, "jira_id": "471", "singleLine": false, "nb_skipped": 1, "commit": "a4b1948b", "nb_failure": 1, "linesRem": 0}, {"files": 3, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["SphereGeneratorTest.testDegeneratedCase:175 expected:<0.003616820213530053> but was:<0.0036167797421054544>", "WelzlEncloser3DTest.testReducingBall:70 \u00bb MathInternal illegal state: internal..."], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\nindex 1bacb25..12a645f 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n@@ -100,7 +101,7 @@ public WelzlEncloser(final double tolerance, final SupportBallGenerator<S, P> ge\n             EnclosingBall<S, P> savedBall = ball;\n             ball = moveToFrontBall(extreme, extreme.size(), support);\n             if (ball.getRadius() < savedBall.getRadius()) {\n-                // TODO: fix this, it should never happen but it does!\n+                // this should never happen\n                 throw new MathInternalError();\n             }\n \ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java\nindex 03e4450..f5a6b7c 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java\n@@ -19,12 +19,13 @@\n import java.util.Arrays;\n import java.util.List;\n \n+import org.apache.commons.math3.fraction.BigFraction;\n import org.apache.commons.math3.geometry.enclosing.EnclosingBall;\n import org.apache.commons.math3.geometry.enclosing.SupportBallGenerator;\n import org.apache.commons.math3.geometry.euclidean.twod.DiskGenerator;\n import org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n-import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.FastMath;\n \n /** Class generating an enclosing ball from its support points.\n  * @version $Id$\n@@ -88,24 +89,39 @@\n                         //      z_0 = +m_14 / (2 m_11)\n                         // Note that the minors m_11, m_12, m_13 and m_14 all have the last column\n                         // filled with 1.0, hence simplifying the computation\n-                        final double[] c1 = new double[] {\n-                            vA.getNormSq(), vB.getNormSq(), vC.getNormSq(), vD.getNormSq()\n+                        final BigFraction[] c2 = new BigFraction[] {\n+                            new BigFraction(vA.getX()), new BigFraction(vB.getX()),\n+                            new BigFraction(vC.getX()), new BigFraction(vD.getX())\n                         };\n-                        final double[] c2 = new double[] {\n-                            vA.getX(), vB.getX(), vC.getX(), vD.getX()\n+                        final BigFraction[] c3 = new BigFraction[] {\n+                            new BigFraction(vA.getY()), new BigFraction(vB.getY()),\n+                            new BigFraction(vC.getY()), new BigFraction(vD.getY())\n                         };\n-                        final double[] c3 = new double[] {\n-                            vA.getY(), vB.getY(), vC.getY(), vD.getY()\n+                        final BigFraction[] c4 = new BigFraction[] {\n+                            new BigFraction(vA.getZ()), new BigFraction(vB.getZ()),\n+                            new BigFraction(vC.getZ()), new BigFraction(vD.getZ())\n                         };\n-                        final double[] c4 = new double[] {\n-                            vA.getZ(), vB.getZ(), vC.getZ(), vD.getZ()\n+                        final BigFraction[] c1 = new BigFraction[] {\n+                            c2[0].multiply(c2[0]).add(c3[0].multiply(c3[0])).add(c4[0].multiply(c4[0])),\n+                            c2[1].multiply(c2[1]).add(c3[1].multiply(c3[1])).add(c4[1].multiply(c4[1])),\n+                            c2[2].multiply(c2[2]).add(c3[2].multiply(c3[2])).add(c4[2].multiply(c4[2])),\n+                            c2[3].multiply(c2[3]).add(c3[3].multiply(c3[3])).add(c4[3].multiply(c4[3]))\n                         };\n-                        final double m11 = minor(c2, c3, c4);\n-                        final double m12 = minor(c1, c3, c4);\n-                        final double m13 = minor(c1, c2, c4);\n-                        final double m14 = minor(c1, c2, c3);\n-                        final Vector3D center = new Vector3D(0.5 * m12 / m11, -0.5 * m13 / m11, 0.5 * m14 / m11);\n-                        return new EnclosingBall<Euclidean3D, Vector3D>(center, center.distance(vA),\n+                        final BigFraction twoM11  = minor(c2, c3, c4).multiply(2);\n+                        final BigFraction m12     = minor(c1, c3, c4);\n+                        final BigFraction m13     = minor(c1, c2, c4);\n+                        final BigFraction m14     = minor(c1, c2, c3);\n+                        final BigFraction centerX = m12.divide(twoM11);\n+                        final BigFraction centerY = m13.divide(twoM11).negate();\n+                        final BigFraction centerZ = m14.divide(twoM11);\n+                        final BigFraction dx      = c2[0].subtract(centerX);\n+                        final BigFraction dy      = c3[0].subtract(centerY);\n+                        final BigFraction dz      = c4[0].subtract(centerZ);\n+                        final BigFraction r2      = dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));\n+                        return new EnclosingBall<Euclidean3D, Vector3D>(new Vector3D(centerX.doubleValue(),\n+                                                                                     centerY.doubleValue(),\n+                                                                                     centerZ.doubleValue()),\n+                                                                        FastMath.sqrt(r2.doubleValue()),\n                                                                         vA, vB, vC, vD);\n                     }\n                 }\n@@ -114,41 +130,24 @@\n     }\n \n     /** Compute a dimension 4 minor, when 4<sup>th</sup> column is known to be filled with 1.0.\n-     * <p>\n-     * The computation is performed using {@link MathArrays#linearCombination(double[], double[])\n-     * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce\n-     * risks in case of near co-planar points.\n-     * </p>\n      * @param c1 first column\n      * @param c2 second column\n      * @param c3 third column\n-     * @return value of the minor computed to high accuracy\n+     * @return value of the minor computed has an exact fraction\n      */\n-    private double minor(final double[] c1, final double[] c2, final double[] c3) {\n-        final double m01 = c2[0] * c3[1];\n-        final double m02 = c2[0] * c3[2];\n-        final double m03 = c2[0] * c3[3];\n-        final double m10 = c2[1] * c3[0];\n-        final double m12 = c2[1] * c3[2];\n-        final double m13 = c2[1] * c3[3];\n-        final double m20 = c2[2] * c3[0];\n-        final double m21 = c2[2] * c3[1];\n-        final double m23 = c2[2] * c3[3];\n-        final double m30 = c2[3] * c3[0];\n-        final double m31 = c2[3] * c3[1];\n-        final double m32 = c2[3] * c3[2];\n-        return MathArrays.linearCombination(new double[] {\n-                                                c1[2], c1[1], c1[3], -c1[1], -c1[3], -c1[2],\n-                                                c1[0], c1[3], c1[2], -c1[3], -c1[0], -c1[2],\n-                                                c1[1], c1[0], c1[3], -c1[0], -c1[3], -c1[1],\n-                                                c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1]\n-                                            },\n-                                            new double[] {\n-                                                m13, m32, m21, m23, m12, m31,\n-                                                m23, m02, m30, m20, m32, m03,\n-                                                m03, m31, m10, m13, m01, m30,\n-                                                m12, m01, m20, m10, m21, m02\n-                                            });\n+    private BigFraction minor(final BigFraction[] c1, final BigFraction[] c2, final BigFraction[] c3) {\n+        return      c2[0].multiply(c3[1]).multiply(c1[2].subtract(c1[3])).\n+                add(c2[0].multiply(c3[2]).multiply(c1[3].subtract(c1[1]))).\n+                add(c2[0].multiply(c3[3]).multiply(c1[1].subtract(c1[2]))).\n+                add(c2[1].multiply(c3[0]).multiply(c1[3].subtract(c1[2]))).\n+                add(c2[1].multiply(c3[2]).multiply(c1[0].subtract(c1[3]))).\n+                add(c2[1].multiply(c3[3]).multiply(c1[2].subtract(c1[0]))).\n+                add(c2[2].multiply(c3[0]).multiply(c1[1].subtract(c1[3]))).\n+                add(c2[2].multiply(c3[1]).multiply(c1[3].subtract(c1[0]))).\n+                add(c2[2].multiply(c3[3]).multiply(c1[0].subtract(c1[1]))).\n+                add(c2[3].multiply(c3[0]).multiply(c1[2].subtract(c1[1]))).\n+                add(c2[3].multiply(c3[1]).multiply(c1[0].subtract(c1[2]))).\n+                add(c2[3].multiply(c3[2]).multiply(c1[1].subtract(c1[0])));\n     }\n \n }\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java\nindex 514df14..d06c013 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java\n@@ -18,9 +18,10 @@\n \n import java.util.List;\n \n+import org.apache.commons.math3.fraction.BigFraction;\n import org.apache.commons.math3.geometry.enclosing.EnclosingBall;\n import org.apache.commons.math3.geometry.enclosing.SupportBallGenerator;\n-import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.FastMath;\n \n /** Class generating an enclosing ball from its support points.\n  * @version $Id$\n@@ -66,42 +67,43 @@\n                     //      y_0 = -m_13 / (2 m_11)\n                     // Note that the minors m_11, m_12 and m_13 all have the last column\n                     // filled with 1.0, hence simplifying the computation\n-                    final double[] c1 = new double[] {\n-                        vA.getNormSq(), vB.getNormSq(), vC.getNormSq()\n+                    final BigFraction[] c2 = new BigFraction[] {\n+                        new BigFraction(vA.getX()), new BigFraction(vB.getX()), new BigFraction(vC.getX())\n                     };\n-                    final double[] c2 = new double[] {\n-                        vA.getX(), vB.getX(), vC.getX()\n+                    final BigFraction[] c3 = new BigFraction[] {\n+                        new BigFraction(vA.getY()), new BigFraction(vB.getY()), new BigFraction(vC.getY())\n                     };\n-                    final double[] c3 = new double[] {\n-                        vA.getY(), vB.getY(), vC.getY()\n+                    final BigFraction[] c1 = new BigFraction[] {\n+                        c2[0].multiply(c2[0]).add(c3[0].multiply(c3[0])),\n+                        c2[1].multiply(c2[1]).add(c3[1].multiply(c3[1])),\n+                        c2[2].multiply(c2[2]).add(c3[2].multiply(c3[2]))\n                     };\n-                    final double m11 = minor(c2, c3);\n-                    final double m12 = minor(c1, c3);\n-                    final double m13 = minor(c1, c2);\n-                    final Vector2D center = new Vector2D(0.5 * m12 / m11, -0.5 * m13 / m11);\n-                    return new EnclosingBall<Euclidean2D, Vector2D>(center, center.distance(vA), vA, vB, vC);\n+                    final BigFraction twoM11  = minor(c2, c3).multiply(2);\n+                    final BigFraction m12     = minor(c1, c3);\n+                    final BigFraction m13     = minor(c1, c2);\n+                    final BigFraction centerX = m12.divide(twoM11);\n+                    final BigFraction centerY = m13.divide(twoM11).negate();\n+                    final BigFraction dx      = c2[0].subtract(centerX);\n+                    final BigFraction dy      = c3[0].subtract(centerY);\n+                    final BigFraction r2      = dx.multiply(dx).add(dy.multiply(dy));\n+                    return new EnclosingBall<Euclidean2D, Vector2D>(new Vector2D(centerX.doubleValue(),\n+                                                                                 centerY.doubleValue()),\n+                                                                    FastMath.sqrt(r2.doubleValue()),\n+                                                                    vA, vB, vC);\n                 }\n             }\n         }\n     }\n \n     /** Compute a dimension 3 minor, when 3<sup>d</sup> column is known to be filled with 1.0.\n-     * <p>\n-     * The computation is performed using {@link MathArrays#linearCombination(double[], double[])\n-     * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce\n-     * risks in case of near co-planar points.\n-     * </p>\n      * @param c1 first column\n      * @param c2 second column\n-     * @return value of the minor computed to high accuracy\n+     * @return value of the minor computed has an exact fraction\n      */\n-    private double minor(final double[] c1, final double[] c2) {\n-        return MathArrays.linearCombination(new double[] {\n-                                                c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1]\n-                                            },\n-                                            new double[] {\n-                                                c2[1], c2[0], c2[2],  c2[1],  c2[2],  c2[0]\n-                                            });\n+    private BigFraction minor(final BigFraction[] c1, final BigFraction[] c2) {\n+        return      c2[0].multiply(c1[2].subtract(c1[1])).\n+                add(c2[1].multiply(c1[0].subtract(c1[2]))).\n+                add(c2[2].multiply(c1[1].subtract(c1[0])));\n     }\n \n }\n", "nb_test": 5671, "linesAdd": 70, "jira_id": "1096", "singleLine": false, "nb_skipped": 5, "commit": "19c1c3bb", "nb_failure": 1, "linesRem": 59}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOuterProductSameType(org.apache.commons.math3.linear.RealVectorTest): NaN * 0.0 expected:<NaN> but was:<0.0>", "testOuterProductMixedTypes(org.apache.commons.math3.linear.RealVectorTest): NaN * 0.0 expected:<NaN> but was:<0.0>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/RealVector.java b/src/main/java/org/apache/commons/math3/linear/RealVector.java\nindex 89611c3..f05ea4d 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVector.java\n@@ -642,27 +642,20 @@ public RealVector mapDivideToSelf(double d){\n      * @return the matrix outer product between this instance and {@code v}.\n      */\n     public RealMatrix outerProduct(RealVector v) {\n-        RealMatrix product;\n+        final int m = this.getDimension();\n+        final int n = v.getDimension();\n+        final RealMatrix product;\n         if (v instanceof SparseRealVector || this instanceof SparseRealVector) {\n-            product = new OpenMapRealMatrix(this.getDimension(),\n-                                            v.getDimension());\n+            product = new OpenMapRealMatrix(m, n);\n         } else {\n-            product = new Array2DRowRealMatrix(this.getDimension(),\n-                                               v.getDimension());\n+            product = new Array2DRowRealMatrix(m, n);\n         }\n-        Iterator<Entry> thisIt = sparseIterator();\n-        while (thisIt.hasNext()) {\n-            final Entry thisE = thisIt.next();\n-            Iterator<Entry> otherIt = v.sparseIterator();\n-            while (otherIt.hasNext()) {\n-                final Entry otherE = otherIt.next();\n-                product.setEntry(thisE.getIndex(), otherE.getIndex(),\n-                                 thisE.getValue() * otherE.getValue());\n+        for (int i = 0; i < m; i++) {\n+            for (int j = 0; j < n; j++) {\n+                product.setEntry(i, j, this.getEntry(i) * v.getEntry(j));\n             }\n         }\n-\n         return product;\n-\n     }\n \n     /**\n", "nb_test": 3751, "linesAdd": 8, "jira_id": "812", "singleLine": false, "nb_skipped": 3, "commit": "607c9ec6", "nb_failure": 2, "linesRem": 15}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testNextExponential(org.apache.commons.math.random.AbstractRandomGeneratorTest)", "testNextExponential(org.apache.commons.math.random.RandomAdaptorTest)", "testNextExponential(org.apache.commons.math.random.RandomDataTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\nindex d5d2474..a44720f 100644\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n@@ -457,12 +457,11 @@ public double nextGaussian(double mu, double sigma) {\n      * uniform deviates.\n      * </p>\n      *\n-     * @param mean\n-     *            the mean of the distribution\n+     * @param mean the mean of the distribution\n      * @return the random Exponential value\n      */\n     public double nextExponential(double mean) {\n-        if (mean < 0.0) {\n+        if (mean <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"mean must be positive ({0})\", mean);\n         }\n", "nb_test": 2085, "linesAdd": 1, "jira_id": "309", "singleLine": false, "nb_skipped": 0, "commit": "0596e314", "nb_failure": 3, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath785(org.apache.commons.math3.distribution.FDistributionTest): Failing to calculate inverse cumulative probability", "testMath718(org.apache.commons.math3.distribution.BinomialDistributionTest): expected:<250000> but was:<249762>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java b/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\nindex 35fe916..253f3c5 100644\n--- a/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n+++ b/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n@@ -101,19 +101,18 @@ public double evaluate(double x, int maxIterations) {\n      * </p>\n      *\n      * <p>\n-     * The implementation of this method is based on equations 14-17 of:\n+     * The implementation of this method is based on the modified Lentz algorithm as described\n+     * on page 18 ff. in:\n      * <ul>\n      * <li>\n-     *   Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n-     *   Resource. <a target=\"_blank\"\n-     *   href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n-     *   http://mathworld.wolfram.com/ContinuedFraction.html</a>\n+     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n+     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n+     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n      * </li>\n      * </ul>\n-     * The recurrence relationship defined in those equations can result in\n-     * very large intermediate results which can result in numerical overflow.\n-     * As a means to combat these overflow conditions, the intermediate results\n-     * are scaled whenever they threaten to become numerically unstable.</p>\n+     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n+     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n+     * </p>\n      *\n      * @param x the evaluation point.\n      * @param epsilon maximum error allowed.\n@@ -122,72 +121,53 @@ public double evaluate(double x, int maxIterations) {\n      * @throws ConvergenceException if the algorithm fails to converge.\n      */\n     public double evaluate(double x, double epsilon, int maxIterations) {\n-        double p0 = 1.0;\n-        double p1 = getA(0, x);\n-        double q0 = 0.0;\n-        double q1 = 1.0;\n-        double c = p1 / q1;\n-        int n = 0;\n-        double relativeError = Double.MAX_VALUE;\n-        while (n < maxIterations && relativeError > epsilon) {\n-            ++n;\n-            double a = getA(n, x);\n-            double b = getB(n, x);\n-            double p2 = a * p1 + b * p0;\n-            double q2 = a * q1 + b * q0;\n-            boolean infinite = false;\n-            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n-                /*\n-                 * Need to scale. Try successive powers of the larger of a or b\n-                 * up to 5th power. Throw ConvergenceException if one or both\n-                 * of p2, q2 still overflow.\n-                 */\n-                double scaleFactor = 1d;\n-                double lastScaleFactor = 1d;\n-                final int maxPower = 5;\n-                final double scale = FastMath.max(a,b);\n-                if (scale <= 0) {  // Can't scale\n-                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n-                                                   x);\n-                }\n-                infinite = true;\n-                for (int i = 0; i < maxPower; i++) {\n-                    lastScaleFactor = scaleFactor;\n-                    scaleFactor *= scale;\n-                    if (a != 0.0 && a > b) {\n-                        p2 = p1 / lastScaleFactor + (b / scaleFactor * p0);\n-                        q2 = q1 / lastScaleFactor + (b / scaleFactor * q0);\n-                    } else if (b != 0) {\n-                        p2 = (a / scaleFactor * p1) + p0 / lastScaleFactor;\n-                        q2 = (a / scaleFactor * q1) + q0 / lastScaleFactor;\n-                    }\n-                    infinite = Double.isInfinite(p2) || Double.isInfinite(q2);\n-                    if (!infinite) {\n-                        break;\n+        final double small = 1e-50;\n+        double hPrev = getA(0, x);\n+\n+        // use the value of small as epsilon criteria for zero checks\n+        if (Precision.equals(hPrev, 0.0, small)) {\n+            hPrev = small;\n         }\n+\n+        int n = 1;\n+        double dPrev = 0.0;\n+        double cPrev = hPrev;\n+        double hN = hPrev;\n+\n+        while (n < maxIterations) {\n+            final double a = getA(n, x);\n+            final double b = getB(n, x);\n+\n+            double dN = a + b * dPrev;\n+            if (Precision.equals(dN, 0.0, small)) {\n+                dN = small;\n             }\n+            double cN = a + b / cPrev;\n+            if (Precision.equals(cN, 0.0, small)) {\n+                cN = small;\n             }\n \n-            if (infinite) {\n-               // Scaling failed\n+            dN = 1 / dN;\n+            final double deltaN = cN * dN;\n+            hN = hPrev * deltaN;\n+\n+            if (Double.isInfinite(hN)) {\n                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                                x);\n             }\n-\n-            double r = p2 / q2;\n-\n-            if (Double.isNaN(r)) {\n+            if (Double.isNaN(hN)) {\n                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                                x);\n             }\n-            relativeError = FastMath.abs(r / c - 1.0);\n-\n-            // prepare for next iteration\n-            c = p2 / q2;\n-            p0 = p1;\n-            p1 = p2;\n-            q0 = q1;\n-            q1 = q2;\n+\n+            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n+                break;\n+            }\n+\n+            dPrev = dN;\n+            cPrev = cN;\n+            hPrev = hN;\n+            n++;\n         }\n \n         if (n >= maxIterations) {\n@@ -195,6 +175,7 @@ public double evaluate(double x, double epsilon, int maxIterations) {\n                                                 maxIterations, x);\n         }\n \n-        return c;\n+        return hN;\n     }\n+\n }\n", "nb_test": 3549, "linesAdd": 38, "jira_id": "718", "singleLine": false, "nb_skipped": 1, "commit": "3a08bfa6", "nb_failure": 2, "linesRem": 50}, {"files": 1, "project": "commons-math", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["GammaTest.testDigammaNonRealArgs \u00bb StackOverflow", "GammaTest.testTrigammaNonRealArgs \u00bb StackOverflow"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/special/Gamma.java b/src/main/java/org/apache/commons/math4/special/Gamma.java\nindex eb3fb5b..aa0e90c 100644\n--- a/src/main/java/org/apache/commons/math4/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math4/special/Gamma.java\n@@ -442,6 +442,10 @@ protected double getB(int n, double x) {\n      * @since 2.0\n      */\n     public static double digamma(double x) {\n+        if (Double.isNaN(x) || Double.isInfinite(x)) {\n+            return x;\n+        }\n+\n         if (x > 0 && x <= S_LIMIT) {\n             // use method 5 from Bernardo AS103\n             // accurate to O(x)\n@@ -472,6 +476,10 @@ public static double digamma(double x) {\n      * @since 2.0\n      */\n     public static double trigamma(double x) {\n+        if (Double.isNaN(x) || Double.isInfinite(x)) {\n+            return x;\n+        }\n+\n         if (x > 0 && x <= S_LIMIT) {\n             return 1 / (x * x);\n         }\n", "nb_test": 5813, "linesAdd": 8, "jira_id": "1241", "singleLine": false, "nb_skipped": 3, "commit": "471e6b07", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAdapter(org.apache.commons.math3.random.SynchronizedRandomGeneratorTest): expected:<85> but was:<-1487906057>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/random/SynchronizedRandomGenerator.java b/src/main/java/org/apache/commons/math3/random/SynchronizedRandomGenerator.java\nindex 54c006d..d28f74b 100644\n--- a/src/main/java/org/apache/commons/math3/random/SynchronizedRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/SynchronizedRandomGenerator.java\n@@ -82,7 +82,7 @@ public synchronized int nextInt() {\n      * {@inheritDoc}\n      */\n     public synchronized int nextInt(int n) {\n-        return wrapped.nextInt();\n+        return wrapped.nextInt(n);\n     }\n \n     /**\n", "nb_test": 4224, "linesAdd": 1, "jira_id": "899", "singleLine": false, "nb_skipped": 4, "commit": "ce126bdb", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["FastMathTest.testIntPowLongMinValue:1237 \u00bb  test timed out after 5000 millisec..."], "patch": "diff --git a/src/main/java/org/apache/commons/math4/util/FastMath.java b/src/main/java/org/apache/commons/math4/util/FastMath.java\nindex a4a9a1b..46c8752 100644\n--- a/src/main/java/org/apache/commons/math4/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math4/util/FastMath.java\n@@ -1711,7 +1711,7 @@ public Split reciprocal() {\n         }\n \n         /** Computes this^e.\n-         * @param e exponent (beware, here it MUST be > 0)\n+         * @param e exponent (beware, here it MUST be > 0; the only exclusion is Long.MIN_VALUE)\n          * @return d^e, split in high and low bits\n          * @since 4.0\n          */\n@@ -1723,7 +1723,7 @@ private Split pow(final long e) {\n             // d^(2p)\n             Split d2p = new Split(full, high, low);\n \n-            for (long p = e; p != 0; p >>= 1) {\n+            for (long p = e; p != 0; p >>>= 1) {\n \n                 if ((p & 0x1) != 0) {\n                     // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm\n", "nb_test": 5847, "linesAdd": 1, "jira_id": "1272", "singleLine": false, "nb_skipped": 3, "commit": "26e878ab", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testIssue639(org.apache.commons.math.geometry.euclidean.threed.RotationTest): expected:<0.6228370359608201> but was:<NaN>"], "patch": "diff --git a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\nindex bfa7f26..ada0a8f 100644\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n@@ -313,92 +313,51 @@ public Rotation(double[][] m, double threshold)\n   public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n \n   // norms computation\n-  double u1u1 = Vector3D.dotProduct(u1, u1);\n-  double u2u2 = Vector3D.dotProduct(u2, u2);\n-  double v1v1 = Vector3D.dotProduct(v1, v1);\n-  double v2v2 = Vector3D.dotProduct(v2, v2);\n+  double u1u1 = u1.getNormSq();\n+  double u2u2 = u2.getNormSq();\n+  double v1v1 = v1.getNormSq();\n+  double v2v2 = v2.getNormSq();\n   if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n     throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n   }\n \n-  double u1x = u1.getX();\n-  double u1y = u1.getY();\n-  double u1z = u1.getZ();\n-\n-  double u2x = u2.getX();\n-  double u2y = u2.getY();\n-  double u2z = u2.getZ();\n-\n   // normalize v1 in order to have (v1'|v1') = (u1|u1)\n-  double coeff = FastMath.sqrt (u1u1 / v1v1);\n-  double v1x   = coeff * v1.getX();\n-  double v1y   = coeff * v1.getY();\n-  double v1z   = coeff * v1.getZ();\n-  v1 = new Vector3D(v1x, v1y, v1z);\n-\n-  // adjust v2 in order to have (u1|u2) = (v1|v2) and (v2'|v2') = (u2|u2)\n-  double u1u2   = Vector3D.dotProduct(u1, u2);\n-  double v1v2   = Vector3D.dotProduct(v1, v2);\n+  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n+\n+  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n+  double u1u2   = u1.dotProduct(u2);\n+  double v1v2   = v1.dotProduct(v2);\n   double coeffU = u1u2 / u1u1;\n   double coeffV = v1v2 / u1u1;\n   double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n   double alpha  = coeffU - beta * coeffV;\n-  double v2x    = alpha * v1x + beta * v2.getX();\n-  double v2y    = alpha * v1y + beta * v2.getY();\n-  double v2z    = alpha * v1z + beta * v2.getZ();\n-  v2 = new Vector3D(v2x, v2y, v2z);\n-\n-  // preliminary computation (we use explicit formulation instead\n-  // of relying on the Vector3D class in order to avoid building lots\n-  // of temporary objects)\n+  v2 = new Vector3D(alpha, v1, beta, v2);\n+\n+  // preliminary computation\n   Vector3D uRef  = u1;\n   Vector3D vRef  = v1;\n-  double dx1 = v1x - u1.getX();\n-  double dy1 = v1y - u1.getY();\n-  double dz1 = v1z - u1.getZ();\n-  double dx2 = v2x - u2.getX();\n-  double dy2 = v2y - u2.getY();\n-  double dz2 = v2z - u2.getZ();\n-  Vector3D k = new Vector3D(dy1 * dz2 - dz1 * dy2,\n-                            dz1 * dx2 - dx1 * dz2,\n-                            dx1 * dy2 - dy1 * dx2);\n-  double c = k.getX() * (u1y * u2z - u1z * u2y) +\n-             k.getY() * (u1z * u2x - u1x * u2z) +\n-             k.getZ() * (u1x * u2y - u1y * u2x);\n-\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is in the (u1, u2) plane\n+  Vector3D v1Su1 = v1.subtract(u1);\n+  Vector3D v2Su2 = v2.subtract(u2);\n+  Vector3D k     = v1Su1.crossProduct(v2Su2);\n+  Vector3D u3    = u1.crossProduct(u2);\n+  double c       = k.dotProduct(u3);\n+  final double inPlaneThreshold = 0.001;\n+  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n+    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n     // we try other vectors\n-    Vector3D u3 = Vector3D.crossProduct(u1, u2);\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    double u3x  = u3.getX();\n-    double u3y  = u3.getY();\n-    double u3z  = u3.getZ();\n-    double v3x  = v3.getX();\n-    double v3y  = v3.getY();\n-    double v3z  = v3.getZ();\n-\n-    double dx3 = v3x - u3x;\n-    double dy3 = v3y - u3y;\n-    double dz3 = v3z - u3z;\n-    k = new Vector3D(dy1 * dz3 - dz1 * dy3,\n-                     dz1 * dx3 - dx1 * dz3,\n-                     dx1 * dy3 - dy1 * dx3);\n-    c = k.getX() * (u1y * u3z - u1z * u3y) +\n-        k.getY() * (u1z * u3x - u1x * u3z) +\n-        k.getZ() * (u1x * u3y - u1y * u3x);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is aligned with u1:\n-      // we try (u2, u3) and (v2, v3)\n-      k = new Vector3D(dy2 * dz3 - dz2 * dy3,\n-                       dz2 * dx3 - dx2 * dz3,\n-                       dx2 * dy3 - dy2 * dx3);\n-      c = k.getX() * (u2y * u3z - u2z * u3y) +\n-          k.getY() * (u2z * u3x - u2x * u3z) +\n-          k.getZ() * (u2x * u3y - u2y * u3x);\n-\n-      if (c == 0) {\n+    Vector3D v3Su3 = v3.subtract(u3);\n+    k = v1Su1.crossProduct(v3Su3);\n+    Vector3D u2Prime = u1.crossProduct(u3);\n+    c = k.dotProduct(u2Prime);\n+\n+    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n+      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n+      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n+      k = v2Su2.crossProduct(v3Su3);;\n+      c = k.dotProduct(u2.crossProduct(u3));;\n+\n+      if (c <= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n@@ -427,8 +386,7 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                     uRef.getZ() * q1 - uRef.getX() * q3,\n                     uRef.getX() * q2 - uRef.getY() * q1);\n-   c = Vector3D.dotProduct(k, k);\n-  q0 = Vector3D.dotProduct(vRef, k) / (c + c);\n+  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n \n   }\n \n@@ -452,7 +410,7 @@ public Rotation(Vector3D u, Vector3D v) {\n         throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n     }\n \n-    double dot = Vector3D.dotProduct(u, v);\n+    double dot = u.dotProduct(v);\n \n     if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n       // special case u = -v: we select a PI angle rotation around\n@@ -467,9 +425,10 @@ public Rotation(Vector3D u, Vector3D v) {\n       // the shortest possible rotation: axis orthogonal to this plane\n       q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));\n       double coeff = 1.0 / (2.0 * q0 * normProduct);\n-      q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());\n-      q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());\n-      q3 = coeff * (v.getX() * u.getY() - v.getY() * u.getX());\n+      Vector3D q = v.crossProduct(u);\n+      q1 = coeff * q.getX();\n+      q2 = coeff * q.getY();\n+      q3 = coeff * q.getZ();\n     }\n \n   }\n", "nb_test": 2888, "linesAdd": 33, "jira_id": "639", "singleLine": false, "nb_skipped": 1, "commit": "8b418000", "nb_failure": 1, "linesRem": 72}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAddNaN(org.apache.commons.math.complex.ComplexTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex e0a8e97..ab58c78 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -150,6 +150,9 @@ public double abs() {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n+        if (isNaN || rhs.isNaN) {\n+            return NaN;\n+        }\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n", "nb_test": 2495, "linesAdd": 3, "jira_id": "618", "singleLine": false, "nb_skipped": 1, "commit": "2123f780", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDoubleValueForLargeNumeratorAndDenominator(org.apache.commons.math.fraction.BigFractionTest): expected:<5.0> but was:<NaN>", "testFloatValueForLargeNumeratorAndDenominator(org.apache.commons.math.fraction.BigFractionTest): expected:<5.0> but was:<NaN>"], "patch": "diff --git a/src/main/java/org/apache/commons/math/fraction/BigFraction.java b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\nindex e93d76d..a6672e4 100644\n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n@@ -682,7 +682,16 @@ public BigFraction divide(final BigFraction fraction) {\n      */\n     @Override\n     public double doubleValue() {\n-        return numerator.doubleValue() / denominator.doubleValue();\n+        double result = numerator.doubleValue() / denominator.doubleValue();\n+        if (Double.isNaN(result)) {\n+            // Numerator and/or denominator must be out of range:\n+            // Calculate how far to shift them to put them in range.\n+            int shift = Math.max(numerator.bitLength(),\n+                                 denominator.bitLength()) - Double.MAX_EXPONENT;\n+            result = numerator.shiftRight(shift).doubleValue() /\n+                denominator.shiftRight(shift).doubleValue();\n+        }\n+        return result;\n     }\n \n     /**\n@@ -726,7 +735,16 @@ public boolean equals(final Object other) {\n      */\n     @Override\n     public float floatValue() {\n-        return numerator.floatValue() / denominator.floatValue();\n+        float result = numerator.floatValue() / denominator.floatValue();\n+        if (Double.isNaN(result)) {\n+            // Numerator and/or denominator must be out of range:\n+            // Calculate how far to shift them to put them in range.\n+            int shift = Math.max(numerator.bitLength(),\n+                                 denominator.bitLength()) - Float.MAX_EXPONENT;\n+            result = numerator.shiftRight(shift).floatValue() /\n+                denominator.shiftRight(shift).floatValue();\n+        }\n+        return result;\n     }\n \n     /**\n", "nb_test": 3489, "linesAdd": 16, "jira_id": "744", "singleLine": false, "nb_skipped": 1, "commit": "8a83581e", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testConstrainedRosen(org.apache.commons.math3.optimization.direct.CMAESOptimizerTest): expected:<0.0> but was:<1.2485018325188872>", "testCigarWithBoundaries(org.apache.commons.math3.optimization.direct.CMAESOptimizerTest): unsupported operation"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex 866c8fd..388d1df 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -123,13 +123,11 @@\n     private boolean isActiveCMA;\n     /**\n      * Determines how often a new random offspring is generated in case it is\n-     * not feasible / beyond the defined limits, default is 0. Only relevant if\n-     * boundaries != null.\n+     * not feasible / beyond the defined limits, default is 0.\n      */\n     private int checkFeasableCount;\n     /**\n-     * Lower and upper boundaries of the objective variables. boundaries == null\n-     * means no boundaries.\n+     * Lower and upper boundaries of the objective variables.\n      */\n     private double[][] boundaries;\n     /**\n@@ -357,7 +355,7 @@ protected PointValuePair doOptimize() {\n          // -------------------- Initialization --------------------------------\n         isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n         final FitnessFunction fitfun = new FitnessFunction();\n-        final double[] guess = fitfun.encode(getStartPoint());\n+        final double[] guess = getStartPoint();\n         // number of objective variables/problem dimension\n         dimension = guess.length;\n         initializeCMA(guess);\n@@ -422,7 +420,7 @@ protected PointValuePair doOptimize() {\n                     bestValue = bestFitness;\n                     lastResult = optimum;\n                     optimum = new PointValuePair(\n-                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n+                            fitfun.repair(bestArx.getColumn(0)),\n                             isMinimize ? bestFitness : -bestFitness);\n                     if (getConvergenceChecker() != null && lastResult != null) {\n                         if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n@@ -506,56 +504,11 @@ private void checkParameters() {\n         final double[] lB = getLowerBound();\n         final double[] uB = getUpperBound();\n \n-        // Checks whether there is at least one finite bound value.\n-        boolean hasFiniteBounds = false;\n-        for (int i = 0; i < lB.length; i++) {\n-            if (!Double.isInfinite(lB[i]) ||\n-                !Double.isInfinite(uB[i])) {\n-                hasFiniteBounds = true;\n-                break;\n-            }\n-        }\n-        // Checks whether there is at least one infinite bound value.\n-        boolean hasInfiniteBounds = false;\n-        if (hasFiniteBounds) {\n-            for (int i = 0; i < lB.length; i++) {\n-                if (Double.isInfinite(lB[i]) ||\n-                    Double.isInfinite(uB[i])) {\n-                    hasInfiniteBounds = true;\n-                    break;\n-                }\n-            }\n-\n-            if (hasInfiniteBounds) {\n-                // If there is at least one finite bound, none can be infinite,\n-                // because mixed cases are not supported by the current code.\n-                throw new MathUnsupportedOperationException();\n-            } else {\n         // Convert API to internal handling of boundaries.\n         boundaries = new double[2][];\n         boundaries[0] = lB;\n         boundaries[1] = uB;\n \n-                // Abort early if the normalization will overflow (cf. \"encode\" method).\n-                for (int i = 0; i < lB.length; i++) {\n-                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n-                        final double max = Double.MAX_VALUE + boundaries[0][i];\n-                        final NumberIsTooLargeException e\n-                            = new NumberIsTooLargeException(boundaries[1][i],\n-                                                            max,\n-                                                            true);\n-                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n-                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n-\n-                        throw e;\n-                    }\n-                }\n-            }\n-        } else {\n-            // Convert API to internal handling of boundaries.\n-            boundaries = null;\n-        }\n-\n         if (inputSigma != null) {\n             if (inputSigma.length != init.length) {\n                 throw new DimensionMismatchException(inputSigma.length, init.length);\n@@ -564,14 +517,12 @@ private void checkParameters() {\n                 if (inputSigma[i] < 0) {\n                     throw new NotPositiveException(inputSigma[i]);\n                 }\n-                if (boundaries != null) {\n                 if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                     throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                 }\n             }\n         }\n     }\n-    }\n \n     /**\n      * Initialization of the dynamic search parameters\n@@ -585,8 +536,7 @@ private void initializeCMA(double[] guess) {\n         // initialize sigma\n         double[][] sigmaArray = new double[guess.length][1];\n         for (int i = 0; i < guess.length; i++) {\n-            final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n-            sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n+            sigmaArray[i][0] = inputSigma == null ? 0.3 : inputSigma[i];\n         }\n         RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n         sigma = max(insigma); // overall standard deviation\n@@ -919,61 +869,19 @@ public FitnessFunction() {\n         }\n \n         /**\n-         * @param x Original objective variables.\n-         * @return the normalized objective variables.\n-         */\n-        public double[] encode(final double[] x) {\n-            if (boundaries == null) {\n-                return x;\n-            }\n-            double[] res = new double[x.length];\n-            for (int i = 0; i < x.length; i++) {\n-                double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = x[i] / diff;\n-            }\n-            return res;\n-        }\n-\n-        /**\n-         * @param x Normalized objective variables.\n-         * @return the original objective variables, possibly repaired.\n-         */\n-        public double[] repairAndDecode(final double[] x) {\n-            return boundaries != null && isRepairMode ?\n-                decode(repair(x)) :\n-                decode(x);\n-        }\n-\n-        /**\n-         * @param x Normalized objective variables.\n-         * @return the original objective variables.\n-         */\n-        public double[] decode(final double[] x) {\n-            if (boundaries == null) {\n-                return x;\n-            }\n-            double[] res = new double[x.length];\n-            for (int i = 0; i < x.length; i++) {\n-                double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = diff * x[i];\n-            }\n-            return res;\n-        }\n-\n-        /**\n          * @param point Normalized objective variables.\n          * @return the objective value + penalty for violated bounds.\n          */\n         public double value(final double[] point) {\n             double value;\n-            if (boundaries != null && isRepairMode) {\n+            if (isRepairMode) {\n                 double[] repaired = repair(point);\n                 value = CMAESOptimizer.this\n-                        .computeObjectiveValue(decode(repaired)) +\n+                        .computeObjectiveValue(repaired) +\n                         penalty(point, repaired);\n             } else {\n                 value = CMAESOptimizer.this\n-                        .computeObjectiveValue(decode(point));\n+                        .computeObjectiveValue(point);\n             }\n             return isMinimize ? value : -value;\n         }\n@@ -983,18 +891,11 @@ public double value(final double[] point) {\n          * @return {@code true} if in bounds.\n          */\n         public boolean isFeasible(final double[] x) {\n-            if (boundaries == null) {\n-                return true;\n-            }\n-\n-            final double[] bLoEnc = encode(boundaries[0]);\n-            final double[] bHiEnc = encode(boundaries[1]);\n-\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < bLoEnc[i]) {\n+                if (x[i] < boundaries[0][i]) {\n                     return false;\n                 }\n-                if (x[i] > bHiEnc[i]) {\n+                if (x[i] > boundaries[1][i]) {\n                     return false;\n                 }\n             }\n@@ -1013,12 +914,12 @@ public void setValueRange(double valueRange) {\n          * @return the repaired objective variables - all in bounds.\n          */\n         private double[] repair(final double[] x) {\n-            double[] repaired = new double[x.length];\n+            final double[] repaired = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < 0) {\n-                    repaired[i] = 0;\n-                } else if (x[i] > 1.0) {\n-                    repaired[i] = 1.0;\n+                if (x[i] < boundaries[0][i]) {\n+                    repaired[i] = boundaries[0][i];\n+                } else if (x[i] > boundaries[1][i]) {\n+                    repaired[i] = boundaries[1][i];\n                 } else {\n                     repaired[i] = x[i];\n                 }\n", "nb_test": 4157, "linesAdd": 13, "jira_id": "867", "singleLine": false, "nb_skipped": 4, "commit": "bfbb156d", "nb_failure": 1, "linesRem": 92}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["LineTest.testRevert:144 arrays first differed at element [0]; expected:<0.028581782127907646> but was:<0.028581782243293483>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\nindex 0c39411..7c9a28f 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n@@ -84,7 +84,9 @@ public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        return new Line(zero, zero.subtract(direction));\n+        final Line reverted = new Line(this);\n+        reverted.direction = reverted.direction.negate();\n+        return reverted;\n     }\n \n     /** Get the normalized direction vector.\n", "nb_test": 4794, "linesAdd": 3, "jira_id": "938", "singleLine": false, "nb_skipped": 4, "commit": "73605560", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["EnumeratedRealDistributionTest.testIssue1065:253 expected:<18.0> but was:<18.000001124999997>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java\nindex d457434..270764f 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java\n@@ -23,6 +24,7 @@\n import org.apache.commons.math3.exception.NotANumberException;\n import org.apache.commons.math3.exception.NotFiniteNumberException;\n import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.random.RandomGenerator;\n import org.apache.commons.math3.random.Well19937c;\n import org.apache.commons.math3.util.Pair;\n@@ -138,6 +140,33 @@ public double cumulativeProbability(final double x) {\n \n     /**\n      * {@inheritDoc}\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n+        if (p < 0.0 || p > 1.0) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        }\n+\n+        double probability = 0;\n+        double x = getSupportLowerBound();\n+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {\n+            if (sample.getValue() == 0.0) {\n+                continue;\n+            }\n+\n+            probability += sample.getValue();\n+            x = sample.getKey();\n+\n+            if (probability >= p) {\n+                break;\n+            }\n+        }\n+\n+        return x;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n      *\n      * @return {@code sum(singletons[i] * probabilities[i])}\n      */\n", "nb_test": 5714, "linesAdd": 25, "jira_id": "1065", "singleLine": false, "nb_skipped": 5, "commit": "996c0c16", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["MultidimensionalCounterTest.testIteratorNoMoreElements Expected exception: java.util.NoSuchElementException"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java b/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java\nindex 0553c6b..3c87fba 100644\n--- a/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java\n@@ -17,6 +17,7 @@\n \n package org.apache.commons.math3.util;\n \n+import java.util.NoSuchElementException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n@@ -77,6 +78,10 @@\n          * Unidimensional counter.\n          */\n         private int count = -1;\n+        /**\n+         * Maximum value for {@link #count}.\n+         */\n+        private final int maxCount = totalSize - 1;\n \n         /**\n          * Create an iterator\n@@ -90,19 +95,20 @@\n          * {@inheritDoc}\n          */\n         public boolean hasNext() {\n-            for (int i = 0; i < dimension; i++) {\n-                if (counter[i] != size[i] - 1) {\n-                    return true;\n-                }\n-            }\n-            return false;\n+            return count < maxCount;\n         }\n \n         /**\n          * @return the unidimensional count after the counter has been\n          * incremented by {@code 1}.\n+         * @throws NoSuchElementException if {@link #hasNext()} would have\n+         * returned {@code false}.\n          */\n         public Integer next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+\n             for (int i = last; i >= 0; i--) {\n                 if (counter[i] == size[i] - 1) {\n                     counter[i] = 0;\n", "nb_test": 5605, "linesAdd": 7, "jira_id": "1088", "singleLine": false, "nb_skipped": 5, "commit": "63d88c74", "nb_failure": 1, "linesRem": 6}, {"files": 4, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMissedEndEvent(org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest)", "testMissedEndEvent(org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\nindex 935bb8b..6ee9bd5 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n@@ -271,7 +271,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n                         if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                            // rejecting the step would lead to a too small next step, we accept it\n+                            // we cannot simply truncate the step, reject the current computation\n+                            // and let the loop compute another state with the truncated step.\n+                            // it is so small (much probably exactly 0 due to limited accuracy)\n+                            // that the code above would fail handling it.\n+                            // So we set up an artificial 0 size step by copying states\n+                            interpolator.storeTime(stepStart);\n+                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                            hNew     = 0;\n+                            stepSize = 0;\n                             loop     = false;\n                         } else {\n                             // reject the step to match exactly the next switch time\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\nindex 27ade7b..e0e2f0d 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n@@ -289,7 +289,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n                         if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                            // rejecting the step would lead to a too small next step, we accept it\n+                            // we cannot simply truncate the step, reject the current computation\n+                            // and let the loop compute another state with the truncated step.\n+                            // it is so small (much probably exactly 0 due to limited accuracy)\n+                            // that the code above would fail handling it.\n+                            // So we set up an artificial 0 size step by copying states\n+                            interpolator.storeTime(stepStart);\n+                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                            hNew     = 0;\n+                            stepSize = 0;\n                             loop     = false;\n                         } else {\n                             // reject the step to match exactly the next switch time\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 34b3dc1..e03be9e 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -292,7 +292,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // rejecting the step would lead to a too small next step, we accept it\n+                  // we cannot simply truncate the step, reject the current computation\n+                  // and let the loop compute another state with the truncated step.\n+                  // it is so small (much probably exactly 0 due to limited accuracy)\n+                  // that the code above would fail handling it.\n+                  // So we set up an artificial 0 size step by copying states\n+                  interpolator.storeTime(stepStart);\n+                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                  hNew     = 0;\n+                  stepSize = 0;\n                   loop     = false;\n               } else {\n                   // reject the step to match exactly the next switch time\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\nindex 3227b98..b61b0b1 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -172,7 +172,14 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // rejecting the step would lead to a too small next step, we accept it\n+                // we cannot simply truncate the step, reject the current computation\n+                // and let the loop compute another state with the truncated step.\n+                // it is so small (much probably exactly 0 due to limited accuracy)\n+                // that the code above would fail handling it.\n+                // So we set up an artificial 0 size step by copying states\n+                interpolator.storeTime(stepStart);\n+                System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                stepSize = 0;\n                 loop     = false;\n             } else {\n                 // reject the step to match exactly the next switch time\n", "nb_test": 2152, "linesAdd": 15, "jira_id": "358", "singleLine": false, "nb_skipped": 0, "commit": "061f5017", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FractionTest.testMath1261:269 null"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/fraction/Fraction.java b/src/main/java/org/apache/commons/math4/fraction/Fraction.java\nindex 0713b85..39eba8d 100644\n--- a/src/main/java/org/apache/commons/math4/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math4/fraction/Fraction.java\n@@ -566,7 +566,7 @@ public Fraction multiply(Fraction fraction) {\n      */\n     @Override\n     public Fraction multiply(final int i) {\n-        return new Fraction(numerator * i, denominator);\n+        return multiply(new Fraction(i));\n     }\n \n     /**\n@@ -597,7 +597,7 @@ public Fraction divide(Fraction fraction) {\n      * @return this * i\n      */\n     public Fraction divide(final int i) {\n-        return new Fraction(numerator, denominator * i);\n+        return divide(new Fraction(i));\n     }\n \n     /**\n", "nb_test": 5826, "linesAdd": 2, "jira_id": "1261", "singleLine": false, "nb_skipped": 3, "commit": "4c4b3e2e", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PrecisionTest.testRoundFloat:495 expected:<0.0> but was:<0.01>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/Precision.java b/src/main/java/org/apache/commons/math3/util/Precision.java\nindex ef3b57f..f0b0c4f 100644\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n@@ -491,8 +491,7 @@ private static double roundUnscaled(double unscaled,\n                 unscaled = FastMath.floor(unscaled);\n             } else {\n                 // The following equality test is intentional and needed for rounding purposes\n-                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(Math\n-                    .floor(unscaled) / 2.0)) { // even\n+                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(FastMath.floor(unscaled) / 2.0)) { // even\n                     unscaled = FastMath.floor(unscaled);\n                 } else { // odd\n                     unscaled = FastMath.ceil(unscaled);\n@@ -516,7 +515,10 @@ private static double roundUnscaled(double unscaled,\n             }\n             break;\n         case BigDecimal.ROUND_UP :\n+            // do not round if the discarded fraction is equal to zero\n+            if (unscaled != FastMath.floor(unscaled)) {\n                 unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+            }\n             break;\n         default :\n             throw new MathIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD,\n", "nb_test": 5472, "linesAdd": 3, "jira_id": "1070", "singleLine": false, "nb_skipped": 5, "commit": "8e5867ed", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPValueNearZero(org.apache.commons.math.stat.correlation.PearsonsCorrelationTest)", "testPValueNearZero(org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\nindex 83b4c41..dc83314 100644\n--- a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n@@ -168,7 +168,7 @@ public RealMatrix getCorrelationPValues() throws MathException {\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                 }\n             }\n         }\n", "nb_test": 2169, "linesAdd": 1, "jira_id": "371", "singleLine": false, "nb_skipped": 0, "commit": "bb005b56", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testSparseIterator(org.apache.commons.math.linear.AbstractRealVectorTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\nindex 023648d..e172543 100644\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n@@ -18,6 +18,7 @@\n package org.apache.commons.math.linear;\n \n import java.util.Iterator;\n+import java.util.NoSuchElementException;\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n@@ -875,34 +876,23 @@ public void setValue(double newValue) {\n         /** Dimension of the vector. */\n         private final int dim;\n \n-        /** Temporary entry (reused on each call to {@link #next()}. */\n-        private EntryImpl tmp = new EntryImpl();\n-\n-        /** Current entry. */\n+        /** last entry returned by {@link #next()} */\n         private EntryImpl current;\n \n-        /** Next entry. */\n+        /** Next entry for {@link #next()} to return. */\n         private EntryImpl next;\n \n         /** Simple constructor. */\n         protected SparseEntryIterator() {\n             dim = getDimension();\n             current = new EntryImpl();\n-            if (current.getValue() == 0) {\n-                advance(current);\n-            }\n-            if(current.getIndex() >= 0){\n-                // There is at least one non-zero entry\n             next = new EntryImpl();\n-                next.setIndex(current.getIndex());\n+            if(next.getValue() == 0){\n             \tadvance(next);\n-            } else {\n-                // The vector consists of only zero entries, so deny having a next\n-                current = null;\n             }\n         }\n \n-        /** Advance an entry up to the next non null one.\n+        /** Advance an entry up to the next nonzero one.\n          * @param e entry to advance\n          */\n         protected void advance(EntryImpl e) {\n@@ -919,22 +909,18 @@ protected void advance(EntryImpl e) {\n \n         /** {@inheritDoc} */\n         public boolean hasNext() {\n-            return current != null;\n+            return next.getIndex() >= 0;\n         }\n \n         /** {@inheritDoc} */\n         public Entry next() {\n-            tmp.setIndex(current.getIndex());\n-            if (next != null) {\n-                current.setIndex(next.getIndex());\n-                advance(next);\n-                if (next.getIndex() < 0) {\n-                    next = null;\n-                }\n-            } else {\n-                current = null;\n+        \tint index = next.getIndex();\n+        \tif(index < 0){\n+        \t\tthrow new NoSuchElementException();\n         \t}\n-            return tmp;\n+        \tcurrent.setIndex(index);\n+        \tadvance(next);\n+        \treturn current;\n         }\n \n         /** {@inheritDoc} */\n", "nb_test": 2167, "linesAdd": 9, "jira_id": "367", "singleLine": false, "nb_skipped": 0, "commit": "3a15d8ce", "nb_failure": 0, "linesRem": 20}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDistributionClone(org.apache.commons.math3.distribution.NormalDistributionTest): expected:<3.176024051402272> but was:<0.6542132477988758>", "testDistributionClone(org.apache.commons.math3.distribution.GammaDistributionTest): expected:<10.688186123440644> but was:<13.675503685260901>", "testDistributionClone(org.apache.commons.math3.distribution.LogNormalDistributionTest): expected:<23.951334711900845> but was:<1.9236285029185378>", "testDistributionClone(org.apache.commons.math3.random.EmpiricalDistributionTest): expected:<92.92388933396902> but was:<94.62472028033713>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java b/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\nindex a621d7b..fab295b 100644\n--- a/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\n@@ -16,21 +16,26 @@\n  */\n package org.apache.commons.math3.random;\n \n+import java.io.Serializable;\n+\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.util.FastMath;\n \n /** Base class for random number generators that generates bits streams.\n-\n+ *\n  * @version $Id$\n  * @since 2.0\n-\n  */\n-public abstract class BitsStreamGenerator implements RandomGenerator {\n-\n+public abstract class BitsStreamGenerator\n+    implements RandomGenerator,\n+               Serializable {\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 20130104L;\n     /** Next gaussian. */\n     private double nextGaussian;\n \n-    /** Creates a new random number generator.\n+    /**\n+     * Creates a new random number generator.\n      */\n     public BitsStreamGenerator() {\n         nextGaussian = Double.NaN;\n", "nb_test": 4514, "linesAdd": 6, "jira_id": "927", "singleLine": false, "nb_skipped": 4, "commit": "185e3033", "nb_failure": 4, "linesRem": 4}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["DescriptiveStatisticsTest.testMath1129:276 null", "SynchronizedDescriptiveStatisticsTest>DescriptiveStatisticsTest.testMath1129:276 null"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/stat/descriptive/rank/Percentile.java b/src/main/java/org/apache/commons/math3/stat/descriptive/rank/Percentile.java\nindex db447aa..15631cf 100644\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/rank/Percentile.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/rank/Percentile.java\n@@ -440,12 +440,18 @@ private int partition(final double[] work, final int begin, final int end, final\n      * @param end index after the last element of the slice to sort\n      */\n     private void insertionSort(final double[] work, final int begin, final int end) {\n+        // Arrays.sort(work, begin, end); // Would also fix MATH-1129\n         for (int j = begin + 1; j < end; j++) {\n             final double saved = work[j];\n             int i = j - 1;\n-            while ((i >= begin) && (saved < work[i])) {\n-                work[i + 1] = work[i];\n+            while (i >= begin) {\n+                final double wi = work[i];\n+                if (saved < wi || Double.isNaN(wi)) {\n+                    work[i + 1] = wi;\n                     i--;\n+                } else {\n+                    break;\n+                }\n             }\n             work[i + 1] = saved;\n         }\n", "nb_test": 5968, "linesAdd": 7, "jira_id": "1129", "singleLine": false, "nb_skipped": 3, "commit": "d4f978dd", "nb_failure": 2, "linesRem": 2}, {"files": 2, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath844(org.apache.commons.math3.optimization.fitting.HarmonicFitterTest): Expected exception: org.apache.commons.math3.exception.MathIllegalStateException"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java b/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\nindex 1ca5635..04edd0b 100644\n--- a/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n@@ -344,7 +344,7 @@\n     WRONG_BLOCK_LENGTH(\"wrong array shape (block length = {0}, expected {1})\"),\n     WRONG_NUMBER_OF_POINTS(\"{0} points are required, got only {1}\"),\n     NUMBER_OF_POINTS(\"number of points ({0})\"), /* keep */\n-    ZERO_DENOMINATOR(\"denominator must be different from 0\"),\n+    ZERO_DENOMINATOR(\"denominator must be different from 0\"), /* keep */\n     ZERO_DENOMINATOR_IN_FRACTION(\"zero denominator in fraction {0}/{1}\"),\n     ZERO_FRACTION_TO_DIVIDE_BY(\"the fraction to divide by must not be zero: {0}/{1}\"),\n     ZERO_NORM(\"zero norm\"),\ndiff --git a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\nindex ebb36d3..c7af9ae 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n@@ -21,6 +21,7 @@\n import org.apache.commons.math3.analysis.function.HarmonicOscillator;\n import org.apache.commons.math3.exception.ZeroException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n \n@@ -250,6 +251,8 @@ private void sortObservations() {\n          * has been called previously.\n          *\n          * @throws ZeroException if the abscissa range is zero.\n+         * @throws MathIllegalStateException when the guessing procedure cannot\n+         * produce sensible results.\n          */\n         private void guessAOmega() {\n             // initialize the sums for the linear model between the two integrals\n@@ -317,6 +320,12 @@ private void guessAOmega() {\n                 }\n                 a = 0.5 * (yMax - yMin);\n             } else {\n+                if (c2 == 0) {\n+                    // In some ill-conditioned cases (cf. MATH-844), the guesser\n+                    // procedure cannot produce sensible results.\n+                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n+                }\n+\n                 a = FastMath.sqrt(c1 / c2);\n                 omega = FastMath.sqrt(c2 / c3);\n             }\n", "nb_test": 4049, "linesAdd": 6, "jira_id": "844", "singleLine": false, "nb_skipped": 4, "commit": "7994d3ee", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMathpbx02(org.apache.commons.math.linear.EigenDecompositionImplTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d..9d1b797 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1132,7 +1132,7 @@ private int goodStep(final int start, final int end) {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * (n - 1);\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n", "nb_test": 2087, "linesAdd": 1, "jira_id": "318", "singleLine": false, "nb_skipped": 0, "commit": "83f18d52", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath288(org.apache.commons.math.optimization.linear.SimplexSolverTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 16d3bae..60a1b3a 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -77,9 +77,10 @@ private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n-            double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n-            if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {\n-                double ratio = rhs / tableau.getEntry(i, col);\n+            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n+            final double entry = tableau.getEntry(i, col);\n+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n+                final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n", "nb_test": 2041, "linesAdd": 4, "jira_id": "288", "singleLine": false, "nb_skipped": 0, "commit": "38983e82", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testIssue801(org.apache.commons.math3.geometry.euclidean.threed.RotationTest): expected:<1.0> but was:<5.097812193678568E10>", "testVectorTwoPairs(org.apache.commons.math3.geometry.euclidean.threed.RotationTest): zero norm for rotation defining vector"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\nindex d5cfb9b..51ffce2 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n@@ -22,6 +22,7 @@\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n \n /**\n  * This class implements rotations in a three-dimensional space.\n@@ -241,6 +242,22 @@ public Rotation(double[][] m, double threshold)\n               det);\n     }\n \n+    double[] quat = mat2quat(ort);\n+    q0 = quat[0];\n+    q1 = quat[1];\n+    q2 = quat[2];\n+    q3 = quat[3];\n+\n+  }\n+\n+  /** Convert an orthogonal rotation matrix to a quaternion.\n+   * @param ort orthogonal rotation matrix\n+   * @return quaternion corresponding to the matrix\n+   */\n+  private static double[] mat2quat(final double[][] ort) {\n+\n+      final double[] quat = new double[4];\n+\n       // There are different ways to compute the quaternions elements\n       // from the matrix. They all involve computing one element from\n       // the diagonal of the matrix, and computing the three other ones\n@@ -255,41 +272,43 @@ public Rotation(double[][] m, double threshold)\n       double s = ort[0][0] + ort[1][1] + ort[2][2];\n       if (s > -0.19) {\n           // compute q0 and deduce q1, q2 and q3\n-      q0 = 0.5 * FastMath.sqrt(s + 1.0);\n-      double inv = 0.25 / q0;\n-      q1 = inv * (ort[1][2] - ort[2][1]);\n-      q2 = inv * (ort[2][0] - ort[0][2]);\n-      q3 = inv * (ort[0][1] - ort[1][0]);\n+          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n+          double inv = 0.25 / quat[0];\n+          quat[1] = inv * (ort[1][2] - ort[2][1]);\n+          quat[2] = inv * (ort[2][0] - ort[0][2]);\n+          quat[3] = inv * (ort[0][1] - ort[1][0]);\n       } else {\n           s = ort[0][0] - ort[1][1] - ort[2][2];\n           if (s > -0.19) {\n               // compute q1 and deduce q0, q2 and q3\n-        q1 = 0.5 * FastMath.sqrt(s + 1.0);\n-        double inv = 0.25 / q1;\n-        q0 = inv * (ort[1][2] - ort[2][1]);\n-        q2 = inv * (ort[0][1] + ort[1][0]);\n-        q3 = inv * (ort[0][2] + ort[2][0]);\n+              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n+              double inv = 0.25 / quat[1];\n+              quat[0] = inv * (ort[1][2] - ort[2][1]);\n+              quat[2] = inv * (ort[0][1] + ort[1][0]);\n+              quat[3] = inv * (ort[0][2] + ort[2][0]);\n           } else {\n               s = ort[1][1] - ort[0][0] - ort[2][2];\n               if (s > -0.19) {\n                   // compute q2 and deduce q0, q1 and q3\n-          q2 = 0.5 * FastMath.sqrt(s + 1.0);\n-          double inv = 0.25 / q2;\n-          q0 = inv * (ort[2][0] - ort[0][2]);\n-          q1 = inv * (ort[0][1] + ort[1][0]);\n-          q3 = inv * (ort[2][1] + ort[1][2]);\n+                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n+                  double inv = 0.25 / quat[2];\n+                  quat[0] = inv * (ort[2][0] - ort[0][2]);\n+                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n+                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n               } else {\n                   // compute q3 and deduce q0, q1 and q2\n                   s = ort[2][2] - ort[0][0] - ort[1][1];\n-          q3 = 0.5 * FastMath.sqrt(s + 1.0);\n-          double inv = 0.25 / q3;\n-          q0 = inv * (ort[0][1] - ort[1][0]);\n-          q1 = inv * (ort[0][2] + ort[2][0]);\n-          q2 = inv * (ort[2][1] + ort[1][2]);\n+                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n+                  double inv = 0.25 / quat[3];\n+                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n+                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n+                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n               }\n           }\n       }\n \n+      return quat;\n+\n   }\n \n   /** Build the rotation that transforms a pair of vector into another pair.\n@@ -308,85 +327,48 @@ public Rotation(double[][] m, double threshold)\n    * @param u2 second vector of the origin pair\n    * @param v1 desired image of u1 by the rotation\n    * @param v2 desired image of u2 by the rotation\n-   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero\n+   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero,\n+   * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)\n    */\n-  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n-\n-  // norms computation\n-  double u1u1 = u1.getNormSq();\n-  double u2u2 = u2.getNormSq();\n-  double v1v1 = v1.getNormSq();\n-  double v2v2 = v2.getNormSq();\n-  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n-    throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n-  }\n-\n-  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n-  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n-\n-  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n-  double u1u2   = u1.dotProduct(u2);\n-  double v1v2   = v1.dotProduct(v2);\n-  double coeffU = u1u2 / u1u1;\n-  double coeffV = v1v2 / u1u1;\n-  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n-  double alpha  = coeffU - beta * coeffV;\n-  v2 = new Vector3D(alpha, v1, beta, v2);\n-\n-  // preliminary computation\n-  Vector3D uRef  = u1;\n-  Vector3D vRef  = v1;\n-  Vector3D v1Su1 = v1.subtract(u1);\n-  Vector3D v2Su2 = v2.subtract(u2);\n-  Vector3D k     = v1Su1.crossProduct(v2Su2);\n-  Vector3D u3    = u1.crossProduct(u2);\n-  double c       = k.dotProduct(u3);\n-  final double inPlaneThreshold = 0.001;\n-  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);\n-      c = k.dotProduct(u2.crossProduct(u3));\n-\n-      if (c <= 0) {\n-        // the (q1, q2, q3) vector is aligned with everything\n-        // this is really the identity rotation\n-        q0 = 1.0;\n-        q1 = 0.0;\n-        q2 = 0.0;\n-        q3 = 0.0;\n-        return;\n-      }\n-\n-      // we will have to use u2 and v2 to compute the scalar part\n-      uRef = u2;\n-      vRef = v2;\n-\n-    }\n-\n+  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)\n+      throws MathIllegalArgumentException {\n+\n+      // build orthonormalized base from u1, u2\n+      // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+      final Vector3D u3 = u1.crossProduct(u2).normalize();\n+      u2 = u3.crossProduct(u1).normalize();\n+      u1 = u1.normalize();\n+\n+      // build an orthonormalized base from v1, v2\n+      // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+      final Vector3D v3 = v1.crossProduct(v2).normalize();\n+      v2 = v3.crossProduct(v1).normalize();\n+      v1 = v1.normalize();\n+\n+      // buid a matrix transforming the first base into the second one\n+      final double[][] m = new double[][] {\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getX(), u2.getX(), v2.getX(), u3.getX(), v3.getX()),\n+              MathArrays.linearCombination(u1.getY(), v1.getX(), u2.getY(), v2.getX(), u3.getY(), v3.getX()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getX(), u2.getZ(), v2.getX(), u3.getZ(), v3.getX())\n+          },\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getY(), u2.getX(), v2.getY(), u3.getX(), v3.getY()),\n+              MathArrays.linearCombination(u1.getY(), v1.getY(), u2.getY(), v2.getY(), u3.getY(), v3.getY()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getY(), u2.getZ(), v2.getY(), u3.getZ(), v3.getY())\n+          },\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getZ(), u2.getX(), v2.getZ(), u3.getX(), v3.getZ()),\n+              MathArrays.linearCombination(u1.getY(), v1.getZ(), u2.getY(), v2.getZ(), u3.getY(), v3.getZ()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getZ(), u2.getZ(), v2.getZ(), u3.getZ(), v3.getZ())\n           }\n+      };\n \n-  // compute the vectorial part\n-  c = FastMath.sqrt(c);\n-  double inv = 1.0 / (c + c);\n-  q1 = inv * k.getX();\n-  q2 = inv * k.getY();\n-  q3 = inv * k.getZ();\n-\n-  // compute the scalar part\n-   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n-                    uRef.getZ() * q1 - uRef.getX() * q3,\n-                    uRef.getX() * q2 - uRef.getY() * q1);\n-  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n+      double[] quat = mat2quat(m);\n+      q0 = quat[0];\n+      q1 = quat[1];\n+      q2 = quat[2];\n+      q3 = quat[3];\n \n   }\n \n", "nb_test": 3611, "linesAdd": 67, "jira_id": "801", "singleLine": false, "nb_skipped": 1, "commit": "118e94b5", "nb_failure": 1, "linesRem": 82}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PolyhedronsSetTest.testIssue1211:394 null"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java\nindex 9c46ae3..2f3bfa9 100644\n--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java\n+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java\n@@ -240,9 +240,9 @@ private void addContribution(final SubHyperplane<Euclidean3D> facet, final boole\n     /** Get the first sub-hyperplane crossed by a semi-infinite line.\n      * @param point start point of the part of the line considered\n      * @param line line to consider (contains point)\n-     * @return the first sub-hyperplaned crossed by the line after the\n+     * @return the first sub-hyperplane crossed by the line after the\n      * given point, or null if the line does not intersect any\n-     * sub-hyperplaned\n+     * sub-hyperplane\n      */\n     public SubHyperplane<Euclidean3D> firstIntersection(final Vector3D point, final Line line) {\n         return recurseFirstIntersection(getTree(true), point, line);\n@@ -252,9 +252,9 @@ private void addContribution(final SubHyperplane<Euclidean3D> facet, final boole\n      * @param node current node\n      * @param point start point of the part of the line considered\n      * @param line line to consider (contains point)\n-     * @return the first sub-hyperplaned crossed by the line after the\n+     * @return the first sub-hyperplane crossed by the line after the\n      * given point, or null if the line does not intersect any\n-     * sub-hyperplaned\n+     * sub-hyperplane\n      */\n     private SubHyperplane<Euclidean3D> recurseFirstIntersection(final BSPTree<Euclidean3D> node,\n                                                                 final Vector3D point,\n@@ -270,7 +270,7 @@ private void addContribution(final SubHyperplane<Euclidean3D> facet, final boole\n \n         // establish search order\n         final double offset = plane.getOffset((Point<Euclidean3D>) point);\n-        final boolean in    = FastMath.abs(offset) < 1.0e-10;\n+        final boolean in    = FastMath.abs(offset) < getTolerance();\n         final BSPTree<Euclidean3D> near;\n         final BSPTree<Euclidean3D> far;\n         if (offset < 0) {\n@@ -298,7 +298,7 @@ private void addContribution(final SubHyperplane<Euclidean3D> facet, final boole\n         if (!in) {\n             // search in the cut hyperplane\n             final Vector3D hit3D = plane.intersection(line);\n-            if (hit3D != null) {\n+            if (hit3D != null && line.getAbscissa(hit3D) > line.getAbscissa(point)) {\n                 final SubHyperplane<Euclidean3D> facet = boundaryFacet(hit3D, node);\n                 if (facet != null) {\n                     return facet;\n", "nb_test": 5852, "linesAdd": 2, "jira_id": "1211", "singleLine": false, "nb_skipped": 3, "commit": "a06a1584", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["FuzzyKMeansClustererTest.testSingleCluster:115 \u00bb ArrayIndexOutOfBounds -1"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java b/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\nindex ed22047..5f89934 100644\n--- a/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\n@@ -346,18 +346,32 @@ private void updateClusterCenters() {\n     private void updateMembershipMatrix() {\n         for (int i = 0; i < points.size(); i++) {\n             final T point = points.get(i);\n-            double maxMembership = 0.0;\n+            double maxMembership = Double.MIN_VALUE;\n             int newCluster = -1;\n             for (int j = 0; j < clusters.size(); j++) {\n                 double sum = 0.0;\n                 final double distA = FastMath.abs(distance(point, clusters.get(j).getCenter()));\n \n+                if (distA != 0.0) {\n                     for (final CentroidCluster<T> c : clusters) {\n                         final double distB = FastMath.abs(distance(point, c.getCenter()));\n+                        if (distB == 0.0) {\n+                            sum = Double.POSITIVE_INFINITY;\n+                            break;\n+                        }\n                         sum += FastMath.pow(distA / distB, 2.0 / (fuzziness - 1.0));\n                     }\n+                }\n \n-                membershipMatrix[i][j] = 1.0 / sum;\n+                double membership;\n+                if (sum == 0.0) {\n+                    membership = 1.0;\n+                } else if (sum == Double.POSITIVE_INFINITY) {\n+                    membership = 0.0;\n+                } else {\n+                    membership = 1.0 / sum;\n+                }\n+                membershipMatrix[i][j] = membership;\n \n                 if (membershipMatrix[i][j] > maxMembership) {\n                     maxMembership = membershipMatrix[i][j];\n", "nb_test": 6167, "linesAdd": 16, "jira_id": "1165", "singleLine": false, "nb_skipped": 3, "commit": "596ccd59", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ArcsSetTest.testSplitWithinEpsilon:577 expected null, but was:<org.apache.commons.math3.geometry.spherical.oned.ArcsSet@8deb247>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java b/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java\nindex 06a8bb2..08ec3ad 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java\n@@ -717,10 +717,10 @@ public Side side(final Arc arc) {\n             final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();\n             final double arcOffset   = a[0] - syncedStart;\n             final double syncedEnd   = a[1] - arcOffset;\n-            if (syncedStart < arcLength || syncedEnd > MathUtils.TWO_PI) {\n+            if (syncedStart <= arcLength - getTolerance() || syncedEnd >= MathUtils.TWO_PI + getTolerance()) {\n                 inMinus = true;\n             }\n-            if (syncedEnd > arcLength) {\n+            if (syncedEnd >= arcLength + getTolerance()) {\n                 inPlus = true;\n             }\n         }\n@@ -749,10 +749,8 @@ public Side side(final Arc arc) {\n      */\n     public Split split(final Arc arc) {\n \n-        final BSPTree<Sphere1D> minus = new BSPTree<Sphere1D>();\n-        minus.setAttribute(Boolean.FALSE);\n-        final BSPTree<Sphere1D> plus  = new BSPTree<Sphere1D>();\n-        plus.setAttribute(Boolean.FALSE);\n+        final List<Double> minus = new ArrayList<Double>();\n+        final List<Double>  plus = new ArrayList<Double>();\n \n         final double reference = FastMath.PI + arc.getInf();\n         final double arcLength = arc.getSup() - arc.getInf();\n@@ -763,51 +761,51 @@ public Split split(final Arc arc) {\n             final double syncedEnd   = a[1] - arcOffset;\n             if (syncedStart < arcLength) {\n                 // the start point a[0] is in the minus part of the arc\n-                addArcLimit(minus, a[0], true);\n+                minus.add(a[0]);\n                 if (syncedEnd > arcLength) {\n                     // the end point a[1] is past the end of the arc\n                     // so we leave the minus part and enter the plus part\n                     final double minusToPlus = arcLength + arcOffset;\n-                    addArcLimit(minus, minusToPlus, false);\n-                    addArcLimit(plus, minusToPlus, true);\n+                    minus.add(minusToPlus);\n+                    plus.add(minusToPlus);\n                     if (syncedEnd > MathUtils.TWO_PI) {\n                         // in fact the end point a[1] goes far enough that we\n                         // leave the plus part of the arc and enter the minus part again\n                         final double plusToMinus = MathUtils.TWO_PI + arcOffset;\n-                        addArcLimit(plus, plusToMinus, false);\n-                        addArcLimit(minus, plusToMinus, true);\n-                        addArcLimit(minus, a[1], false);\n+                        plus.add(plusToMinus);\n+                        minus.add(plusToMinus);\n+                        minus.add(a[1]);\n                     } else {\n                         // the end point a[1] is in the plus part of the arc\n-                        addArcLimit(plus, a[1], false);\n+                        plus.add(a[1]);\n                     }\n                 } else {\n                     // the end point a[1] is in the minus part of the arc\n-                    addArcLimit(minus, a[1], false);\n+                    minus.add(a[1]);\n                 }\n             } else {\n                 // the start point a[0] is in the plus part of the arc\n-                addArcLimit(plus, a[0], true);\n+                plus.add(a[0]);\n                 if (syncedEnd > MathUtils.TWO_PI) {\n                     // the end point a[1] wraps around to the start of the arc\n                     // so we leave the plus part and enter the minus part\n                     final double plusToMinus = MathUtils.TWO_PI + arcOffset;\n-                    addArcLimit(plus, plusToMinus, false);\n-                    addArcLimit(minus, plusToMinus, true);\n+                    plus.add(plusToMinus);\n+                    minus.add(plusToMinus);\n                     if (syncedEnd > MathUtils.TWO_PI + arcLength) {\n                         // in fact the end point a[1] goes far enough that we\n                         // leave the minus part of the arc and enter the plus part again\n                         final double minusToPlus = MathUtils.TWO_PI + arcLength + arcOffset;\n-                        addArcLimit(minus, minusToPlus, false);\n-                        addArcLimit(plus, minusToPlus, true);\n-                        addArcLimit(plus, a[1], false);\n+                        minus.add(minusToPlus);\n+                        plus.add(minusToPlus);\n+                        plus.add(a[1]);\n                     } else {\n                         // the end point a[1] is in the minus part of the arc\n-                        addArcLimit(minus, a[1], false);\n+                        minus.add(a[1]);\n                     }\n                 } else {\n                     // the end point a[1] is in the plus part of the arc\n-                    addArcLimit(plus, a[1], false);\n+                    plus.add(a[1]);\n                 }\n             }\n         }\n@@ -825,27 +824,81 @@ private void addArcLimit(final BSPTree<Sphere1D> tree, final double alpha, final\n         final LimitAngle limit = new LimitAngle(new S1Point(alpha), !isStart, getTolerance());\n         final BSPTree<Sphere1D> node = tree.getCell(limit.getLocation(), getTolerance());\n         if (node.getCut() != null) {\n-            // we find again an already added limit,\n-            // this means we have done a full turn around the circle\n-            leafBefore(node).setAttribute(Boolean.valueOf(!isStart));\n-        } else {\n-            // it's a new node\n+            // this should never happen\n+            throw new MathInternalError();\n+        }\n+\n         node.insertCut(limit);\n         node.setAttribute(null);\n         node.getPlus().setAttribute(Boolean.FALSE);\n         node.getMinus().setAttribute(Boolean.TRUE);\n-        }\n+\n     }\n \n     /** Create a split part.\n-     * @param tree BSP tree containing the limit angles of the split part\n+     * <p>\n+     * As per construction, the list of limit angles is known to have\n+     * an even number of entries, with start angles at even indices and\n+     * end angles at odd indices.\n+     * </p>\n+     * @param limits limit angles of the split part\n      * @return split part (may be null)\n      */\n-    private ArcsSet createSplitPart(final BSPTree<Sphere1D> tree) {\n-        if (tree.getCut() == null && !(Boolean) tree.getAttribute()) {\n+    private ArcsSet createSplitPart(final List<Double> limits) {\n+        if (limits.isEmpty()) {\n+            return null;\n+        } else {\n+\n+            // collapse close limit angles\n+            for (int i = 0; i < limits.size(); ++i) {\n+                final int    j  = (i + 1) % limits.size();\n+                final double lA = limits.get(i);\n+                final double lB = MathUtils.normalizeAngle(limits.get(j), lA);\n+                if (FastMath.abs(lB - lA) <= getTolerance()) {\n+                    // the two limits are too close to each other, we remove both of them\n+                    if (j > 0) {\n+                        // regular case, the two entries are consecutive ones\n+                        limits.remove(j);\n+                        limits.remove(i);\n+                        i = i - 1;\n+                    } else {\n+                        // special case, i the the last entry and j is the first entry\n+                        // we have wrapped around list end\n+                        final double lEnd   = limits.remove(limits.size() - 1);\n+                        final double lStart = limits.remove(0);\n+                        if (limits.isEmpty()) {\n+                            // the ends were the only limits, is it a full circle or an empty circle?\n+                            if (lEnd - lStart > FastMath.PI) {\n+                                // it was full circle\n+                                return new ArcsSet(new BSPTree<Sphere1D>(Boolean.TRUE), getTolerance());\n+                            } else {\n+                                // it was an empty circle\n                                 return null;\n+                            }\n                         } else {\n+                            // we have removed the first interval start, so our list\n+                            // currently starts with an interval end, which is wrong\n+                            // we need to move this interval end to the end of the list\n+                            limits.add(limits.remove(0) + MathUtils.TWO_PI);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // build the tree by adding all angular sectors\n+            BSPTree<Sphere1D> tree = new BSPTree<Sphere1D>(Boolean.FALSE);\n+            for (int i = 0; i < limits.size() - 1; i += 2) {\n+                addArcLimit(tree, limits.get(i),     true);\n+                addArcLimit(tree, limits.get(i + 1), false);\n+            }\n+\n+            if (tree.getCut() == null) {\n+                // we did not insert anything\n+                return null;\n+            }\n+\n             return new ArcsSet(tree, getTolerance());\n+\n         }\n     }\n \n", "nb_test": 5627, "linesAdd": 63, "jira_id": "1093", "singleLine": false, "nb_skipped": 5, "commit": "7cfbc0da", "nb_failure": 1, "linesRem": 27}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath679(org.apache.commons.math.linear.OpenMapRealMatrixTest): Expected exception: org.apache.commons.math.exception.NumberIsTooLargeException"], "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\nindex 4369db7..f05c878 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n@@ -19,6 +19,7 @@\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.util.OpenIntToDoubleHashMap;\n \n /**\n@@ -46,6 +47,11 @@\n      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n+        long lRow = (long) rowDimension;\n+        long lCol = (long) columnDimension;\n+        if (lRow * lCol >= (long) Integer.MAX_VALUE) {\n+            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);\n+        }\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);\n", "nb_test": 3026, "linesAdd": 6, "jira_id": "679", "singleLine": false, "nb_skipped": 1, "commit": "5e638976", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["EmpiricalDistributionTest.testKernelOverrideConstant:489 expected:<0.0> but was:<0.2>", "EmpiricalDistributionTest.testNoBinVariance:449 expected:<0.5> but was:<1.0>"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\nindex 61bb65b..685c08b 100644\n--- a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n+++ b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n@@ -610,8 +610,12 @@ public double cumulativeProbability(double x) {\n         final double pB = pB(binIndex);\n         final RealDistribution kernel = k(x);\n         if (kernel instanceof ConstantRealDistribution) {\n+            if (x < kernel.getNumericalMean()) {\n+                return pBminus;\n+            } else {\n                 return pBminus + pB;\n             }\n+        }\n         final double[] binBounds = getUpperBounds();\n         final double kB = kB(binIndex);\n         final double lower = binIndex == 0 ? min : binBounds[binIndex - 1];\n", "nb_test": 5851, "linesAdd": 4, "jira_id": "1208", "singleLine": false, "nb_skipped": 3, "commit": "ce2badf0", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["BrentOptimizerTest.testQuinticMinStatistics:167 null"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java\nindex a5fca86..b788c2c 100644\n--- a/src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java\n@@ -150,7 +150,6 @@ protected UnivariatePointValuePair doOptimize() {\n         // Best point encountered so far (which is the initial guess).\n         UnivariatePointValuePair best = current;\n \n-        int iter = 0;\n         while (true) {\n             final double m = 0.5 * (a + b);\n             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n@@ -238,7 +237,7 @@ protected UnivariatePointValuePair doOptimize() {\n                                  isMinim),\n                             isMinim);\n \n-                if (checker != null && checker.converged(iter, previous, current)) {\n+                if (checker != null && checker.converged(getIterations(), previous, current)) {\n                     return best;\n                 }\n \n@@ -281,7 +280,8 @@ protected UnivariatePointValuePair doOptimize() {\n                                  isMinim),\n                             isMinim);\n             }\n-            ++iter;\n+\n+            incrementIterationCount();\n         }\n     }\n \n", "nb_test": 5962, "linesAdd": 3, "jira_id": "1121", "singleLine": false, "nb_skipped": 3, "commit": "5a6ccd58", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSqueezedHexa(org.apache.commons.math3.geometry.euclidean.twod.PolygonsSetTest): expected:<OUTSIDE> but was:<INSIDE>", "testIssue880Complete(org.apache.commons.math3.geometry.euclidean.twod.PolygonsSetTest): expected:<OUTSIDE> but was:<INSIDE>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\nindex 9bd9dae..9cb82de 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -111,6 +111,20 @@ public PolygonsSet(final double xMin, final double xMax,\n      * constructor} using {@link SubHyperplane subhyperplanes}.</p>\n      * <p>If the list is empty, the region will represent the whole\n      * space.</p>\n+     * <p>\n+     * Polygons with thin pikes or dents are inherently difficult to handle because\n+     * they involve lines with almost opposite directions at some vertices. Polygons\n+     * whose vertices come from some physical measurement with noise are also\n+     * difficult because an edge that should be straight may be broken in lots of\n+     * different pieces with almost equal directions. In both cases, computing the\n+     * lines intersections is not numerically robust due to the almost 0 or almost\n+     * &pi; angle. Such cases need to carefully adjust the {@code hyperplaneThickness}\n+     * parameter. A too small value would often lead to completely wrong polygons\n+     * with large area wrongly identified as inside or outside. Large values are\n+     * often much safer. As a rule of thumb, a value slightly below the size of the\n+     * most accurate detail needed is a good value for the {@code hyperplaneThickness}\n+     * parameter.\n+     * </p>\n      * @param hyperplaneThickness tolerance below which points are considered to\n      * belong to the hyperplane (which is therefore more a slab)\n      * @param vertices vertices of the simple loop boundary\n@@ -157,20 +171,50 @@ public PolygonsSet(final double hyperplaneThickness, final Vector2D ... vertices\n     private static BSPTree<Euclidean2D> verticesToTree(final double hyperplaneThickness,\n                                                        final Vector2D ... vertices) {\n \n-        if (vertices.length == 0) {\n+        final int n = vertices.length;\n+        if (n == 0) {\n             // the tree represents the whole space\n             return new BSPTree<Euclidean2D>(Boolean.TRUE);\n         }\n \n-        // at start, none of the edges have been processed\n-        final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>();\n-        List<Vertex> list = new ArrayList<PolygonsSet.Vertex>(vertices.length);\n-        for (final Vector2D vertex : vertices) {\n-            list.add(new Vertex(vertex));\n+        // build the vertices\n+        final Vertex[] vArray = new Vertex[n];\n+        for (int i = 0; i < n; ++i) {\n+            vArray[i] = new Vertex(vertices[i]);\n+        }\n+\n+        // build the edges\n+        List<Edge> edges = new ArrayList<Edge>();\n+        for (int i = 0; i < n; ++i) {\n+\n+            // get the endpoints of the edge\n+            final Vertex start = vArray[i];\n+            final Vertex end   = vArray[(i + 1) % n];\n+\n+            // get the line supporting the edge, taking care not to recreate it\n+            // if it was already created earlier due to another edge being aligned\n+            // with the current one\n+            Line line = start.sharedLineWith(end);\n+            if (line == null) {\n+                line = new Line(start.getLocation(), end.getLocation());\n+            }\n+\n+            // create the edge and store it\n+            edges.add(new Edge(start, end, line));\n+\n+            // check if another vertex also happens to be on this line\n+            for (final Vertex vertex : vArray) {\n+                if (vertex != start && vertex != end &&\n+                    FastMath.abs(line.getOffset(vertex.getLocation())) <= hyperplaneThickness) {\n+                    vertex.bindWith(line);\n+                }\n+            }\n+\n         }\n \n         // build the tree top-down\n-        insertVertices(hyperplaneThickness, tree, list);\n+        final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>();\n+        insertEdges(hyperplaneThickness, tree, edges);\n \n         return tree;\n \n@@ -181,45 +225,32 @@ public PolygonsSet(final double hyperplaneThickness, final Vector2D ... vertices\n      * belong to the hyperplane (which is therefore more a slab)\n      * @param node current tree node (it is a leaf node at the beginning\n      * of the call)\n-     * @param vertices list of vertices belonging to the boundary of the\n-     * cell defined by the node\n+     * @param edges list of edges to insert in the cell defined by this node\n+     * (excluding edges not belonging to the cell defined by this node)\n      */\n-    private static void insertVertices(final double hyperplaneThickness,\n+    private static void insertEdges(final double hyperplaneThickness,\n                                     final BSPTree<Euclidean2D> node,\n-                                       final List<Vertex> vertices) {\n+                                    final List<Edge> edges) {\n \n-        Vertex current = vertices.get(vertices.size() - 1);\n+        // find an edge with an hyperplane that can be inserted in the node\n         int index = 0;\n-        Line inserted = null;\n-        while (inserted == null && index < vertices.size()) {\n-            final Vertex previous = current;\n-            current = vertices.get(index++);\n-            if (previous.outgoingNeedsProcessing() && current.incomingNeedsProcessing()) {\n-\n-                if (previous.shareNodeWith(current)) {\n-                    // both vertices are already handled by an existing node,\n-                    // closer to the tree root, they were probably created\n-                    // when split points were introduced\n-                    inserted = null;\n-                } else {\n-\n-                    inserted = new Line(previous.getLocation(), current.getLocation());\n-\n-                    if (node.insertCut(inserted)) {\n-                        previous.addNode(node);\n-                        previous.outgoingProcessed();\n-                        current.addNode(node);\n-                        current.incomingProcessed();\n+        Edge inserted =null;\n+        while (inserted == null && index < edges.size()) {\n+            inserted = edges.get(index++);\n+            if (inserted.getNode() == null) {\n+                if (node.insertCut(inserted.getLine())) {\n+                    inserted.setNode(node);\n                 } else {\n                     inserted = null;\n                 }\n-\n-                }\n-\n+            } else {\n+                inserted = null;\n             }\n         }\n \n-        if (node.getCut() == null) {\n+        if (inserted == null) {\n+            // no suitable edge was found, the node remains a leaf node\n+            // we need to set its inside/outside boolean indicator\n             final BSPTree<Euclidean2D> parent = node.getParent();\n             if (parent == null || node == parent.getMinus()) {\n                 node.setAttribute(Boolean.TRUE);\n@@ -229,67 +260,58 @@ private static void insertVertices(final double hyperplaneThickness,\n             return;\n         }\n \n-        // distribute the remaining vertices in the two sub-trees\n-        Side currentSide = Side.HYPER;\n-        final List<Vertex> plusList  = new ArrayList<Vertex>();\n-        plusList.add(current);\n-        int plusCount = 0;\n-        final List<Vertex> minusList = new ArrayList<Vertex>();\n-        minusList.add(current);\n-        int minusCount = 0;\n-        while (index < vertices.size()) {\n-            final Vertex previous = current;\n-            final Side previousSide = currentSide;\n-            current = vertices.get(index++);\n-            final double currentOffset = inserted.getOffset(current.getLocation());\n-            currentSide = (FastMath.abs(currentOffset) <= hyperplaneThickness) ?\n-                           Side.HYPER :\n-                           ((currentOffset < 0) ? Side.MINUS : Side.PLUS);\n-            switch (currentSide) {\n+        // we have split the node by inserted an edge as a cut sub-hyperplane\n+        // distribute the remaining edges in the two sub-trees\n+        final List<Edge> plusList  = new ArrayList<Edge>();\n+        final List<Edge> minusList = new ArrayList<Edge>();\n+        for (final Edge edge : edges) {\n+            if (edge != inserted) {\n+                final double startOffset = inserted.getLine().getOffset(edge.getStart().getLocation());\n+                final double endOffset   = inserted.getLine().getOffset(edge.getEnd().getLocation());\n+                Side startSide = (FastMath.abs(startOffset) <= hyperplaneThickness) ?\n+                                 Side.HYPER : ((startOffset < 0) ? Side.MINUS : Side.PLUS);\n+                Side endSide   = (FastMath.abs(endOffset) <= hyperplaneThickness) ?\n+                                 Side.HYPER : ((endOffset < 0) ? Side.MINUS : Side.PLUS);\n+                switch (startSide) {\n                     case PLUS:\n-                if (previousSide == Side.MINUS) {\n+                        if (endSide == Side.MINUS) {\n                             // we need to insert a split point on the hyperplane\n-                    final Line line = new Line(previous.getLocation(), current.getLocation());\n-                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\n-                    splitPoint.addNode(node);\n-                    minusList.add(splitPoint);\n-                    plusList.add(splitPoint);\n-                }\n-                plusList.add(current);\n-                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\n-                    ++plusCount;\n+                            final Vertex splitPoint = edge.split(inserted.getLine());\n+                            minusList.add(splitPoint.getOutgoing());\n+                            plusList.add(splitPoint.getIncoming());\n+                        } else {\n+                            plusList.add(edge);\n                         }\n                         break;\n                     case MINUS:\n-                if (previousSide == Side.PLUS) {\n+                        if (endSide == Side.PLUS) {\n                             // we need to insert a split point on the hyperplane\n-                    final Line line = new Line(previous.getLocation(), current.getLocation());\n-                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\n-                    splitPoint.addNode(node);\n-                    minusList.add(splitPoint);\n-                    plusList.add(splitPoint);\n-                }\n-                minusList.add(current);\n-                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\n-                    ++minusCount;\n+                            final Vertex splitPoint = edge.split(inserted.getLine());\n+                            minusList.add(splitPoint.getIncoming());\n+                            plusList.add(splitPoint.getOutgoing());\n+                        } else {\n+                            minusList.add(edge);\n                         }\n                         break;\n                     default:\n-                current.addNode(node);\n-                plusList.add(current);\n-                minusList.add(current);\n+                        if (endSide == Side.PLUS) {\n+                            plusList.add(edge);\n+                        } else if (endSide == Side.MINUS) {\n+                            minusList.add(edge);\n+                        }\n                         break;\n                 }\n             }\n+        }\n \n         // recurse through lower levels\n-        if (plusCount > 0) {\n-            insertVertices(hyperplaneThickness, node.getPlus(),  plusList);\n+        if (!plusList.isEmpty()) {\n+            insertEdges(hyperplaneThickness, node.getPlus(),  plusList);\n         } else {\n             node.getPlus().setAttribute(Boolean.FALSE);\n         }\n-        if (minusCount > 0) {\n-            insertVertices(hyperplaneThickness, node.getMinus(), minusList);\n+        if (!minusList.isEmpty()) {\n+            insertEdges(hyperplaneThickness, node.getMinus(), minusList);\n         } else {\n             node.getMinus().setAttribute(Boolean.TRUE);\n         }\n@@ -302,23 +324,23 @@ private static void insertVertices(final double hyperplaneThickness,\n         /** Vertex location. */\n         private final Vector2D location;\n \n-        /** Nodes associated with the hyperplane containing this vertex. */\n-        private final List<BSPTree<Euclidean2D>> nodes;\n+        /** Incoming edge. */\n+        private Edge incoming;\n \n-        /** Indicator for incoming edges that still need processing. */\n-        private boolean incomingNeedsProcessing;\n+        /** Outgoing edge. */\n+        private Edge outgoing;\n \n-        /** Indicator for outgoing edges that still need processing. */\n-        private boolean outgoingNeedsProcessing;\n+        /** Lines bound with this vertex. */\n+        private final List<Line> lines;\n \n         /** Build a non-processed vertex not owned by any node yet.\n          * @param location vertex location\n          */\n         public Vertex(final Vector2D location) {\n             this.location = location;\n-            this.nodes                   = new ArrayList<BSPTree<Euclidean2D>>();\n-            this.incomingNeedsProcessing = true;\n-            this.outgoingNeedsProcessing = true;\n+            this.incoming = null;\n+            this.outgoing = null;\n+            this.lines    = new ArrayList<Line>();\n         }\n \n         /** Get Vertex location.\n@@ -328,57 +350,160 @@ public Vector2D getLocation() {\n             return location;\n         }\n \n-        /** Check if the instance and another vertex share a node.\n+        /** Bind a line considered to contain this vertex.\n+         * @param line line to bind with this vertex\n+         */\n+        public void bindWith(final Line line) {\n+            lines.add(line);\n+        }\n+\n+        /** Get the common line bound with both the instance and another vertex, if any.\n          * <p>\n-         * When two vertices share a node, this means they are already handled\n-         * by the hyperplane of this node, so there is no need to create a cut\n-         * hyperplane for them.\n+         * When two vertices are both bound to the same line, this means they are\n+         * already handled by node associated with this line, so there is no need\n+         * to create a cut hyperplane for them.\n          * </p>\n          * @param vertex other vertex to check instance against\n-         * @return true if the instance and another vertex share a node\n+         * @return line bound with both the instance and another vertex, or null if the\n+         * two vertices do not share a line yet\n          */\n-        public boolean shareNodeWith(final Vertex vertex) {\n-            for (final BSPTree<Euclidean2D> node1 : nodes) {\n-                for (final BSPTree<Euclidean2D> node2 : vertex.nodes) {\n-                    if (node1 == node2) {\n-                        return true;\n+        public Line sharedLineWith(final Vertex vertex) {\n+            for (final Line line1 : lines) {\n+                for (final Line line2 : vertex.lines) {\n+                    if (line1 == line2) {\n+                        return line1;\n                     }\n                 }\n             }\n-            return false;\n+            return null;\n         }\n \n-        /** Add a node whose hyperplane contains this vertex.\n-         * @param node node whose hyperplane contains this vertex\n+        /** Set incoming edge.\n+         * <p>\n+         * The line supporting the incoming edge is automatically bound\n+         * with the instance.\n+         * </p>\n+         * @param incoming incoming edge\n+         */\n+        public void setIncoming(final Edge incoming) {\n+            this.incoming = incoming;\n+            bindWith(incoming.getLine());\n+        }\n+\n+        /** Get incoming edge.\n+         * @return incoming edge\n+         */\n+        public Edge getIncoming() {\n+            return incoming;\n+        }\n+\n+        /** Set outgoing edge.\n+         * <p>\n+         * The line supporting the outgoing edge is automatically bound\n+         * with the instance.\n+         * </p>\n+         * @param incoming outgoing edge\n+         */\n+        public void setOutgoing(final Edge outgoing) {\n+            this.outgoing = outgoing;\n+            bindWith(outgoing.getLine());\n+        }\n+\n+        /** Get outgoing edge.\n+         * @return outgoing edge\n+         */\n+        public Edge getOutgoing() {\n+            return outgoing;\n+        }\n+\n+    }\n+\n+    /** Internal class for holding edges while they are processed to build a BSP tree. */\n+    private static class Edge {\n+\n+        /** Start vertex. */\n+        private final Vertex start;\n+\n+        /** End vertex. */\n+        private final Vertex end;\n+\n+        /** Line supporting the edge. */\n+        private final Line line;\n+\n+        /** Node whose cut hyperplane contains this edge. */\n+        private BSPTree<Euclidean2D> node;\n+\n+        /** Build an edge not contained in any node yet.\n+         * @param start start vertex\n+         * @param end end vertex\n+         * @param line line supporting the edge\n          */\n-        public void addNode(final BSPTree<Euclidean2D> node) {\n-            nodes.add(node);\n+        public Edge(final Vertex start, final Vertex end, final Line line) {\n+\n+            this.start = start;\n+            this.end   = end;\n+            this.line  = line;\n+            this.node  = null;\n+\n+            // connect the vertices back to the edge\n+            start.setOutgoing(this);\n+            end.setIncoming(this);\n+\n         }\n \n-        /** Check incoming edge processed indicator.\n-         * @return true if incoming edge needs processing\n+        /** Get start vertex.\n+         * @return start vertex\n          */\n-        public boolean incomingNeedsProcessing() {\n-            return incomingNeedsProcessing;\n+        public Vertex getStart() {\n+            return start;\n         }\n \n-        /** Check outgoing edge processed indicator.\n-         * @return true if outgoing edge needs processing\n+        /** Get end vertex.\n+         * @return end vertex\n          */\n-        public boolean outgoingNeedsProcessing() {\n-            return outgoingNeedsProcessing;\n+        public Vertex getEnd() {\n+            return end;\n         }\n \n-        /** Mark the incoming edge as processed.\n+        /** Get the line supporting this edge.\n+         * @return line supporting this edge\n          */\n-        public void incomingProcessed() {\n-            incomingNeedsProcessing = false;\n+        public Line getLine() {\n+            return line;\n         }\n \n-        /** Mark the outgoing edge as processed.\n+        /** Set the node whose cut hyperplane contains this edge.\n+         * @param node node whose cut hyperplane contains this edge\n+         */\n+        public void setNode(final BSPTree<Euclidean2D> node) {\n+            this.node = node;\n+        }\n+\n+        /** Get the node whose cut hyperplane contains this edge.\n+         * @return node whose cut hyperplane contains this edge\n+         * (null if edge has not yet been inserted into the BSP tree)\n+         */\n+        public BSPTree<Euclidean2D> getNode() {\n+            return node;\n+        }\n+\n+        /** Split the edge.\n+         * <p>\n+         * Once split, this edge is not referenced anymore by the vertices,\n+         * it is replaced by the two half-edges and an intermediate splitting\n+         * vertex is introduced to connect these two halves.\n+         * </p>\n+         * @param splitLine line splitting the edge in two halves\n+         * @return split vertex (its incoming and outgoing edges are the two halves)\n          */\n-        public void outgoingProcessed() {\n-            outgoingNeedsProcessing = false;\n+        public Vertex split(final Line splitLine) {\n+            final Vertex splitVertex = new Vertex(line.intersection(splitLine));\n+            splitVertex.bindWith(splitLine);\n+            final Edge startHalf = new Edge(start, splitVertex, line);\n+            final Edge endHalf   = new Edge(splitVertex, end, line);\n+            startHalf.node = node;\n+            endHalf.node   = node;\n+            return splitVertex;\n         }\n \n     }\n", "nb_test": 4170, "linesAdd": 151, "jira_id": "880", "singleLine": false, "nb_skipped": 4, "commit": "2a9cbbab", "nb_failure": 2, "linesRem": 95}, {"files": 2, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testLargeSample(org.apache.commons.math3.fitting.PolynomialFitterTest): Java heap space"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\nindex 789bc25..aa3299a 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n@@ -18,7 +18,7 @@\n \n import org.apache.commons.math3.optim.OptimizationData;\n import org.apache.commons.math3.linear.RealMatrix;\n-import org.apache.commons.math3.linear.MatrixUtils;\n+import org.apache.commons.math3.linear.DiagonalMatrix;\n import org.apache.commons.math3.linear.NonSquareMatrixException;\n \n /**\n@@ -40,10 +40,7 @@\n      */\n     public Weight(double[] weight) {\n         final int dim = weight.length;\n-        weightMatrix = MatrixUtils.createRealMatrix(dim, dim);\n-        for (int i = 0; i < dim; i++) {\n-            weightMatrix.setEntry(i, i, weight[i]);\n-        }\n+        weightMatrix = new DiagonalMatrix(weight);\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\nindex b7bb6f5..ef52943 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n@@ -20,6 +20,7 @@\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n import org.apache.commons.math3.linear.ArrayRealVector;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.linear.DiagonalMatrix;\n import org.apache.commons.math3.linear.DecompositionSolver;\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.QRDecomposition;\n@@ -263,7 +264,16 @@ private void parseOptimizationData(OptimizationData... optData) {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n+        if (m instanceof DiagonalMatrix) {\n+            final int dim = m.getRowDimension();\n+            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n+            for (int i = 0; i < dim; i++) {\n+                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n+            }\n+            return sqrtM;\n+        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n         }\n     }\n+}\n", "nb_test": 4501, "linesAdd": 12, "jira_id": "924", "singleLine": false, "nb_skipped": 4, "commit": "b07ecae3", "nb_failure": 0, "linesRem": 5}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["KendallsCorrelationTest.testLargeArray:259 expected:<1.0> but was:<5780.723968475119>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/stat/correlation/KendallsCorrelation.java b/src/main/java/org/apache/commons/math3/stat/correlation/KendallsCorrelation.java\nindex 1e4495c..81fb39f 100644\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/KendallsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/KendallsCorrelation.java\n@@ -160,7 +160,7 @@ public double correlation(final double[] xArray, final double[] yArray)\n         }\n \n         final int n = xArray.length;\n-        final int numPairs = n * (n - 1) / 2;\n+        final long numPairs = n * (n - 1l) / 2l;\n \n         @SuppressWarnings(\"unchecked\")\n         Pair<Double, Double>[] pairs = new Pair[n];\n@@ -254,7 +254,8 @@ public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {\n         }\n         tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;\n \n-        int concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;\n-        return concordantMinusDiscordant / FastMath.sqrt((numPairs - tiedXPairs) * (numPairs - tiedYPairs));\n+        final long concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;\n+        final double nonTiedPairsMultiplied = (numPairs - tiedXPairs) * (double) (numPairs - tiedYPairs);\n+        return concordantMinusDiscordant / FastMath.sqrt(nonTiedPairsMultiplied);\n     }\n }\n", "nb_test": 5477, "linesAdd": 4, "jira_id": "1068", "singleLine": false, "nb_skipped": 5, "commit": "b12610d3", "nb_failure": 1, "linesRem": 3}, {"files": 2, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testNextUniformExtremeValues(org.apache.commons.math.random.ISAACTest)", "testNextIntNegativeToPositiveRange(org.apache.commons.math.random.ISAACTest): Chisquare test failed p-value = 0.0 chisquare statistic = 219.24800000000005.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t118", "3\t0.11\t\t122", "4\t0.11\t\t216", "5\t0.11\t\t133", "6\t0.11\t\t110", "7\t0.11\t\t101", "8\t0.11\t\t103", "9\t0.11\t\t97", "This test can fail randomly due to sampling error with probability 0.01.", "testNextIntNegativeRange(org.apache.commons.math.random.ISAACTest): nextInt range", "testNextLongNegativeToPositiveRange(org.apache.commons.math.random.ISAACTest): Chisquare test failed p-value = 0.0 chisquare statistic = 219.24800000000005.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t118", "3\t0.11\t\t122", "4\t0.11\t\t216", "5\t0.11\t\t133", "6\t0.11\t\t110", "7\t0.11\t\t101", "8\t0.11\t\t103", "9\t0.11\t\t97", "This test can fail randomly due to sampling error with probability 0.01.", "testNextLongNegativeRange(org.apache.commons.math.random.ISAACTest): nextLong range", "testNextUniformIAE(org.apache.commons.math.random.ISAACTest): MathIllegalArgumentException expected", "testNextUniformUniformMaximalInterval(org.apache.commons.math.random.ISAACTest): nextUniform range", "testNextUniformExtremeValues(org.apache.commons.math.random.Well512aTest)", "testNextIntNegativeToPositiveRange(org.apache.commons.math.random.Well512aTest): Chisquare test failed p-value = 0.0 chisquare statistic = 258.03800000000007.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t106", "3\t0.11\t\t114", "4\t0.11\t\t237", "5\t0.11\t\t121", "6\t0.11\t\t107", "7\t0.11\t\t93", "8\t0.11\t\t111", "9\t0.11\t\t111", "This test can fail randomly due to sampling error with probability 0.01.", "testNextIntNegativeRange(org.apache.commons.math.random.Well512aTest): nextInt range", "testNextLongNegativeToPositiveRange(org.apache.commons.math.random.Well512aTest): Chisquare test failed p-value = 0.0 chisquare statistic = 258.03800000000007.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t106", "3\t0.11\t\t114", "4\t0.11\t\t237", "5\t0.11\t\t121", "6\t0.11\t\t107", "7\t0.11\t\t93", "8\t0.11\t\t111", "9\t0.11\t\t111", "This test can fail randomly due to sampling error with probability 0.01.", "testNextLongNegativeRange(org.apache.commons.math.random.Well512aTest): nextLong range", "testNextUniformIAE(org.apache.commons.math.random.Well512aTest): MathIllegalArgumentException expected", "testNextUniformUniformMaximalInterval(org.apache.commons.math.random.Well512aTest): nextUniform range", "testNextUniformExtremeValues(org.apache.commons.math.random.RandomDataTest)", "testNextIntNegativeToPositiveRange(org.apache.commons.math.random.RandomDataTest): Chisquare test failed p-value = 0.0 chisquare statistic = 264.24800000000005.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t101", "3\t0.11\t\t107", "4\t0.11\t\t240", "5\t0.11\t\t104", "6\t0.11\t\t118", "7\t0.11\t\t120", "8\t0.11\t\t109", "9\t0.11\t\t101", "This test can fail randomly due to sampling error with probability 0.01.", "testNextIntNegativeRange(org.apache.commons.math.random.RandomDataTest): nextInt range", "testNextLongNegativeToPositiveRange(org.apache.commons.math.random.RandomDataTest): Chisquare test failed p-value = 0.0 chisquare statistic = 264.24800000000005.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t101", "3\t0.11\t\t107", "4\t0.11\t\t240", "5\t0.11\t\t104", "6\t0.11\t\t118", "7\t0.11\t\t120", "8\t0.11\t\t109", "9\t0.11\t\t101", "This test can fail randomly due to sampling error with probability 0.01.", "testNextLongNegativeRange(org.apache.commons.math.random.RandomDataTest): nextLong range", "testNextUniformIAE(org.apache.commons.math.random.RandomDataTest): MathIllegalArgumentException expected", "testNextUniformUniformMaximalInterval(org.apache.commons.math.random.RandomDataTest): nextUniform range", "testNextUniformExtremeValues(org.apache.commons.math.random.Well19937aTest)", "testNextIntNegativeToPositiveRange(org.apache.commons.math.random.Well19937aTest): Chisquare test failed p-value = 0.0 chisquare statistic = 266.6240000000001.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t116", "3\t0.11\t\t107", "4\t0.11\t\t240", "5\t0.11\t\t109", "6\t0.11\t\t93", "7\t0.11\t\t121", "8\t0.11\t\t98", "9\t0.11\t\t116", "This test can fail randomly due to sampling error with probability 0.01.", "testNextIntNegativeRange(org.apache.commons.math.random.Well19937aTest): nextInt range", "testNextLongNegativeToPositiveRange(org.apache.commons.math.random.Well19937aTest): Chisquare test failed p-value = 0.0 chisquare statistic = 266.6240000000001.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t116", "3\t0.11\t\t107", "4\t0.11\t\t240", "5\t0.11\t\t109", "6\t0.11\t\t93", "7\t0.11\t\t121", "8\t0.11\t\t98", "9\t0.11\t\t116", "This test can fail randomly due to sampling error with probability 0.01.", "testNextLongNegativeRange(org.apache.commons.math.random.Well19937aTest): nextLong range", "testNextUniformIAE(org.apache.commons.math.random.Well19937aTest): MathIllegalArgumentException expected", "testNextUniformUniformMaximalInterval(org.apache.commons.math.random.Well19937aTest): nextUniform range", "testNextUniformExtremeValues(org.apache.commons.math.random.AbstractRandomGeneratorTest)", "testNextIntNegativeToPositiveRange(org.apache.commons.math.random.AbstractRandomGeneratorTest): Chisquare test failed p-value = 0.0 chisquare statistic = 220.34600000000006.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t106", "3\t0.11\t\t116", "4\t0.11\t\t220", "5\t0.11\t\t125", "6\t0.11\t\t107", "7\t0.11\t\t108", "8\t0.11\t\t110", "9\t0.11\t\t108", "This test can fail randomly due to sampling error with probability 0.01.", "testNextIntNegativeRange(org.apache.commons.math.random.AbstractRandomGeneratorTest): nextInt range", "testNextLongNegativeToPositiveRange(org.apache.commons.math.random.AbstractRandomGeneratorTest): Chisquare test failed p-value = 0.0 chisquare statistic = 220.34600000000006.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t106", "3\t0.11\t\t116", "4\t0.11\t\t220", "5\t0.11\t\t125", "6\t0.11\t\t107", "7\t0.11\t\t108", "8\t0.11\t\t110", "9\t0.11\t\t108", "This test can fail randomly due to sampling error with probability 0.01.", "testNextLongNegativeRange(org.apache.commons.math.random.AbstractRandomGeneratorTest): nextLong range", "testNextUniformIAE(org.apache.commons.math.random.AbstractRandomGeneratorTest): MathIllegalArgumentException expected", "testNextUniformUniformMaximalInterval(org.apache.commons.math.random.AbstractRandomGeneratorTest): nextUniform range", "testNextUniformExtremeValues(org.apache.commons.math.random.Well44497aTest)", "testNextIntNegativeToPositiveRange(org.apache.commons.math.random.Well44497aTest): Chisquare test failed p-value = 0.0 chisquare statistic = 271.07.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t106", "3\t0.11\t\t116", "4\t0.11\t\t243", "5\t0.11\t\t102", "6\t0.11\t\t107", "7\t0.11\t\t106", "8\t0.11\t\t100", "9\t0.11\t\t120", "This test can fail randomly due to sampling error with probability 0.01.", "testNextIntNegativeRange(org.apache.commons.math.random.Well44497aTest): nextInt range", "testNextLongNegativeToPositiveRange(org.apache.commons.math.random.Well44497aTest): Chisquare test failed p-value = 0.0 chisquare statistic = 271.07.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t106", "3\t0.11\t\t116", "4\t0.11\t\t243", "5\t0.11\t\t102", "6\t0.11\t\t107", "7\t0.11\t\t106", "8\t0.11\t\t100", "9\t0.11\t\t120", "This test can fail randomly due to sampling error with probability 0.01.", "testNextLongNegativeRange(org.apache.commons.math.random.Well44497aTest): nextLong range", "testNextUniformIAE(org.apache.commons.math.random.Well44497aTest): MathIllegalArgumentException expected", "testNextUniformUniformMaximalInterval(org.apache.commons.math.random.Well44497aTest): nextUniform range", "testNextUniformExtremeValues(org.apache.commons.math.random.BitsStreamGeneratorTest)", "testNextIntNegativeToPositiveRange(org.apache.commons.math.random.BitsStreamGeneratorTest): Chisquare test failed p-value = 0.0 chisquare statistic = 190.59200000000007.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t115", "3\t0.11\t\t109", "4\t0.11\t\t204", "5\t0.11\t\t110", "6\t0.11\t\t121", "7\t0.11\t\t109", "8\t0.11\t\t112", "9\t0.11\t\t120", "This test can fail randomly due to sampling error with probability 0.01.", "testNextIntNegativeRange(org.apache.commons.math.random.BitsStreamGeneratorTest): nextInt range", "testNextLongNegativeToPositiveRange(org.apache.commons.math.random.BitsStreamGeneratorTest): Chisquare test failed p-value = 0.0 chisquare statistic = 190.59200000000007.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t115", "3\t0.11\t\t109", "4\t0.11\t\t204", "5\t0.11\t\t110", "6\t0.11\t\t121", "7\t0.11\t\t109", "8\t0.11\t\t112", "9\t0.11\t\t120", "This test can fail randomly due to sampling error with probability 0.01.", "testNextLongNegativeRange(org.apache.commons.math.random.BitsStreamGeneratorTest): nextLong range", "testNextUniformIAE(org.apache.commons.math.random.BitsStreamGeneratorTest): MathIllegalArgumentException expected", "testNextUniformUniformMaximalInterval(org.apache.commons.math.random.BitsStreamGeneratorTest): nextUniform range", "testNextUniformExtremeValues(org.apache.commons.math.random.Well1024aTest)", "testNextIntNegativeToPositiveRange(org.apache.commons.math.random.Well1024aTest): Chisquare test failed p-value = 0.0 chisquare statistic = 230.31800000000004.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t116", "3\t0.11\t\t125", "4\t0.11\t\t224", "5\t0.11\t\t108", "6\t0.11\t\t104", "7\t0.11\t\t116", "8\t0.11\t\t97", "9\t0.11\t\t110", "This test can fail randomly due to sampling error with probability 0.01.", "testNextIntNegativeRange(org.apache.commons.math.random.Well1024aTest): nextInt range", "testNextLongNegativeToPositiveRange(org.apache.commons.math.random.Well1024aTest): Chisquare test failed p-value = 0.0 chisquare statistic = 230.31800000000004.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t116", "3\t0.11\t\t125", "4\t0.11\t\t224", "5\t0.11\t\t108", "6\t0.11\t\t104", "7\t0.11\t\t116", "8\t0.11\t\t97", "9\t0.11\t\t110", "This test can fail randomly due to sampling error with probability 0.01.", "testNextLongNegativeRange(org.apache.commons.math.random.Well1024aTest): nextLong range", "testNextUniformIAE(org.apache.commons.math.random.Well1024aTest): MathIllegalArgumentException expected", "testNextUniformUniformMaximalInterval(org.apache.commons.math.random.Well1024aTest): nextUniform range", "testNextUniformExtremeValues(org.apache.commons.math.random.Well44497bTest)", "testNextIntNegativeToPositiveRange(org.apache.commons.math.random.Well44497bTest): Chisquare test failed p-value = 0.0 chisquare statistic = 208.75400000000005.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t110", "3\t0.11\t\t105", "4\t0.11\t\t212", "5\t0.11\t\t131", "6\t0.11\t\t116", "7\t0.11\t\t104", "8\t0.11\t\t102", "9\t0.11\t\t120", "This test can fail randomly due to sampling error with probability 0.01.", "testNextIntNegativeRange(org.apache.commons.math.random.Well44497bTest): nextInt range", "testNextLongNegativeToPositiveRange(org.apache.commons.math.random.Well44497bTest): Chisquare test failed p-value = 0.0 chisquare statistic = 208.75400000000005.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t110", "3\t0.11\t\t105", "4\t0.11\t\t212", "5\t0.11\t\t131", "6\t0.11\t\t116", "7\t0.11\t\t104", "8\t0.11\t\t102", "9\t0.11\t\t120", "This test can fail randomly due to sampling error with probability 0.01.", "testNextLongNegativeRange(org.apache.commons.math.random.Well44497bTest): nextLong range", "testNextUniformIAE(org.apache.commons.math.random.Well44497bTest): MathIllegalArgumentException expected", "testNextUniformUniformMaximalInterval(org.apache.commons.math.random.Well44497bTest): nextUniform range", "testNextUniformExtremeValues(org.apache.commons.math.random.MersenneTwisterTest)", "testNextIntNegativeToPositiveRange(org.apache.commons.math.random.MersenneTwisterTest): Chisquare test failed p-value = 0.0 chisquare statistic = 213.39800000000005.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t113", "3\t0.11\t\t110", "4\t0.11\t\t216", "5\t0.11\t\t126", "6\t0.11\t\t112", "7\t0.11\t\t109", "8\t0.11\t\t100", "9\t0.11\t\t114", "This test can fail randomly due to sampling error with probability 0.01.", "testNextIntNegativeRange(org.apache.commons.math.random.MersenneTwisterTest): nextInt range", "testNextLongNegativeToPositiveRange(org.apache.commons.math.random.MersenneTwisterTest): Chisquare test failed p-value = 0.0 chisquare statistic = 213.39800000000005.", "value\texpected\tobserved", "1\t0.11\t\t0", "2\t0.11\t\t113", "3\t0.11\t\t110", "4\t0.11\t\t216", "5\t0.11\t\t126", "6\t0.11\t\t112", "7\t0.11\t\t109", "8\t0.11\t\t100", "9\t0.11\t\t114", "This test can fail randomly due to sampling error with probability 0.01.", "testNextLongNegativeRange(org.apache.commons.math.random.MersenneTwisterTest): nextLong range", "testNextUniformIAE(org.apache.commons.math.random.MersenneTwisterTest): MathIllegalArgumentException expected", "testNextUniformUniformMaximalInterval(org.apache.commons.math.random.MersenneTwisterTest): nextUniform range"], "patch": "diff --git a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\nindex cfec8ca..c5c14a9 100644\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n@@ -116,6 +116,7 @@\n     INDEX_OUT_OF_RANGE(\"index {0} out of allowed range [{1}, {2}]\"),\n     INDEX(\"index ({0})\"), /* keep */\n     NOT_FINITE_NUMBER(\"{0} is not a finite number\"), /* keep */\n+    INFINITE_BOUND(\"interval bounds must be finite\"),\n     ARRAY_ELEMENT(\"value {0} at index {1}\"), /* keep */\n     INFINITE_ARRAY_ELEMENT(\"Array contains an infinite element, {0} at index {1}\"),\n     INFINITE_VALUE_CONVERSION(\"cannot convert infinite value\"),\n@@ -240,6 +241,7 @@\n     NO_REGRESSORS(\"Regression model must include at least one regressor\"),\n     NO_RESULT_AVAILABLE(\"no result available\"),\n     NO_SUCH_MATRIX_ENTRY(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\"),\n+    NAN_NOT_ALLOWED(\"NaN is not allowed\"),\n     NULL_NOT_ALLOWED(\"null is not allowed\"), /* keep */\n     ARRAY_ZERO_LENGTH_OR_NULL_NOTALLOWED(\"A null or zero length array not allowed\"),\n     COVARIANCE_MATRIX(\"covariance matrix\"), /* keep */\ndiff --git a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\nindex 0fda688..16d655b 100644\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n@@ -36,6 +36,7 @@\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.WeibullDistribution;\n import org.apache.commons.math.distribution.ZipfDistribution;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n@@ -250,7 +251,8 @@ public int nextInt(int lower, int upper) {\n                                                 lower, upper, false);\n         }\n         double r = getRan().nextDouble();\n-        return (int) ((r * upper) + ((1.0 - r) * lower) + r);\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (int)FastMath.floor(scaled);\n     }\n \n     /**\n@@ -270,7 +272,8 @@ public long nextLong(long lower, long upper) {\n                                                 lower, upper, false);\n         }\n         double r = getRan().nextDouble();\n-        return (long) ((r * upper) + ((1.0 - r) * lower) + r);\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (long)FastMath.floor(scaled);\n     }\n \n     /**\n@@ -361,7 +364,9 @@ public int nextSecureInt(int lower, int upper) {\n                                                 lower, upper, false);\n         }\n         SecureRandom sec = getSecRan();\n-        return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n+        double r = sec.nextDouble();\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (int)FastMath.floor(scaled);\n     }\n \n     /**\n@@ -382,7 +387,9 @@ public long nextSecureLong(long lower, long upper) {\n                                                 lower, upper, false);\n         }\n         SecureRandom sec = getSecRan();\n-        return lower + (long) (sec.nextDouble() * (upper - lower + 1));\n+        double r = sec.nextDouble();\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (long)FastMath.floor(scaled);\n     }\n \n     /**\n@@ -579,19 +586,26 @@ public double nextExponential(double mean) {\n      * provide a symmetric output interval (both endpoints excluded).\n      * </p>\n      *\n-     * @param lower\n-     *            the lower bound.\n-     * @param upper\n-     *            the upper bound.\n-     * @return a uniformly distributed random value from the interval (lower,\n-     *         upper)\n-     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     * @param lower the lower bound.\n+     * @param upper the upper bound.\n+     * @return a uniformly distributed random value from the interval (lower, upper)\n+     * @throws MathIllegalArgumentException if {@code lower >= upper}\n+     * or either bound is infinite or NaN\n      */\n     public double nextUniform(double lower, double upper) {\n         if (lower >= upper) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                                                lower, upper, false);\n+            throw new MathIllegalArgumentException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper);\n+        }\n+\n+        if (Double.isInfinite(lower) || Double.isInfinite(upper)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_BOUND);\n         }\n+\n+        if (Double.isNaN(lower) || Double.isNaN(upper)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.NAN_NOT_ALLOWED);\n+        }\n+\n         final RandomGenerator generator = getRan();\n \n         // ensure nextDouble() isn't 0.0\n@@ -600,7 +614,7 @@ public double nextUniform(double lower, double upper) {\n             u = generator.nextDouble();\n         }\n \n-        return lower + u * (upper - lower);\n+        return u * upper + (1.0 - u) * lower;\n     }\n \n     /**\n", "nb_test": 3326, "linesAdd": 25, "jira_id": "724", "singleLine": false, "nb_skipped": 1, "commit": "9c8bb934", "nb_failure": 70, "linesRem": 7}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["EigenDecompositionTest.testMath1051:457->checkUnsymmetricMatrix:520 Failed to create EigenDecomposition for matrix Array2DRowRealMatrix{{0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,1.0},{0.0,0.0,0.0,1.0,0.0},{1.0,1.0,0.0,0.0,1.0},{1.0,0.0,1.0,0.0,1.0}}, ex=org.apache.commons.math3.exception.MaxCountExceededException: illegal state: convergence failed"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\nindex a2ea88e..b566de7 100644\n--- a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n@@ -364,15 +364,13 @@ private void performDoubleQRStep(final int il, final int im, final int iu,\n                 q = matrixT[k + 1][k - 1];\n                 r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                 shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n-                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n+                if (Precision.equals(shift.x, 0.0, epsilon)) {\n+                    continue;\n+                }\n                 p = p / shift.x;\n                 q = q / shift.x;\n                 r = r / shift.x;\n             }\n-            }\n-            if (shift.x == 0.0) {\n-                break;\n-            }\n             double s = FastMath.sqrt(p * p + q * q + r * r);\n             if (p < 0.0) {\n                 s = -s;\n", "nb_test": 5400, "linesAdd": 3, "jira_id": "1051", "singleLine": false, "nb_skipped": 4, "commit": "bda25b40", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testIssue631(org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest): illegal state: maximal count (3,624) exceeded: evaluations"], "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex fde7172..b3a23a1 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -169,25 +169,37 @@ protected final double doSolve() {\n \n             // Update the bounds with the new approximation.\n             if (f1 * fx < 0) {\n-                // We had [x0..x1]. We update it to [x1, x]. Note that the\n-                // value of x1 has switched to the other bound, thus inverting\n+                // The value of x1 has switched to the other bound, thus inverting\n                 // the interval.\n                 x0 = x1;\n                 f0 = f1;\n-                x1 = x;\n-                f1 = fx;\n                 inverted = !inverted;\n             } else {\n-                // We had [x0..x1]. We update it to [x0, x].\n-                if (method == Method.ILLINOIS) {\n+                switch (method) {\n+                case ILLINOIS:\n                     f0 *= 0.5;\n-                }\n-                if (method == Method.PEGASUS) {\n+                    break;\n+                case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n+                    break;\n+                case REGULA_FALSI:\n+                    if (x == x1) {\n+                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n+                                                          atol);\n+                        // Update formula cannot make any progress: Update the\n+                        // search interval.\n+                        x0 = 0.5 * (x0 + x1 - delta);\n+                        f0 = computeObjectiveValue(x0);\n                     }\n+                    break;\n+                default:\n+                    // Should never happen.\n+                    throw new MathInternalError();\n+                }\n+            }\n+            // Update from [x0, x1] to [x0, x].\n             x1 = x;\n             f1 = fx;\n-            }\n \n             // If the function value of the last approximation is too small,\n             // given the function value accuracy, then we can't get closer to\n", "nb_test": 2891, "linesAdd": 16, "jira_id": "631", "singleLine": false, "nb_skipped": 1, "commit": "334c01e6", "nb_failure": 0, "linesRem": 6}, {"files": 3, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["WeibullDistributionTest.testInverseCumulativeProbabilitySmallPAccuracy:73 expected:<9.48683298050514E-9> but was:<0.0>", "LogNormalDistributionTest.testTinyVariance:251 expected:<1.0E-18> but was:<0.0>", "BetaTest.testRegularizedBetaTinyArgument:141 expected:<9.999950000166648E-6> but was:<1.0000050000166648E-5>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java b/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java\nindex 810c9e4..ab7a13b 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java\n@@ -289,7 +289,7 @@ public double getNumericalMean() {\n     public double getNumericalVariance() {\n         final double s = shape;\n         final double ss = s * s;\n-        return (FastMath.exp(ss) - 1) * FastMath.exp(2 * scale + ss);\n+        return (FastMath.expm1(ss)) * FastMath.exp(2 * scale + ss);\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math3/distribution/WeibullDistribution.java b/src/main/java/org/apache/commons/math3/distribution/WeibullDistribution.java\nindex ec34b50..6e69bc9 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/WeibullDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/WeibullDistribution.java\n@@ -221,7 +221,7 @@ public double inverseCumulativeProbability(double p) {\n         } else  if (p == 1) {\n             ret = Double.POSITIVE_INFINITY;\n         } else {\n-            ret = scale * FastMath.pow(-FastMath.log(1.0 - p), 1.0 / shape);\n+            ret = scale * FastMath.pow(-FastMath.log1p(-p), 1.0 / shape);\n         }\n         return ret;\n     }\ndiff --git a/src/main/java/org/apache/commons/math3/special/Beta.java b/src/main/java/org/apache/commons/math3/special/Beta.java\nindex 59f696a..c6091b4 100644\n--- a/src/main/java/org/apache/commons/math3/special/Beta.java\n+++ b/src/main/java/org/apache/commons/math3/special/Beta.java\n@@ -218,7 +218,7 @@ protected double getA(int n, double x) {\n                     return 1.0;\n                 }\n             };\n-            ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -\n+            ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) -\n                 FastMath.log(a) - logBeta(a, b)) *\n                 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n         }\n", "nb_test": 5428, "linesAdd": 3, "jira_id": "1058", "singleLine": false, "nb_skipped": 4, "commit": "4ebd967c", "nb_failure": 3, "linesRem": 3}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["BetaTest.testMath1067:153 Infinite recursion"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/special/Beta.java b/src/main/java/org/apache/commons/math3/special/Beta.java\nindex c6091b4..04696f9 100644\n--- a/src/main/java/org/apache/commons/math3/special/Beta.java\n+++ b/src/main/java/org/apache/commons/math3/special/Beta.java\n@@ -189,11 +189,12 @@ public static double regularizedBeta(double x,\n             Double.isNaN(b) ||\n             x < 0 ||\n             x > 1 ||\n-            a <= 0.0 ||\n-            b <= 0.0) {\n+            a <= 0 ||\n+            b <= 0) {\n             ret = Double.NaN;\n-        } else if (x > (a + 1.0) / (a + b + 2.0)) {\n-            ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n+        } else if (x > (a + 1) / (2 + b + a) &&\n+                   1 - x <= (b + 1) / (2 + b + a)) {\n+            ret = 1 - regularizedBeta(1 - x, b, a, epsilon, maxIterations);\n         } else {\n             ContinuedFraction fraction = new ContinuedFraction() {\n \n", "nb_test": 5476, "linesAdd": 5, "jira_id": "1067", "singleLine": false, "nb_skipped": 5, "commit": "aff82362", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["polynomial(org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 70b2a2b..1bbad3e 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -17,8 +17,6 @@\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import java.util.Arrays;\n-\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n@@ -244,12 +242,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance != null) {\n-            scale = vecAbsoluteTolerance;\n+          final double[] scale = new double[y0.length];\n+          if (vecAbsoluteTolerance == null) {\n+              for (int i = 0; i < scale.length; ++i) {\n+                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n+              }\n             } else {\n-            scale = new double[y0.length];\n-            Arrays.fill(scale, scalAbsoluteTolerance);\n+              for (int i = 0; i < scale.length; ++i) {\n+                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n+              }\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n", "nb_test": 2121, "linesAdd": 8, "jira_id": "338", "singleLine": false, "nb_skipped": 0, "commit": "8dd22390", "nb_failure": 1, "linesRem": 7}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testMath369(org.apache.commons.math.analysis.solvers.BisectionSolverTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f66927..180caef 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,7 @@ public double solve(double min, double max)\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n", "nb_test": 2167, "linesAdd": 1, "jira_id": "369", "singleLine": false, "nb_skipped": 0, "commit": "f4a4464b", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPcts(org.apache.commons.math.stat.FrequencyTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d728..68c8bf2 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,7 @@ public long getCount(char v) {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct((Comparable<?>) v);\n     }\n \n     /**\n", "nb_test": 2125, "linesAdd": 1, "jira_id": "329", "singleLine": false, "nb_skipped": 0, "commit": "6dd3724b", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testExtremeValues(org.apache.commons.math.distribution.NormalDistributionTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\nindex 456555b..0d7ce7d 100644\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n@@ -114,26 +114,20 @@ public double density(double x) {\n \n     /**\n      * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+     * If {@code x}is more than 40 standard deviations from the mean, 0 or 1 is returned,\n+     * as in these cases the actual value is within {@code Double.MIN_VALUE} of 0 or 1.\n      *\n      * @param x Value at which the CDF is evaluated.\n      * @return CDF evaluated at {@code x}.\n-     * @throws MathException if the algorithm fails to converge; unless\n-     * {@code x} is more than 20 standard deviations from the mean, in which\n-     * case the convergence exception is caught and 0 or 1 is returned.\n+     * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n-        try {\n-            return 0.5 * (1.0 + Erf.erf((x - mean) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n+        final double dev = x - mean;\n+        if (FastMath.abs(dev) > 40 * standardDeviation) { \n+            return dev < 0 ? 0.0d : 1.0d;\n         }\n+        return 0.5 * (1.0 + Erf.erf((dev) /\n+                    (standardDeviation * FastMath.sqrt(2.0))));\n     }\n \n     /**\n", "nb_test": 2209, "linesAdd": 5, "jira_id": "414", "singleLine": false, "nb_skipped": 1, "commit": "5fe9b36c", "nb_failure": 0, "linesRem": 11}, {"files": 2, "project": "commons-math", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["WelzlEncloser2DTest.testReducingBall1:71->checkDisk:108->checkDisk:153 \u00bb MathInternal", "WelzlEncloser2DTest.testLargeSamples:94->checkDisk:153 \u00bb MathInternal illegal ..."], "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java b/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java\nindex 4e92704..a2e1684 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.commons.math3.geometry.enclosing;\n \n-import java.util.List;\n-\n import org.apache.commons.math3.geometry.Point;\n import org.apache.commons.math3.geometry.Space;\n \n@@ -34,6 +32,6 @@\n      * @param points points to enclose\n      * @return enclosing ball\n      */\n-    EnclosingBall<S, P> enclose(List<P> points);\n+    EnclosingBall<S, P> enclose(Iterable<P> points);\n \n }\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\nindex ce5c58c..b8ea5d6 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n@@ -65,9 +65,9 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n     }\n \n     /** {@inheritDoc} */\n-    public EnclosingBall<S, P> enclose(final List<P> points) {\n+    public EnclosingBall<S, P> enclose(final Iterable<P> points) {\n \n-        if (points == null || points.isEmpty()) {\n+        if (points == null || !points.iterator().hasNext()) {\n             // return an empty ball\n             return generator.ballOnSupport(new ArrayList<P>());\n         }\n@@ -81,14 +81,14 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n      * @param points points to be enclosed\n      * @return enclosing ball\n      */\n-    private EnclosingBall<S, P> pivotingBall(final List<P> points) {\n+    private EnclosingBall<S, P> pivotingBall(final Iterable<P> points) {\n \n         List<P> extreme = new ArrayList<P>(max);\n         List<P> support = new ArrayList<P>(max);\n \n         // start with only first point selected as a candidate support\n-        extreme.add(points.get(0));\n-        EnclosingBall<S, P> ball = moveToFrontBall(extreme, support);\n+        extreme.add(points.iterator().next());\n+        EnclosingBall<S, P> ball = moveToFrontBall(extreme, extreme.size(), support);\n \n         while (true) {\n \n@@ -103,7 +103,7 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n             support.clear();\n             support.add(farthest);\n             EnclosingBall<S, P> savedBall = ball;\n-            ball = moveToFrontBall(extreme, support);\n+            ball = moveToFrontBall(extreme, extreme.size(), support);\n             if (ball.getRadius() < savedBall.getRadius()) {\n                 // TODO: fix this, it should never happen but it does!\n                 throw new MathInternalError();\n@@ -122,28 +122,31 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n \n     /** Compute enclosing ball using Welzl's move to front heuristic.\n      * @param extreme subset of extreme points\n+     * @param nbExtreme number of extreme points to consider\n      * @param support points that must belong to the ball support\n      * @return enclosing ball, for the extreme subset only\n      */\n-    private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final List<P> support) {\n+    private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final int nbExtreme,\n+                                                final List<P> support) {\n \n         // create a new ball on the prescribed support\n         EnclosingBall<S, P> ball = generator.ballOnSupport(support);\n \n         if (ball.getSupportSize() < max) {\n \n-            for (int i = 0; i < extreme.size(); ++i) {\n+            for (int i = 0; i < nbExtreme; ++i) {\n                 final P pi = extreme.get(i);\n                 if (!ball.contains(pi, tolerance)) {\n \n                     // we have found an outside point,\n                     // enlarge the ball by adding it to the support\n                     support.add(pi);\n-                    ball = moveToFrontBall(extreme.subList(i + 1, extreme.size()), support);\n+                    ball = moveToFrontBall(extreme, i, support);\n+                    support.remove(support.size() - 1);\n \n                     // it was an interesting point, move it to the front\n                     // according to Welzl's heuristic\n-                    for (int j = i; j > 1; --j) {\n+                    for (int j = i; j > 0; --j) {\n                         extreme.set(j, extreme.get(j - 1));\n                     }\n                     extreme.set(0, pi);\n@@ -162,7 +165,7 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n      * @param ball current ball\n      * @return farthest point\n      */\n-    public P selectFarthest(final List<P> points, final EnclosingBall<S, P> ball) {\n+    public P selectFarthest(final Iterable<P> points, final EnclosingBall<S, P> ball) {\n \n         final P center = ball.getCenter();\n         P farthest   = null;\n", "nb_test": 5656, "linesAdd": 14, "jira_id": "1096", "singleLine": false, "nb_skipped": 5, "commit": "faf99727", "nb_failure": 0, "linesRem": 14}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMath320A(org.apache.commons.math.linear.SingularValueSolverTest)", "testMath320B(org.apache.commons.math.linear.SingularValueSolverTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\nindex 6003ed6..e418c08 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n@@ -159,27 +159,28 @@ public RealMatrix getU()\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p - 1; ++i) {\n+                for (int i = 0; i < p; ++i) {\n                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                     final double mi = mainBidiagonal[i];\n-                    final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n+                    if (i < n - 1) {\n                         ei1 = eData[i + 1];\n+                        final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n-                }\n-                // last row\n-                final double lastMain = mainBidiagonal[p - 1];\n-                final double[] wr1  = wData[p - 1];\n+                    } else {\n                         for (int j = 0; j < p; ++j) {\n-                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n+                            wi[j] = mi * ei0[j] / singularValues[j];\n+                        }\n                     }\n+                }\n+\n                 for (int i = p; i < m; ++i) {\n                     wData[i] = new double[p];\n                 }\n@@ -247,25 +248,25 @@ public RealMatrix getV()\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p - 1; ++i) {\n+                for (int i = 0; i < p; ++i) {\n                     final double mi = mainBidiagonal[i];\n-                    final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n+                    if (i < m - 1) {\n                         ei1 = eData[i + 1];\n+                        final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n-                }\n-                // last row\n-                final double lastMain = mainBidiagonal[p - 1];\n-                final double[] wr1  = wData[p - 1];\n+                    } else {\n                         for (int j = 0; j < p; ++j) {\n-                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n+                            wi[j] = mi * ei0[j] / singularValues[j];\n+                        }\n+                    }\n                 }\n                 for (int i = p; i < n; ++i) {\n                     wData[i] = new double[p];\n", "nb_test": 2125, "linesAdd": 17, "jira_id": "320", "singleLine": false, "nb_skipped": 0, "commit": "b2f3f6db", "nb_failure": 2, "linesRem": 14}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["GammaTest.testGammaNegativeDouble:985 expected:<1> but was:<-1>"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/special/Gamma.java b/src/main/java/org/apache/commons/math4/special/Gamma.java\nindex aa0e90c..f390f7c 100644\n--- a/src/main/java/org/apache/commons/math4/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math4/special/Gamma.java\n@@ -695,7 +695,7 @@ public static double gamma(final double x) {\n             }\n         } else {\n             final double y = absX + LANCZOS_G + 0.5;\n-            final double gammaAbs = SQRT_TWO_PI / x *\n+            final double gammaAbs = SQRT_TWO_PI / absX *\n                                     FastMath.pow(y, absX + 0.5) *\n                                     FastMath.exp(-y) * lanczos(absX);\n             if (x > 0.0) {\n", "nb_test": 5864, "linesAdd": 1, "jira_id": "1283", "singleLine": false, "nb_skipped": 3, "commit": "9e0c5ad4", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testIterator(org.apache.commons.math3.genetics.ListPopulationTest): Expected exception: java.lang.UnsupportedOperationException"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\nindex 8fe3ffe..3f3919c 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n@@ -200,11 +200,12 @@ public String toString() {\n     }\n \n     /**\n-     * Chromosome list iterator\n+     * Returns an iterator over the unmodifiable list of chromosomes.\n+     * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+        return getChromosomes().iterator();\n     }\n }\n", "nb_test": 3508, "linesAdd": 1, "jira_id": "779", "singleLine": false, "nb_skipped": 1, "commit": "ebadb558", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testIssue695(org.apache.commons.math.ode.events.EventStateTest): going backard in time! (7.796578226186635 < 10.99)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\nindex 2d878b1..8f315e3 100644\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n@@ -40,7 +40,6 @@\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.Incrementor;\n-import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.Precision;\n \n /**\n@@ -278,7 +277,6 @@ protected double acceptStep(final AbstractStepInterpolator interpolator,\n \n             double previousT = interpolator.getGlobalPreviousTime();\n             final double currentT = interpolator.getGlobalCurrentTime();\n-            resetOccurred = false;\n \n             // initialize the events states if needed\n             if (! statesInitialized) {\n@@ -332,6 +330,9 @@ public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n@@ -341,6 +342,9 @@ public int compare(EventState es0, EventState es1) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n", "nb_test": 3070, "linesAdd": 6, "jira_id": "695", "singleLine": false, "nb_skipped": 1, "commit": "7980a242", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PrecisionTest.testMath1127:546 null"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/Precision.java b/src/main/java/org/apache/commons/math3/util/Precision.java\nindex d089476..fa938c0 100644\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n@@ -62,6 +62,14 @@\n     private static final int SGN_MASK_FLOAT = 0x80000000;\n     /** Positive zero. */\n     private static final double POSITIVE_ZERO = 0d;\n+    /** Positive zero bits. */\n+    private static final long POSITIVE_ZERO_DOUBLE_BITS = Double.doubleToRawLongBits(+0.0);\n+    /** Negative zero bits. */\n+    private static final long NEGATIVE_ZERO_DOUBLE_BITS = Double.doubleToRawLongBits(-0.0);\n+    /** Positive zero bits. */\n+    private static final int POSITIVE_ZERO_FLOAT_BITS   = Float.floatToRawIntBits(+0.0f);\n+    /** Negative zero bits. */\n+    private static final int NEGATIVE_ZERO_FLOAT_BITS   = Float.floatToRawIntBits(-0.0f);\n \n     static {\n         /*\n@@ -109,7 +117,7 @@ public static int compareTo(double x, double y, double eps) {\n      * (or fewer) floating point numbers between them, i.e. two adjacent floating\n      * point numbers are considered equal.\n      * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n      * Bruce Dawson</a>\n      *\n      * @param x first value\n@@ -190,7 +198,7 @@ public static boolean equalsIncludingNaN(float x, float y, float eps) {\n      * (or fewer) floating point numbers between them, i.e. two adjacent floating\n      * point numbers are considered equal.\n      * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n      * Bruce Dawson</a>\n      *\n      * @param x first value\n@@ -201,21 +209,37 @@ public static boolean equalsIncludingNaN(float x, float y, float eps) {\n      * point values between {@code x} and {@code y}.\n      * @since 2.2\n      */\n-    public static boolean equals(float x, float y, int maxUlps) {\n-        int xInt = Float.floatToIntBits(x);\n-        int yInt = Float.floatToIntBits(y);\n+    public static boolean equals(final float x, final float y, final int maxUlps) {\n \n-        // Make lexicographically ordered as a two's-complement integer.\n-        if (xInt < 0) {\n-            xInt = SGN_MASK_FLOAT - xInt;\n+        final int xInt = Float.floatToRawIntBits(x);\n+        final int yInt = Float.floatToRawIntBits(y);\n+\n+        final boolean isEqual;\n+        if (((xInt ^ yInt) & SGN_MASK_FLOAT) == 0) {\n+            // number have same sign, there is no risk of overflow\n+            isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        } else {\n+            // number have opposite signs, take care of overflow\n+            final int deltaPlus;\n+            final int deltaMinus;\n+            if (xInt < yInt) {\n+                deltaPlus  = yInt - POSITIVE_ZERO_FLOAT_BITS;\n+                deltaMinus = xInt - NEGATIVE_ZERO_FLOAT_BITS;\n+            } else {\n+                deltaPlus  = xInt - POSITIVE_ZERO_FLOAT_BITS;\n+                deltaMinus = yInt - NEGATIVE_ZERO_FLOAT_BITS;\n             }\n-        if (yInt < 0) {\n-            yInt = SGN_MASK_FLOAT - yInt;\n+\n+            if (deltaPlus > maxUlps) {\n+                isEqual = false;\n+            } else {\n+                isEqual = deltaMinus <= (maxUlps - deltaPlus);\n             }\n \n-        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        }\n \n         return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n+\n     }\n \n     /**\n@@ -315,12 +339,16 @@ public static boolean equalsIncludingNaN(double x, double y, double eps) {\n     /**\n      * Returns true if both arguments are equal or within the range of allowed\n      * error (inclusive).\n+     * <p>\n      * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n-     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n-     * point numbers are considered equal.\n+     * (or fewer) floating point numbers between them, i.e. two adjacent\n+     * floating point numbers are considered equal.\n+     * </p>\n+     * <p>\n      * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n      * Bruce Dawson</a>\n+     * </p>\n      *\n      * @param x first value\n      * @param y second value\n@@ -329,21 +357,37 @@ public static boolean equalsIncludingNaN(double x, double y, double eps) {\n      * @return {@code true} if there are fewer than {@code maxUlps} floating\n      * point values between {@code x} and {@code y}.\n      */\n-    public static boolean equals(double x, double y, int maxUlps) {\n-        long xInt = Double.doubleToLongBits(x);\n-        long yInt = Double.doubleToLongBits(y);\n+    public static boolean equals(final double x, final double y, final int maxUlps) {\n \n-        // Make lexicographically ordered as a two's-complement integer.\n-        if (xInt < 0) {\n-            xInt = SGN_MASK - xInt;\n+        final long xInt = Double.doubleToRawLongBits(x);\n+        final long yInt = Double.doubleToRawLongBits(y);\n+\n+        final boolean isEqual;\n+        if (((xInt ^ yInt) & SGN_MASK) == 0l) {\n+            // number have same sign, there is no risk of overflow\n+            isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        } else {\n+            // number have opposite signs, take care of overflow\n+            final long deltaPlus;\n+            final long deltaMinus;\n+            if (xInt < yInt) {\n+                deltaPlus  = yInt - POSITIVE_ZERO_DOUBLE_BITS;\n+                deltaMinus = xInt - NEGATIVE_ZERO_DOUBLE_BITS;\n+            } else {\n+                deltaPlus  = xInt - POSITIVE_ZERO_DOUBLE_BITS;\n+                deltaMinus = yInt - NEGATIVE_ZERO_DOUBLE_BITS;\n             }\n-        if (yInt < 0) {\n-            yInt = SGN_MASK - yInt;\n+\n+            if (deltaPlus > maxUlps) {\n+                isEqual = false;\n+            } else {\n+                isEqual = deltaMinus <= (maxUlps - deltaPlus);\n             }\n \n-        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        }\n \n         return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n+\n     }\n \n     /**\n", "nb_test": 5966, "linesAdd": 50, "jira_id": "1127", "singleLine": false, "nb_skipped": 3, "commit": "ba62c59d", "nb_failure": 1, "linesRem": 16}, {"files": 2, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testQuinticMin(org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest)"], "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\nindex 10bc9e6..26fd5e0 100644\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n@@ -89,12 +89,12 @@ public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n+        return optimaValues[0];\n     }\n \n     /** {@inheritDoc} */\n     public double getResult() {\n-        return optimizer.getResult();\n+        return optima[0];\n     }\n \n     /** {@inheritDoc} */\ndiff --git a/src/main/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\nindex bf406ab..07d8c4f 100644\n--- a/src/main/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\n@@ -36,7 +36,7 @@\n     void setMaxEvaluations(int maxEvaluations);\n \n     /** Get the maximal number of functions evaluations.\n-     * @return maximal number of functions evaluations\n+     * @return the maximal number of functions evaluations.\n      */\n     int getMaxEvaluations();\n \n@@ -46,7 +46,7 @@\n      * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n      * method. It is 0 if the method has not been called yet.\n      * </p>\n-     * @return number of evaluations of the objective function\n+     * @return the number of evaluations of the objective function.\n      */\n     int getEvaluations();\n \n@@ -57,16 +57,16 @@\n      * </p>\n      * @param f the function to optimize.\n      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}\n+     * or {@link GoalType#MINIMIZE}.\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n-     * @return a value where the function is optimum\n+     * @return a value where the function is optimum.\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the optimizer detects convergence problems otherwise.\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * function.\n      * @throws IllegalArgumentException if min > max or the endpoints do not\n-     * satisfy the requirements specified by the optimizer\n+     * satisfy the requirements specified by the optimizer.\n      */\n     double optimize(UnivariateRealFunction f, GoalType goalType,\n                     double min, double max)\n@@ -79,17 +79,17 @@\n      * </p>\n      * @param f the function to optimize.\n      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}\n+     * or {@link GoalType#MINIMIZE}.\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n-     * @param startValue the start value to use\n-     * @return a value where the function is optimum\n+     * @param startValue the start value to use.\n+     * @return a value where the function is optimum.\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the optimizer detects convergence problems otherwise.\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * function.\n      * @throws IllegalArgumentException if min > max or the arguments do not\n-     * satisfy the requirements specified by the optimizer\n+     * satisfy the requirements specified by the optimizer.\n      */\n     double optimize(UnivariateRealFunction f, GoalType goalType,\n                     double min, double max, double startValue)\n@@ -98,7 +98,7 @@\n     /**\n      * Get the result of the last run of the optimizer.\n      *\n-     * @return the last result.\n+     * @return the optimum.\n      * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n      */\n@@ -107,7 +107,7 @@\n     /**\n      * Get the result of the last run of the optimizer.\n      *\n-     * @return the value of the function at the last result.\n+     * @return the value of the function at the optimum.\n      * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n      */\n", "nb_test": 2245, "linesAdd": 2, "jira_id": "393", "singleLine": false, "nb_skipped": 0, "commit": "d4b02f6a", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testBoundaryRangeTooLarge(org.apache.commons.math3.optimization.direct.CMAESOptimizerTest): Unexpected exception, expected<org.apache.commons.math3.exception.NumberIsTooLargeException> but was<org.apache.commons.math3.exception.MathIllegalStateException>"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex b54cb37..f6a4f28 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -24,8 +24,8 @@\n import org.apache.commons.math3.analysis.MultivariateFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n@@ -78,6 +78,12 @@\n  *  <li><a href=\"http://en.wikipedia.org/wiki/CMA-ES\">Wikipedia</a></li>\n  * </ul>\n  *\n+ * When simple constraints (boundaries) are used, care must be taken that the\n+ * difference between the upper and lower bounds does not overflow; should it\n+ * be the case, a {@link NumberIsTooLargeException} will be thrown by the\n+ * {@link BaseAbstractMultivariateSimpleBoundsOptimizer#optimize(int,\n+ * MultivariateFunction,GoalType,double[],double[],double[]) optimize} method.\n+ *\n  * @version $Id$\n  * @since 3.0\n  */\n@@ -529,6 +535,21 @@ private void checkParameters() {\n                 boundaries = new double[2][];\n                 boundaries[0] = lB;\n                 boundaries[1] = uB;\n+\n+                // Abort early if the normalization will overflow (cf. \"encode\" method).\n+                for (int i = 0; i < lB.length; i++) {\n+                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n+                        final double max = Double.MAX_VALUE + boundaries[0][i];\n+                        final NumberIsTooLargeException e\n+                            = new NumberIsTooLargeException(boundaries[1][i],\n+                                                            max,\n+                                                            true);\n+                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n+                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n+\n+                        throw e;\n+                    }\n+                }\n             }\n         } else {\n             // Convert API to internal handling of boundaries.\n", "nb_test": 4153, "linesAdd": 15, "jira_id": "865", "singleLine": false, "nb_skipped": 4, "commit": "b55e0206", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testMath828Cycle(org.apache.commons.math3.optimization.linear.SimplexSolverTest): illegal state: maximal count (100) exceeded"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\nindex c2fa14d..dec310b 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -116,6 +116,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n+            if (tableau.getNumArtificialVariables() > 0) {\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n@@ -125,16 +126,23 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                         }\n                     }\n                 }\n+            }\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n             // see http://www.stanford.edu/class/msande310/blandrule.pdf\n             // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+            //\n+            // Additional heuristic: if we did not get a solution after half of maxIterations\n+            //                       revert to the simple case of just returning the top-most row\n+            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+            if (getIterations() < getMaxIterations() / 2) {\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {\n-                for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1 && minRow != row; i++) {\n+                    int i = tableau.getNumObjectiveFunctions();\n+                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n@@ -143,9 +151,9 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                         }\n                     }\n                 }\n-\n                 return minRow;\n             }\n+        }\n         return minRatioPositions.get(0);\n     }\n \n", "nb_test": 3967, "linesAdd": 6, "jira_id": "828", "singleLine": false, "nb_skipped": 4, "commit": "a49e443c", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "commons-math", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ResizableDoubleArrayTest.testConstructors:131 array lengths differed, expected.length=1 actual.length=0"], "patch": "diff --git a/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java b/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\nindex 6377141..7d9547c 100644\n--- a/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\n@@ -287,7 +287,7 @@ public ResizableDoubleArray(int initialCapacity,\n         numElements = 0;\n         startIndex = 0;\n \n-        if (data != null && data.length > 1) {\n+        if (data != null && data.length > 0) {\n             addElements(data);\n         }\n     }\n", "nb_test": 5821, "linesAdd": 1, "jira_id": "1252", "singleLine": false, "nb_skipped": 3, "commit": "09fe956a", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "commons-math", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["MathArraysTest.testLinearCombinationWithSingleElementArray:591 \u00bb ArrayIndexOutOfBounds"], "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 1aa56cc..8f83d96 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -818,6 +818,11 @@ public static double linearCombination(final double[] a, final double[] b)\n             throw new DimensionMismatchException(len, b.length);\n         }\n \n+        if (len == 1) {\n+            // Revert to scalar multiplication.\n+            return a[0] * b[0];\n+        }\n+\n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;\n \n", "nb_test": 5035, "linesAdd": 4, "jira_id": "1005", "singleLine": false, "nb_skipped": 4, "commit": "91d280b7", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEmptyTable(org.apache.wicket.markup.html.list.TableTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/list/PageableListView.java b/wicket/src/main/java/org/apache/wicket/markup/html/list/PageableListView.java\nindex 707cef4..e1b2e77 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/list/PageableListView.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/list/PageableListView.java\n@@ -84,7 +84,7 @@ public PageableListView(final String id, final List<T> list, final int rowsPerPa\n \tpublic final int getCurrentPage()\n \t{\n \t\t// If first cell is out of range, bring page back into range\n-\t\twhile ((currentPage * rowsPerPage) >= getList().size())\n+\t\twhile ((currentPage > 0) && ((currentPage * rowsPerPage) >= getList().size()))\n \t\t{\n \t\t\tcurrentPage--;\n \t\t}\n", "nb_test": 782, "linesAdd": 1, "jira_id": "2181", "singleLine": false, "nb_skipped": 0, "commit": "d79d0192", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMicroMap(wicket.util.collections.MicroMapTest): Expected i.next() to fail with NoSuchElementException"], "patch": "diff --git a/jdk-1.4/wicket/src/main/java/wicket/util/collections/MicroMap.java b/jdk-1.4/wicket/src/main/java/wicket/util/collections/MicroMap.java\nindex c708f98..1253baa 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/util/collections/MicroMap.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/util/collections/MicroMap.java\n@@ -22,6 +22,7 @@\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.Map;\n+import java.util.NoSuchElementException;\n import java.util.Set;\n \n /**\n@@ -211,6 +212,10 @@ public boolean hasNext()\n \n \t\t\t\t\tpublic Object next()\n \t\t\t\t\t{\n+\t\t\t\t\t\tif (!hasNext())\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tthrow new NoSuchElementException();\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tindex++;\n \n \t\t\t\t\t\treturn key;\n@@ -241,6 +246,9 @@ public Collection values()\n \t\t{\n \t\t\tpublic Object get(final int index)\n \t\t\t{\n+\t\t\t\tif (index > size() - 1) {\n+\t\t\t\t\tthrow new IndexOutOfBoundsException();\n+\t\t\t\t}\n \t\t\t\treturn value;\n \t\t\t}\n \n@@ -269,6 +277,10 @@ public boolean hasNext()\n \n \t\t\t\t\tpublic Object next()\n \t\t\t\t\t{\n+\t\t\t\t\t\tif (!hasNext())\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tthrow new NoSuchElementException();\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tindex++;\n \n \t\t\t\t\t\treturn new Map.Entry()\n", "nb_test": 408, "linesAdd": 12, "jira_id": "428", "singleLine": false, "nb_skipped": 0, "commit": "d906576c", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["PageParametersEncoderTest.decodeParameters:42 \u00bb IllegalArgument Argument 'name..."], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\nindex 13e45ec..aa095de 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\n@@ -18,6 +18,7 @@\n \n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.Url.QueryParameter;\n+import org.apache.wicket.util.string.Strings;\n \n /**\n  * Simple encoder with direct indexed/named parameters mapping.\n@@ -47,7 +48,11 @@ public PageParameters decodePageParameters(final Url url)\n \n \t\tfor (QueryParameter p : url.getQueryParameters())\n \t\t{\n-\t\t\tparameters.add(p.getName(), p.getValue(), INamedParameters.Type.QUERY_STRING);\n+\t\t\tString parameterName = p.getName();\n+\t\t\tif (Strings.isEmpty(parameterName) == false)\n+\t\t\t{\n+\t\t\t\tparameters.add(parameterName, p.getValue(), INamedParameters.Type.QUERY_STRING);\n+\t\t\t}\n \t\t}\n \n \t\treturn parameters.isEmpty() ? null : parameters;\n", "nb_test": 105, "linesAdd": 6, "jira_id": "5770", "singleLine": false, "nb_skipped": 0, "commit": "cf6172bd", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["StringsTest.testJoin:570->Assert.assertEquals:144->Assert.assertEquals:115 expected:<foo[barb]az> but was:<foo[ar]az>"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java b/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\nindex f3ebe1b..fdb75a4 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\n@@ -677,7 +677,7 @@ else if (fragments.length < 2)\n \t\t\t\t{\r\n \t\t\t\t\tboolean lhsClosed = fragments[i - 1].endsWith(separator);\r\n \t\t\t\t\tboolean rhsClosed = fragment.startsWith(separator);\r\n-\t\t\t\t\tif (lhsClosed && rhsClosed)\r\n+\t\t\t\t\tif (!Strings.isEmpty(separator) && lhsClosed && rhsClosed)\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tbuff.append(fragment.substring(1));\r\n \t\t\t\t\t}\r\n", "nb_test": 181, "linesAdd": 1, "jira_id": "5720", "singleLine": false, "nb_skipped": 2, "commit": "2fc6a395", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testLocaleUsed(org.apache.wicket.datetime.DateConverterTest)"], "patch": "diff --git a/wicket-datetime/src/main/java/org/apache/wicket/datetime/StyleDateConverter.java b/wicket-datetime/src/main/java/org/apache/wicket/datetime/StyleDateConverter.java\nindex d68b04a..92ade4c 100644\n--- a/wicket-datetime/src/main/java/org/apache/wicket/datetime/StyleDateConverter.java\n+++ b/wicket-datetime/src/main/java/org/apache/wicket/datetime/StyleDateConverter.java\n@@ -16,14 +16,14 @@\n  */\n package org.apache.wicket.datetime;\n \n-import java.util.Locale;\n-\n import org.apache.wicket.datetime.markup.html.form.DateTextField;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n+import java.util.Locale;\n+\n \n /**\n  * Date converter that uses Joda Time and can be configured to take the time zone difference between\n@@ -52,15 +52,13 @@\n \n \t/**\n \t * Construct. The dateStyle 'S-' (which is the same as {@link DateTimeFormat#shortDate()}) will\n-\t * be used for constructing the date format for the current locale.\n-\t * </p>\n-\t * When applyTimeZoneDifference is true, the current time is applied on the parsed date, and the\n-\t * date will be corrected for the time zone difference between the server and the client. For\n+\t * be used for constructing the date format for the current locale. </p> When\n+\t * applyTimeZoneDifference is true, the current time is applied on the parsed date, and the date\n+\t * will be corrected for the time zone difference between the server and the client. For\n \t * instance, if I'm in Seattle and the server I'm working on is in Amsterdam, the server is 9\n \t * hours ahead. So, if I'm inputting say 12/24 at a couple of hours before midnight, at the\n \t * server it is already 12/25. If this boolean is true, it will be transformed to 12/25, while\n-\t * the client sees 12/24.\n-\t * </p>\n+\t * the client sees 12/24. </p>\n \t * \n \t * @param applyTimeZoneDifference\n \t *            whether to apply the difference in time zones between client and server\n@@ -72,15 +70,13 @@ public StyleDateConverter(boolean applyTimeZoneDifference)\n \n \t/**\n \t * Construct. The provided pattern will be used as the base format (but they will be localized\n-\t * for the current locale) and if null, {@link DateTimeFormat#shortDate()} will be used.\n-\t * </p>\n+\t * for the current locale) and if null, {@link DateTimeFormat#shortDate()} will be used. </p>\n \t * When applyTimeZoneDifference is true, the current time is applied on the parsed date, and the\n \t * date will be corrected for the time zone difference between the server and the client. For\n \t * instance, if I'm in Seattle and the server I'm working on is in Amsterdam, the server is 9\n \t * hours ahead. So, if I'm inputting say 12/24 at a couple of hours before midnight, at the\n \t * server it is already 12/25. If this boolean is true, it will be transformed to 12/25, while\n-\t * the client sees 12/24.\n-\t * </p>\n+\t * the client sees 12/24. </p>\n \t * \n \t * @param dateStyle\n \t *            Date style to use. The first character is the date style, and the second character\n@@ -119,6 +115,8 @@ public final String getDatePattern(Locale locale)\n \t@Override\n \tprotected DateTimeFormatter getFormat(Locale locale)\n \t{\n-\t\treturn DateTimeFormat.forPattern(getDatePattern(locale)).withPivotYear(2000);\n+\t\treturn DateTimeFormat.forPattern(getDatePattern(locale))\n+\t\t\t.withLocale(locale)\n+\t\t\t.withPivotYear(2000);\n \t}\n }\n\\ No newline at end of file\n", "nb_test": 14, "linesAdd": 5, "jira_id": "3598", "singleLine": false, "nb_skipped": 0, "commit": "7c364566", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["booleanHasFieldAndGetter(org.apache.wicket.bean.validation.DefaultPropertyResolverTest): (..)"], "patch": "diff --git a/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java b/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\nindex 91eb1a3..442bca2 100644\n--- a/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\n+++ b/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\n@@ -3,6 +3,7 @@\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n \n+import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.markup.html.form.FormComponent;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.IPropertyReflectionAwareModel;\n@@ -50,11 +51,26 @@ public Property resolveProperty(FormComponent<?> component)\n \t\t\treturn new Property(field.getDeclaringClass(), field.getName());\n \t\t}\n \n+\t\tString name;\n \t\tMethod getter = delegate.getPropertyGetter();\n \t\tif (getter != null)\n \t\t{\n-\t\t\tString name = getter.getName().substring(3, 4).toLowerCase() +\n-\t\t\t\tgetter.getName().substring(4);\n+\t\t\tString methodName = getter.getName();\n+\t\t\tif (methodName.startsWith(\"get\"))\n+\t\t\t{\n+\t\t\t\tname = methodName.substring(3, 4).toLowerCase() +\n+\t\t\t\t\tmethodName.substring(4);\n+\t\t\t}\n+\t\t\telse if (methodName.startsWith(\"is\"))\n+\t\t\t{\n+\t\t\t\tname = methodName.substring(2, 3).toLowerCase() +\n+\t\t\t\t\t\tmethodName.substring(3);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tthrow new WicketRuntimeException(\"Invalid name for a getter method: '\"\n+\t\t\t\t\t\t+ methodName + \"'. It must start either with 'get' or 'is'.\");\n+\t\t\t}\n \t\t\treturn new Property(getter.getDeclaringClass(), name);\n \t\t}\n \n", "nb_test": 5, "linesAdd": 18, "jira_id": "5505", "singleLine": false, "nb_skipped": 0, "commit": "6cceff44", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["testDisabledBehaviorRequest(org.apache.wicket.BehaviorRequestTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/RequestListenerInterface.java b/wicket/src/main/java/org/apache/wicket/RequestListenerInterface.java\nindex 06d4dcf..26282cc 100644\n--- a/wicket/src/main/java/org/apache/wicket/RequestListenerInterface.java\n+++ b/wicket/src/main/java/org/apache/wicket/RequestListenerInterface.java\n@@ -255,6 +255,7 @@ public final void invoke(final IRequestableComponent component, final IBehavior\n \t\t{\n \t\t\tlog.warn(\"behavior not enabled; ignore call. Behavior {} at component {}\", behavior,\n \t\t\t\tcomponent);\n+\t\t\treturn;\n \t\t}\n \n \t\ttry\n", "nb_test": 972, "linesAdd": 1, "jira_id": "3098", "singleLine": true, "nb_skipped": 0, "commit": "1b7afefc", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["CachingResourceStreamLocatorTest.nonStrictMatchingDoesntResultInInvalidStrictMatch:162", "Expected: is null", "but: was <file:/home/ylyu/dataset/wicket3/dataset/wicket/WICKET-5968_8b7946d822433fcb0873b9ff47b93630d60cfbb4/wicket-core/target/classes/org/apache/wicket/ajax/res/js/wicket-ajax-jquery-debug.js>", "CachingResourceStreamLocatorTest.strictMatchingDoesntInvalidateNonStrictMatching:130", "Expected: is not null", "but: was null"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/util/resource/locator/caching/CachingResourceStreamLocator.java b/wicket-core/src/main/java/org/apache/wicket/core/util/resource/locator/caching/CachingResourceStreamLocator.java\nindex ceeb59f..f9b3624 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/util/resource/locator/caching/CachingResourceStreamLocator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/util/resource/locator/caching/CachingResourceStreamLocator.java\n@@ -73,7 +73,7 @@ public CachingResourceStreamLocator(final IResourceStreamLocator resourceStreamL\n \t@Override\n \tpublic IResourceStream locate(Class<?> clazz, String path)\n \t{\n-\t\tCacheKey key = new CacheKey(clazz.getName(), path, null, null, null, null);\n+\t\tCacheKey key = new CacheKey(clazz.getName(), path, null, null, null, null, true);\n \t\tIResourceStreamReference resourceStreamReference = cache.get(key);\n \n \t\tfinal IResourceStream result;\n@@ -113,7 +113,7 @@ else if (stream instanceof UrlResourceStream)\n \tpublic IResourceStream locate(Class<?> scope, String path, String style, String variation,\n \t\tLocale locale, String extension, boolean strict)\n \t{\n-\t\tCacheKey key = new CacheKey(scope.getName(), path, extension, locale, style, variation);\n+\t\tCacheKey key = new CacheKey(scope.getName(), path, extension, locale, style, variation, strict);\n \t\tIResourceStreamReference resourceStreamReference = cache.get(key);\n \n \t\tfinal IResourceStream result;\n@@ -154,37 +154,54 @@ public void clearCache()\n \t */\n \tprivate static class CacheKey extends Key\n \t{\n+\t\tprivate static final long serialVersionUID = 1L;\n+\n \t\t/**\n \t\t * The file extension\n \t\t */\n \t\tprivate final String extension;\n \n-\t\tprivate CacheKey(String scope, String name, String extension, Locale locale, String style, String variation)\n+\t\t/** Whether the key was looked up using a strict matching search */\n+\t\tprivate final boolean strict;\n+\n+\t\tprivate CacheKey(String scope, String name, String extension, Locale locale, String style, String variation, boolean strict)\n \t\t{\n \t\t\tsuper(scope, name, locale, style, variation);\n \n \t\t\tthis.extension = extension;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean equals(Object o)\n-\t\t{\n-\t\t\tif (this == o) return true;\n-\t\t\tif (o == null || getClass() != o.getClass()) return false;\n-\t\t\tif (!super.equals(o)) return false;\n-\n-\t\t\tCacheKey cacheKey = (CacheKey) o;\n-\n-\t\t\treturn !(extension != null ? !extension.equals(cacheKey.extension) : cacheKey.extension != null);\n-\n+\t\t\tthis.strict = strict;\n \t\t}\n \n \t\t@Override\n \t\tpublic int hashCode()\n \t\t{\n+\t\t\tfinal int prime = 31;\n \t\t\tint result = super.hashCode();\n-\t\t\tresult = 31 * result + (extension != null ? extension.hashCode() : 0);\n+\t\t\tresult = prime * result + ((extension == null) ? 0 : extension.hashCode());\n+\t\t\tresult = prime * result + (strict ? 1231 : 1237);\n \t\t\treturn result;\n \t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj)\n+\t\t{\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (!super.equals(obj))\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tCacheKey other = (CacheKey)obj;\n+\t\t\tif (extension == null)\n+\t\t\t{\n+\t\t\t\tif (other.extension != null)\n+\t\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\telse if (!extension.equals(other.extension))\n+\t\t\t\treturn false;\n+\t\t\tif (strict != other.strict)\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n \t}\n }\n", "nb_test": 1859, "linesAdd": 33, "jira_id": "5968", "singleLine": false, "nb_skipped": 1, "commit": "8b7946d8", "nb_failure": 2, "linesRem": 17}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testComponentAndFragmentWithSameId(org.apache.wicket.markup.html.panel.FragmentTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/FragmentMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/FragmentMarkupSourcingStrategy.java\nindex ac47e37..400ea8d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/FragmentMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/FragmentMarkupSourcingStrategy.java\n@@ -152,7 +152,7 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t\t\t{\n \t\t\t\tthrow new MarkupNotFoundException(\"Markup found for Fragment '\" + markupId\n \t\t\t\t\t+ \"' in providing markup container \" + getMarkupProvider(container)\n-\t\t\t\t\t+ \" is not a fragment tag\");\n+\t\t\t\t\t+ \" is not a <wicket:fragment> tag\");\n \t\t\t}\n \t\t}\n \n", "nb_test": 1529, "linesAdd": 1, "jira_id": "5060", "singleLine": false, "nb_skipped": 2, "commit": "8e6a6ec5", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testParse13(org.apache.wicket.request.UrlTest): expected:<[a=b]> but was:<[a=b, ]>"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex bbaf6ea..d387a13 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -298,9 +298,12 @@ public static Url parse(String url, Charset charset)\n \t\t\tString queryArray[] = Strings.split(queryString, '&');\n \t\t\tfor (String s : queryArray)\n \t\t\t{\n+\t\t\t\tif (Strings.isEmpty(s) == false)\n+\t\t\t\t{\n \t\t\t\t\tresult.parameters.add(parseQueryParameter(s, charset));\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n \n \t\treturn result;\n \t}\n@@ -315,23 +318,14 @@ private static QueryParameter parseQueryParameter(final String qp, final Charset\n \t{\n \t\tif (qp.indexOf('=') == -1)\n \t\t{\n+\t\t\t// name => empty value\n \t\t\treturn new QueryParameter(decodeParameter(qp, charset), \"\");\n \t\t}\n+\n \t\tString parts[] = Strings.split(qp, '=');\n-\t\tif (parts.length == 0)\n-\t\t{\n-\t\t\treturn new QueryParameter(\"\", \"\");\n-\t\t}\n-\t\telse if (parts.length == 1)\n-\t\t{\n-\t\t\treturn new QueryParameter(\"\", decodeParameter(parts[0], charset));\n-\t\t}\n-\t\telse\n-\t\t{\n \t\treturn new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1],\n \t\t\tcharset));\n \t}\n-\t}\n \n \t/**\n \t * get default port number for protocol\ndiff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/INamedParameters.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/INamedParameters.java\nindex e84ed21..bcf16be 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/INamedParameters.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/INamedParameters.java\n@@ -49,9 +49,8 @@\n \t\t */\r\n \t\tpublic NamedPair(final String key, final String value)\r\n \t\t{\r\n-\t\t\tArgs.notEmpty(key, \"key\");\r\n-\t\t\tthis.key = key;\r\n-\t\t\tthis.value = value;\r\n+\t\t\tthis.key = Args.notNull(key, \"key\");;\r\n+\t\t\tthis.value = Args.notNull(value, \"value\");\r\n \t\t}\r\n \r\n \t\t/**\r\n", "nb_test": 70, "linesAdd": 6, "jira_id": "4398", "singleLine": false, "nb_skipped": 0, "commit": "f88721fd", "nb_failure": 1, "linesRem": 14}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["Issue5569Test.testIssue5569:31 pattern 'WRONG_SPECIAL' found"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\nindex c7fe735..cbddd25 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n@@ -26,6 +26,8 @@\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.apache.wicket.util.lang.Classes;\n+import org.apache.wicket.util.visit.IVisit;\n+import org.apache.wicket.util.visit.IVisitor;\n \n /**\n  * Implements boilerplate as needed by many markup sourcing strategies.\n@@ -60,22 +62,37 @@ public AbstractMarkupSourcingStrategy()\n \tprotected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container,\n \t\tfinal Component child)\n \t{\n-\t\tIMarkupFragment markup = null;\n+\t\treturn container.visitChildren(MarkupContainer.class, new IVisitor<MarkupContainer, IMarkupFragment>()\n+\t\t{\n+\t\t\t@Override\n+\t\t\tpublic void component(MarkupContainer resolvingContainer, IVisit<IMarkupFragment> visit)\n+\t\t\t{\n+\t\t\t\tif (resolvingContainer instanceof IComponentResolver)\n+\t\t\t\t{\n+\t\t\t\t\tIMarkupFragment childMarkup = resolvingContainer.getMarkup(child);\n \n-\t\tfor (Component ch : container)\n+\t\t\t\t\tif (childMarkup != null && childMarkup.size() > 0)\n \t\t\t\t\t{\n-\t\t\tif ((ch != child) && (ch instanceof MarkupContainer) &&\n-\t\t\t\t(ch instanceof IComponentResolver))\n+\t\t\t\t\t\tIComponentResolver componentResolver = (IComponentResolver)resolvingContainer;\n+\n+\t\t\t\t\t\tMarkupStream stream = new MarkupStream(childMarkup);\n+\n+\t\t\t\t\t\tComponentTag tag = stream.getTag();\n+\n+\t\t\t\t\t\tComponent resolvedComponent = resolvingContainer.get(tag.getId());\n+\t\t\t\t\t\tif (resolvedComponent == null)\n \t\t\t\t\t\t{\n-\t\t\t\tmarkup = ((MarkupContainer)ch).getMarkup(child);\n-\t\t\t\tif (markup != null)\n+\t\t\t\t\t\t\tresolvedComponent = componentResolver.resolve(resolvingContainer, stream, tag);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (child == resolvedComponent)\n \t\t\t\t\t\t{\n-\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\tvisit.stop(childMarkup);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\n-\t\treturn markup;\n+\t\t\t}\n+\t\t});\n \t}\n \n \t/**\n", "nb_test": 1646, "linesAdd": 26, "jira_id": "5569", "singleLine": false, "nb_skipped": 2, "commit": "5efb8091", "nb_failure": 1, "linesRem": 9}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testNewValue1Append(org.apache.wicket.AttributeModifierTest)", "testNewValue1Prepend(org.apache.wicket.AttributeModifierTest)", "testNewValue2Append(org.apache.wicket.AttributeModifierTest)", "testNewValue2Prepend(org.apache.wicket.AttributeModifierTest)", "nullModelDoesNotAppendEmptyAttribute(org.apache.wicket.AttributeModifierTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/behavior/AttributeAppender.java b/wicket-core/src/main/java/org/apache/wicket/behavior/AttributeAppender.java\nindex 13b7fe9..5db4526 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/behavior/AttributeAppender.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/behavior/AttributeAppender.java\n@@ -152,9 +152,9 @@ protected String newValue(String currentValue, String appendValue)\n \t{\n \t\t// Short circuit when one of the values is empty: return the other value.\n \t\tif (Strings.isEmpty(currentValue))\n-\t\t\treturn appendValue != null ? appendValue : \"\";\n+\t\t\treturn appendValue != null ? appendValue : null;\n \t\telse if (Strings.isEmpty(appendValue))\n-\t\t\treturn currentValue != null ? currentValue : \"\";\n+\t\t\treturn currentValue != null ? currentValue : null;\n \n \t\tStringBuilder sb = new StringBuilder(currentValue);\n \t\tsb.append((getSeparator() == null ? \"\" : getSeparator()));\n", "nb_test": 1140, "linesAdd": 2, "jira_id": "3884", "singleLine": false, "nb_skipped": 2, "commit": "b772ff87", "nb_failure": 5, "linesRem": 2}, {"files": 5, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["hideableBorder(org.apache.wicket.markup.html.border.ComponentBorderTest): org/apache/wicket/markup/html/border/HideableBorderPage_ExpectedResult.html expected:<...r.HideableBorderPage[?0]\";(..)", "renderHomePage_13(org.apache.wicket.markup.html.basic.SimplePageTest): org/apache/wicket/markup/html/basic/SimplePageExpectedResult_13.html expected:<....basic.SimplePage_13[?0]\";(..)", "renderHomePage_1(org.apache.wicket.ajax.markup.html.ajaxLink.AjaxLinkTest): org/apache/wicket/ajax/markup/html/ajaxLink/AjaxLinkPageExpectedResult.html expected:<...jaxLink.AjaxLinkPage[?0]\";(..)", "renderHomePage_2(org.apache.wicket.ajax.markup.html.ajaxLink.AjaxLinkTest): org/apache/wicket/ajax/markup/html/ajaxLink/AjaxLinkWithBorderPageExpectedResult.html expected:<...axLinkWithBorderPage[?0]\";(..)", "page_2(org.apache.wicket.ajax.markup.html.ajaxLink.AjaxLinkTest): org/apache/wicket/ajax/markup/html/ajaxLink/AjaxPage2_ExpectedResult.html expected:<...l.ajaxLink.AjaxPage2[?0]\";(..)", "inlinePanel_7(org.apache.wicket.markup.html.panel.PanelTest): org/apache/wicket/markup/html/panel/InlinePanelPageExpectedResult_7.html expected:<...el.InlinePanelPage_7[?0]\";(..)", "inlinePanel_8(org.apache.wicket.markup.html.panel.PanelTest): org/apache/wicket/markup/html/panel/InlinePanelPageExpectedResult_8.html expected:<...el.InlinePanelPage_8[?0]\";(..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\nindex eea361d..81829d0 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n@@ -56,7 +56,7 @@ public IRequestHandler map(Exception e)\n \t\t\tResponse response = RequestCycle.get().getResponse();\n \t\t\tif (response instanceof WebResponse)\n \t\t\t{\n-\t\t\t\t// we don't wan't to cache an exceptional reply in the browser\n+\t\t\t\t// we don't want to cache an exceptional reply in the browser\n \t\t\t\t((WebResponse)response).disableCaching();\n \t\t\t}\n \t\t\treturn internalMap(e);\n@@ -92,7 +92,7 @@ private IRequestHandler internalMap(Exception e)\n \n \t\tif (e instanceof StalePageException)\n \t\t{\n-\t\t\t// If the page was stale, just rerender it\n+\t\t\t// If the page was stale, just re-render it\n \t\t\t// (the url should always be updated by an redirect in that case)\n \t\t\treturn new RenderPageRequestHandler(new PageProvider(((StalePageException)e).getPage()));\n \t\t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/Page.java b/wicket-core/src/main/java/org/apache/wicket/Page.java\nindex 1467798..86c0472 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Page.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Page.java\n@@ -450,6 +450,8 @@ public final boolean isPageStateless()\n \n \t\tif (stateless == null)\n \t\t{\n+\t\t\tinternalInitialize();\n+\n \t\t\tif (isStateless() == false)\n \t\t\t{\n \t\t\t\tstateless = Boolean.FALSE;\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/page/AbstractPageManager.java b/wicket-core/src/main/java/org/apache/wicket/page/AbstractPageManager.java\nindex 263bb62..da259e4 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/page/AbstractPageManager.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/page/AbstractPageManager.java\n@@ -127,10 +127,6 @@ public void newSessionCreated()\n \t@Override\n \tpublic void touchPage(IManageablePage page)\n \t{\n-\t\tif (!page.isPageStateless())\n-\t\t{\n-\t\t\tgetContext().bind();\n-\t\t}\n \t\tgetRequestAdapter().touch(page);\n \t}\n }\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\nindex be577f3..f40a0c9 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n@@ -431,6 +431,23 @@ public void init(final boolean isServlet, final FilterConfig filterConfig)\n \t\t\t\tThreadContext.detach();\n \t\t\t}\n \t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\t// #destroy() might not be called by the web container when #init() fails,\n+\t\t\t// so destroy now\n+\t\t\tlog.warn(\"initialization failed, destroying now\");\n+\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tdestroy();\n+\t\t\t}\n+\t\t\tcatch (Exception destroyException)\n+\t\t\t{\n+\t\t\t\tlog.warn(\"Unable to destroy after initialization failure\", destroyException);\n+\t\t\t}\n+\n+\t\t\tthrow new ServletException(e);\n+\t\t}\n \t\tfinally\n \t\t{\n \t\t\tif (newClassLoader != previousClassLoader)\n@@ -578,8 +595,15 @@ public void destroy()\n \n \t\tif (applicationFactory != null)\n \t\t{\n+\t\t\ttry\n+\t\t\t{\n \t\t\t\tapplicationFactory.destroy(this);\n \t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tapplicationFactory = null;\n+\t\t\t}\n+\t\t}\n \t}\n \n \t/**\n@@ -781,7 +805,7 @@ private void initIgnorePaths(final FilterConfig filterConfig)\n \t * level \"/\" then an empty string should be used instead.\n \t * \n \t * @param filterPath\n-\t * @return\n+\t * @return canonic filter path\n \t */\n \tstatic String canonicaliseFilterPath(String filterPath)\n \t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/cycle/PageRequestHandlerTracker.java b/wicket-core/src/main/java/org/apache/wicket/request/cycle/PageRequestHandlerTracker.java\nindex caa5a6d..b2390a6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/cycle/PageRequestHandlerTracker.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/cycle/PageRequestHandlerTracker.java\n@@ -59,6 +59,13 @@ public void onRequestHandlerScheduled(RequestCycle cycle, IRequestHandler handle\n \t\tregisterLastHandler(cycle,handler);\n \t}\n \n+\t@Override\n+\tpublic void onExceptionRequestHandlerResolved(RequestCycle cycle, IRequestHandler handler, Exception exception)\n+\t{\n+\t\tsuper.onExceptionRequestHandlerResolved(cycle, handler, exception);\n+\t\tregisterLastHandler(cycle,handler);\n+\t}\n+\n \t/**\n \t * Registers pagerequesthandler when it's resolved ,keeps up with the most recent handler resolved\n \t *\n", "nb_test": 1472, "linesAdd": 31, "jira_id": "5147", "singleLine": false, "nb_skipped": 3, "commit": "184e51e9", "nb_failure": 7, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["placeholderEncode4(org.apache.wicket.core.request.mapper.MountedMapperTest): expected null, but was:<some//path/?0>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\nindex 12f8985..c55222e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n@@ -424,6 +424,11 @@ protected Url buildUrl(UrlInfo info)\n \t\t\tString optionalPlaceholder = getOptionalPlaceholder(mountSegments[i]);\n \t\t\tif (placeholder != null)\n \t\t\t{\n+\t\t\t\tif (!copy.getNamedKeys().contains(placeholder))\n+\t\t\t\t{\n+\t\t\t\t\t// no value for placeholder - cannot mount\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n \t\t\t\turl.getSegments().set(i - dropped, copy.get(placeholder).toString(\"\"));\n \t\t\t\tcopy.remove(placeholder);\n \t\t\t}\n", "nb_test": 1499, "linesAdd": 4, "jira_id": "5247", "singleLine": false, "nb_skipped": 3, "commit": "44a4132f", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["test_1(org.apache.wicket.extensions.markup.html.repeater.data.table.DataTableTest)"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/HeadersToolbar.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/HeadersToolbar.java\nindex 4fbeab2..9935c68 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/HeadersToolbar.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/HeadersToolbar.java\n@@ -21,6 +21,7 @@\n import org.apache.wicket.extensions.markup.html.repeater.data.sort.ISortStateLocator;\n import org.apache.wicket.extensions.markup.html.repeater.data.sort.OrderByBorder;\n import org.apache.wicket.markup.html.WebMarkupContainer;\n+import org.apache.wicket.markup.html.border.Border;\n import org.apache.wicket.markup.html.list.AbstractItem;\n import org.apache.wicket.markup.repeater.RepeatingView;\n \n@@ -87,7 +88,14 @@ protected String getCssClass()\n \n \t\t\titem.add(header);\n \t\t\titem.setRenderBodyOnly(true);\n+\t\t\tif (header instanceof Border)\n+\t\t\t{\n+\t\t\t\t((Border)header).addToBody(column.getHeader(\"label\"));\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n \t\t\t\theader.add(column.getHeader(\"label\"));\n+\t\t\t}\n \n \t\t}\n \t}\n", "nb_test": 13, "linesAdd": 8, "jira_id": "3702", "singleLine": false, "nb_skipped": 0, "commit": "a08562a7", "nb_failure": 0, "linesRem": 0}, {"files": 12, "project": "wicket", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["ConvertersTest.longConversions:351->Assert.fail:88 Conversion should have thrown an exception", "ConvertersTest.bigDecimalConverter:519 \u00bb Conversion Value cannot be greater th...", "ConvertersTest.customFormat:535 \u00bb Conversion Cannot parse 'two' using format j..."], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractDecimalConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractDecimalConverter.java\nindex 09485fa..f16ad92 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractDecimalConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractDecimalConverter.java\n@@ -16,14 +16,11 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n-import java.text.DecimalFormat;\n import java.text.NumberFormat;\n import java.util.Locale;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n \n /**\n- * Base class for all number converters.\n+ * Base class for all converters of decimal numbers.\n  * \n  * @author Jonathan Locke\n  * @param <N>\n@@ -32,25 +29,6 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n-\t/** The date format to use */\n-\tprivate final Map<Locale, NumberFormat> numberFormats = new ConcurrentHashMap<>();\n-\n-\t/**\n-\t * @param locale\n-\t * @return Returns the numberFormat.\n-\t */\n-\t@Override\n-\tpublic NumberFormat getNumberFormat(final Locale locale)\n-\t{\n-\t\tNumberFormat numberFormat = numberFormats.get(locale);\n-\t\tif (numberFormat == null)\n-\t\t{\n-\t\t\tnumberFormat = newNumberFormat(locale);\n-\t\t\tsetNumberFormat(locale, numberFormat);\n-\t\t}\n-\t\treturn (NumberFormat)numberFormat.clone();\n-\t}\n-\n \t/**\n \t * Creates a new {@link NumberFormat} for the given locale. The instance is later cached and is\n \t * accessible through {@link #getNumberFormat(Locale)}\n@@ -58,24 +36,9 @@ public NumberFormat getNumberFormat(final Locale locale)\n \t * @param locale\n \t * @return number format\n \t */\n+\t@Override\n \tprotected NumberFormat newNumberFormat(final Locale locale)\n \t{\n \t\treturn NumberFormat.getInstance(locale);\n \t}\n-\n-\t/**\n-\t * @param locale\n-\t *            The Locale that was used for this NumberFormat\n-\t * @param numberFormat\n-\t *            The numberFormat to set.\n-\t */\n-\tpublic final void setNumberFormat(final Locale locale, final NumberFormat numberFormat)\n-\t{\n-\t\tif (numberFormat instanceof DecimalFormat)\n-\t\t{\n-\t\t\t((DecimalFormat)numberFormat).setParseBigDecimal(true);\n-\t\t}\n-\n-\t\tnumberFormats.put(locale, numberFormat);\n-\t}\n }\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractIntegerConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractIntegerConverter.java\nindex 88639c0..0499814 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractIntegerConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractIntegerConverter.java\n@@ -18,10 +18,9 @@\n \n import java.text.NumberFormat;\n import java.util.Locale;\n-import java.util.concurrent.ConcurrentHashMap;\n \n /**\n- * Base class for all number converters.\n+ * Base class for all converters of integer numbers.\n  * \n  * @author Jonathan Locke\n  * @param <I>\n@@ -30,29 +29,12 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n-\t/** The date format to use */\n-\tprivate final ConcurrentHashMap<Locale, NumberFormat> numberFormats = new ConcurrentHashMap<>();\n-\n-\t/**\n-\t * @param locale\n-\t *            The locale\n-\t * @return Returns the numberFormat.\n-\t */\n \t@Override\n-\tpublic NumberFormat getNumberFormat(final Locale locale)\n-\t{\n-\t\tNumberFormat numberFormat = numberFormats.get(locale);\n-\t\tif (numberFormat == null)\n+\tprotected NumberFormat newNumberFormat(Locale locale)\n \t{\n-\t\t\tnumberFormat = NumberFormat.getIntegerInstance(locale);\n+\t\tNumberFormat numberFormat  = NumberFormat.getIntegerInstance(locale);\n \t\tnumberFormat.setParseIntegerOnly(true);\n \t\tnumberFormat.setGroupingUsed(false);\n-\t\t\tNumberFormat tmpNumberFormat = numberFormats.putIfAbsent(locale, numberFormat);\n-\t\t\tif (tmpNumberFormat != null)\n-\t\t\t{\n-\t\t\t\tnumberFormat = tmpNumberFormat;\n-\t\t\t}\n-\t\t}\n-\t\treturn (NumberFormat)numberFormat.clone();\n+\t\treturn numberFormat;\n \t}\n }\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\nindex 5c448c0..da3df42 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\n@@ -16,8 +16,11 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n+import java.text.DecimalFormat;\n import java.text.NumberFormat;\n import java.util.Locale;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.wicket.util.convert.ConversionException;\n \n@@ -32,11 +35,45 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\t/** The date format to use */\n+\tprivate final ConcurrentHashMap<Locale, NumberFormat> numberFormats = new ConcurrentHashMap<>();\n+\n \t/**\n \t * @param locale\n+\t *            The locale\n \t * @return Returns the numberFormat.\n \t */\n-\tpublic abstract NumberFormat getNumberFormat(Locale locale);\n+\tpublic NumberFormat getNumberFormat(final Locale locale)\n+\t{\n+\t\tNumberFormat numberFormat = numberFormats.get(locale);\n+\t\tif (numberFormat == null)\n+\t\t{\n+\t\t\tnumberFormat = newNumberFormat(locale);\n+\n+\t\t\tif (numberFormat instanceof DecimalFormat)\n+\t\t\t{\n+\t\t\t\t// always try to parse BigDecimals\n+\t\t\t\t((DecimalFormat)numberFormat).setParseBigDecimal(true);\n+\t\t\t}\n+\n+\t\t\tNumberFormat tmpNumberFormat = numberFormats.putIfAbsent(locale, numberFormat);\n+\t\t\tif (tmpNumberFormat != null)\n+\t\t\t{\n+\t\t\t\tnumberFormat = tmpNumberFormat;\n+\t\t\t}\n+\t\t}\n+\t\t// return a clone because NumberFormat.get..Instance use a pool\n+\t\treturn (NumberFormat)numberFormat.clone();\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link NumberFormat} for the given locale. The instance is later cached and is\n+\t * accessible through {@link #getNumberFormat(Locale)}\n+\t *\n+\t * @param locale\n+\t * @return number format\n+\t */\n+\tprotected abstract NumberFormat newNumberFormat(final Locale locale);\n \n \t/**\n \t * Parses a value as a String and returns a Number.\n@@ -44,15 +81,15 @@\n \t * @param value\n \t *            The object to parse (after converting with toString())\n \t * @param min\n-\t *            The minimum allowed value\n+\t *            The minimum allowed value or {@code null} if none\n \t * @param max\n-\t *            The maximum allowed value\n+\t *            The maximum allowed value or {@code null} if none\n \t * @param locale\n \t * @return The number\n \t * @throws ConversionException\n \t *             if value is unparsable or out of range\n \t */\n-\tprotected N parse(Object value, final double min, final double max, Locale locale)\n+\tprotected BigDecimal parse(Object value, final BigDecimal min, final BigDecimal max, Locale locale)\n \t{\n \t\tif (locale == null)\n \t\t{\n@@ -78,19 +115,30 @@ else if (value instanceof String)\n \t\t\treturn null;\n \t\t}\n \n-\t\tif (number.doubleValue() < min)\n+\t\tBigDecimal bigDecimal;\n+\t\tif (number instanceof BigDecimal)\n+\t\t{\n+\t\t\tbigDecimal = (BigDecimal)number;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\t// should occur rarely, see #getNumberFormat(Locale)\n+\t\t\tbigDecimal = new BigDecimal(number.toString());\n+\t\t}\n+\n+\t\tif (min != null && bigDecimal.compareTo(min) < 0)\n \t\t{\n-\t\t\tthrow newConversionException(\"Value cannot be less than \" + min, value, locale).setFormat(\n-\t\t\t\tnumberFormat);\n+\t\t\tthrow newConversionException(\"Value cannot be less than \" + min, value, locale)\n+\t\t\t\t\t.setFormat(numberFormat);\n \t\t}\n \n-\t\tif (number.doubleValue() > max)\n+\t\tif (max != null && bigDecimal.compareTo(max) > 0)\n \t\t{\n-\t\t\tthrow newConversionException(\"Value cannot be greater than \" + max, value, locale).setFormat(\n-\t\t\t\tnumberFormat);\n+\t\t\tthrow newConversionException(\"Value cannot be greater than \" + max, value, locale)\n+\t\t\t\t\t.setFormat(numberFormat);\n \t\t}\n \n-\t\treturn number;\n+\t\treturn bigDecimal;\n \t}\n \n \t@Override\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigDecimalConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigDecimalConverter.java\nindex dd6e0ba..162a6de 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigDecimalConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigDecimalConverter.java\n@@ -44,33 +44,6 @@ public BigDecimal convertToObject(final String value, final Locale locale)\n \t\t\treturn null;\r\n \t\t}\r\n \r\n-\t\tfinal Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\r\n-\r\n-\t\tif (number instanceof BigDecimal)\r\n-\t\t{\r\n-\t\t\treturn (BigDecimal)number;\r\n-\t\t}\r\n-\t\telse if (number instanceof Double)\r\n-\t\t{\r\n-\t\t\t// See link why the String is preferred for doubles\r\n-\t\t\t// http://java.sun.com/j2se/1.4.2/docs/api/java/math/BigDecimal.html#BigDecimal%28double%29\r\n-\t\t\treturn new BigDecimal(Double.toString(number.doubleValue()));\r\n-\t\t}\r\n-\t\telse if (number instanceof Long)\r\n-\t\t{\r\n-\t\t\treturn new BigDecimal(number.longValue());\r\n-\t\t}\r\n-\t\telse if (number instanceof Float)\r\n-\t\t{\r\n-\t\t\treturn new BigDecimal(number.floatValue());\r\n-\t\t}\r\n-\t\telse if (number instanceof Integer)\r\n-\t\t{\r\n-\t\t\treturn new BigDecimal(number.intValue());\r\n-\t\t}\r\n-\t\telse\r\n-\t\t{\r\n-\t\t\treturn new BigDecimal(value);\r\n-\t\t}\r\n+\t\treturn parse(value, null, null, locale);\r\n \t}\r\n }\r\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigIntegerConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigIntegerConverter.java\nindex 22077be..5da0034 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigIntegerConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigIntegerConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.Locale;\n \n@@ -44,23 +45,13 @@ public BigInteger convertToObject(final String value, final Locale locale)\n \t\t\treturn null;\n \t\t}\n \n-\t\tfinal Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, null, null, locale);\n \n-\t\tif (number instanceof BigInteger)\n+\t\tif (number == null)\n \t\t{\n-\t\t\treturn (BigInteger)number;\n-\t\t}\n-\t\telse if (number instanceof Long)\n-\t\t{\n-\t\t\treturn BigInteger.valueOf(number.longValue());\n-\t\t}\n-\t\telse if (number instanceof Integer)\n-\t\t{\n-\t\t\treturn BigInteger.valueOf(number.intValue());\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn new BigInteger(value);\n+\t\t\treturn null;\n \t\t}\n+\n+\t\treturn new BigInteger(number.toString());\n \t}\n }\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ByteConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ByteConverter.java\nindex 8c351e4..8850165 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ByteConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ByteConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,9 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(Byte.MIN_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Byte.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a byte converter\n \t */\n@@ -42,7 +46,7 @@\n \t@Override\n \tpublic Byte convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, Byte.MIN_VALUE, Byte.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/DoubleConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/DoubleConverter.java\nindex fbf5862..ce2ca99 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/DoubleConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/DoubleConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,11 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\t// Double.MIN is the smallest nonzero positive number, not the largest\n+\t// negative number\n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(-Double.MAX_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Double.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a double converter\n \t */\n@@ -42,9 +48,7 @@\n \t@Override\n \tpublic Double convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\n-\t\t// Double.MIN is the smallest nonzero positive number, not the largest\n-\t\t// negative number\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/FloatConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/FloatConverter.java\nindex bc1562a..c4b2b79 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/FloatConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/FloatConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,11 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\t// Float.MIN is the smallest nonzero positive number, not the largest\n+\t// negative number\n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(-Float.MAX_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Float.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a float converter\n \t */\n@@ -42,7 +48,7 @@\n \t@Override\n \tpublic Float convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, -Float.MAX_VALUE, Float.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/IntegerConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/IntegerConverter.java\nindex 8fd1edf..5055d4a 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/IntegerConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/IntegerConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,9 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(Integer.MIN_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Integer.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a integer converter\n \t */\n@@ -42,7 +46,7 @@\n \t@Override\n \tpublic Integer convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, Integer.MIN_VALUE, Integer.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/LongConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/LongConverter.java\nindex 67401b2..0cf8db6 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/LongConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/LongConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,9 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(Long.MIN_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Long.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a long converter\n \t */\n@@ -42,7 +46,7 @@\n \t@Override\n \tpublic Long convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, Long.MIN_VALUE, Long.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ShortConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ShortConverter.java\nindex 4d2a2fa..30aa1b7 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ShortConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ShortConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,9 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(Short.MIN_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Short.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a short converter\n \t */\n@@ -42,7 +46,7 @@\n \t@Override\n \tpublic Short convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, Short.MIN_VALUE, Short.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ZeroPaddingIntegerConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ZeroPaddingIntegerConverter.java\nindex 84c4f62..181be0b 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ZeroPaddingIntegerConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ZeroPaddingIntegerConverter.java\n@@ -24,8 +24,10 @@\n  * @author Eelco Hillenius\n  * @author Jonathan Locke\n  * @author Al Maw\n+ * \n+ * @deprecated use an {@link IntegerConverter} with suitable format string instead\n  */\n-public class ZeroPaddingIntegerConverter extends AbstractIntegerConverter<Integer>\n+public class ZeroPaddingIntegerConverter extends IntegerConverter\n {\n \tprivate static final long serialVersionUID = 1L;\n \n@@ -58,29 +60,4 @@ public String convertToString(final Integer value, final Locale locale)\n \n \t\treturn result;\n \t}\n-\n-\t/**\n-\t * @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\n-\t */\n-\t@Override\n-\tpublic Integer convertToObject(final String value, final Locale locale)\n-\t{\n-\t\tfinal Number number = parse(value, Integer.MIN_VALUE, Integer.MAX_VALUE, locale);\n-\n-\t\tif (number == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn number.intValue();\n-\t}\n-\n-\t/**\n-\t * @see org.apache.wicket.util.convert.converter.AbstractConverter#getTargetType()\n-\t */\n-\t@Override\n-\tprotected Class<Integer> getTargetType()\n-\t{\n-\t\treturn Integer.class;\n-\t}\n }\n\\ No newline at end of file\n", "nb_test": 188, "linesAdd": 87, "jira_id": "5853", "singleLine": false, "nb_skipped": 2, "commit": "b80f6640", "nb_failure": 1, "linesRem": 118}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testClientBidListPage(org.apache.wicket.protocol.http.request.CryptedUrlWebRequestCodingStrategyTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java b/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\nindex 7b240c6..b998156 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\n@@ -1255,6 +1255,16 @@ else if (component instanceof IOnChangeListener)\n \t\t\t\t\t.get(clazz);\n \n \t\t\t\tString auto = component.getRequestCycle().urlFor(component, rli).toString();\n+\n+\t\t\t\t// check for crypted strategy\n+\t\t\t\tif (auto.startsWith(\"?x=\"))\n+\t\t\t\t{\n+\t\t\t\t\tauto = auto.substring(3);\n+\t\t\t\t\tparameters.put(\"x\", auto);\n+\t\t\t\t\tparameters.remove(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n \t\t\t\t\tint idx = auto.indexOf(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n \t\t\t\t\tif (idx >= 0)\n \t\t\t\t\t{\n@@ -1263,22 +1273,14 @@ else if (component instanceof IOnChangeListener)\n \t\t\t\t\t}\n \t\t\t\t\telse\n \t\t\t\t\t{\n-\t\t\t\t\t// additional check for crypted strategy\n-\t\t\t\t\tidx = auto.indexOf(\"x=6*\");\n-\t\t\t\t\tif (idx >= 0)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tauto = auto.substring(idx + 4);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n \t\t\t\t\t\tidx = auto.indexOf(\"&\");\n \t\t\t\t\t\tif (idx >= 0)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tauto = auto.substring(0, idx);\n \t\t\t\t\t\t}\n-\n+\t\t\t\t\t}\n \t\t\t\t\tparameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, auto);\n-\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception e)\n \t\t\t{\n", "nb_test": 789, "linesAdd": 11, "jira_id": "2281", "singleLine": false, "nb_skipped": 0, "commit": "6e0b40bc", "nb_failure": 0, "linesRem": 9}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRenderHomePage_13(org.apache.wicket.markup.html.basic.SimplePageTest)", "testUrlIndexRendering(org.apache.wicket.behavior.ImmutableBehaviorIdsTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Behaviors.java b/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\nindex 2e358e2..627d4e6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\n@@ -70,7 +70,7 @@ public void add(Behavior... behaviors)\n \tprivate void internalAdd(final Behavior behavior)\r\n \t{\r\n \t\tcomponent.data_add(behavior);\r\n-\t\tif (behavior.isStateless(component))\r\n+\t\tif (behavior.getStatelessHint(component))\r\n \t\t{\r\n \t\t\tgetBehaviorId(behavior);\r\n \t\t}\r\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/behavior/Behavior.java b/wicket-core/src/main/java/org/apache/wicket/behavior/Behavior.java\nindex ff2e04a..a809405 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/behavior/Behavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/behavior/Behavior.java\n@@ -178,23 +178,6 @@ public boolean isTemporary(Component component)\n \t}\n \n \t/**\n-\t * Returns whether or not this behavior is stateless. Most behaviors should either not override\n-\t * this method or return {@code false} because most behavior are not stateless.\n-\t * \n-\t * A small subset of behaviors are made specifically to be stateless and as such should override\n-\t * this method and return {@code true}. One sideeffect of this method is that the behavior id\n-\t * will be generated eagerly when the behavior is added to the component instead of before\n-\t * render when a method to create the url is called - this allows for stateless callback urls.\n-\t * \n-\t * @param component\n-\t * @return whether or not this behavior is stateless\n-\t */\n-\tpublic boolean isStateless(Component component)\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\t/**\n \t * Checks if a listener can be invoked on this behavior\n \t * \n \t * @param component\n", "nb_test": 1210, "linesAdd": 1, "jira_id": "3764", "singleLine": false, "nb_skipped": 1, "commit": "48454f4d", "nb_failure": 2, "linesRem": 6}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ISecuritySettingsTest.enforceMountsWithCryptoMapper:84->enforceMounts:66 page was null"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex 60764fa..bf7e64b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -19,11 +19,11 @@\n import java.util.List;\n \n import org.apache.wicket.Application;\n-import org.apache.wicket.core.request.handler.PageProvider;\n-import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n+import org.apache.wicket.request.IRequestMapper;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n+import org.apache.wicket.request.mapper.ICompoundRequestMapper;\n import org.apache.wicket.request.mapper.info.PageComponentInfo;\n import org.apache.wicket.request.mapper.parameter.IPageParametersEncoder;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n@@ -118,9 +118,7 @@ protected UrlInfo parseRequest(Request request)\n \t\t\t\t\t\tif (!pageClass.equals(application.getHomePage()))\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\t// WICKET-5094 only enforce mount if page is mounted\n-\t\t\t\t\t\t\tUrl reverseUrl = application.getRootRequestMapper().mapHandler(\n-\t\t\t\t\t\t\t\tnew RenderPageRequestHandler(new PageProvider(pageClass)));\n-\t\t\t\t\t\t\tif (!matches(request.cloneWithUrl(reverseUrl)))\n+\t\t\t\t\t\t\tif (isPageMounted(pageClass, application))\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n@@ -138,6 +136,27 @@ protected UrlInfo parseRequest(Request request)\n \t\treturn null;\n \t}\n \n+\tprivate boolean isPageMounted(Class<? extends IRequestablePage> pageClass,\n+\t\tApplication application)\n+\t{\n+\t    ICompoundRequestMapper applicationMappers = application.getRootRequestMapperAsCompound();\n+\t    \n+\t    for (IRequestMapper requestMapper : applicationMappers)\n+\t    {\n+\t\tif(requestMapper instanceof AbstractBookmarkableMapper  && requestMapper != this)\n+\t\t{\n+\t\t    AbstractBookmarkableMapper mapper = (AbstractBookmarkableMapper) requestMapper;  \n+\t\t    \n+\t\t    if(mapper.checkPageClass(pageClass))\n+\t\t    {\n+\t\t\treturn true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t    \n+\t    return false;\n+\t}\n+\n \t@Override\n \tprotected boolean pageMustHaveBeenCreatedBookmarkable()\n \t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\nindex 4f0f107..ff13a62 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n@@ -221,4 +221,11 @@ protected boolean pageMustHaveBeenCreatedBookmarkable()\n \t{\n \t\treturn false;\n \t}\n+\t\n+\t@Override\n+\tprotected boolean checkPageClass(Class<? extends IRequestablePage> pageClass)\n+\t{\n+\t\tPackageName pageClassPackageName = PackageName.forClass(pageClass);\n+\t\treturn packageName.equals(pageClassPackageName);\n+\t}\n }\n", "nb_test": 1639, "linesAdd": 31, "jira_id": "5560", "singleLine": false, "nb_skipped": 2, "commit": "aa82ccfc", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\nindex 64caf18..91eb1a3 100644\n--- a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\n+++ b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\n@@ -6,6 +6,7 @@\n import org.apache.wicket.markup.html.form.FormComponent;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.IPropertyReflectionAwareModel;\n+import org.apache.wicket.model.IWrapModel;\n import org.apache.wicket.model.PropertyModel;\n \n /**\n@@ -23,8 +24,21 @@ public Property resolveProperty(FormComponent<?> component)\n \t{\n \t\tIModel<?> model = component.getModel();\n \n-\t\tif (!(model instanceof IPropertyReflectionAwareModel))\n+\t\twhile (true)\n \t\t{\n+\t\t\tif (model == null)\n+\t\t\t{\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tif (model instanceof IPropertyReflectionAwareModel)\n+\t\t\t{\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (model instanceof IWrapModel<?>)\n+\t\t\t{\n+\t\t\t\tmodel = ((IWrapModel<?>)model).getWrappedModel();\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\treturn null;\n \t\t}\n \n@@ -39,7 +53,7 @@ public Property resolveProperty(FormComponent<?> component)\n \t\tMethod getter = delegate.getPropertyGetter();\n \t\tif (getter != null)\n \t\t{\n-\t\t\tString name = getter.getName().substring(3, 1).toLowerCase() +\n+\t\t\tString name = getter.getName().substring(3, 4).toLowerCase() +\n \t\t\t\tgetter.getName().substring(4);\n \t\t\treturn new Property(getter.getDeclaringClass(), name);\n \t\t}\n", "nb_test": 1, "linesAdd": 16, "jira_id": "5102", "singleLine": false, "nb_skipped": 0, "commit": "d110e307", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": true}, "failing_tests": ["loadMarkupWithNonClosedTagsDynamically(org.apache.wicket.markup.parser.filter.HtmlHandlerTest): Unable to find close tag for: '<img alt=\"logo\" src=\"logo.png\">' in org.apache.wicket.util.resource.StringResourceStream@6c2e7024: <img alt='logo' src='logo.png'><br>Some text<br>Some more text"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHandler.java\nindex b45ed7c..440e5bc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHandler.java\n@@ -78,6 +78,7 @@ public void postProcess(final Markup markup)\n \t\t\tif (!requiresCloseTag(top.getName()))\n \t\t\t{\n \t\t\t\tstack.pop();\n+\t\t\t\ttop.setHasNoCloseTag(true);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n", "nb_test": 1325, "linesAdd": 1, "jira_id": "4494", "singleLine": true, "nb_skipped": 8, "commit": "35843c19", "nb_failure": 0, "rtElixir": true, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBufferedExceptionErrorPage(org.apache.wicket.protocol.http.WebResponseExceptionsTest)", "testExceptionErrorPage(org.apache.wicket.protocol.http.WebResponseExceptionsTest)", "testInternalErrorPage(org.apache.wicket.protocol.http.WebResponseExceptionsTest)", "testAjaxSubmitWhileAnotherButtonIsNotVisible(org.apache.wicket.ajax.form.OnChangeAjaxBehaviorTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java b/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\nindex 59e69e0..bde3d67 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\n@@ -544,7 +544,22 @@ public final void postProcessRequestCycle(WebRequestCycle cycle)\n \t\t\t\tcycle = createRequestCycle();\n \t\t\t\tcycle.request();\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tString url = httpResponse.getHeader(\"Ajax-Location\");\n+\t\t\t\tif (url != null)\n+\t\t\t\t{\n+\t\t\t\t\tMockHttpServletRequest newHttpRequest = new MockHttpServletRequest(application,\n+\t\t\t\t\t\tservletSession, application.getServletContext());\n+\t\t\t\t\tnewHttpRequest.setRequestToRedirectString(url);\n+\t\t\t\t\twicketRequest = application.newWebRequest(newHttpRequest);\n+\n+\t\t\t\t\tcycle = createRequestCycle();\n+\t\t\t\t\tcycle.request();\n \t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t\tlastRenderedPage = generateLastRenderedPage(cycle);\n \n \t\tSession.set(getWicketSession());\n", "nb_test": 791, "linesAdd": 15, "jira_id": "2261", "singleLine": false, "nb_skipped": 0, "commit": "089303f4", "nb_failure": 4, "linesRem": 0}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["domReadyOrder(org.apache.wicket.ajax.DomReadyOrderTest): org/apache/wicket/ajax/DomReadyOrderPage_ajax_expected.html expected:<...![CDATA[(function(){[Wicket.Ajax.ajax({\"u\":\"./page?0-1.IBehaviorListener.0-test\",\"e\":\"click\",\"c\":\"test1\"});})();(function(){test1();})();(function(){test2(]);})();]]></evaluate...> but was:<...![CDATA[(function(){[test1();})();(function(){test2();})();(function(){Wicket.Ajax.ajax({\"u\":\"./page?0-1.IBehaviorListener.0-test\",\"e\":\"click\",\"c\":\"test1\"}]);})();]]></evaluate...>", "domReadyOrder2(org.apache.wicket.ajax.DomReadyOrderTest): org/apache/wicket/ajax/DomReadyOrderPage_ajax_expected.html expected:<...![CDATA[(function(){[Wicket.Ajax.ajax({\"u\":\"./page?0-1.IBehaviorListener.0-test\",\"e\":\"click\",\"c\":\"test1\"});})();(function(){test1();})();(function(){test2(]);})();]]></evaluate...> but was:<...![CDATA[(function(){[test1();})();(function(){test2();})();(function(){Wicket.Ajax.ajax({\"u\":\"./page?0-1.IBehaviorListener.0-test\",\"e\":\"click\",\"c\":\"test1\"}]);})();]]></evaluate...>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxResponse.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxResponse.java\nindex 80624bf..1e3cd1a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxResponse.java\n@@ -25,7 +25,6 @@\n import java.util.Map;\n \n import org.apache.wicket.Component;\n-import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.Page;\n import org.apache.wicket.markup.head.HeaderItem;\n import org.apache.wicket.markup.head.IHeaderResponse;\n@@ -34,6 +33,8 @@\n import org.apache.wicket.markup.head.internal.HeaderResponse;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n import org.apache.wicket.markup.parser.filter.HtmlHeaderSectionHandler;\n+import org.apache.wicket.markup.renderStrategy.AbstractHeaderRenderStrategy;\n+import org.apache.wicket.markup.renderStrategy.IHeaderRenderStrategy;\n import org.apache.wicket.markup.repeater.AbstractRepeater;\n import org.apache.wicket.request.IRequestCycle;\n import org.apache.wicket.request.Response;\n@@ -44,8 +45,6 @@\n import org.apache.wicket.util.lang.Generics;\n import org.apache.wicket.util.string.AppendingStringBuffer;\n import org.apache.wicket.util.string.Strings;\n-import org.apache.wicket.util.visit.IVisit;\n-import org.apache.wicket.util.visit.IVisitor;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -460,28 +459,9 @@ protected void writeHeaderContribution(final Response response, final Component\n \t\ttry {\n \t\t\tencodingHeaderResponse.reset();\n \n-\t\t\t// render the head of component and all it's children\n+\t\t\tIHeaderRenderStrategy strategy = AbstractHeaderRenderStrategy.get();\n \n-\t\t\tcomponent.renderHead(header);\n-\n-\t\t\tif (component instanceof MarkupContainer)\n-\t\t\t{\n-\t\t\t\t((MarkupContainer)component).visitChildren(new IVisitor<Component, Void>()\n-\t\t\t\t{\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void component(final Component component, final IVisit<Void> visit)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (component.isVisibleInHierarchy())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcomponent.renderHead(header);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tvisit.dontGoDeeper();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}\n+\t\t\tstrategy.renderHeader(header, null, component);\n \t\t} finally {\n \t\t\t// revert to old response\n \t\t\trequestCycle.setResponse(oldResponse);\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\nindex 8998cb5..0cee432 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n@@ -82,16 +82,8 @@ public void renderHead(final Component component, final IHeaderResponse response\n \t\t{\n \t\t\tCharSequence js = getCallbackScript(component);\n \n-\t\t\tAjaxRequestTarget target = component.getRequestCycle().find(AjaxRequestTarget.class);\n-\t\t\tif (target == null)\n-\t\t\t{\n \t\t\tresponse.render(OnDomReadyHeaderItem.forScript(js.toString()));\n \t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\ttarget.appendJavaScript(js);\n-\t\t\t}\n-\t\t}\n \t}\n \n \t@Override\n", "nb_test": 1460, "linesAdd": 4, "jira_id": "5082", "singleLine": false, "nb_skipped": 3, "commit": "217fbb3b", "nb_failure": 2, "linesRem": 31}, {"files": 1, "project": "wicket", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["standard(org.apache.wicket.extensions.markup.html.form.palette.PaletteTest): An error occurred while getting the model object for Component: [Choices [Component id = choices, page = org.apache.wicket.extensions.markup.html.form.palette.PaletteTestPage, path = 0:form:palette:choices.Choices, isVisible = true, isVersioned = false]]", "choicesModelMissingSelected(org.apache.wicket.extensions.markup.html.form.palette.PaletteTest): An error occurred while getting the model object for Component: [Choices [Component id = choices, page = org.apache.wicket.extensions.markup.html.form.palette.PaletteTestPage, path = 0:form:palette:choices.Choices, isVisible = true, isVersioned = false]]", "choicesModelAccountingForSelected(org.apache.wicket.extensions.markup.html.form.palette.PaletteTest): An error occurred while getting the model object for Component: [Choices [Component id = choices, page = org.apache.wicket.extensions.markup.html.form.palette.PaletteTestPage, path = 0:form:palette:choices.Choices, isVisible = true, isVersioned = false]]"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/palette/component/AbstractOptions.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/palette/component/AbstractOptions.java\nindex 73d6e82..f5d3fc0 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/palette/component/AbstractOptions.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/palette/component/AbstractOptions.java\n@@ -199,4 +199,13 @@ protected void avoidAjaxSerialization()\n \tpublic void updateModel()\n \t{\n \t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tprotected String getModelValue()\n+\t{\n+\t\treturn null;\n+\t}\n }\n", "nb_test": 47, "linesAdd": 6, "jira_id": "5086", "singleLine": false, "nb_skipped": 0, "commit": "ba516f02", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testNotExistingResource(org.apache.wicket.util.resource.locator.CachingResourceStreamLocatorTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/util/resource/locator/CachingResourceStreamLocator.java b/wicket-core/src/main/java/org/apache/wicket/util/resource/locator/CachingResourceStreamLocator.java\nindex 08f5b26..dba4976 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/util/resource/locator/CachingResourceStreamLocator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/util/resource/locator/CachingResourceStreamLocator.java\n@@ -22,6 +22,7 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n \n+import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.request.resource.ResourceReference.Key;\n import org.apache.wicket.util.file.File;\n import org.apache.wicket.util.lang.Args;\n@@ -49,7 +50,7 @@\n \t */\n \tprivate static interface IResourceStreamReference\n \t{\n-\t\tString getReference();\n+\t\tIResourceStream getReference();\n \t}\n \n \t/**\n@@ -61,7 +62,7 @@\n \t{\n \t\tprivate final static NullResourceStreamReference INSTANCE = new NullResourceStreamReference();\n \n-\t\tpublic String getReference()\n+\t\tpublic IResourceStream getReference()\n \t\t{\n \t\t\treturn null;\n \t\t}\n@@ -79,9 +80,9 @@ private FileResourceStreamReference(final String fileName)\n \t\t\tthis.fileName = fileName;\n \t\t}\n \n-\t\tpublic String getReference()\n+\t\tpublic FileResourceStream getReference()\n \t\t{\n-\t\t\treturn fileName;\n+\t\t\treturn new FileResourceStream(new File(fileName));\n \t\t}\n \t}\n \n@@ -97,9 +98,18 @@ private UrlResourceStreamReference(final String url)\n \t\t\tthis.url = url;\n \t\t}\n \n-\t\tpublic String getReference()\n+\t\tpublic UrlResourceStream getReference()\n \t\t{\n-\t\t\treturn url;\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\treturn new UrlResourceStream(new URL(url));\n+\t\t\t}\n+\t\t\tcatch (MalformedURLException e)\n+\t\t\t{\n+\t\t\t\t// should not ever happen. The cached url is created by previously existing URL\n+\t\t\t\t// instance\n+\t\t\t\tthrow new WicketRuntimeException(e);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -133,16 +143,21 @@ public CachingResourceStreamLocator(final IResourceStreamLocator resourceStreamL\n \tpublic IResourceStream locate(Class<?> clazz, String path)\n \t{\n \t\tKey key = new Key(clazz.getName(), path, null, null, null);\n-\t\tIResourceStream resourceStream = getCopyFromCache(key);\n+\t\tIResourceStreamReference resourceStreamReference = cache.get(key);\n \n-\t\tif (resourceStream == null)\n+\t\tfinal IResourceStream result;\n+\t\tif (resourceStreamReference == null)\n \t\t{\n-\t\t\tresourceStream = delegate.locate(clazz, path);\n+\t\t\tresult = delegate.locate(clazz, path);\n \n-\t\t\tupdateCache(key, resourceStream);\n+\t\t\tupdateCache(key, result);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tresult = resourceStreamReference.getReference();\n \t\t}\n \n-\t\treturn resourceStream;\n+\t\treturn result;\n \t}\n \n \tprivate void updateCache(Key key, IResourceStream stream)\n@@ -165,60 +180,25 @@ else if (stream instanceof UrlResourceStream)\n \t\t}\n \t}\n \n-\t/**\n-\t * Make a copy before returning an item from the cache as resource streams are not thread-safe.\n-\t * \n-\t * @param key\n-\t *            the cache key\n-\t * @return the cached File or Url resource stream\n-\t */\n-\tprivate IResourceStream getCopyFromCache(Key key)\n-\t{\n-\t\tfinal IResourceStreamReference orig = cache.get(key);\n-\t\tif (NullResourceStreamReference.INSTANCE == orig)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tif (orig instanceof UrlResourceStreamReference)\n-\t\t{\n-\t\t\tUrlResourceStreamReference resourceStreamReference = (UrlResourceStreamReference)orig;\n-\t\t\tString url = resourceStreamReference.getReference();\n-\t\t\ttry\n-\t\t\t{\n-\t\t\t\treturn new UrlResourceStream(new URL(url));\n-\t\t\t}\n-\t\t\tcatch (MalformedURLException e)\n-\t\t\t{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (orig instanceof FileResourceStreamReference)\n-\t\t{\n-\t\t\tFileResourceStreamReference resourceStreamReference = (FileResourceStreamReference)orig;\n-\t\t\tString absolutePath = resourceStreamReference.getReference();\n-\t\t\treturn new FileResourceStream(new File(absolutePath));\n-\t\t}\n-\n-\t\treturn null;\n-\t}\n-\n \tpublic IResourceStream locate(Class<?> scope, String path, String style, String variation,\n \t\tLocale locale, String extension, boolean strict)\n \t{\n \t\tKey key = new Key(scope.getName(), path, locale, style, variation);\n-\t\tIResourceStream resourceStream = getCopyFromCache(key);\n+\t\tIResourceStreamReference resourceStreamReference = cache.get(key);\n \n-\t\tif (resourceStream == null)\n+\t\tfinal IResourceStream result;\n+\t\tif (resourceStreamReference == null)\n \t\t{\n-\t\t\tresourceStream = delegate.locate(scope, path, style, variation, locale, extension,\n-\t\t\t\tstrict);\n+\t\t\tresult = delegate.locate(scope, path, style, variation, locale, extension, strict);\n \n-\t\t\tupdateCache(key, resourceStream);\n+\t\t\tupdateCache(key, result);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tresult = resourceStreamReference.getReference();\n \t\t}\n \n-\t\treturn resourceStream;\n+\t\treturn result;\n \t}\n \n \tpublic ResourceNameIterator newResourceNameIterator(String path, Locale locale, String style,\n", "nb_test": 1078, "linesAdd": 34, "jira_id": "3511", "singleLine": false, "nb_skipped": 0, "commit": "4a875f46", "nb_failure": 1, "linesRem": 49}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["decodePageClassWithPathParameters(org.apache.wicket.core.request.mapper.BookmarkableMapperTest)", "decodePageClassWithPathParameters(org.apache.wicket.core.request.mapper.PackageMapperTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractComponentMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractComponentMapper.java\nindex b1480ee..efd77c6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractComponentMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractComponentMapper.java\n@@ -130,9 +130,28 @@ protected void encodePageComponentInfo(Url url, PageComponentInfo info)\n \t */\n \tprotected Class<? extends IRequestablePage> getPageClass(String name)\n \t{\n-\t\tArgs.notEmpty(name, \"name\");\n+\t\tString cleanedClassName = cleanClassName(name);\n+\t\treturn WicketObjects.resolveClass(cleanedClassName);\n+\t}\n+\n+\t/**\n+\t * Cleans the class name from any extra information that may be there.\n+\t *\n+\t * @param className\n+\t *              The raw class name parsed from the url\n+\t * @return The cleaned class name\n+\t */\n+\tprotected String cleanClassName(String className)\n+\t{\n+\t\tArgs.notEmpty(className, \"className\");\n+\n+\t\tif (Strings.indexOf(className, ';') > -1)\n+\t\t{\n+\t\t\t// remove any path parameters set manually by the user. WICKET-5500\n+\t\t\tclassName = Strings.beforeFirst(className, ';');\n+\t\t}\n \n-\t\treturn WicketObjects.resolveClass(name);\n+\t\treturn className;\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\nindex 41c6696..ad15d6d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n@@ -139,7 +139,8 @@ protected UrlInfo parseRequest(Request request)\n \t\t\tPageComponentInfo info = getPageComponentInfo(url);\n \n \t\t\t// load the page class\n-\t\t\tString className = url.getSegments().get(mountSegments.length);\n+\t\t\tString name = url.getSegments().get(mountSegments.length);\n+\t\t\tString className = cleanClassName(name);\n \n \t\t\tif (isValidClassName(className) == false)\n \t\t\t{\n", "nb_test": 1577, "linesAdd": 15, "jira_id": "5500", "singleLine": false, "nb_skipped": 2, "commit": "825da305", "nb_failure": 2, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testRender9a(org.apache.wicket.markup.html.internal.EnclosureTest): org/apache/wicket/markup/html/internal/EnclosurePageExpectedResult_9.html expected:<...od=\"post\" action=\"./[page]?0-1.IFormSubmitList...> but was:<...od=\"post\" action=\"./[bookmarkable/org.apache.wicket.markup.html.internal.EnclosurePage_9]?0-1.IFormSubmitList...>", "testRender9(org.apache.wicket.markup.html.internal.EnclosureTest): org/apache/wicket/markup/html/internal/EnclosurePageExpectedResult_9.html expected:<...od=\"post\" action=\"./[page]?0-1.IFormSubmitList...> but was:<...od=\"post\" action=\"./[bookmarkable/org.apache.wicket.markup.html.internal.EnclosurePage_9]?0-1.IFormSubmitList...>", "headerContribution3(org.apache.wicket.ajax.AjaxRequestHandlerTest): org/apache/wicket/ajax/MockComponent3-expected.html expected:<...e=\"text/css\" href=\".[]/resource/org.apache...> but was:<...e=\"text/css\" href=\".[.]/resource/org.apache...>", "testLinkOnPageWithRecreationDisabled[0](org.apache.wicket.markup.html.link.MountedPageLinkTest): expected:<./wicket/[page]?0-1.ILinkListener-l...> but was:<./wicket/[bookmarkable/org.apache.wicket.markup.html.link.PageWithLink]?0-1.ILinkListener-l...>", "testLinkOnPageWithRecreationDisabled[1](org.apache.wicket.markup.html.link.MountedPageLinkTest): expected:<./wicket/[page]?0-1.ILinkListener-l...> but was:<./wicket/[bookmarkable/org.apache.wicket.markup.html.link.PageWithLink]?0-1.ILinkListener-l...>", "testExpiredPageWithRecreationDisabled[0](org.apache.wicket.markup.html.link.MountedPageLinkTest): Unexpected exception, expected<org.apache.wicket.protocol.http.PageExpiredException> but was<org.junit.ComparisonFailure>", "testExpiredPageWithRecreationDisabled[1](org.apache.wicket.markup.html.link.MountedPageLinkTest): Unexpected exception, expected<org.apache.wicket.protocol.http.PageExpiredException> but was<org.junit.ComparisonFailure>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 0c56063..b78f8bf 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -3334,7 +3334,8 @@ public final CharSequence urlFor(final Behavior behaviour,\n \t\tPage page = getPage();\n \t\tPageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\n \t\tIRequestHandler handler;\n-\t\tif (page.isBookmarkable())\n+\t\tif (getApplication().getPageSettings().getRecreateMountedPagesAfterExpiry() &&\n+\t\t\t((page.isBookmarkable() && page.wasCreatedBookmarkable()) || page.isPageStateless()))\n \t\t{\n \t\t\thandler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);\n \t\t}\n@@ -3377,7 +3378,8 @@ public final CharSequence urlFor(final RequestListenerInterface listener,\n \t\tPage page = getPage();\n \t\tPageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\n \t\tIRequestHandler handler;\n-\t\tif (page.isBookmarkable())\n+\t\tif (getApplication().getPageSettings().getRecreateMountedPagesAfterExpiry() &&\n+\t\t\t((page.isBookmarkable() && page.wasCreatedBookmarkable()) || page.isPageStateless()))\n \t\t{\n \t\t\thandler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\n \t\t}\n", "nb_test": 1525, "linesAdd": 4, "jira_id": "4997", "singleLine": false, "nb_skipped": 2, "commit": "ee02c883", "nb_failure": 5, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["wicket_5114_allowtoStringFullWhenContainingTwoDots(org.apache.wicket.request.UrlTest): Cannot render this url in FULL mode because it has a `..` segment: /mountPoint/whatever.../"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 12ca5f0..9ca2c0d 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -674,7 +674,7 @@ else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)\n \t\t\t\tresult.append(port);\n \t\t\t}\n \n-\t\t\tif (path.contains(\"..\"))\n+\t\t\tif (segments.contains(\"..\"))\n \t\t\t{\n \t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n \t\t\t\t\tStringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n", "nb_test": 92, "linesAdd": 1, "jira_id": "5114", "singleLine": false, "nb_skipped": 0, "commit": "518c933b", "nb_failure": 0, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testFilterAddCommentFilter(org.apache.wicket.response.filter.ResponseFilterTest)", "testAddCommentFilterInAjaxResponse(org.apache.wicket.response.filter.ResponseFilterTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\nindex 0c73aff..f6ff1ad 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n@@ -600,8 +600,8 @@ public final void respond(final IRequestCycle requestCycle)\n \t\t\t{\n \t\t\t\tfinal StringResponse bodyResponse = new StringResponse();\n \t\t\t\tcontructResponseBody(bodyResponse, encoding);\n-\t\t\t\tinvokeResponseFilters(bodyResponse);\n-\t\t\t\tresponse.write(bodyResponse.getBuffer());\n+\t\t\t\tCharSequence filteredResponse = invokeResponseFilters(bodyResponse);\n+\t\t\t\tresponse.write(filteredResponse);\n \t\t\t}\n \t\t\tfinally\n \t\t\t{\n@@ -670,8 +670,9 @@ private void contructResponseBody(final Response bodyResponse, final String enco\n \t * \n \t * @param contentResponse\n \t *            the Ajax {@link Response} body\n+\t * @return filtered response\n \t */\n-\tprivate void invokeResponseFilters(final StringResponse contentResponse)\n+\tprivate AppendingStringBuffer invokeResponseFilters(final StringResponse contentResponse)\n \t{\n \t\tAppendingStringBuffer responseBuffer = new AppendingStringBuffer(\n \t\t\tcontentResponse.getBuffer());\n@@ -684,9 +685,10 @@ private void invokeResponseFilters(final StringResponse contentResponse)\n \t\t{\n \t\t\tfor (IResponseFilter filter : responseFilters)\n \t\t\t{\n-\t\t\t\tfilter.filter(responseBuffer);\n+\t\t\t\tresponseBuffer = filter.filter(responseBuffer);\n \t\t\t}\n \t\t}\n+\t\treturn responseBuffer;\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\nindex 83c0556..03e18f9 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n@@ -142,10 +142,10 @@ protected void invoke(WebResponse response)\n \t\t\t{\n \t\t\t\tfor (IResponseFilter filter : responseFilters)\n \t\t\t\t{\n-\t\t\t\t\tfilter.filter(responseBuffer);\n+\t\t\t\t\tresponseBuffer = filter.filter(responseBuffer);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tresponse.write(builder);\n+\t\t\tresponse.write(responseBuffer);\n \t\t}\n \n \t\t@Override\n", "nb_test": 1111, "linesAdd": 7, "jira_id": "3620", "singleLine": false, "nb_skipped": 0, "commit": "1a2bc1bc", "nb_failure": 2, "linesRem": 6}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["parseAbsoluteUrl(org.apache.wicket.request.UrlTest)"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 247197e..d9e0cd5 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -22,6 +22,7 @@\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Locale;\n \n import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Generics;\n@@ -105,6 +106,7 @@ else if (parts.length == 1)\n \t * Parses the given URL string.\n \t * \n \t * @param url\n+\t *           absolute or relative url with query string\n \t * @return Url object\n \t */\n \tpublic static Url parse(final String url)\n@@ -116,7 +118,7 @@ public static Url parse(final String url)\n \t * Parses the given URL string.\n \t * \n \t * @param url\n-\t *           full absolute or relative url with query string\n+\t *           absolute or relative url with query string\n \t * @param charset\n \t * @return Url object\n \t */\n@@ -154,7 +156,7 @@ public static Url parse(String url, Charset charset)\n \n \t\tif (protocolAt != -1)\n \t\t{\n-\t\t\tresult.protocol = absoluteUrl.substring(0, protocolAt);\n+\t\t\tresult.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\n \t\t\tfinal String afterProto = absoluteUrl.substring(protocolAt + 3);\n \t\t\tfinal String hostAndPort;\n \n@@ -176,7 +179,7 @@ public static Url parse(String url, Charset charset)\n \t\t\tif (portAt == -1)\n \t\t\t{\n \t\t\t\tresult.host = hostAndPort;\n-\t\t\t\tresult.port = null;\n+\t\t\t\tresult.port = getDefaultPortForProtocol(result.protocol);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n@@ -230,6 +233,33 @@ public static Url parse(String url, Charset charset)\n \t}\n \n \t/**\n+\t * get default port number for protocol\n+\t * \n+\t * @param protocol\n+\t *           name of protocol\n+\t * @return default port for protocol or <code>null</code> if unknown\n+\t */\n+\tprivate static Integer getDefaultPortForProtocol(String protocol)\n+\t{\n+\t\tif (\"http\".equals(protocol))\n+\t\t{\n+\t\t\treturn 80;\n+\t\t}\n+\t\telse if (\"https\".equals(protocol))\n+\t\t{\n+\t\t\treturn 443;\n+\t\t}\n+\t\telse if (\"ftp\".equals(protocol))\n+\t\t{\n+\t\t\treturn 21;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n \t * Construct.\n \t */\n \tpublic Url()\n", "nb_test": 10, "linesAdd": 23, "jira_id": "3834", "singleLine": false, "nb_skipped": 0, "commit": "747bccb5", "nb_failure": 1, "linesRem": 2}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["componentAttributesNotDoubleEscaped(org.apache.wicket.markup.ComponentTagAttributeEscapingTest): escape manually added attributes"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/TagAttributes.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/TagAttributes.java\nindex 6f9719d..041b0cdb 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/TagAttributes.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/TagAttributes.java\n@@ -54,7 +54,7 @@ public TagAttributes(final IValueMap map)\n \tpublic final Object put(String key, Object value)\r\n \t{\r\n \r\n-\t\treturn super.put(key, unescapeHtml(value));\r\n+\t\treturn super.put(key, value);\r\n \t}\r\n \r\n \t@Override\r\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\nindex 0ec91c9..93c57d0 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\n@@ -31,6 +31,7 @@\n import org.apache.wicket.util.parse.metapattern.parsers.TagNameParser;\n import org.apache.wicket.util.parse.metapattern.parsers.VariableAssignmentParser;\n import org.apache.wicket.util.resource.ResourceStreamNotFoundException;\n+import org.apache.wicket.util.string.Strings;\n \n /**\n  * A fairly shallow markup pull parser which parses a markup string of a given type of markup (for\n@@ -665,6 +666,9 @@ private boolean parseTagText(final XmlTag tag, final String tagText) throws Pars\n \t\t\t\t// Trim trailing whitespace\n \t\t\t\tvalue = value.trim();\n \n+\t\t\t\t// Unescape\n+\t\t\t\tvalue = Strings.unescapeMarkup(value).toString();\n+\n \t\t\t\t// Get key\n \t\t\t\tfinal String key = attributeParser.getKey();\n \n", "nb_test": 1328, "linesAdd": 4, "jira_id": "4505", "singleLine": false, "nb_skipped": 8, "commit": "a4caaa57", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["dontStoreNotRenderedPage(org.apache.wicket.dontstoreunrendered.DontStoreNotRenderedPageRedirectToRenderTest): Internal error in WicketTester. Please report this in Wicket's Issue Tracker.", "dontStoreNotRenderedPage(org.apache.wicket.dontstoreunrendered.DontStoreNotRenderedPageOnePassRenderTest): Internal error in WicketTester. Please report this in Wicket's Issue Tracker.", "dontStoreNotRenderedPage(org.apache.wicket.dontstoreunrendered.DontStoreNotRenderedPageRedirectToBufferTest): Internal error in WicketTester. Please report this in Wicket's Issue Tracker."], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex c7d38f1..3ac6f59 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -680,6 +680,9 @@ public Component(final String id)\n \tpublic Component(final String id, final IModel<?> model)\n \t{\n \t\tsetId(id);\n+\n+\t\tinit();\n+\n \t\tgetApplication().getComponentInstantiationListeners().onInstantiation(this);\n \n \t\tfinal DebugSettings debugSettings = getApplication().getDebugSettings();\n@@ -696,6 +699,15 @@ public Component(final String id, final IModel<?> model)\n \t}\n \n \t/**\n+\t * Let subclasses initialize this instance, before constructors are executed. <br>\n+\t * This method is intentionally <b>not</b> declared protected, to limit overriding to classes in\n+\t * this package.\n+\t */\n+\tvoid init()\n+\t{\n+\t}\n+\n+\t/**\n \t * Get the Markup associated with the Component. If not subclassed, the parent container is\n \t * asked to return the markup of this child component.\n \t * <p/>\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/Page.java b/wicket-core/src/main/java/org/apache/wicket/Page.java\nindex ea1dad2..0935942 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Page.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Page.java\n@@ -177,7 +177,6 @@ private Page(final PageParameters parameters, IModel<?> model)\n \t\t{\n \t\t\tpageParameters = parameters;\n \t\t}\n-\t\tinit();\n \t}\n \n \t/**\n@@ -703,7 +702,8 @@ private boolean hasInvisibleTransparentChild(final MarkupContainer root, final C\n \t/**\n \t * Initializes Page by adding it to the Session and initializing it.\n \t */\n-\tprivate void init()\n+\t@Override\n+\tvoid init()\n \t{\n \t\tif (isBookmarkable() == false)\n \t\t{\n", "nb_test": 1636, "linesAdd": 9, "jira_id": "5546", "singleLine": false, "nb_skipped": 2, "commit": "f1af9e03", "nb_failure": 0, "linesRem": 2}, {"files": 3, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testAjaxUpdate(org.apache.wicket.markup.html.TransparentWebMarkupContainerTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex bd62e47..77dd7e1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -40,6 +40,7 @@\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.IWrapModel;\n import org.apache.wicket.settings.IDebugSettings;\n+import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Generics;\n import org.apache.wicket.util.string.ComponentStrings;\n import org.apache.wicket.util.string.Strings;\n@@ -129,10 +130,7 @@ public final MarkupContainer add(final Component... childs)\n \t{\n \t\tfor (Component child : childs)\n \t\t{\n-\t\t\tif (child == null)\n-\t\t\t{\n-\t\t\t\tthrow new IllegalArgumentException(\"argument child may not be null\");\n-\t\t\t}\n+\t\t\tArgs.notNull(child, \"child\");\n \n \t\t\tMarkupContainer parent = getParent();\n \t\t\twhile (parent != null)\n@@ -899,10 +900,7 @@ public String toString(final boolean detailed)\n \tprivate final void addedComponent(final Component child)\n \t{\n \t\t// Check for degenerate case\n-\t\tif (child == this)\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"Component can't be added to itself\");\n-\t\t}\n+\t\tArgs.notNull(child, \"child\");\n \n \t\tMarkupContainer parent = child.getParent();\n \t\tif (parent != null)\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/Markup.java b/wicket-core/src/main/java/org/apache/wicket/markup/Markup.java\nindex 6bc5bd8..2d27638 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/Markup.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/Markup.java\n@@ -25,7 +25,6 @@\n import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.resource.ResourceStreamNotFoundException;\n import org.apache.wicket.util.string.AppendingStringBuffer;\n-import org.apache.wicket.util.string.Strings;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -187,10 +186,7 @@ final public void makeImmutable()\n \n \tpublic final IMarkupFragment find(final String id)\n \t{\n-\t\tif (Strings.isEmpty(id))\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"Parameter 'id' must not be null or empty\");\n-\t\t}\n+\t\tArgs.notEmpty(id, \"id\");\n \n \t\tMarkupStream stream = new MarkupStream(this);\n \t\tstream.setCurrentIndex(0);\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\nindex e183553..9a4a1d3 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n@@ -23,6 +23,7 @@\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n import org.apache.wicket.markup.html.list.AbstractItem;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -95,6 +96,24 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t\t\treturn markup;\n \t\t}\n \n+\t\t// If the child has not been directly added to the container, but via a\n+\t\t// TransparentWebMarkupContainer, than we are in trouble. In general Wicket iterates over\n+\t\t// the markup elements and searches for associated components, not the other way around.\n+\t\t// Because of TransparentWebMarkupContainer (or more generally resolvers), there is no\n+\t\t// \"synchronous\" search possible.\n+\t\tfor (Component ch : container)\n+\t\t{\n+\t\t\tif ((ch != child) && (ch instanceof MarkupContainer) &&\n+\t\t\t\t(ch instanceof IComponentResolver))\n+\t\t\t{\n+\t\t\t\tmarkup = ((MarkupContainer)ch).getMarkup(child);\n+\t\t\t\tif (markup != null)\n+\t\t\t\t{\n+\t\t\t\t\treturn markup;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t\t// This is to make migration for Items from 1.4 to 1.5 more easy\n \t\tif (Character.isDigit(child.getId().charAt(0)))\n \t\t{\n", "nb_test": 1197, "linesAdd": 18, "jira_id": "3719", "singleLine": false, "nb_skipped": 1, "commit": "5ad32df9", "nb_failure": 0, "linesRem": 13}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testNullAcceptingValidators(org.apache.wicket.markup.html.form.FormComponentTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\nindex 52612b2..1f2d23e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n@@ -1405,9 +1405,17 @@ protected final void validateValidators()\n \t\t{\n \t\t\tfor (Behavior behavior : getBehaviors())\n \t\t\t{\n-\t\t\t\tif (behavior instanceof IValidator)\n+\t\t\t\tvalidator = null;\n+\t\t\t\tif (behavior instanceof ValidatorAdapter)\n+\t\t\t\t{\n+\t\t\t\t\tvalidator = ((ValidatorAdapter<T>)behavior).getValidator();\n+\t\t\t\t}\n+\t\t\t\telse if (behavior instanceof IValidator)\n \t\t\t\t{\n \t\t\t\t\tvalidator = (IValidator<T>)behavior;\n+\t\t\t\t}\n+\t\t\t\tif (validator != null)\n+\t\t\t\t{\n \t\t\t\t\tif (isNull == false || validator instanceof INullAcceptingValidator<?>)\n \t\t\t\t\t{\n \t\t\t\t\t\tvalidator.validate(validatable);\n", "nb_test": 1195, "linesAdd": 9, "jira_id": "3767", "singleLine": false, "nb_skipped": 1, "commit": "84c3baac", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPagedTable(org.apache.wicket.markup.html.list.PagedTableTest)", "testPagedTable(org.apache.wicket.markup.html.list.PagedTableNavigatorWithLabelProviderTest)", "testPagedTable(org.apache.wicket.markup.html.list.PagedTableNavigatorTest)", "testPagedTable(org.apache.wicket.markup.html.list.PagedTableNavigatorWithMarginTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigation.java b/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigation.java\nindex 3342762..60c5499 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigation.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigation.java\n@@ -345,7 +345,8 @@ protected void populateItem(final Loop.LoopItem loopItem)\n \t\t\t@Override\n \t\t\tpublic boolean isEnabled()\n \t\t\t{\n-\t\t\t\treturn PagingNavigation.this.isEnabled() && PagingNavigation.this.isEnableAllowed();\n+\t\t\t\treturn super.isEnabled() && PagingNavigation.this.isEnabled() &&\n+\t\t\t\t\tPagingNavigation.this.isEnableAllowed();\n \t\t\t}\n \t\t};\n \t}\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigator.java b/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigator.java\nindex 018d165..9d9fd47 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigator.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigator.java\n@@ -119,7 +119,8 @@ protected void onBeforeRender()\n \t\t\t@Override\n \t\t\tpublic boolean isEnabled()\n \t\t\t{\n-\t\t\t\treturn PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n+\t\t\t\treturn super.isEnabled() && PagingNavigator.this.isEnabled() &&\n+\t\t\t\t\tPagingNavigator.this.isEnableAllowed();\n \t\t\t}\n \t\t};\n \t}\n@@ -145,9 +146,11 @@ public boolean isEnabled()\n \t\t\t@Override\n \t\t\tpublic boolean isEnabled()\n \t\t\t{\n-\t\t\t\treturn PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n+\t\t\t\treturn super.isEnabled() && PagingNavigator.this.isEnabled() &&\n+\t\t\t\t\tPagingNavigator.this.isEnableAllowed();\n \t\t\t}\n \t\t};\n+\n \t}\n \n \t/**\n@@ -169,7 +172,8 @@ protected PagingNavigation newNavigation(final IPageable pageable,\n \t\t\t@Override\n \t\t\tpublic boolean isEnabled()\n \t\t\t{\n-\t\t\t\treturn PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n+\t\t\t\treturn super.isEnabled() && PagingNavigator.this.isEnabled() &&\n+\t\t\t\t\tPagingNavigator.this.isEnableAllowed();\n \t\t\t}\n \t\t};\n \t}\n", "nb_test": 715, "linesAdd": 9, "jira_id": "1619", "singleLine": false, "nb_skipped": 0, "commit": "b154d12f", "nb_failure": 4, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["asArray(org.apache.wicket.ajax.json.JsonUtilsTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/json/JsonUtils.java b/wicket-core/src/main/java/org/apache/wicket/ajax/json/JsonUtils.java\nindex f4b8a9b..ece4997 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/json/JsonUtils.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/json/JsonUtils.java\n@@ -58,7 +58,9 @@ public static JSONArray asArray(Map<String, Object> map) throws JSONException\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\telse if (value.getClass().isArray())\n+\t\t\t\telse if (value != null)\n+\t\t\t\t{\n+\t\t\t\t\tif (value.getClass().isArray())\n \t\t\t\t\t{\n \t\t\t\t\t\tObject[] array = (Object[]) value;\n \t\t\t\t\t\tfor (Object v : array)\n@@ -74,8 +76,6 @@ else if (value.getClass().isArray())\n \t\t\t\t\t}\n \t\t\t\t\telse\n \t\t\t\t\t{\n-\t\t\t\t\tif (value != null)\n-\t\t\t\t\t{\n \t\t\t\t\t\tJSONObject object = new JSONObject();\n \t\t\t\t\t\tobject.put(\"name\", name);\n \t\t\t\t\t\tobject.put(\"value\", value);\n", "nb_test": 1575, "linesAdd": 3, "jira_id": "5497", "singleLine": false, "nb_skipped": 2, "commit": "724066f4", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["HtmlHeaderItemsContainerTest.pageWithBasePageWithHeaderItems:213->Assert.fail:88 Error while parsing the markup for the autogenerated page: More than one <wicket:header-items/> detected in the <head> element. Only one is allowed."], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\nindex 5b79f80..b695713 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n@@ -31,6 +31,7 @@\n import org.apache.wicket.markup.parser.AbstractMarkupFilter;\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n import org.apache.wicket.markup.resolver.HtmlHeaderResolver;\n+import org.apache.wicket.util.tester.BaseWicketTester;\n \n \n /**\n@@ -172,7 +173,7 @@ private void handleBodyTag()\n \t */\n \tprivate void handleHeaderItemsTag(ComponentTag tag)\n \t{\n-\t\tif (foundHeaderItemsTag)\n+\t\tif ((tag.isOpen() || tag.isOpenClose()) && foundHeaderItemsTag)\n \t\t{\n \t\t\tthrow new MarkupException(new MarkupStream(markup),\n \t\t\t\t\t\"More than one <wicket:header-items/> detected in the <head> element. Only one is allowed.\");\n", "nb_test": 1871, "linesAdd": 2, "jira_id": "5989", "singleLine": false, "nb_skipped": 1, "commit": "a255bbca", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["AjaxEventBehaviorTest.cutLeadingOnPrefix:100->Assert.assertThat:832->Assert.assertThat:865", "Expected: is \"event event2\"", "but: was \"event onevent2\""], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\nindex b1a6f98..aba06de 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n@@ -16,11 +16,16 @@\n  */\n package org.apache.wicket.ajax;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n import org.apache.wicket.Component;\n import org.apache.wicket.ajax.attributes.AjaxRequestAttributes;\n import org.apache.wicket.markup.head.IHeaderResponse;\n import org.apache.wicket.markup.head.OnDomReadyHeaderItem;\n import org.apache.wicket.util.lang.Args;\n+import org.apache.wicket.util.lang.Checks;\n+import org.apache.wicket.util.string.Strings;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -44,6 +49,13 @@\n  * represents, and so anytime a user clicks this div the {@link #onEvent(AjaxRequestTarget)} of the\n  * behavior is invoked.\n  *\n+ * <p>\n+ * <strong>Note</strong>: {@link #getEvent()} method cuts any <em>on</em> prefix from the given event name(s).\n+ * This is being done for easier migration of applications coming from Wicket 1.5.x where Wicket used\n+ * inline attributes like 'onclick=...'. If the application needs to use custom events with names starting with\n+ * <em>on</em> then {@link #getEvent()} should be overridden.\n+ * </p>\n+ *\n  * @since 1.2\n  * \n  * @author Igor Vaynberg (ivaynberg)\n@@ -69,18 +81,6 @@ public AjaxEventBehavior(String event)\n \n \t\tonCheckEvent(event);\n \n-\t\tevent = event.toLowerCase();\n-\t\tif (event.startsWith(\"on\"))\n-\t\t{\n-\t\t\tString shortName = event.substring(2);\n-\t\t\t// TODO Wicket 8 Change this to throw an error in the milestone/RC versions and remove it for the final version\n-\t\t\tLOGGER.warn(\"Since version 6.0.0 Wicket uses JavaScript event registration so there is no need of the leading \" +\n-\t\t\t\t\t\"'on' in the event name '{}'. Please use just '{}'. Wicket 8.x won't manipulate the provided event \" +\n-\t\t\t\t\t\"names so the leading 'on' may break your application.\"\n-\t\t\t\t\t, event, shortName);\n-\t\t\tevent = shortName;\n-\t\t}\n-\n \t\tthis.event = event;\n \t}\n \n@@ -102,7 +102,9 @@ protected void updateAjaxAttributes(AjaxRequestAttributes attributes)\n \t{\n \t\tsuper.updateAjaxAttributes(attributes);\n \n-\t\tattributes.setEventNames(event);\n+\t\tString evt = getEvent();\n+\t\tChecks.notEmpty(evt, \"getEvent() should return non-empty event name(s)\");\n+\t\tattributes.setEventNames(evt);\n \t}\n \n \t/**\n@@ -115,13 +117,33 @@ protected void onCheckEvent(final String event)\n \t}\n \n \t/**\n-\t * \n \t * @return event\n \t *      the event this behavior is attached to\n \t */\n-\tpublic final String getEvent()\n+\tpublic String getEvent()\n \t{\n-\t\treturn event;\n+\t\tString events = event.toLowerCase();\n+\t\tString[] splitEvents = events.split(\"\\\\s+\");\n+\t\tList<String> cleanedEvents = new ArrayList<>(splitEvents.length);\n+\t\tfor (String evt : splitEvents)\n+\t\t{\n+\t\t\tif (Strings.isEmpty(evt) == false)\n+\t\t\t{\n+\t\t\t\tif (evt.startsWith(\"on\"))\n+\t\t\t\t{\n+\t\t\t\t\tString shortName = evt.substring(2);\n+\t\t\t\t\t// TODO Wicket 8 Change this to throw an error in the milestone/RC versions and remove it for the final version\n+\t\t\t\t\tLOGGER.warn(\"Since version 6.0.0 Wicket uses JavaScript event registration so there is no need of the leading \" +\n+\t\t\t\t\t\t\t\"'on' in the event name '{}'. Please use just '{}'. Wicket 8.x won't manipulate the provided event \" +\n+\t\t\t\t\t\t\t\"names so the leading 'on' may break your application.\"\n+\t\t\t\t\t\t\t, evt, shortName);\n+\t\t\t\t\tevt = shortName;\n+\t\t\t\t}\n+\t\t\t\tcleanedEvents.add(evt);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn Strings.join(\" \", cleanedEvents);\n \t}\n \n \t/**\n", "nb_test": 1718, "linesAdd": 30, "jira_id": "5783", "singleLine": false, "nb_skipped": 1, "commit": "7b8b6767", "nb_failure": 1, "linesRem": 14}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["properlyClosed(org.apache.wicket.extensions.markup.html.repeater.tree.table.NodeBorderTest): expected:<...n></div></div></div>[</div></div>]> but was:<...n></div></div></div>[]>"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/tree/table/NodeBorder.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/tree/table/NodeBorder.java\nindex 089a367..db1ca42 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/tree/table/NodeBorder.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/tree/table/NodeBorder.java\n@@ -83,6 +83,10 @@ public void afterRender(Component component)\n \n \t\tfor (int i = 0; i < branches.length; i++)\n \t\t{\n+\t\t\tif (i > 0)\n+\t\t\t{\n+\t\t\t\tresponse.write(\"</div>\");\n+\t\t\t}\n \t\t\tresponse.write(\"</div>\");\n \t\t}\n \t}\n", "nb_test": 55, "linesAdd": 4, "jira_id": "5447", "singleLine": false, "nb_skipped": 0, "commit": "2abc18f1", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testWriteStream(org.apache.wicket.request.resource.WriteCallbackTest)", "testLastModifiedForResourceInJar(org.apache.wicket.util.resource.UrlResourceStreamTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/request/resource/AbstractResource.java b/wicket/src/main/java/org/apache/wicket/request/resource/AbstractResource.java\nindex 1f6f526..00358a06 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/resource/AbstractResource.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/resource/AbstractResource.java\n@@ -463,7 +463,7 @@ public void write(byte[] b) throws IOException\n \t\t\t\t@Override\n \t\t\t\tpublic void write(byte[] b, int off, int len) throws IOException\n \t\t\t\t{\n-\t\t\t\t\tif (off == 0 || len == b.length)\n+\t\t\t\t\tif (off == 0 && len == b.length)\n \t\t\t\t\t{\n \t\t\t\t\t\twrite(b);\n \t\t\t\t\t}\ndiff --git a/wicket/src/main/java/org/apache/wicket/util/resource/UrlResourceStream.java b/wicket/src/main/java/org/apache/wicket/util/resource/UrlResourceStream.java\nindex 8a0cef7..02a144b 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/resource/UrlResourceStream.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/resource/UrlResourceStream.java\n@@ -193,6 +193,8 @@ public URL getURL()\n \t@Override\n \tpublic Time lastModifiedTime()\n \t{\n+\t\ttry\n+\t\t{\n \t\t\tif (file != null)\n \t\t\t{\n \t\t\t\t// in case the file has been removed by now\n@@ -207,13 +209,11 @@ public Time lastModifiedTime()\n \t\t\t\tif (lastModified != this.lastModified)\n \t\t\t\t{\n \t\t\t\t\tthis.lastModified = lastModified;\n-\t\t\t\tcontentLength = (int)file.length();\n+\t\t\t\t\tsetContentLength();\n \t\t\t\t}\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\ttry\n-\t\t\t{\n \t\t\t\tlong lastModified = Connections.getLastModified(url);\n \n \t\t\t\t// if last modified changed update content length and last modified date\n@@ -221,10 +221,10 @@ public Time lastModifiedTime()\n \t\t\t\t{\n \t\t\t\t\tthis.lastModified = lastModified;\n \n-\t\t\t\t\tURLConnection connection = url.openConnection();\n-\t\t\t\t\tcontentLength = connection.getContentLength();\n-\t\t\t\t\tConnections.close(connection);\n+\t\t\t\t\tsetContentLength();\n+\t\t\t\t}\n \t\t\t}\n+\t\t\treturn Time.milliseconds(lastModified);\n \t\t}\n \t\tcatch (IOException e)\n \t\t{\n@@ -243,9 +243,13 @@ public Time lastModifiedTime()\n \t\t\t// allow modification watcher to detect the problem\n \t\t\treturn null;\n \t\t}\n-\n \t}\n-\t\treturn Time.milliseconds(lastModified);\n+\n+\tprivate void setContentLength() throws IOException\n+\t{\n+\t\tURLConnection connection = url.openConnection();\n+\t\tcontentLength = connection.getContentLength();\n+\t\tConnections.close(connection);\n \t}\n \n \t/**\n", "nb_test": 880, "linesAdd": 13, "jira_id": "2839", "singleLine": false, "nb_skipped": 1, "commit": "15477252", "nb_failure": 2, "linesRem": 9}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["mapHandler(org.apache.wicket.protocol.https.HttpsMapperTest): org.hamcrest.Matcher.describeMismatch(Ljava/lang/Object;Lorg/hamcrest/Description;)V"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/https/HttpsMapper.java b/wicket-core/src/main/java/org/apache/wicket/protocol/https/HttpsMapper.java\nindex a5f765a..aaa1a3e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/https/HttpsMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/https/HttpsMapper.java\n@@ -170,11 +170,8 @@ final Url mapHandler(IRequestHandler handler, Request request)\n \t\t\t// the generated url does not have the correct scheme, set it (which in turn will cause\n \t\t\t// the url to be rendered in its full representation)\n \t\t\turl.setProtocol(desired.urlName());\n-\t\t\tif (url.getPort() != null || !desired.usesStandardPort(config))\n-\t\t\t{\n \t\t\turl.setPort(desired.getPort(config));\n \t\t}\n-\t\t}\n \t\treturn url;\n \t}\n \n", "nb_test": 1422, "linesAdd": 0, "jira_id": "4824", "singleLine": false, "nb_skipped": 5, "commit": "ad849602", "nb_failure": 0, "linesRem": 3}, {"files": 3, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test_1(org.apache.wicket.markup.html.header.testing3.HeaderTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/Component.java b/wicket/src/main/java/org/apache/wicket/Component.java\nindex aeba674..1660a13 100644\n--- a/wicket/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket/src/main/java/org/apache/wicket/Component.java\n@@ -64,6 +64,7 @@\n import org.apache.wicket.settings.IDebugSettings;\n import org.apache.wicket.util.IHierarchical;\n import org.apache.wicket.util.convert.IConverter;\n+import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Classes;\n import org.apache.wicket.util.lang.WicketObjects;\n import org.apache.wicket.util.string.ComponentStrings;\n@@ -2775,6 +2774,21 @@ public final void setMarkupIdImpl(Object markupId)\n \t}\n \n \t/**\n+\t * Copy markupId\n+\t * \n+\t * @param comp\n+\t */\n+\tfinal void setMarkupId(Component comp)\n+\t{\n+\t\tArgs.notNull(comp, \"comp\");\n+\n+\t\tgeneratedMarkupId = comp.generatedMarkupId;\n+\t\tsetMetaData(MARKUP_ID_KEY, comp.getMetaData(MARKUP_ID_KEY));\n+\t\tsetOutputMarkupId(comp.getOutputMarkupId());\n+\t\treturn;\n+\t}\n+\n+\t/**\n \t * Sets this component's markup id to a user defined value. It is up to the user to ensure this\n \t * value is unique.\n \t * <p>\ndiff --git a/wicket/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 07536ee..cff9056 100644\n--- a/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -804,7 +804,7 @@ public final MarkupContainer replace(final Component child)\n \t\t\taddedComponent(child);\n \n \t\t\t// The generated markup id remains the same\n-\t\t\tchild.setMarkupIdImpl(replaced.getMarkupIdImpl());\n+\t\t\tchild.setMarkupId(replaced);\n \t\t}\n \n \t\treturn this;\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/panel/Panel.java b/wicket/src/main/java/org/apache/wicket/markup/html/panel/Panel.java\nindex 8fa10e2..3245a54 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/panel/Panel.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/panel/Panel.java\n@@ -106,6 +106,13 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\t// <span wicket:id=\"myPanel\">...</span>\n \t\t\ttag.setType(XmlTag.OPEN);\n \t\t}\n+\n+// IMarkupFragment markup = getMarkup(null);\n+// ComponentTag panelTag = (ComponentTag)markup.get(0);\n+// for (String key : panelTag.getAttributes().keySet())\n+// {\n+// tag.append(key, panelTag.getAttribute(key), \", \");\n+// }\n \t\tsuper.onComponentTag(tag);\n \t}\n \n", "nb_test": 1003, "linesAdd": 13, "jira_id": "3197", "singleLine": false, "nb_skipped": 0, "commit": "be70e608", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["changeVariation(org.apache.wicket.markup.MarkupVariationTest): pattern 'One' found"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 956df88..94bef50 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -36,6 +36,7 @@\n import org.apache.wicket.feedback.IFeedback;\n import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.markup.IMarkupFragment;\n+import org.apache.wicket.markup.MarkupCache;\n import org.apache.wicket.markup.MarkupElement;\n import org.apache.wicket.markup.MarkupException;\n import org.apache.wicket.markup.MarkupNotFoundException;\n@@ -1170,6 +1171,8 @@ public final void detach()\n \n \t\trequestFlags = 0;\n \n+\t\tinternalDetach();\n+\n \t\t// notify any detach listener\n \t\tIDetachListener detachListener = getApplication().getFrameworkSettings()\n \t\t\t.getDetachListener();\n@@ -1180,6 +1183,15 @@ public final void detach()\n \t}\n \n \t/**\n+\t * Removes the cached markup at the end of the request. For the next request it will be get\n+\t * either from the parent's markup or from {@link MarkupCache}.\n+\t */\n+\tprivate void internalDetach()\n+\t{\n+\t\tmarkup = null;\n+\t}\n+\n+\t/**\n \t * Detaches all models\n \t */\n \tpublic void detachModels()\n@@ -3065,7 +3077,7 @@ public final Component setOutputMarkupPlaceholderTag(final boolean outputTag)\n \t\t\t{\n \t\t\t\tsetFlag(FLAG_PLACEHOLDER, false);\n \t\t\t\t// I think it's better to not setOutputMarkupId to false...\n-\t\t\t\t// user can do it if we want\n+\t\t\t\t// user can do it if she want\n \t\t\t}\n \t\t}\n \t\treturn this;\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\nindex 614ccb6..9caac6d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\n@@ -17,6 +17,8 @@\n package org.apache.wicket.markup.html.internal;\r\n \r\n import org.apache.wicket.markup.ComponentTag;\r\n+import org.apache.wicket.markup.IMarkupFragment;\r\n+import org.apache.wicket.markup.Markup;\r\n import org.apache.wicket.markup.parser.filter.InlineEnclosureHandler;\r\n import org.slf4j.Logger;\r\n import org.slf4j.LoggerFactory;\r\n@@ -42,6 +44,8 @@\n \r\n \tprivate static final Logger log = LoggerFactory.getLogger(InlineEnclosure.class);\r\n \r\n+\tprivate String enclosureMarkupAsString;\r\n+\r\n \t/**\r\n \t * Construct.\r\n \t * \r\n@@ -53,8 +57,9 @@ public InlineEnclosure(final String id, final String childId)\n \t{\r\n \t\tsuper(id, childId);\r\n \r\n+\t\tenclosureMarkupAsString = null;\r\n+\r\n \t\t// ensure that the Enclosure is ready for ajax updates\r\n-\t\tsetOutputMarkupId(true);\r\n \t\tsetOutputMarkupPlaceholderTag(true);\r\n \t\tsetMarkupId(getId());\r\n \t}\r\n@@ -79,4 +84,32 @@ public boolean updateVisibility()\n \t\tsetVisible(visible);\r\n \t\treturn visible;\r\n \t}\r\n+\r\n+\t/**\r\n+\t * {@link InlineEnclosure}s keep their own cache of their markup because Component#markup is\r\n+\t * detached and later during Ajax request it is hard to re-lookup {@link InlineEnclosure}'s\r\n+\t * markup from its parent.\r\n+\t * \r\n+\t * @see org.apache.wicket.Component#getMarkup()\r\n+\t */\r\n+\t@Override\r\n+\tpublic IMarkupFragment getMarkup()\r\n+\t{\r\n+\t\tIMarkupFragment enclosureMarkup = null;\r\n+\t\tif (enclosureMarkupAsString == null)\r\n+\t\t{\r\n+\t\t\tIMarkupFragment markup = super.getMarkup();\r\n+\t\t\tif (markup != null && markup != Markup.NO_MARKUP)\r\n+\t\t\t{\r\n+\t\t\t\tenclosureMarkup = markup;\r\n+\t\t\t\tenclosureMarkupAsString = markup.toString(true);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\telse\r\n+\t\t{\r\n+\t\t\tenclosureMarkup = Markup.of(enclosureMarkupAsString);\r\n+\t\t}\r\n+\r\n+\t\treturn enclosureMarkup;\r\n+\t}\r\n }\r\n", "nb_test": 1147, "linesAdd": 35, "jira_id": "3931", "singleLine": false, "nb_skipped": 2, "commit": "8fbdc68f", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["options(org.apache.wicket.protocol.http.WicketFilterTest): Should never get here when an OPTIONS request is issued"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\nindex eb73ee7..be577f3 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n@@ -96,8 +96,8 @@\n \tprivate boolean isServlet = false;\n \n \t/**\n-\t * default constructor, usually invoked through the servlet \n-\t * container by the web.xml configuration\n+\t * default constructor, usually invoked through the servlet container by the web.xml\n+\t * configuration\n \t */\n \tpublic WicketFilter()\n \t{\n@@ -106,8 +106,8 @@ public WicketFilter()\n \t/**\n \t * constructor supporting programmatic setup of the filter\n \t * <p/>\n-\t *  this can be useful for programmatically creating and appending the \n-\t *  wicket filter to the servlet context using servlet 3 features.\n+\t * this can be useful for programmatically creating and appending the wicket filter to the\n+\t * servlet context using servlet 3 features.\n \t * \n \t * @param application\n \t *            web application\n@@ -174,7 +174,7 @@ boolean processRequest(ServletRequest request, final ServletResponse response,\n \t\t\t\treturn false;\n \t\t\t}\n \n-\t\t\tif (\"OPTIONS\".equals(httpServletRequest.getMethod()))\n+\t\t\tif (\"OPTIONS\".equalsIgnoreCase(httpServletRequest.getMethod()))\n \t\t\t{\n \t\t\t\t// handle the OPTIONS request outside of normal request processing.\n \t\t\t\t// wicket pages normally only support GET and POST methods, but resources and\n@@ -198,7 +198,8 @@ boolean processRequest(ServletRequest request, final ServletResponse response,\n \t\t\t\t\thttpServletResponse);\n \n \t\t\t\tRequestCycle requestCycle = application.createRequestCycle(webRequest, webResponse);\n-\t\t\t\tres = processRequestCycle(requestCycle, webResponse, httpServletRequest, httpServletResponse, chain);\n+\t\t\t\tres = processRequestCycle(requestCycle, webResponse, httpServletRequest,\n+\t\t\t\t\thttpServletResponse, chain);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n@@ -250,7 +251,8 @@ boolean processRequest(ServletRequest request, final ServletResponse response,\n \t */\n \tprotected boolean processRequestCycle(RequestCycle requestCycle, WebResponse webResponse,\n \t\tHttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,\n-\t\tfinal FilterChain chain) throws IOException, ServletException {\n+\t\tfinal FilterChain chain) throws IOException, ServletException\n+\t{\n \t\t// Assume we are able to handle the request\n \t\tboolean res = true;\n \n@@ -518,6 +520,7 @@ protected String getFilterPath(final HttpServletRequest request)\n \n \t/**\n \t * Provide a standard getter for filterPath.\n+\t * \n \t * @return The configured filterPath.\n \t */\n \tprotected String getFilterPath()\n@@ -651,7 +654,8 @@ public final void setFilterPath(String filterPath)\n \t\tif (this.filterPath != null)\n \t\t{\n \t\t\tthrow new IllegalStateException(\n-\t\t\t\t\"Filter path is write-once. You can not change it. Current value='\" + filterPath + '\\'');\n+\t\t\t\t\"Filter path is write-once. You can not change it. Current value='\" + filterPath +\n+\t\t\t\t\t'\\'');\n \t\t}\n \t\tif (filterPath != null)\n \t\t{\n", "nb_test": 1469, "linesAdd": 7, "jira_id": "5138", "singleLine": false, "nb_skipped": 3, "commit": "e8dab4a0", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["shouldRenderPageAndWriteResponseVariation(org.apache.wicket.request.handler.render.WebPageRendererTest): ajax=false,onePassRender=false,redirectToRender=false,redirectPolicy=ALWAYS_REDIRECT,shouldPreserveClientUrl=true,targetEqualsCurrentUrl=false,newPageInstance=false,pageStateless=false, expected:<false> but was:<true>", "testShouldPreserveClientUrlOverruledByRedirectPolicyAlwaysRedirect(org.apache.wicket.request.handler.render.WebPageRendererTest): (..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex 8c99c13..1b98bed 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -342,7 +342,7 @@ protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url curre\n \t\t\t|| ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl\n \t\t\t\t.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(),\n \t\t\t\tisPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender())\n-\t\t\t|| shouldPreserveClientUrl(cycle);\n+\t\t\t|| (shouldPreserveClientUrl(cycle) && notForcedRedirect(getRedirectPolicy()));\n \t}\n \n \tprivate static boolean notNewAndNotStatelessPage(boolean newPageInstance, boolean pageStateless)\n", "nb_test": 1608, "linesAdd": 1, "jira_id": "5486", "singleLine": false, "nb_skipped": 2, "commit": "a79ed51e", "nb_failure": 2, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDepth_Component(org.apache.wicket.ComponentEventsTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ComponentEventSender.java b/wicket-core/src/main/java/org/apache/wicket/ComponentEventSender.java\nindex efbd0ff..a01f8d4 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ComponentEventSender.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ComponentEventSender.java\n@@ -164,6 +164,10 @@ private void depth(final ComponentEvent<?> event)\n \t\t{\n \t\t\tVisits.visitPostOrder(cursor, new ComponentEventVisitor(event, dispatcher));\n \t\t}\n+\t\telse\n+\t\t{\n+\t\t\tdispatcher.dispatchEvent(cursor, event);\n+\t\t}\n \t\tif (event.isStop())\n \t\t{\n \t\t\treturn;\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/event/Broadcast.java b/wicket-core/src/main/java/org/apache/wicket/event/Broadcast.java\nindex 401a4f2..5328637 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/event/Broadcast.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/event/Broadcast.java\n@@ -39,6 +39,12 @@\n \t * <li>{@link Component}s</li>\n \t * </ol>\n \t * \n+\t * Components receive the event with a preorder breadth-first traversal, eg: Apply recursively:\n+\t * <ol>\n+\t * <li>The component receives the event</li>\n+\t * <li>The component's children receive the event</li>\n+\t * </ol>\n+\t * \n \t * Any sink along the path can be specified and traversal will start with the specified sink as\n \t * root, eg:\n \t * \n@@ -61,6 +67,12 @@\n \t * <li>{@link Application}</li>\n \t * </ol>\n \t * \n+\t * Components receive the event with a postorder depth-first traversal, eg: Apply recursively:\n+\t * <ol>\n+\t * <li>The component's children receive the event</li>\n+\t * <li>The component receives the event</li>\n+\t * </ol>\n+\t * \n \t * Any sink along the path can be specified and traversal will start with the specified sink as\n \t * root, eg:\n \t * \n", "nb_test": 1080, "linesAdd": 4, "jira_id": "3539", "singleLine": false, "nb_skipped": 0, "commit": "a4459ef4", "nb_failure": 1, "linesRem": 0}, {"files": 4, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["contentType(org.apache.wicket.request.resource.ByteArrayResourceTest): null expected:<application/octet-stream> but was:<null>", "contentType(org.apache.wicket.markup.html.PackageResourceTest): null expected:<text/[javascript]> but was:<text/[plain]>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockServletContext.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockServletContext.java\nindex 42a8996..392e921 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockServletContext.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockServletContext.java\n@@ -107,7 +107,7 @@ public MockServletContext(final Application application, final String path)\n \t\tmimeTypes.put(\"htm\", \"text/html\");\n \t\tmimeTypes.put(\"css\", \"text/css\");\n \t\tmimeTypes.put(\"xml\", \"text/xml\");\n-\t\tmimeTypes.put(\"js\", \"text/plain\");\n+\t\tmimeTypes.put(\"js\", \"text/javascript\");\n \t\tmimeTypes.put(\"gif\", \"image/gif\");\n \t\tmimeTypes.put(\"jpg\", \"image/jpeg\");\n \t\tmimeTypes.put(\"png\", \"image/png\");\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\nindex d156c11..d11cab8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.wicket.request.resource;\n \n+import java.net.URLConnection;\n+\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.util.time.Time;\n \n@@ -95,6 +97,22 @@ protected ResourceResponse newResourceResponse(final Attributes attributes)\n \t{\n \t\tfinal ResourceResponse response = new ResourceResponse();\n \n+\t\tString contentType = this.contentType;\n+\n+\t\tif (contentType == null)\n+\t\t{\n+\t\t\tif (filename != null)\n+\t\t\t{\n+\t\t\t\tcontentType = URLConnection.getFileNameMap().getContentTypeFor(filename);\n+\t\t\t}\n+\n+\t\t\tif (contentType == null)\n+\t\t\t{\n+\t\t\t\tcontentType = \"application/octet-stream\";\n+\t\t\t}\n+\t\t}\n+\n+\n \t\tresponse.setContentType(contentType);\n \t\tresponse.setLastModified(lastModified);\n \ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResource.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResource.java\nindex 449c344..a4ce0fe 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResource.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResource.java\n@@ -252,11 +252,15 @@ protected ResourceResponse newResourceResponse(Attributes attributes)\n \t\t\t\treturn sendResourceError(resourceResponse, HttpServletResponse.SC_NOT_FOUND,\n \t\t\t\t\t\"Unable to find resource\");\n \n-\t\t\tString contentType = resourceStream.getContentType();\n-\t\t\tif (contentType == null && Application.exists())\n+\t\t\tfinal String contentType;\n+\t\t\tif (Application.exists())\n \t\t\t{\n \t\t\t\tcontentType = Application.get().getMimeType(path);\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tcontentType = resourceStream.getContentType();\n+\t\t\t}\n \t\t\t// set Content-Type (may be null)\n \t\t\tresourceResponse.setContentType(contentType);\n \ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/ResourceStreamResource.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/ResourceStreamResource.java\nindex e9d25f0..e83257a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/ResourceStreamResource.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/ResourceStreamResource.java\n@@ -123,11 +123,15 @@ protected ResourceResponse newResourceResponse(Attributes attributes)\n \t\t\t}\n \t\t\tdata.setFileName(fileName);\n \n-\t\t\tString contentType = stream.getContentType();\n-\t\t\tif (contentType == null && fileName != null && Application.exists())\n+\t\t\tfinal String contentType;\n+\t\t\tif (fileName != null && Application.exists())\n \t\t\t{\n \t\t\t\tcontentType = Application.get().getMimeType(fileName);\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tcontentType = stream.getContentType();\n+\t\t\t}\n \t\t\tdata.setContentType(contentType);\n \t\t\tdata.setTextEncoding(textEncoding);\n \n", "nb_test": 1206, "linesAdd": 31, "jira_id": "4119", "singleLine": false, "nb_skipped": 2, "commit": "bb7a6995", "nb_failure": 2, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["IntHashMapTest.serialize:56 \u00bb NullPointer"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/collections/IntHashMap.java b/wicket-util/src/main/java/org/apache/wicket/util/collections/IntHashMap.java\nindex 7b377fc..7a8d180 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/collections/IntHashMap.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/collections/IntHashMap.java\n@@ -1145,6 +1145,8 @@ private void writeObject(final java.io.ObjectOutputStream s) throws IOException\n \tprivate void readObject(final java.io.ObjectInputStream s) throws IOException,\n \t\tClassNotFoundException\n \t{\n+\t\tmodCount = new AtomicInteger(0);\n+\n \t\t// Read in the threshold, loadfactor, and any hidden stuff\n \t\ts.defaultReadObject();\n \n", "nb_test": 183, "linesAdd": 2, "jira_id": "5751", "singleLine": false, "nb_skipped": 2, "commit": "bcea89fc", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["renderHomePage(org.apache.wicket.markup.outputTransformer.OutputTransformerContainerTest): Unable to find associated markup file for Border: [SimpleBorder [Component id = myBorder]]"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\nindex d09c100..4d1724b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\n@@ -19,7 +19,6 @@\n import org.apache.wicket.AttributeModifier;\n import org.apache.wicket.Component;\n import org.apache.wicket.markup.MarkupResourceStream;\n-import org.apache.wicket.markup.MarkupType;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.Model;\n \n@@ -29,9 +28,8 @@\n  * with an associated markup and must have a filename equal to the component's id.\n  * <p>\n  * The containers tag will be the root element of the xml data applied for transformation to ensure\n- * the xml data are well formed (single root element). In addition the attribute\n- * <code>xmlns:wicket=\"http://wicket.apache.org/dtds.data/wicket-xhtml1.3-strict.dtd</code> is added\n- * to the root element to allow the XSL processor to handle the wicket namespace.\n+ * the xml data are well formed (single root element). In addition the attribute <code>xmlns:wicket=\"http://wicket.apache.org/dtds.data/wicket-xhtml1.3-strict.dtd</code>\n+ * is added to the root element to allow the XSL processor to handle the wicket namespace.\n  * <p>\n  * Similar to this container, a <code>IBehavior</code> is available which does the same, but does\n  * not require an additional Container.\n@@ -105,12 +103,6 @@ public XsltOutputTransformerContainer(final String id)\n \t}\n \n \t@Override\n-\tpublic MarkupType getMarkupType()\n-\t{\n-\t\treturn new MarkupType(\"xsl\", null);\n-\t}\n-\n-\t@Override\n \tpublic CharSequence transform(final Component component, final CharSequence output)\n \t\tthrows Exception\n \t{\n", "nb_test": 1298, "linesAdd": 0, "jira_id": "4391", "singleLine": false, "nb_skipped": 4, "commit": "5d64196a", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testWithPanelAjax(org.apache.wicket.markup.html.form.validation.HomePageTest)", "testWithPanelForm(org.apache.wicket.markup.html.form.validation.HomePageTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 521e014..a1d958f 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -1238,12 +1238,16 @@ public Object component(final Component component)\n \t\t\t}\n \t\t};\n \n-\t\tvisitChildren(FormComponent.class, new IVisitor<Component>()\n+\t\tvisitChildren(Component.class, new IVisitor<Component>()\n \t\t{\n \t\t\tpublic Object component(final Component component)\n \t\t\t{\n+\t\t\t\tif ((component instanceof Form) || (component instanceof FormComponent))\n+\t\t\t\t{\n \t\t\t\t\treturn visitor.component(component);\n \t\t\t\t}\n+\t\t\t\treturn Component.IVisitor.CONTINUE_TRAVERSAL;\n+\t\t\t}\n \t\t});\n \n \t\tif (!error[0])\n", "nb_test": 794, "linesAdd": 5, "jira_id": "2202", "singleLine": false, "nb_skipped": 0, "commit": "24ac1a35", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEmailWithMinusChar(org.apache.wicket.extensions.markup.html.basic.DefaultLinkParserTest): Expected chars to left of - to be included in the link. expected:<[<a href=\"mailto:my-test@example.com\">my-]test@example.com</a>> but was:<[my-<a href=\"mailto:test@example.com\">]test@example.com</a>>"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\nindex 54705e4..515bba9 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\n@@ -29,7 +29,7 @@\n public class DefaultLinkParser extends LinkParser\n {\n \t/** Email address pattern */\n-\tprivate static final String emailPattern = \"[\\\\w\\\\.-\\\\\\\\+]+@[\\\\w\\\\.-]+\";\n+\tprivate static final String emailPattern = \"[\\\\w\\\\.\\\\-\\\\\\\\+]+@[\\\\w\\\\.\\\\-]+\";\n \n \t/** URL pattern */\n \tprivate static final String urlPattern = \"([a-zA-Z]+://[\\\\w\\\\.\\\\-\\\\:\\\\/~]+)[\\\\w\\\\.:\\\\-/?&=%]*\";\n", "nb_test": 32, "linesAdd": 1, "jira_id": "4477", "singleLine": false, "nb_skipped": 0, "commit": "2624d2db", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEncodeInnerClass(org.apache.wicket.request.mapper.PackageMapperTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/PackageMapper.java\nindex 563afd0..f6082e3 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/PackageMapper.java\n@@ -16,11 +16,11 @@\n  */\n package org.apache.wicket.request.mapper;\n \n+import org.apache.wicket.protocol.http.WebApplication;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n import org.apache.wicket.request.mapper.info.PageComponentInfo;\n-import org.apache.wicket.request.mapper.mount.MountMapper;\n import org.apache.wicket.request.mapper.parameter.IPageParametersEncoder;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n import org.apache.wicket.request.mapper.parameter.PageParametersEncoder;\n@@ -30,10 +30,14 @@\n /**\n  * A request mapper that mounts all bookmarkable pages in a given package.\n  * <p>\n- * To mount this mapper onto a path use the {@link MountMapper}, ex:\n+ * To mount this mapper onto a path use the {@link WebApplication#mountPackage(String, Class)}, ex:\n  * \n  * <pre>\n- * new MountMapper(&quot;/my/path&quot;, new packageMapper(PackageName.forClass(MyPage.class)));\n+ * MyApp#init() {\n+ * \n+ *   super.init();\n+ *   mountPackage(&quot;/my/path&quot;, MyPage.class);\n+ * }\n  * </pre>\n  * \n  * will result in urls like {@code /my/path/MyPage}\n@@ -96,10 +100,19 @@ public PackageMapper(final PackageName packageName,\n \tprotected Url buildUrl(UrlInfo info)\n \t{\n \t\tClass<? extends IRequestablePage> pageClass = info.getPageClass();\n-\t\tif (PackageName.forClass(pageClass).equals(packageName))\n+\t\tPackageName pageClassPackageName = PackageName.forClass(pageClass);\n+\t\tif (pageClassPackageName.equals(packageName))\n \t\t{\n \t\t\tUrl url = new Url();\n-\t\t\turl.getSegments().add(pageClass.getSimpleName());\n+\n+\t\t\tString fullyQualifiedClassName = pageClass.getName();\n+\t\t\tString packageRelativeClassName = fullyQualifiedClassName;\n+\t\t\tint packageNameLength = packageName.getName().length();\n+\t\t\tif (packageNameLength > 0)\n+\t\t\t{\n+\t\t\t\tpackageRelativeClassName = fullyQualifiedClassName.substring(packageNameLength + 1);\n+\t\t\t}\n+\t\t\turl.getSegments().add(packageRelativeClassName);\n \t\t\tencodePageComponentInfo(url, info.getPageComponentInfo());\n \t\t\treturn encodePageParameters(url, info.getPageParameters(), pageParametersEncoder);\n \t\t}\n", "nb_test": 1203, "linesAdd": 12, "jira_id": "3838", "singleLine": false, "nb_skipped": 2, "commit": "97514205", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["decryptHomePageWithNonEncryptedQueryParameters(org.apache.wicket.request.mapper.CryptoMapperTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\nindex 417e9d0..a53ce24 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\n@@ -152,7 +152,7 @@ private Url encryptUrl(final Url url)\n \r\n \tprivate Url decryptUrl(final Request request, final Url encryptedUrl)\r\n \t{\r\n-\t\tif (encryptedUrl.getSegments().isEmpty() && encryptedUrl.getQueryParameters().isEmpty())\r\n+\t\tif (encryptedUrl.getSegments().isEmpty())\r\n \t\t{\r\n \t\t\treturn encryptedUrl;\r\n \t\t}\r\n", "nb_test": 1291, "linesAdd": 1, "jira_id": "4345", "singleLine": false, "nb_skipped": 4, "commit": "4f08e6f2", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["urlResourceReference(org.apache.wicket.core.request.mapper.CryptoMapperTest): Cannot render this url in FULL mode because it does not have a host set."], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\nindex 58e704e..91708a3 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n@@ -43,7 +43,6 @@\n  * deemed a plain text sibling of the corresponding segment in the encrypted URL, and all subsequent\r\n  * segments are considered plain text children of the current segment.\r\n  * \r\n- *\r\n  * @author igor.vaynberg\r\n  * @author Jesse Long\r\n  * @author svenmeier\r\n@@ -98,6 +97,12 @@ public Url mapHandler(final IRequestHandler requestHandler)\n \t\t\treturn null;\r\n \t\t}\r\n \r\n+\t\tif (url.isFull())\r\n+\t\t{\r\n+\t\t\t// do not encrypt full urls\r\n+\t\t\treturn url;\r\n+\t\t}\r\n+\r\n \t\treturn encryptUrl(url);\r\n \t}\r\n \r\n@@ -163,8 +168,8 @@ protected Url encryptUrl(final Url url)\n \tprotected Url decryptUrl(final Request request, final Url encryptedUrl)\r\n \t{\r\n \t\t/*\r\n-\t\t * If the encrypted URL has no segments it is the home page URL,\r\n-\t\t * and does not need decrypting.\r\n+\t\t * If the encrypted URL has no segments it is the home page URL, and does not need\r\n+\t\t * decrypting.\r\n \t\t */\r\n \t\tif (encryptedUrl.getSegments().isEmpty())\r\n \t\t{\r\n@@ -177,8 +182,8 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\ttry\r\n \t\t{\r\n \t\t\t/*\r\n-\t\t\t * The first encrypted segment contains an encrypted version of the\r\n-\t\t\t * entire plain text url.\r\n+\t\t\t * The first encrypted segment contains an encrypted version of the entire plain text\r\n+\t\t\t * url.\r\n \t\t\t */\r\n \t\t\tString encryptedUrlString = encryptedSegments.get(0);\r\n \t\t\tif (Strings.isEmpty(encryptedUrlString))\r\n@@ -210,17 +215,16 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\t\tif (!next.equals(encryptedSegment))\r\n \t\t\t\t{\r\n \t\t\t\t\t/*\r\n-\t\t\t\t\t * This segment received from the browser is not the same as the\r\n-\t\t\t\t\t * expected segment generated by the HashSegmentGenerator. Hence it,\r\n-\t\t\t\t\t * and all subsequent segments are considered plain text siblings of the\r\n-\t\t\t\t\t * original encrypted url.\r\n+\t\t\t\t\t * This segment received from the browser is not the same as the expected\r\n+\t\t\t\t\t * segment generated by the HashSegmentGenerator. Hence it, and all subsequent\r\n+\t\t\t\t\t * segments are considered plain text siblings of the original encrypted url.\r\n \t\t\t\t\t */\r\n \t\t\t\t\tbreak;\r\n \t\t\t\t}\r\n \r\n \t\t\t\t/*\r\n-\t\t\t\t * This segments matches the expected checksum, so we add the corresponding\r\n-\t\t\t\t * segment from the original URL.\r\n+\t\t\t\t * This segments matches the expected checksum, so we add the corresponding segment\r\n+\t\t\t\t * from the original URL.\r\n \t\t\t\t */\r\n \t\t\t\turl.getSegments().add(originalUrl.getSegments().get(segNo - 1));\r\n \t\t\t}\r\n", "nb_test": 1510, "linesAdd": 5, "jira_id": "5319", "singleLine": false, "nb_skipped": 2, "commit": "c863b032", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["seeOtherShouldSetLocationHeader(org.apache.wicket.request.http.handler.RedirectRequestHandlerTest): Status must be either 301 or 302, but was: 303"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/http/handler/RedirectRequestHandler.java b/wicket-request/src/main/java/org/apache/wicket/request/http/handler/RedirectRequestHandler.java\nindex e21856f..13c99fa 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/http/handler/RedirectRequestHandler.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/http/handler/RedirectRequestHandler.java\n@@ -59,9 +59,10 @@ public RedirectRequestHandler(final String redirectUrl)\n \tpublic RedirectRequestHandler(final String redirectUrl, final int status)\n \t{\n \t\tif ((status != HttpServletResponse.SC_MOVED_PERMANENTLY) &&\n-\t\t\t(status != HttpServletResponse.SC_MOVED_TEMPORARILY))\n+\t\t\t(status != HttpServletResponse.SC_MOVED_TEMPORARILY) &&\n+\t\t\t(status != HttpServletResponse.SC_SEE_OTHER))\n \t\t{\n-\t\t\tthrow new IllegalStateException(\"Status must be either 301 or 302, but was: \" + status);\n+\t\t\tthrow new IllegalStateException(\"Status must be either 301, 302 or 303, but was: \" + status);\n \t\t}\n \t\tthis.redirectUrl = redirectUrl;\n \t\tthis.status = status;\n@@ -93,17 +94,19 @@ public void respond(final IRequestCycle requestCycle)\n \t{\n \t\tfinal String location;\n \n-\t\tif (redirectUrl.startsWith(\"/\"))\n+\t\tfinal String url = getRedirectUrl();\n+\n+\t\tif (url.charAt(0) == '/')\n \t\t{\n \t\t\t// context-absolute url\n-\t\t\tlocation = requestCycle.getUrlRenderer().renderContextRelativeUrl(redirectUrl);\n+\t\t\tlocation = requestCycle.getUrlRenderer().renderContextRelativeUrl(url);\n \t\t}\n \t\telse\n \t\t{\n \t\t\t// if relative url, servlet container will translate to absolute as\n \t\t\t// per the servlet spec\n \t\t\t// if absolute url still do the same\n-\t\t\tlocation = redirectUrl;\n+\t\t\tlocation = url;\n \t\t}\n \n \t\tWebResponse response = (WebResponse)requestCycle.getResponse();\n@@ -114,7 +117,7 @@ public void respond(final IRequestCycle requestCycle)\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tresponse.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\n+\t\t\tresponse.setStatus(status);\n \t\t\tresponse.setHeader(\"Location\", location);\n \t\t}\n \t}\n", "nb_test": 93, "linesAdd": 9, "jira_id": "5131", "singleLine": false, "nb_skipped": 0, "commit": "4b7367ef", "nb_failure": 0, "linesRem": 6}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["isStateless(org.apache.wicket.ComponentTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 4470dbc..b616d1b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -2080,11 +2080,6 @@ public final boolean isRenderAllowed()\n \t */\n \tpublic final boolean isStateless()\n \t{\n-\t\tif (!getStatelessHint())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n \t\tif (\n \t\t\t// the component is either invisible or disabled\n \t\t\t(isVisibleInHierarchy() && isEnabledInHierarchy()) == false &&\n@@ -2097,6 +2092,11 @@ public final boolean isStateless()\n \t\t\treturn true;\n \t\t}\n \n+\t\tif (!getStatelessHint())\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n \t\tfor (Behavior behavior : getBehaviors())\n \t\t{\n \t\t\tif (!behavior.getStatelessHint(this))\n", "nb_test": 1368, "linesAdd": 5, "jira_id": "4578", "singleLine": false, "nb_skipped": 8, "commit": "c66cf607", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["loadMarkupWithBodyInsideHead(org.apache.wicket.markup.parser.filter.HtmlHeaderSectionHandlerTest): Unexpected exception, expected<org.apache.wicket.markup.MarkupException> but was<java.lang.StackOverflowError>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\nindex 5d7cd84..1b2ac8e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n@@ -21,6 +21,8 @@\n import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.markup.Markup;\n import org.apache.wicket.markup.MarkupElement;\n+import org.apache.wicket.markup.MarkupException;\n+import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.parser.AbstractMarkupFilter;\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n \n@@ -46,6 +48,9 @@\n \t/** True if <head> has been found already */\n \tprivate boolean foundHead = false;\n \n+\t/** True if </head> has been found already */\n+\tprivate boolean foundClosingHead = false;\n+\n \t/** True if all the rest of the markup file can be ignored */\n \tprivate boolean ignoreTheRest = false;\n \n@@ -78,16 +83,21 @@ protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseExcep\n \t\t\tif (tag.getNamespace() == null)\n \t\t\t{\n \t\t\t\t// we found <head>\n-\t\t\t\tif (tag.isClose())\n+\t\t\t\tif (tag.isOpen())\n \t\t\t\t{\n \t\t\t\t\tfoundHead = true;\n-\t\t\t\t}\n-\t\t\t\telse if (tag.getId() == null)\n+\n+\t\t\t\t\tif (tag.getId() == null)\n \t\t\t\t\t{\n \t\t\t\t\t\ttag.setId(HEADER_ID);\n \t\t\t\t\t\ttag.setAutoComponentTag(true);\n \t\t\t\t\t\ttag.setModified(true);\n \t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse if (tag.isClose())\n+\t\t\t\t{\n+\t\t\t\t\tfoundClosingHead = true;\n+\t\t\t\t}\n \n \t\t\t\treturn tag;\n \t\t\t}\n@@ -95,10 +105,18 @@ else if (tag.getId() == null)\n \t\t\t{\n \t\t\t\t// we found <wicket:head>\n \t\t\t\tfoundHead = true;\n+\t\t\t\tfoundClosingHead = true;\n \t\t\t}\n \t\t}\n \t\telse if (BODY.equalsIgnoreCase(tag.getName()) && (tag.getNamespace() == null))\n \t\t{\n+\t\t\t// WICKET-4511: We found <body> inside <head> tag. Markup is not valid!\n+\t\t\tif (foundHead && !foundClosingHead)\n+\t\t\t{\n+\t\t\t\tthrow new MarkupException(new MarkupStream(markup),\n+\t\t\t\t\t\"Invalid page markup. Tag <BODY> found inside <HEAD>\");\n+\t\t\t}\n+\n \t\t\t// We found <body>\n \t\t\tif (foundHead == false)\n \t\t\t{\n", "nb_test": 1333, "linesAdd": 19, "jira_id": "4511", "singleLine": false, "nb_skipped": 8, "commit": "4ee5ad1f", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testComments(org.apache.wicket.markup.MarkupParserTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/AbstractMarkupParser.java b/wicket/src/main/java/org/apache/wicket/markup/AbstractMarkupParser.java\nindex de976e7..51c46e6 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/AbstractMarkupParser.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/AbstractMarkupParser.java\n@@ -30,7 +30,6 @@\n import org.apache.wicket.settings.IMarkupSettings;\n import org.apache.wicket.util.resource.ResourceStreamNotFoundException;\n import org.apache.wicket.util.resource.StringResourceStream;\n-import org.apache.wicket.util.string.AppendingStringBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -404,9 +403,9 @@ private String removeComment(String rawMarkup)\n \t\tint pos1 = rawMarkup.indexOf(\"<!--\");\n \t\twhile (pos1 != -1)\n \t\t{\n-\t\t\tfinal int pos2 = rawMarkup.indexOf(\"-->\", pos1 + 4);\n+\t\t\tint pos2 = rawMarkup.indexOf(\"-->\", pos1 + 4);\n \n-\t\t\tfinal AppendingStringBuffer buf = new AppendingStringBuffer(rawMarkup.length());\n+\t\t\tfinal StringBuilder buf = new StringBuilder(rawMarkup.length());\n \t\t\tif (pos2 != -1)\n \t\t\t{\n \t\t\t\tfinal String comment = rawMarkup.substring(pos1 + 4, pos2);\n@@ -424,8 +423,12 @@ private String removeComment(String rawMarkup)\n \t\t\t\t\t}\n \t\t\t\t\trawMarkup = buf.toString();\n \t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tpos1 = pos2;\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tpos1 = rawMarkup.length() <= pos1 + 2 ? -1 : rawMarkup.indexOf(\"<!--\", pos1 + 4);\n+\t\t\tpos1 = rawMarkup.indexOf(\"<!--\", pos1);\n \t\t}\n \t\treturn rawMarkup;\n \t}\n", "nb_test": 1023, "linesAdd": 7, "jira_id": "3222", "singleLine": false, "nb_skipped": 0, "commit": "5729ed90", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ignorePageFoundByIdIfItsClassMatchButPageParametersDont(org.apache.wicket.request.handler.PageProviderTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\nindex 50402f6..6068e35 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n@@ -296,7 +296,10 @@ private IRequestablePage getStoredPage(final int pageId)\n \t\tIRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\n \t\tif (storedPageInstance != null)\n \t\t{\n-\t\t\tif (pageClass == null || pageClass.equals(storedPageInstance.getClass()))\n+\t\t\tif (\n+\t\t\t\t(pageClass == null || pageClass.equals(storedPageInstance.getClass())) &&\n+\t\t\t\t(isPageParametersEmpty(pageParameters) || arePageParametersSame(storedPageInstance))\n+\t\t\t)\n \t\t\t{\n \t\t\t\tpageInstance = storedPageInstance;\n \t\t\t\tpageInstanceIsFresh = false;\n@@ -413,4 +416,23 @@ public final boolean isPageInstanceFresh()\n \t\t}\n \t\treturn pageInstanceIsFresh;\n \t}\n+\n+\t/**\n+\t * A helper method that compares the requested PageParameters with the ones in the stored\n+\t * page instance. {@code null} and empty PageParameters are considered equal.\n+\t *\n+\t * @param storedPageInstance\n+\t *      the page instance with the original page parameters\n+\t * @return {@code true} if the indexed and named parameters are equal, {@code false} - otherwise\n+\t */\n+\tprivate boolean arePageParametersSame(IRequestablePage storedPageInstance) {\n+\t\tPageParameters currentCopy = new PageParameters(pageParameters);\n+\t\tPageParameters storedCopy = new PageParameters(storedPageInstance.getPageParameters());\n+\t\treturn currentCopy.equals(storedCopy);\n+\t}\n+\n+\tprivate boolean isPageParametersEmpty(PageParameters parameters)\n+\t{\n+\t\treturn parameters == null || parameters.isEmpty();\n+\t}\n }\n", "nb_test": 1328, "linesAdd": 15, "jira_id": "4441", "singleLine": false, "nb_skipped": 8, "commit": "54c86ebb", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["redirectToAbsoluteUrlTest(org.apache.wicket.util.tester.WicketTesterTest): expected:<302> but was:<200>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\nindex 01581ef..af09060 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\n@@ -604,6 +604,7 @@ private String getURL()\n \tpublic void sendRedirect(String location) throws IOException\n \t{\n \t\tredirectLocation = location;\n+\t\tstatus = HttpServletResponse.SC_FOUND;\n \t}\n \n \t/**\n", "nb_test": 1374, "linesAdd": 1, "jira_id": "4610", "singleLine": true, "nb_skipped": 5, "commit": "b19a3d69", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["parseAttributeName(org.apache.wicket.util.parse.metapattern.parsers.VariableAssignmentParserTest): expected:<namespace:name[:subname]> but was:<namespace:name[]>"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/parse/metapattern/parsers/VariableAssignmentParser.java b/wicket-util/src/main/java/org/apache/wicket/util/parse/metapattern/parsers/VariableAssignmentParser.java\nindex dc49c17..ee4f443 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/parse/metapattern/parsers/VariableAssignmentParser.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/parse/metapattern/parsers/VariableAssignmentParser.java\n@@ -29,11 +29,11 @@\n  */\n public final class VariableAssignmentParser extends MetaPatternParser\n {\n-\t/** The optional namespace like \"namespace:*\" */\n+\t/** The optional namespace like \"namespace:*[:*]\" */\n \tprivate static final MetaPattern namespace = new OptionalMetaPattern(new MetaPattern[] {\n-\t\t\tMetaPattern.VARIABLE_NAME, MetaPattern.COLON });\n+\t\t\tMetaPattern.VARIABLE_NAME, MetaPattern.COLON, new OptionalMetaPattern(new MetaPattern[] {MetaPattern.VARIABLE_NAME, MetaPattern.COLON })});\n \n-\t/** The key (lvalue) like \"name\" or \"namespace:name\" */\n+\t/** The key (lvalue) like \"name\" or \"namespace:name\" or \"namespace:name:subname\" */\n \tprivate final Group key = new Group(new MetaPattern(namespace, MetaPattern.XML_ATTRIBUTE_NAME));\n \n \t/** The rvalue of the assignment */\n", "nb_test": 162, "linesAdd": 1, "jira_id": "4679", "singleLine": false, "nb_skipped": 0, "commit": "f3ec1503", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["WicketTesterLazyIsPageStatelessRedirectToBufferTest.statelessListenerInterfaceInvoked:65 page was null"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 9a72a11..c1d1826 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -4544,6 +4544,7 @@ public Component add(final Behavior... behaviors)\n \t@Override\n \tpublic boolean canCallListenerInterfaceAfterExpiry()\n \t{\n-\t\treturn getApplication().getPageSettings().getCallListenerInterfaceAfterExpiry();\n+        \treturn getApplication().getPageSettings()\n+        \t\t.getCallListenerInterfaceAfterExpiry() || isStateless();\n \t}\n }\n", "nb_test": 1659, "linesAdd": 2, "jira_id": "5578", "singleLine": false, "nb_skipped": 2, "commit": "5cdc1c8d", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["getClientUrlAjaxWithoutBaseUrl(org.apache.wicket.protocol.http.servlet.ServletWebRequestTest): Current ajax request is missing the base url header or parameter"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\nindex 02ffe67..8e41aef 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\n@@ -30,6 +30,7 @@\n import javax.servlet.ServletRequest;\n import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n \n import org.apache.wicket.protocol.http.RequestUtils;\n import org.apache.wicket.request.IRequestParameters;\n@@ -37,9 +38,9 @@\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.UrlUtils;\n import org.apache.wicket.request.http.WebRequest;\n+import org.apache.wicket.request.http.flow.AbortWithHttpErrorCodeException;\n import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Bytes;\n-import org.apache.wicket.util.lang.Checks;\n import org.apache.wicket.util.string.PrependingStringBuffer;\n import org.apache.wicket.util.string.StringValue;\n import org.apache.wicket.util.string.Strings;\n@@ -168,7 +169,11 @@ else if (!isAjax())\n \t\t\t\tbase = getRequestParameters().getParameterValue(PARAM_AJAX_BASE_URL).toString(null);\n \t\t\t}\n \n-\t\t\tChecks.notNull(base, \"Current ajax request is missing the base url header or parameter\");\n+\t\t\tif (base == null)\n+\t\t\t{\n+\t\t\t\tthrow new AbortWithHttpErrorCodeException(HttpServletResponse.SC_BAD_REQUEST,\n+\t\t\t\t\t\"Current ajax request is missing the base url header or parameter\");\n+\t\t\t}\n \n \t\t\treturn setParameters(Url.parse(base, getCharset()));\n \t\t}\n", "nb_test": 1426, "linesAdd": 7, "jira_id": "4841", "singleLine": false, "nb_skipped": 5, "commit": "ce172da8", "nb_failure": 0, "linesRem": 2}, {"files": 0, "project": "wicket", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testNonBookmarkablePage(org.apache.wicket.devutils.stateless.StatelessCheckerTest)", "testPositive(org.apache.wicket.devutils.stateless.StatelessCheckerTest)"], "patch": "", "nb_test": 2, "linesAdd": 0, "jira_id": "2334", "singleLine": false, "nb_skipped": 0, "commit": "96330447", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["DequeueingTransparentWebMarkupContainerTest.queuedComponentsInsideTransparentContainer:57 \u00bb WicketRuntime"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\nindex 49d55c3..882a3ba 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n@@ -16,12 +16,17 @@\n  */\n package org.apache.wicket.markup.html.internal;\n \n+import java.util.Iterator;\n+\n import org.apache.wicket.Component;\n+import org.apache.wicket.DequeueContext;\n import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.markup.ComponentTag;\n+import org.apache.wicket.markup.IMarkupFragment;\n import org.apache.wicket.markup.MarkupException;\n import org.apache.wicket.markup.MarkupStream;\n+import org.apache.wicket.markup.html.TransparentWebMarkupContainer;\n import org.apache.wicket.markup.html.WebMarkupContainer;\n import org.apache.wicket.markup.html.basic.EnclosureContainer;\n import org.apache.wicket.markup.parser.filter.EnclosureHandler;\n@@ -125,7 +130,7 @@ protected final Component getChild()\n \t\tif (childComponent == null)\n \t\t{\n \t\t\t// try to find child when queued\n-\t\t\tchildComponent = get(childId);\n+\t\t\tchildComponent = resolveChild(this);\n \t\t}\n \t\tif (childComponent == null)\n \t\t{\n@@ -135,6 +140,33 @@ protected final Component getChild()\n \t\treturn childComponent;\n \t}\n \t\n+\t/**\n+\t * Searches for the controlling child component looking also \n+\t * through transparent components.\n+\t * \n+\t * @param container\n+\t * \t\t\tthe current container\n+\t * @return the controlling child component, null if no one is found \n+\t */\n+\tprivate Component resolveChild(MarkupContainer container)\n+\t{\n+\t\tComponent childController = container.get(childId);\n+\t\t\n+\t\tIterator<Component> children = container.iterator();\n+\t\t\n+\t\twhile (children.hasNext() && childController == null)\n+\t\t{\n+\t\t\tComponent transparentChild = children.next();\n+\t\t\t\n+\t\t\tif(transparentChild instanceof TransparentWebMarkupContainer)\n+\t\t\t{\n+\t\t\t\tchildController = resolveChild((MarkupContainer)transparentChild);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn childController;\n+\t}\n+\n \t@Override\n \tpublic boolean isVisible()\n \t{\n@@ -274,4 +306,16 @@ else if (controller == this)\n \t\t\t\t\"Programming error: childComponent == enclose component; endless loop\");\n \t\t}\n \t}\n+\t\n+\t@Override\n+\tpublic DequeueContext newDequeueContext()\n+\t{\n+\t\tIMarkupFragment markup = getMarkupSourcingStrategy().getMarkup(this, null);\n+\t\tif (markup == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new DequeueContext(markup, this, true);\n+\t}\n }\n", "nb_test": 1859, "linesAdd": 37, "jira_id": "5964", "singleLine": false, "nb_skipped": 1, "commit": "86066852", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testParse15(org.apache.wicket.request.UrlTest): For input string: \"56704;jsessionid=8kxeo3reannw1qjtxgkju8yiu\""], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 9fb454c..191ebbe 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -232,8 +232,11 @@ public static Url parse(CharSequence _url, Charset charset)\n \t\t\tfinal String afterProto = absoluteUrl.substring(protocolAt + 3);\n \t\t\tfinal String hostAndPort;\n \n-\t\t\tfinal int relativeAt = afterProto.indexOf('/');\n-\n+\t\t\tint relativeAt = afterProto.indexOf('/');\n+\t\t\tif (relativeAt == -1)\n+\t\t\t{\n+\t\t\t\trelativeAt = afterProto.indexOf(';');\n+\t\t\t}\n \t\t\tif (relativeAt == -1)\n \t\t\t{\n \t\t\t\trelativeUrl = \"\";\n", "nb_test": 89, "linesAdd": 5, "jira_id": "4877", "singleLine": false, "nb_skipped": 0, "commit": "6470c3f7", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["nestedInvalidFormComponent(org.apache.wicket.ajax.form.AjaxFormChoiceComponentUpdatingBehaviorTest): expected:<true> but was:<null>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/form/AjaxFormComponentUpdatingBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/form/AjaxFormComponentUpdatingBehavior.java\nindex c5b15ec..2d6cf0e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/form/AjaxFormComponentUpdatingBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/form/AjaxFormComponentUpdatingBehavior.java\n@@ -46,7 +46,8 @@\n  */\n public abstract class AjaxFormComponentUpdatingBehavior extends AjaxEventBehavior\n {\n-\tprivate static final Logger log = LoggerFactory.getLogger(AjaxFormComponentUpdatingBehavior.class);\n+\tprivate static final Logger log = LoggerFactory\n+\t\t.getLogger(AjaxFormComponentUpdatingBehavior.class);\n \n \t/**\n \t * \n@@ -76,8 +77,8 @@ protected void onBind()\n \t\tComponent component = getComponent();\n \t\tif (!(component instanceof FormComponent))\n \t\t{\n-\t\t\tthrow new WicketRuntimeException(\"Behavior \" + getClass().getName() +\n-\t\t\t\t\" can only be added to an instance of a FormComponent\");\n+\t\t\tthrow new WicketRuntimeException(\"Behavior \" + getClass().getName()\n+\t\t\t\t+ \" can only be added to an instance of a FormComponent\");\n \t\t}\n \n \t\tcheckComponent((FormComponent<?>)component);\n@@ -94,10 +95,11 @@ protected void onBind()\n \t */\n \tprotected void checkComponent(FormComponent<?> component)\n \t{\n-\t\tif (Application.get().usesDevelopmentConfig() &&\n-\t\t\tAjaxFormChoiceComponentUpdatingBehavior.appliesTo(component))\n+\t\tif (Application.get().usesDevelopmentConfig()\n+\t\t\t&& AjaxFormChoiceComponentUpdatingBehavior.appliesTo(component))\n \t\t{\n-\t\t\tlog.warn(String.format(\n+\t\t\tlog.warn(String\n+\t\t\t\t.format(\n \t\t\t\t\t\"AjaxFormComponentUpdatingBehavior is not supposed to be added in the form component at path: \\\"%s\\\". \"\n \t\t\t\t\t\t+ \"Use the AjaxFormChoiceComponentUpdatingBehavior instead, that is meant for choices/groups that are not one component in the html but many\",\n \t\t\t\t\tcomponent.getPageRelativePath()));\n@@ -139,13 +141,7 @@ protected final void onEvent(final AjaxRequestTarget target)\n \t\t{\n \t\t\tformComponent.inputChanged();\n \t\t\tformComponent.validate();\n-\t\t\tif (formComponent.hasErrorMessage())\n-\t\t\t{\n-\t\t\t\tformComponent.invalid();\n-\n-\t\t\t\tonError(target, null);\n-\t\t\t}\n-\t\t\telse\n+\t\t\tif (formComponent.isValid())\n \t\t\t{\n \t\t\t\tformComponent.valid();\n \t\t\t\tif (getUpdateModel())\n@@ -155,6 +151,12 @@ protected final void onEvent(final AjaxRequestTarget target)\n \n \t\t\t\tonUpdate(target);\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tformComponent.invalid();\n+\n+\t\t\t\tonError(target, null);\n+\t\t\t}\n \t\t}\n \t\tcatch (RuntimeException e)\n \t\t{\n", "nb_test": 1481, "linesAdd": 15, "jira_id": "5230", "singleLine": false, "nb_skipped": 4, "commit": "9c8f658a", "nb_failure": 1, "linesRem": 13}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["modelChange(org.apache.wicket.ComponentTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex fb56254..342f107 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -2985,15 +2985,11 @@ public Component setDefaultModel(final IModel<?> model)\n \t\t// Change model\n \t\tif (wrappedModel != model)\n \t\t{\n-\t\t\tif (wrappedModel != null)\n-\t\t\t{\n-\t\t\t\taddStateChange();\n-\t\t\t}\n-\n+\t\t\tmodelChanging();\n \t\t\tsetModelImpl(wrap(model));\n+\t\t\tmodelChanged();\n \t\t}\n \n-\t\tmodelChanged();\n \t\treturn this;\n \t}\n \n", "nb_test": 1323, "linesAdd": 2, "jira_id": "4483", "singleLine": false, "nb_skipped": 8, "commit": "53442bb4", "nb_failure": 1, "linesRem": 6}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["afterRenderJustOnce(org.apache.wicket.MarkupContainerTest): expected:<1> but was:<4>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 33c515d..13b32cb 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -941,6 +941,11 @@ public final void afterRender()\n \t\ttry\n \t\t{\n \t\t\tsetFlag(FLAG_AFTER_RENDERING, true);\n+\n+\t\t\t// always detach children because components can be attached\n+\t\t\t// independently of their parents\n+\t\t\tonAfterRenderChildren();\n+\n \t\t\tonAfterRender();\n \t\t\tgetApplication().getComponentOnAfterRenderListeners().onAfterRender(this);\n \t\t\tif (getFlag(FLAG_AFTER_RENDERING))\n@@ -950,9 +955,6 @@ public final void afterRender()\n \t\t\t\t\tgetClass().getName() +\n \t\t\t\t\t\" has not called super.onAfterRender() in the override of onAfterRender() method\");\n \t\t\t}\n-\t\t\t// always detach children because components can be attached\n-\t\t\t// independently of their parents\n-\t\t\tonAfterRenderChildren();\n \t\t}\n \t\tfinally\n \t\t{\n@@ -2852,10 +2854,7 @@ final void setMarkupId(Component comp)\n \t */\n \tpublic Component setMarkupId(String markupId)\n \t{\n-\t\tif (markupId != null && Strings.isEmpty(markupId))\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"Markup id cannot be an empty string\");\n-\t\t}\n+\t\tArgs.notEmpty(markupId, \"markupId\");\n \n \t\t// TODO check if an automatic id has already been generated or getmarkupid() called\n \t\t// previously and throw an illegalstateexception because something else might be depending\n@@ -4112,6 +4111,10 @@ void internalMarkRendering(boolean setRenderingFlag)\n \t\t\tsetFlag(FLAG_PREPARED_FOR_RENDER, false);\n \t\t\tsetFlag(FLAG_RENDERING, true);\n \t\t}\n+\t\telse\n+\t\t{\n+\t\t\tsetFlag(FLAG_RENDERING, false);\n+\t\t}\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 37986ff..056d483 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -1835,13 +1835,11 @@ public void component(Component component, IVisit<Void> visit)\n \t@Override\n \tprotected void onAfterRenderChildren()\n \t{\n-\t\t// Loop through child components\n \t\tfor (Component child : this)\n \t\t{\n-\t\t\t// Call end request on the child\n-\t\t\tchild.afterRender();\n+\t\t\t// set RENDERING_FLAG to false for auto-component's children (like Enclosure)\n+\t\t\tchild.markRendering(false);\n \t\t}\n-\n \t\tsuper.onAfterRenderChildren();\n \t}\n \n", "nb_test": 1133, "linesAdd": 9, "jira_id": "4012", "singleLine": false, "nb_skipped": 2, "commit": "d35d2d85", "nb_failure": 1, "linesRem": 7}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["visitObject(org.apache.wicket.util.visit.ClassVisitFilterTest)"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/visit/ClassVisitFilter.java b/wicket-util/src/main/java/org/apache/wicket/util/visit/ClassVisitFilter.java\nindex c94e069..0a7d0b1 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/visit/ClassVisitFilter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/visit/ClassVisitFilter.java\n@@ -45,6 +45,6 @@ public boolean visitChildren(final Object object)\n \t/** {@inheritDoc} */\r\n \tpublic boolean visitObject(final Object object)\r\n \t{\r\n-\t\treturn clazz.isAssignableFrom(object.getClass());\r\n+\t\treturn clazz == null || clazz.isAssignableFrom(object.getClass());\r\n \t}\r\n }\r\n", "nb_test": 154, "linesAdd": 1, "jira_id": "4519", "singleLine": false, "nb_skipped": 0, "commit": "e62ded51", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["resolveRelative1(org.apache.wicket.request.UrlTest): expected:<c/a/b[?]p1=v1> but was:<c/a/b[]p1=v1>", "resolveRelative2(org.apache.wicket.request.UrlTest): expected:<c/a/b[?]p1=v1> but was:<c/a/b[]p1=v1>", "resolveRelative3(org.apache.wicket.request.UrlTest): expected:<a/b[?]p1=v1> but was:<a/b[]p1=v1>", "resolveRelative4(org.apache.wicket.request.UrlTest): expected:<[?]p1=v1> but was:<[]p1=v1>", "resolveRelative_EmptyTrailingSegmentInBase(org.apache.wicket.request.UrlTest): expected:<Home/[?]0-1.ILinkListener-li...> but was:<Home/[]0-1.ILinkListener-li...>", "resolveRelative_EmptyTrailingSegmentInBase2(org.apache.wicket.request.UrlTest): expected:<Home/foo/[?]0-1.ILinkListener-li...> but was:<Home/foo/[]0-1.ILinkListener-li...>", "resolveRelative_NoSegmentsInBase(org.apache.wicket.request.UrlTest): expected:<[?]a=b> but was:<[]a=b>", "resolveRelative_NoSegmentsInBase2(org.apache.wicket.request.UrlTest): expected:<bar/baz[?]a=b> but was:<bar/baz[]a=b>", "resolveRelative_DotFollowedByEmptySegment1(org.apache.wicket.request.UrlTest): expected:<[?]a=b> but was:<[]a=b>", "resolveRelative_DotFollowedByEmptySegment2(org.apache.wicket.request.UrlTest): expected:<bar/[?]a=b> but was:<bar/[]a=b>", "parseAbsoluteUrl(org.apache.wicket.request.UrlTest): expected:<ftp://myhost:8081/[]> but was:<ftp://myhost:8081/[null]>", "render1(org.apache.wicket.request.UrlTest): expected:<foo/b=r/b&z/x%3F[?]a=b&x%3F%264=y%3Dz> but was:<foo/b=r/b&z/x%3F[]a=b&x%3F%264=y%3Dz>", "render2(org.apache.wicket.request.UrlTest): expected:</absolute/url[null]> but was:</absolute/url[]>", "render3(org.apache.wicket.request.UrlTest): expected:<//absolute/url[null]> but was:<//absolute/url[]>", "render4(org.apache.wicket.request.UrlTest): expected:</[null]> but was:</[]>", "render5(org.apache.wicket.request.UrlTest): expected:</foo/bar[?]baz=ban> but was:</foo/bar[]baz=ban>", "parseHttpSlashSlashColon(org.apache.wicket.request.UrlTest): expected:<...bc/http://host:9090/[]> but was:<...bc/http://host:9090/[null]>", "prependLeadingSegments1(org.apache.wicket.request.UrlTest): expected:<x/y/a[]> but was:<x/y/a[null]>", "prependLeadingSegments2(org.apache.wicket.request.UrlTest): expected:<x/a[]> but was:<x/a[null]>", "prependLeadingSegments3(org.apache.wicket.request.UrlTest): expected:<a[]> but was:<a[null]>", "prependLeadingSegments4(org.apache.wicket.request.UrlTest): expected:<x[]> but was:<x[null]>", "removeLeadingSegments1(org.apache.wicket.request.UrlTest): expected:<b[]> but was:<b[null]>", "removeLeadingSegments2(org.apache.wicket.request.UrlTest): expected:<[]> but was:<[null]>", "wicket_5114_allowtoStringFullWhenContainingTwoDots(org.apache.wicket.request.UrlTest): expected:<...ntPoint/whatever.../[]> but was:<...ntPoint/whatever.../[null]>", "encodeNamedParameters(org.apache.wicket.request.mapper.parameter.UrlPathPageParametersEncoderTest): expected:<.../value1/name2/value2[]> but was:<.../value1/name2/value2[null]>", "encodeNamedParametersWithSpecialChars(org.apache.wicket.request.mapper.parameter.UrlPathPageParametersEncoderTest): expected:<...name%E3%84%98/value2[]> but was:<...name%E3%84%98/value2[null]>"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex c9ddc69..2e24b5c 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -714,7 +714,12 @@ else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)\n \n \n \t\tresult.append(path);\n-\t\tresult.append(getQueryString(charset));\n+        \n+        final String queryString = getQueryString(charset);\n+        if (queryString != null)\n+        {\n+            result.append('?').append(queryString);\n+        }\n \t\treturn result.toString();\n \t}\n \n", "nb_test": 96, "linesAdd": 6, "jira_id": "4664", "singleLine": false, "nb_skipped": 0, "commit": "2fcb3417", "nb_failure": 26, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDifferentDateTimeZoneConversion(org.apache.wicket.extensions.yui.calendar.DatePickerTest)"], "patch": "diff --git a/wicket-datetime/src/main/java/org/apache/wicket/datetime/markup/html/form/DateTextField.java b/wicket-datetime/src/main/java/org/apache/wicket/datetime/markup/html/form/DateTextField.java\nindex 718e7a3..ba144cf 100644\n--- a/wicket-datetime/src/main/java/org/apache/wicket/datetime/markup/html/form/DateTextField.java\n+++ b/wicket-datetime/src/main/java/org/apache/wicket/datetime/markup/html/form/DateTextField.java\n@@ -132,7 +132,7 @@ public static DateTextField forDateStyle(String id, String dateStyle)\n \t */\n \tpublic static DateTextField forShortStyle(String id)\n \t{\n-\t\treturn forShortStyle(id, null);\n+\t\treturn forShortStyle(id, null, true);\n \t}\n \n \t/**\n@@ -144,9 +144,10 @@ public static DateTextField forShortStyle(String id)\n \t *            The model\n \t * @return DateTextField\n \t */\n-\tpublic static DateTextField forShortStyle(String id, IModel<Date> model)\n+\tpublic static DateTextField forShortStyle(String id, IModel<Date> model,\n+\t\tboolean applyTimeZoneDifference)\n \t{\n-\t\treturn new DateTextField(id, model, new StyleDateConverter(true));\n+\t\treturn new DateTextField(id, model, new StyleDateConverter(applyTimeZoneDifference));\n \t}\n \n \t/**\ndiff --git a/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java b/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\nindex ebb04e4..25f0d5c 100644\n--- a/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\n+++ b/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\n@@ -377,7 +377,7 @@ protected void convertInput()\n \t */\n \tprotected DateTextField newDateTextField(String id, PropertyModel<Date> dateFieldModel)\n \t{\n-\t\treturn DateTextField.forShortStyle(id, dateFieldModel);\n+\t\treturn DateTextField.forShortStyle(id, dateFieldModel, false);\n \t}\n \n \t/**\n", "nb_test": 9, "linesAdd": 5, "jira_id": "3510", "singleLine": false, "nb_skipped": 0, "commit": "292a2582", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["ConnectionsTest.getLastModified:40->Assert.assertThat:923->Assert.assertThat:956", "Expected: is not null", "but: was null"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/io/Connections.java b/wicket-util/src/main/java/org/apache/wicket/util/io/Connections.java\nindex 5336af6..167cefd 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/io/Connections.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/io/Connections.java\n@@ -57,7 +57,6 @@ public static Time getLastModified(final URL url) throws IOException\n \r\n \t\t// otherwise open the url and proceed\r\n \t\tURLConnection connection = url.openConnection();\r\n-\t\tconnection.setDoInput(false);\r\n \r\n \t\tfinal long milliseconds;\r\n \r\n", "nb_test": 187, "linesAdd": 0, "jira_id": "5838", "singleLine": true, "nb_skipped": 2, "commit": "e93fdd5a", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 5, "classification": {"singleLine": false}, "failing_tests": ["testConditionalRenderCSSReferenceWithUrl(org.apache.wicket.markup.html.internal.HeaderResponseTest): url cannot be empty or null", "testDeferJavaScriptReference(org.apache.wicket.markup.html.internal.HeaderResponseTest): url cannot be empty or null", "testDeferFalseJavaScriptReference(org.apache.wicket.markup.html.internal.HeaderResponseTest): url cannot be empty or null", "testCharsetSetJavaScriptReference(org.apache.wicket.markup.html.internal.HeaderResponseTest): url cannot be empty or null", "testCharsetNotSetJavaScriptReference(org.apache.wicket.markup.html.internal.HeaderResponseTest): url cannot be empty or null"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HeaderResponse.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HeaderResponse.java\nindex dbde562..25e908a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HeaderResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HeaderResponse.java\n@@ -25,7 +25,6 @@\n import org.apache.wicket.markup.html.WicketEventReference;\n import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.Response;\n-import org.apache.wicket.request.Url;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.handler.resource.ResourceReferenceRequestHandler;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n@@ -378,22 +377,22 @@ public boolean isClosed()\n \t}\n \n \t/**\n+\t * Rewrites a relative url into a context-relative one, leaves absolute urls alone\n \t * \n-\t * @param location\n+\t * @param url\n \t * @return relative path\n \t */\n-\tprivate String relative(final String location)\n+\tprivate String relative(final String url)\n \t{\n-\t\tArgs.notEmpty(location, \"location\");\n+\t\tArgs.notEmpty(url, \"location\");\n \n-\t\tif (location.startsWith(\"http://\") || location.startsWith(\"https://\") ||\n-\t\t\tlocation.startsWith(\"/\"))\n+\t\tif (url.startsWith(\"http://\") || url.startsWith(\"https://\") || url.startsWith(\"/\"))\n \t\t{\n-\t\t\treturn location;\n+\t\t\treturn url;\n \t\t}\n \n \t\tRequestCycle rc = RequestCycle.get();\n-\t\treturn rc.getUrlRenderer().renderUrl(Url.parse(location, rc.getRequest().getCharset()));\n+\t\treturn rc.getUrlRenderer().renderContextRelativeUrl(url);\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/mock/MockWebRequest.java b/wicket-core/src/main/java/org/apache/wicket/mock/MockWebRequest.java\nindex 3b26621..c79b716 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/mock/MockWebRequest.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/mock/MockWebRequest.java\n@@ -47,7 +47,7 @@\n \tprivate Locale locale = Locale.getDefault();\n \tprivate String contextPath;\n \tprivate String filterPath;\n-\tprivate String prefixToContextPath;\n+\tprivate String prefixToContextPath = \"\";\n \n \t/**\n \t * Construct.\n", "nb_test": 1187, "linesAdd": 6, "jira_id": "4030", "singleLine": false, "nb_skipped": 2, "commit": "5f69685d", "nb_failure": 0, "linesRem": 8}, {"files": 5, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRendering(org.apache.wicket.markup.html.form.RadioGroupTest)", "testRadioGroupTestPage3(org.apache.wicket.markup.html.form.RadioGroupTest)", "testDisabledRadioGroup(org.apache.wicket.markup.html.form.RadioGroupTest)", "testRendering(org.apache.wicket.markup.html.form.CheckGroupTest)", "testDisabledCheckGroup(org.apache.wicket.markup.html.form.CheckGroupTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormChoiceComponentUpdatingBehavior.java b/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormChoiceComponentUpdatingBehavior.java\nindex ce38a7c..f8f2e50 100644\n--- a/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormChoiceComponentUpdatingBehavior.java\n+++ b/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormChoiceComponentUpdatingBehavior.java\n@@ -33,6 +33,9 @@\n  * <p>\n  * Use the normal {@link AjaxFormChoiceComponentUpdatingBehavior} for the normal single component\n  * fields\n+ * <p>\n+ * In order to be supported by this behavior the group components must output children with markup\n+ * id in format of 'groupId-childId'\n  * \n  * @author jcompagner\n  * \n@@ -67,6 +70,7 @@ public void renderHead(IHeaderResponse response)\n \t\tasb.append(\" for (var i = 0 ; i < inputNodes.length ; i ++) {\\n\");\n \t\tasb.append(\" var inputNode = inputNodes[i];\\n\");\n \t\tasb.append(\" if (!inputNode.type) continue;\\n\");\n+\t\tasb.append(\" if (!(inputNode.id.indexOf(markupId+'-')===0)) continue;\\n\");\n \t\tasb.append(\" var inputType = inputNode.type.toLowerCase();\\n\");\n \t\tasb.append(\" if (inputType == 'checkbox' || inputType == 'radio') {\\n\");\n \t\tasb.append(\" Wicket.Event.add(inputNode, 'click', callbackScript);\\n\");\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/Check.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/Check.java\nindex 7ebf5c3..c74b293 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/Check.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/Check.java\n@@ -94,6 +94,7 @@ public Check(String id, IModel<T> model, CheckGroup<T> group)\n \t{\n \t\tsuper(id, model);\n \t\tthis.group = group;\n+\t\tsetOutputMarkupId(true);\n \t}\n \n \n@@ -112,6 +113,32 @@ public final String getValue()\n \t\treturn \"check\" + uuid;\n \t}\n \n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate CheckGroup<T> getGroup()\n+\t{\n+\t\tCheckGroup<T> group = this.group;\n+\t\tif (group == null)\n+\t\t{\n+\t\t\tgroup = findParent(CheckGroup.class);\n+\t\t\tif (group == null)\n+\t\t\t{\n+\t\t\t\tthrow new WicketRuntimeException(\"Check component [\" + getPath() +\n+\t\t\t\t\t\"] cannot find its parent CheckGroup\");\n+\t\t\t}\n+\t\t}\n+\t\treturn group;\n+\t}\n+\n+\t/** {@inheritDoc} */\n+\t@Override\n+\tprotected void onBeforeRender()\n+\t{\n+\t\t// prefix markup id of this radio with its group's id\n+\t\t// this will make it easier to identify all radios that belong to a specific group\n+\t\tsetMarkupId(getGroup().getMarkupId() + \"-\" + getMarkupId());\n+\t\tsuper.onBeforeRender();\n+\t}\n+\n \n \t/**\n \t * @see Component#onComponentTag(ComponentTag)\n@@ -128,16 +155,7 @@ protected void onComponentTag(final ComponentTag tag)\n \t\tcheckComponentTag(tag, \"input\");\n \t\tcheckComponentTagAttribute(tag, \"type\", \"checkbox\");\n \n-\t\tCheckGroup<?> group = this.group;\n-\t\tif (group == null)\n-\t\t{\n-\t\t\tgroup = findParent(CheckGroup.class);\n-\t\t\tif (group == null)\n-\t\t\t{\n-\t\t\t\tthrow new WicketRuntimeException(\"Check component [\" + getPath() +\n-\t\t\t\t\t\"] cannot find its parent CheckGroup\");\n-\t\t\t}\n-\t\t}\n+\t\tCheckGroup<?> group = getGroup();\n \n \t\tfinal String uuid = getValue();\n \ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/CheckBoxMultipleChoice.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/CheckBoxMultipleChoice.java\nindex e52fe46..65dab2f 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/CheckBoxMultipleChoice.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/CheckBoxMultipleChoice.java\n@@ -411,7 +411,7 @@ else if (displayValue != null)\n \t\t\t\tbuffer.append(getPrefix());\n \n \t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n-\t\t\t\tfinal String idAttr = getInputName() + \"_\" + id;\n+\t\t\t\tfinal String idAttr = getMarkupId() + \"-\" + getInputName() + \"_\" + id;\n \n \t\t\t\t// Add checkbox element\n \t\t\t\tbuffer.append(\"<input name=\\\"\")\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/Radio.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/Radio.java\nindex 130c2d9..0788018 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/Radio.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/Radio.java\n@@ -91,6 +91,7 @@ public Radio(String id, IModel<T> model, RadioGroup<T> group)\n \t{\n \t\tsuper(id, model);\n \t\tthis.group = group;\n+\t\tsetOutputMarkupId(true);\n \t}\n \n \n@@ -109,6 +110,34 @@ public final String getValue()\n \t\treturn \"radio\" + uuid;\n \t}\n \n+\t/** {@inheritDoc} */\n+\t@Override\n+\tprotected void onBeforeRender()\n+\t{\n+\t\t// prefix markup id of this radio with its group's id\n+\t\t// this will make it easier to identify all radios that belong to a specific group\n+\t\tsetMarkupId(getGroup().getMarkupId() + \"-\" + getMarkupId());\n+\t\tsuper.onBeforeRender();\n+\t}\n+\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate RadioGroup<T> getGroup()\n+\t{\n+\t\tRadioGroup<T> group = this.group;\n+\t\tif (group == null)\n+\t\t{\n+\t\t\tgroup = findParent(RadioGroup.class);\n+\t\t\tif (group == null)\n+\t\t\t{\n+\t\t\t\tthrow new WicketRuntimeException(\n+\t\t\t\t\t\"Radio component [\" +\n+\t\t\t\t\t\tgetPath() +\n+\t\t\t\t\t\t\"] cannot find its parent RadioGroup. All Radio components must be a child of or below in the hierarchy of a RadioGroup component.\");\n+\t\t\t}\n+\t\t}\n+\t\treturn group;\n+\t}\n \n \t/**\n \t * @see Component#onComponentTag(ComponentTag)\n@@ -127,19 +156,7 @@ protected void onComponentTag(final ComponentTag tag)\n \n \t\tfinal String value = getValue();\n \n-\t\tRadioGroup<?> group = this.group;\n-\t\tif (group == null)\n-\t\t{\n-\t\t\tgroup = findParent(RadioGroup.class);\n-\t\t\tif (group == null)\n-\t\t\t{\n-\t\t\t\tthrow new WicketRuntimeException(\n-\t\t\t\t\t\"Radio component [\" +\n-\t\t\t\t\t\tgetPath() +\n-\t\t\t\t\t\t\"] cannot find its parent RadioGroup. All Radio components must be a child of or below in the hierarchy of a RadioGroup component.\");\n-\t\t\t}\n-\t\t}\n-\n+\t\tRadioGroup<?> group = getGroup();\n \n \t\t// assign name and value\n \t\ttag.put(\"name\", group.getInputName());\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/RadioChoice.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/RadioChoice.java\nindex 2b762e2..cf1d867 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/RadioChoice.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/RadioChoice.java\n@@ -450,7 +450,7 @@ else if (displayValue != null)\n \t\t\t\tbuffer.append(getPrefix());\n \n \t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n-\t\t\t\tfinal String idAttr = getMarkupId() + \"_\" + id;\n+\t\t\t\tfinal String idAttr = getMarkupId() + \"-\" + id;\n \n \t\t\t\tboolean enabled = isEnabledInHierarchy() && !isDisabled(choice, index, selected);\n \n", "nb_test": 763, "linesAdd": 55, "jira_id": "1677", "singleLine": false, "nb_skipped": 0, "commit": "01a3dd66", "nb_failure": 5, "linesRem": 25}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["noMinifiedResourceAvailable(org.apache.wicket.request.resource.MinifiedAwareResourceReferenceTest): expected:<1> but was:<2>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\nindex ea2ddb6..cc72731 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n@@ -173,7 +173,7 @@ private String getCurrentStyle()\n \tprivate String internalGetMinifiedName()\n \t{\n \t\tString minifiedName = MINIFIED_NAMES_CACHE.get(this);\n-\t\tif (minifiedName != null && minifiedName != NO_MINIFIED_NAME)\n+\t\tif (minifiedName != null)\n \t\t{\n \t\t\treturn minifiedName;\n \t\t}\n", "nb_test": 1452, "linesAdd": 1, "jira_id": "5019", "singleLine": false, "nb_skipped": 5, "commit": "917dd2b5", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["resolveRelative_EmptyTrailingSegmentInBase(org.apache.wicket.request.UrlTest): expected:<Home[/]?0-1.ILinkListener-l...> but was:<Home[]?0-1.ILinkListener-l...>", "resolveRelative_DotFollowedByEmptySegment2(org.apache.wicket.request.UrlTest): expected:<bar[/]?a=b> but was:<bar[]?a=b>"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 364b5d3..9fb454c 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -81,8 +81,7 @@\n \t * \n \t * @author igor\n \t */\n-\tpublic static enum StringMode \n-\t{\n+\tpublic static enum StringMode {\n \t\t/** local urls are rendered without the host name */\n \t\tLOCAL,\n \t\t/**\n@@ -123,13 +122,13 @@ public Url(final Url url)\n \t{\n \t\tArgs.notNull(url, \"url\");\n \n-\t\tthis.protocol = url.protocol;\n-\t\tthis.host = url.host;\n-\t\tthis.port = url.port;\n-\t\tthis.segments = new ArrayList<String>(url.segments);\n-\t\tthis.parameters = new ArrayList<QueryParameter>(url.parameters);\n-\t\tthis.charsetName = url.charsetName;\n-\t\tthis._charset = url._charset;\n+\t\tprotocol = url.protocol;\n+\t\thost = url.host;\n+\t\tport = url.port;\n+\t\tsegments = new ArrayList<String>(url.segments);\n+\t\tparameters = new ArrayList<QueryParameter>(url.parameters);\n+\t\tcharsetName = url.charsetName;\n+\t\t_charset = url._charset;\n \t}\n \n \t/**\n@@ -938,12 +937,12 @@ public void resolveRelative(final Url relative)\n \t{\n \t\tif (getSegments().size() > 0)\n \t\t{\n-\t\t\t// strip the first non-folder segment\n+\t\t\t// strip the first non-folder segment (if it is not empty)\n \t\t\tgetSegments().remove(getSegments().size() - 1);\n \t\t}\n \n-\t\t// remove leading './' (current folder) and empty segments, process any ../ segments from the\n-\t\t// relative url\n+\t\t// remove leading './' (current folder) and empty segments, process any ../ segments from\n+\t\t// the relative url\n \t\twhile (!relative.getSegments().isEmpty())\n \t\t{\n \t\t\tif (\".\".equals(relative.getSegments().get(0)))\n@@ -968,6 +967,11 @@ else if (\"..\".equals(relative.getSegments().get(0)))\n \t\t\t}\n \t\t}\n \n+\t\tif (!getSegments().isEmpty() && relative.getSegments().isEmpty())\n+\t\t{\n+\t\t\tgetSegments().add(\"\");\n+\t\t}\n+\n \t\t// append the remaining relative segments\n \t\tgetSegments().addAll(relative.getSegments());\n \n@@ -1107,32 +1111,37 @@ public String getQueryString()\n \n \n \t/**\n-\t * Try to reduce url by eliminating '..' and '.' from the path where appropriate\n-\t * (this is somehow similar to {@link java.io.File#getCanonicalPath()}).\n-\t * Either by different / unexpected browser behavior or by malicious attacks it \n-\t * can happen that these kind of redundant urls are processed by wicket. These urls \n-\t * can cause some trouble when mapping the request.\n+\t * Try to reduce url by eliminating '..' and '.' from the path where appropriate (this is\n+\t * somehow similar to {@link java.io.File#getCanonicalPath()}). Either by different / unexpected\n+\t * browser behavior or by malicious attacks it can happen that these kind of redundant urls are\n+\t * processed by wicket. These urls can cause some trouble when mapping the request.\n \t * <p/>\n \t * <strong>example:</strong>\n \t * \n \t * the url\n \t * \n-\t * <pre>  /example/..;jsessionid=234792?0</pre> \n+\t * <pre>\n+\t * /example/..;jsessionid=234792?0\n+\t * </pre>\n \t * \n-\t * will not get normalized by the browser due to the ';jsessionid' string that \n-\t * gets appended by the servlet container. After wicket strips the \n-\t * jsessionid part the resulting internal url will be\n+\t * will not get normalized by the browser due to the ';jsessionid' string that gets appended by\n+\t * the servlet container. After wicket strips the jsessionid part the resulting internal url\n+\t * will be\n \t * \n-\t * <pre>  /example/..</pre>\n+\t * <pre>\n+\t * /example/..\n+\t * </pre>\n \t * \n \t * instead of\n \t * \n-\t * <pre>  /</pre>\n+\t * <pre>\n+\t * /\n+\t * </pre>\n \t * \n \t * <p/>\n \t * \n-\t * This code correlates to \n-\t * <a href=\"https://issues.apache.org/jira/browse/WICKET-4303\">WICKET-4303</a>\n+\t * This code correlates to <a\n+\t * href=\"https://issues.apache.org/jira/browse/WICKET-4303\">WICKET-4303</a>\n \t * \n \t * @return canonical url\n \t */\n@@ -1141,9 +1150,9 @@ public Url canonical()\n \t\tUrl url = new Url(this);\n \t\turl.segments.clear();\n \n-\t\tfor (int i = 0; i < this.segments.size(); i++)\n+\t\tfor (int i = 0; i < segments.size(); i++)\n \t\t{\n-\t\t\tfinal String segment = this.segments.get(i);\n+\t\t\tfinal String segment = segments.get(i);\n \n \t\t\t// drop '.' from path\n \t\t\tif (\".\".equals(segment))\n@@ -1152,7 +1161,7 @@ public Url canonical()\n \t\t\t}\n \n \t\t\t// skip segment if following segment is a '..'\n-\t\t\tif ((i + 1) < this.segments.size() && \"..\".equals(this.segments.get(i + 1)))\n+\t\t\tif ((i + 1) < segments.size() && \"..\".equals(segments.get(i + 1)))\n \t\t\t{\n \t\t\t\ti++;\n \t\t\t\tcontinue;\n", "nb_test": 88, "linesAdd": 16, "jira_id": "4789", "singleLine": false, "nb_skipped": 0, "commit": "6f0863f4", "nb_failure": 2, "linesRem": 12}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEmptyInputConvertedToNull(org.apache.wicket.markup.html.form.TextFieldTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AbstractTextComponent.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AbstractTextComponent.java\nindex 845187c..b9a4244 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AbstractTextComponent.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AbstractTextComponent.java\n@@ -21,7 +21,6 @@\n import org.apache.wicket.Component;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.IObjectClassAwareModel;\n-import org.apache.wicket.util.convert.ConversionException;\n import org.apache.wicket.util.string.Strings;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -109,6 +108,8 @@ public boolean isInputNullable()\n \t}\n \n \t/**\n+\t * Convert the input respecting the flag convertEmptyInputStringToNull. Subclasses that override\n+\t * this method should test this flag also.\n \t * \n \t * @see org.apache.wicket.markup.html.form.FormComponent#convertInput()\n \t */\n@@ -118,8 +119,17 @@ protected void convertInput()\n \t\t// Stateless forms don't have to be rendered first, convertInput could be called before\n \t\t// onBeforeRender calling resolve type here again to check if the type is correctly set.\n \t\tresolveType();\n+\t\tString[] value = getInputAsArray();\n+\t\tString tmp = value != null && value.length > 0 ? value[0] : null;\n+\t\tif (getConvertEmptyInputStringToNull() && Strings.isEmpty(tmp))\n+\t\t{\n+\t\t\tsetConvertedInput(null);\n+\t\t}\n+\t\telse\n+\t\t{\n \t\t\tsuper.convertInput();\n \t\t}\n+\t}\n \n \t/**\n \t * If the type is not set try to guess it if the model supports it.\n@@ -140,13 +150,8 @@ private void resolveType()\n \t{\n \t\tif (!getFlag(TYPE_RESOLVED) && getType() == null)\n \t\t{\n-\t\t\t// Set the type, but only if it's not a String (see WICKET-606).\n-\t\t\t// Otherwise, getConvertEmptyInputStringToNull() won't work.\n \t\t\tClass<?> type = getModelType(getDefaultModel());\n-\t\t\tif (!String.class.equals(type))\n-\t\t\t{\n \t\t\tsetType(type);\n-\t\t\t}\n \t\t\tsetFlag(TYPE_RESOLVED, true);\n \t\t}\n \t}\n@@ -186,18 +191,4 @@ private void resolveType()\n \t\tsetFlag(FLAG_CONVERT_EMPTY_INPUT_STRING_TO_NULL, flag);\n \t\treturn this;\n \t}\n-\n-\t/**\n-\t * @see org.apache.wicket.markup.html.form.FormComponent#convertValue(String[])\n-\t */\n-\t@Override\n-\tprotected T convertValue(String[] value) throws ConversionException\n-\t{\n-\t\tString tmp = value != null && value.length > 0 ? value[0] : null;\n-\t\tif (getConvertEmptyInputStringToNull() && Strings.isEmpty(tmp))\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\t\treturn super.convertValue(value);\n-\t}\n }\n", "nb_test": 1046, "linesAdd": 9, "jira_id": "3304", "singleLine": false, "nb_skipped": 0, "commit": "7e7ab76c", "nb_failure": 1, "linesRem": 15}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["AbstractBookmarkableMapperTest.testProcessHybridWithAuthorizationException \u00bb RestartResponseAtInterceptPage"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\nindex 658c98f..0a047ac 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n@@ -265,7 +265,12 @@ protected IRequestHandler processHybrid(PageInfo pageInfo,\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tPageParameters constructionPageParameters = provider.getPageInstance().getPageParameters();\n+\t\t\t/** \n+\t\t\t * https://issues.apache.org/jira/browse/WICKET-5734\n+\t\t\t * */\n+\t\t\tPageParameters constructionPageParameters = provider.hasPageInstance() ? \n+\t\t\t\tprovider.getPageInstance().getPageParameters() : new PageParameters();\n+\n \t\t\tif (PageParameters.equals(constructionPageParameters, pageParameters) == false)\n \t\t\t{\n \t\t\t\t// create a fresh page instance because the request page parameters are different than the ones\n", "nb_test": 1706, "linesAdd": 3, "jira_id": "5734", "singleLine": false, "nb_skipped": 1, "commit": "71674df5", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testWicket3603(org.apache.wicket.extensions.markup.html.repeater.data.table.DataTableTest)", "test_1(org.apache.wicket.extensions.markup.html.repeater.data.table.DataTableTest)"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\nindex f3146d1..d7af5f7 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\n@@ -33,6 +33,8 @@\n import org.apache.wicket.markup.repeater.data.IDataProvider;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.util.string.Strings;\n+import org.apache.wicket.util.visit.IVisit;\n+import org.apache.wicket.util.visit.IVisitor;\n \n \n /**\n@@ -109,9 +111,9 @@ public void onComponentTag(final Component component, final ComponentTag tag)\n \n \tprivate final List<IColumn<T>> columns;\n \n-\tprivate final RepeatingView topToolbars;\n+\tprivate final ToolbarsContainer topToolbars;\n \n-\tprivate final RepeatingView bottomToolbars;\n+\tprivate final ToolbarsContainer bottomToolbars;\n \n \t/**\n \t * Constructor\n@@ -320,14 +322,14 @@ public int getItemCount()\n \t\treturn datagrid.getItemCount();\n \t}\n \n-\tprivate void addToolbar(final AbstractToolbar toolbar, final RepeatingView container)\n+\tprivate void addToolbar(final AbstractToolbar toolbar, final ToolbarsContainer container)\n \t{\n \t\tif (toolbar == null)\n \t\t{\n \t\t\tthrow new IllegalArgumentException(\"argument [toolbar] cannot be null\");\n \t\t}\n \n-\t\tcontainer.add(toolbar);\n+\t\tcontainer.getRepeatingView().add(toolbar);\n \t}\n \n \t/**\n@@ -392,14 +394,18 @@ protected void onPageChanged()\n \t}\n \n \t/**\n-\t * This class acts as a repeater that will contain the toolbar.\n+\t * This class acts as a repeater that will contain the toolbar. It makes sure that the table row\n+\t * group (e.g. thead) tags are only visible when they contain rows in accordance with the HTML\n+\t * specification.\n \t * \n \t * @author igor.vaynberg\n \t */\n-\tprivate static class ToolbarsContainer extends RepeatingView\n+\tprivate static class ToolbarsContainer extends WebMarkupContainer\n \t{\n \t\tprivate static final long serialVersionUID = 1L;\n \n+\t\tprivate final RepeatingView toolbars;\n+\n \t\t/**\n \t\t * Constructor\n \t\t * \n@@ -408,6 +414,41 @@ protected void onPageChanged()\n \t\tprivate ToolbarsContainer(final String id)\n \t\t{\n \t\t\tsuper(id);\n+\t\t\ttoolbars = new RepeatingView(\"toolbars\");\n+\t\t\tadd(toolbars);\n+\t\t}\n+\n+\t\tpublic RepeatingView getRepeatingView()\n+\t\t{\n+\t\t\treturn toolbars;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isVisible()\n+\t\t{\n+\t\t\tif (!super.isVisible())\n+\t\t\t{\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\ttoolbars.configure();\n+\n+\t\t\tBoolean visible = toolbars.visitChildren(new IVisitor<Component, Boolean>()\n+\t\t\t{\n+\t\t\t\tpublic void component(Component object, IVisit<Boolean> visit)\n+\t\t\t\t{\n+\t\t\t\t\tobject.configure();\n+\t\t\t\t\tif (object.isVisible())\n+\t\t\t\t\t{\n+\t\t\t\t\t\tvisit.stop(Boolean.TRUE);\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t{\n+\t\t\t\t\t\tvisit.dontGoDeeper();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\treturn visible == Boolean.TRUE;\n \t\t}\n \t}\n }\n", "nb_test": 12, "linesAdd": 44, "jira_id": "3603", "singleLine": false, "nb_skipped": 0, "commit": "aa1d177a", "nb_failure": 0, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testResolveRelative_DotFollowedByEmptySegment1(org.apache.wicket.request.UrlTest): no empty segment expected:<0> but was:<1>", "testResolveRelative_DotFollowedByEmptySegment2(org.apache.wicket.request.UrlTest): expected:<bar[]?a=b> but was:<bar[/]?a=b>"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex d387a13..acb4287 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -989,18 +989,29 @@ public void resolveRelative(final Url relative)\n \t\t\t// strip the first non-folder segment\n \t\t\tgetSegments().remove(getSegments().size() - 1);\n \t\t}\n-\t\t// remove all './' (current folder) from the relative url\n-\t\tif (!relative.getSegments().isEmpty() && \".\".equals(relative.getSegments().get(0)))\n+\n+\t\t// remove leading './' (current folder) and empty segments, process any ../ segments from the\n+\t\t// relative url\n+\t\twhile (!relative.getSegments().isEmpty())\n+\t\t{\n+\t\t\tif (\".\".equals(relative.getSegments().get(0)))\n \t\t\t{\n \t\t\t\trelative.getSegments().remove(0);\n \t\t\t}\n-\n-\t\t// process any ../ segments in the relative url\n-\t\twhile (!relative.getSegments().isEmpty() && \"..\".equals(relative.getSegments().get(0)))\n+\t\t\telse if (\"\".equals(relative.getSegments().get(0)))\n+\t\t\t{\n+\t\t\t\trelative.getSegments().remove(0);\n+\t\t\t}\n+\t\t\telse if (\"..\".equals(relative.getSegments().get(0)))\n \t\t\t{\n \t\t\t\trelative.getSegments().remove(0);\n \t\t\t\tgetSegments().remove(getSegments().size() - 1);\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n \n \t\t// append the remaining relative segments\n \t\tgetSegments().addAll(relative.getSegments());\n", "nb_test": 77, "linesAdd": 14, "jira_id": "4518", "singleLine": false, "nb_skipped": 0, "commit": "a88882f7", "nb_failure": 2, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["transformationInAjaxRequest(org.apache.wicket.markup.transformer.AbstractTransformerBehaviorTest): org.apache.wicket.ajax.AjaxRequestTarget$AjaxResponse cannot be cast to org.apache.wicket.request.http.WebResponse"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\nindex be0490b..f752e10 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\n@@ -20,12 +20,13 @@\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.behavior.Behavior;\n import org.apache.wicket.protocol.http.BufferedWebResponse;\n+import org.apache.wicket.request.Response;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.http.WebResponse;\n \n /**\n- * A IBehavior which can be added to any component. It allows to post-process (transform) the markup\n- * generated by the component.\n+ * A {@link Behavior} which can be added to any component. It allows to post-process (transform) the\n+ * markup generated by the component.\n  * \n  * @see org.apache.wicket.markup.transformer.AbstractOutputTransformerContainer\n  * \n@@ -35,20 +36,17 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n-\tprivate WebResponse webResponse;\n-\n \t/**\n-\t * Construct.\n+\t * The request cycle's response before the transformation.\n \t */\n-\tpublic AbstractTransformerBehavior()\n-\t{\n-\t}\n+\tprivate Response originalResponse;\n \n \t/**\n \t * Create a new response object which is used to store the markup generated by the child\n \t * objects.\n \t * \n \t * @param originalResponse\n+\t *            the original web response or {@code null} if it isn't a {@link WebResponse}\n \t * \n \t * @return Response object. Must not be null\n \t */\n@@ -65,17 +63,14 @@ public void beforeRender(Component component)\n \t\tfinal RequestCycle requestCycle = RequestCycle.get();\n \n \t\t// Temporarily replace the web response with a String response\n-\t\twebResponse = (WebResponse)requestCycle.getResponse();\n+\t\toriginalResponse = requestCycle.getResponse();\n \n-\t\t// Create a new response object\n-\t\tfinal BufferedWebResponse response = newResponse(webResponse);\n-\t\tif (response == null)\n-\t\t{\n-\t\t\tthrow new IllegalStateException(\"newResponse() must not return null\");\n-\t\t}\n+\t\tWebResponse origResponse = (WebResponse)((originalResponse instanceof WebResponse)\n+\t\t\t? originalResponse : null);\n+\t\tBufferedWebResponse tempResponse = newResponse(origResponse);\n \n-\t\t// and make it the current one\n-\t\trequestCycle.setResponse(response);\n+\t\t// temporarily set StringResponse to collect the transformed output\n+\t\trequestCycle.setResponse(tempResponse);\n \t}\n \n \t@Override\n@@ -85,28 +80,28 @@ public void afterRender(final Component component)\n \n \t\ttry\n \t\t{\n-\t\t\tBufferedWebResponse response = (BufferedWebResponse)requestCycle.getResponse();\n+\t\t\tBufferedWebResponse tempResponse = (BufferedWebResponse)requestCycle.getResponse();\n \n \t\t\t// Transform the data\n-\t\t\tCharSequence output = transform(component, response.getText());\n-\t\t\tresponse.setText(output);\n-\t\t\tresponse.writeTo(webResponse);\n+\t\t\tCharSequence output = transform(component, tempResponse.getText());\n+\t\t\toriginalResponse.write(output);\n \t\t}\n \t\tcatch (Exception ex)\n \t\t{\n-\t\t\tthrow new WicketRuntimeException(\"Error while transforming the output: \" + this, ex);\n+\t\t\tthrow new WicketRuntimeException(\"Error while transforming the output of component: \" +\n+\t\t\t\tcomponent, ex);\n \t\t}\n \t\tfinally\n \t\t{\n \t\t\t// Restore the original response object\n-\t\t\trequestCycle.setResponse(webResponse);\n+\t\t\trequestCycle.setResponse(originalResponse);\n \t\t}\n \t}\n \n \t@Override\n \tpublic void detach(Component component)\n \t{\n-\t\twebResponse = null;\n+\t\toriginalResponse = null;\n \t\tsuper.detach(component);\n \t}\n \n", "nb_test": 1200, "linesAdd": 14, "jira_id": "4105", "singleLine": false, "nb_skipped": 2, "commit": "64656c98", "nb_failure": 0, "linesRem": 19}, {"files": 3, "project": "wicket", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["TransparentWebMarkupContainerTest.ajaxRequestForComponentInTransparentWebMarkupContainerShouldntCauseStackOverflow3 \u00bb StackOverflow", "TransparentWebMarkupContainerTest.ajaxRequestForComponentInTransparentWebMarkupContainerShouldntCauseStackOverflow4 \u00bb StackOverflow", "TransparentWebMarkupContainerTest.ajaxRequestForComponentInTransparentWebMarkupContainerShouldntCauseStackOverflow5 \u00bb StackOverflow"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\nindex 27407cf..b49f2f4 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.wicket.markup.html.panel;\n \n+import java.util.Iterator;\n+\n import org.apache.wicket.Component;\n import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.markup.ComponentTag;\n@@ -26,8 +28,6 @@\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.apache.wicket.util.lang.Classes;\n-import org.apache.wicket.util.visit.IVisit;\n-import org.apache.wicket.util.visit.IVisitor;\n \n /**\n  * Implements boilerplate as needed by many markup sourcing strategies.\n@@ -55,53 +55,58 @@ public AbstractMarkupSourcingStrategy()\n \t * \n \t * @param container\n \t *            the parent container.\n+\t * @param\n+\t * \t\t  containerMarkup\n+\t * \t\t\t  the markup of the container.           \n \t * @param child\n \t *            The component to find the markup for.\n \t * @return the markup fragment for the child, or {@code null}.\n \t */\n-\tprotected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container,\n-\t\tfinal Component child)\n-\t{\n-\t\treturn container.visitChildren(MarkupContainer.class, new IVisitor<MarkupContainer, IMarkupFragment>()\n-\t\t{\n-\t\t\t@Override\n-\t\t\tpublic void component(MarkupContainer resolvingContainer, IVisit<IMarkupFragment> visit)\n+\tprotected IMarkupFragment searchMarkupInTransparentResolvers(MarkupContainer container,\n+\t\tIMarkupFragment containerMarkup, Component child)\n \t{\n-\t\t\t\t//prevents possible searching loops\n-\t\t\t\tif (child == resolvingContainer) \n+\t\tIMarkupFragment childMarkupFound = null;\n+\t\tIterator<Component> siblingsIterator = container.iterator();\n+\t\t\n+\t\twhile (siblingsIterator.hasNext() && childMarkupFound == null)\n \t\t{\n-\t\t\t\t\tvisit.dontGoDeeper();\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n+\t\t\tComponent sibling = siblingsIterator.next();\n \t\t\t\n-\t\t\t\tif (resolvingContainer instanceof IComponentResolver)\n+\t\t\tif(sibling == child || !sibling.isVisible())\n \t\t\t{\n-\t\t\t\t\tvisit.dontGoDeeper();\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\t\n-\t\t\t\t\tIMarkupFragment childMarkup = resolvingContainer.getMarkup(child);\n+\t\t\tIMarkupFragment siblingMarkup = containerMarkup.find(sibling.getId());\n \t\t\t\n-\t\t\t\t\tif (childMarkup != null && childMarkup.size() > 0)\n+\t\t\tif (siblingMarkup != null && sibling instanceof MarkupContainer)\n \t\t\t{\n-\t\t\t\t\t\tIComponentResolver componentResolver = (IComponentResolver)resolvingContainer;\n+\t\t\t\tIMarkupFragment childMarkup  = siblingMarkup.find(child.getId());\n \t\t\t\t\n+\t\t\t\tif (childMarkup != null && sibling instanceof IComponentResolver)\n+\t\t\t\t{\n+\t\t\t\t\tIComponentResolver componentResolver = (IComponentResolver)sibling;\n \t\t\t\t\tMarkupStream stream = new MarkupStream(childMarkup);\n-\n \t\t\t\t\tComponentTag tag = stream.getTag();\n \t\t\t\t\t\n-\t\t\t\t\t\tComponent resolvedComponent = resolvingContainer.get(tag.getId());\n+\t\t\t\t\tComponent resolvedComponent = sibling.get(tag.getId());\n \t\t\t\t\tif (resolvedComponent == null)\n \t\t\t\t\t{\n-\t\t\t\t\t\t\tresolvedComponent = componentResolver.resolve(resolvingContainer, stream, tag);\n+\t\t\t\t\t\tresolvedComponent = componentResolver.resolve((MarkupContainer)sibling, stream, tag);\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tif (child == resolvedComponent)\n \t\t\t\t\t{\n-\t\t\t\t\t\t\tvisit.stop(childMarkup);\n+\t\t\t\t\t\tchildMarkupFound = childMarkup;\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\telse \n+\t\t\t\t{\n+\t\t\t\t\tchildMarkupFound = searchMarkupInTransparentResolvers((MarkupContainer)sibling, siblingMarkup, child);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t});\n+\t\treturn childMarkupFound;\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\nindex 0ac0647..5f547ac 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\n@@ -120,7 +120,7 @@ public IMarkupFragment getMarkup(final MarkupContainer parent, final Component c\n \t\t\treturn associatedMarkup;\n \t\t}\n \n-\t\tassociatedMarkup = searchMarkupInTransparentResolvers(parent, child);\n+\t\tassociatedMarkup = searchMarkupInTransparentResolvers(parent, markup, child);\n \t\tif (associatedMarkup != null)\n \t\t{\n \t\t\treturn associatedMarkup;\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\nindex 6699a68..7506d23 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n@@ -78,26 +78,24 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t{\n \t\t// If the sourcing strategy did not provide one, than ask the component.\n \t\t// Get the markup for the container\n-\t\tIMarkupFragment markup = container.getMarkup();\n-\t\tif (markup == null)\n+\t\tIMarkupFragment containerMarkup = container.getMarkup();\n+\t\tif (containerMarkup == null)\n \t\t{\n \t\t\treturn null;\n \t\t}\n \n \t\tif (child == null)\n \t\t{\n-\t\t\treturn markup;\n+\t\t\treturn containerMarkup;\n \t\t}\n \t\t\n \t\t// Find the child's markup\n-\t\tmarkup = markup.find(child.getId());\n-\t\tif (markup != null)\n+\t\tIMarkupFragment childMarkup = containerMarkup.find(child.getId());\n+\t\tif (childMarkup != null)\n \t\t{\n-\t\t\treturn markup;\n+\t\t\treturn childMarkup;\n \t\t}\n \t\t\n-\t\tmarkup = searchMarkupInTransparentResolvers(container, child);\n-\t\t\n-\t\treturn markup;\n+\t\treturn searchMarkupInTransparentResolvers(container, containerMarkup, child);\n \t}\n }\n", "nb_test": 1753, "linesAdd": 34, "jira_id": "5898", "singleLine": false, "nb_skipped": 1, "commit": "ffdd0864", "nb_failure": 0, "linesRem": 33}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["getMinValue(org.apache.wicket.util.lang.NumbersTest): expected:<-3.4028235E38> but was:<1.4E-45>"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/lang/Numbers.java b/wicket-util/src/main/java/org/apache/wicket/util/lang/Numbers.java\nindex f4e7858..260d8d1 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/lang/Numbers.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/lang/Numbers.java\n@@ -38,8 +38,8 @@ private Numbers()\n \t * \n \t * @param numberType\n \t *            the type of the number for which the minimum value will be returned\n-\t * @return the minimum value of the numberType or {@value Double#MIN_VALUE} if the numberType\n-\t *         itself is either {@code null} or has no minimum value\n+\t * @return the minimum value of the numberType or Double if the numberType itself is either\n+\t *         {@code null} or has no minimum value\n \t */\n \tpublic static Number getMinValue(Class<? extends Number> numberType)\n \t{\n@@ -54,11 +54,11 @@ else if (Long.class == numberType || long.class == numberType)\n \t\t}\n \t\telse if (Float.class == numberType || float.class == numberType)\n \t\t{\n-\t\t\tresult = Float.MIN_VALUE;\n+\t\t\tresult = -Float.MAX_VALUE;\n \t\t}\n \t\telse if (Double.class == numberType || double.class == numberType)\n \t\t{\n-\t\t\tresult = Double.MIN_VALUE;\n+\t\t\tresult = -Double.MAX_VALUE;\n \t\t}\n \t\telse if (Byte.class == numberType || byte.class == numberType)\n \t\t{\n@@ -70,8 +70,8 @@ else if (Short.class == numberType || short.class == numberType)\n \t\t}\n \t\telse\n \t\t{ // null of any other Number\n-\t\t\tLOG.debug(\"'{}' has no minimum value. Falling back to Double.MIN_VALUE.\", numberType);\n-\t\t\tresult = Double.MIN_VALUE;\n+\t\t\tLOG.debug(\"'{}' has no minimum value. Falling back to Double.\", numberType);\n+\t\t\tresult = -Double.MAX_VALUE;\n \t\t}\n \n \t\treturn result;\n", "nb_test": 163, "linesAdd": 4, "jira_id": "4696", "singleLine": false, "nb_skipped": 0, "commit": "f5f802c5", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["fileWithWhitespace(org.apache.wicket.util.file.FilesTest): expected:</file[ with ]whitespace> but was:</file[%20with%20]whitespace>"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java b/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java\nindex 3b5b97c..f9d2579 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java\n@@ -23,7 +23,9 @@\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n import java.net.URL;\n+import java.net.URLDecoder;\n \n import org.apache.wicket.util.io.IOUtils;\n import org.apache.wicket.util.io.Streams;\n@@ -363,7 +365,16 @@ public static void copy(final File sourceFile, final File targetFile) throws IOE\n \t */\n \tpublic static File getLocalFileFromUrl(URL url)\n \t{\n-\t\treturn getLocalFileFromUrl(Args.notNull(url, \"url\").toExternalForm());\n+\t\tfinal URL location = Args.notNull(url, \"url\");\n+\n+\t\ttry\n+\t\t{\n+\t\t\treturn getLocalFileFromUrl(URLDecoder.decode(location.toExternalForm(), \"UTF-8\"));\n+\t\t}\n+\t\tcatch (UnsupportedEncodingException ex)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n \t}\n \n \t/**\n", "nb_test": 151, "linesAdd": 12, "jira_id": "4509", "singleLine": false, "nb_skipped": 0, "commit": "b672cb2d", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["parse17(org.apache.wicket.request.UrlTest): For input string: \"secret@localhost\""], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex b9769e8..596163e 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -263,7 +263,8 @@ public static Url parse(CharSequence _url, Charset charset)\n \t\t\t\thostAndPort = afterProto.substring(0, relativeAt);\n \t\t\t}\n \n-\t\t\tfinal int portAt = hostAndPort.lastIndexOf(':');\n+\t\t\tfinal int credentialsAt = hostAndPort.lastIndexOf('@') + 1;\n+\t\t\tfinal int portAt = hostAndPort.substring(credentialsAt).lastIndexOf(':');\n \n \t\t\tif (portAt == -1)\n \t\t\t{\n@@ -272,8 +273,8 @@ public static Url parse(CharSequence _url, Charset charset)\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tresult.host = hostAndPort.substring(0, portAt);\n-\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n+\t\t\t\tresult.host = hostAndPort.substring(0, portAt + credentialsAt);\n+\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portAt + credentialsAt + 1));\n \t\t\t}\n \n \t\t\tif (relativeAt < 0)\n", "nb_test": 98, "linesAdd": 4, "jira_id": "5259", "singleLine": false, "nb_skipped": 0, "commit": "a9e56e1e", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["exceptionIsHandledByFirstAvailableHandler(org.apache.wicket.request.cycle.RequestCycleListenerTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycleListenerCollection.java b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycleListenerCollection.java\nindex 7422820..821b883 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycleListenerCollection.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycleListenerCollection.java\n@@ -19,14 +19,13 @@\n import java.util.ArrayList;\r\n import java.util.List;\r\n \r\n-import org.apache.wicket.WicketRuntimeException;\r\n import org.apache.wicket.request.IRequestHandler;\r\n import org.apache.wicket.util.listener.ListenerCollection;\r\n import org.slf4j.Logger;\r\n import org.slf4j.LoggerFactory;\r\n \r\n /**\r\n- * \r\n+ * Special, Wicket internal composite {@link IRequestCycleListener} that\r\n  */\r\n public class RequestCycleListenerCollection extends ListenerCollection<IRequestCycleListener>\r\n \timplements\r\n@@ -57,6 +56,13 @@ public void notify(IRequestCycleListener listener)\n \t\t});\r\n \t}\r\n \r\n+\t/**\r\n+\t * Notifies all registered listeners of the exception and calls the first handler that was\r\n+\t * returned by the listeners.\r\n+\t * \r\n+\t * @see org.apache.wicket.request.cycle.IRequestCycleListener#onException(org.apache.wicket.request.cycle.RequestCycle,\r\n+\t *      java.lang.Exception)\r\n+\t */\r\n \tpublic IRequestHandler onException(final RequestCycle cycle, final Exception ex)\r\n \t{\r\n \t\tfinal List<IRequestHandler> handlers = new ArrayList<IRequestHandler>();\r\n@@ -77,14 +83,12 @@ public void notify(IRequestCycleListener listener)\n \t\t{\r\n \t\t\treturn null;\r\n \t\t}\r\n-\r\n \t\tif (handlers.size() > 1)\r\n \t\t{\r\n-\t\t\tthrow new WicketRuntimeException(\r\n-\t\t\t\t\"More than one request cycle listener returned a request handler while handling the exception.\",\r\n-\t\t\t\tex);\r\n+\t\t\tlogger.debug(\r\n+\t\t\t\t\"{} exception handlers available for exception {}, using the first handler\",\r\n+\t\t\t\thandlers.size(), ex);\r\n \t\t}\r\n-\r\n \t\treturn handlers.get(0);\r\n \t}\r\n \r\n", "nb_test": 1128, "linesAdd": 3, "jira_id": "3644", "singleLine": false, "nb_skipped": 0, "commit": "ab1856db", "nb_failure": 0, "linesRem": 6}, {"files": 2, "project": "wicket", "nb_error": 22, "classification": {"singleLine": false}, "failing_tests": ["WebPageRendererTest.testRedirectPolicyNever:233 \u00bb WicketRuntime There is no ap...", "WebPageRendererTest.testRedirectToBufferIsFallback:983 \u00bb WicketRuntime There i...", "WebPageRendererTest.testRedirectPolicyAlways:359 \u00bb WicketRuntime There is no a...", "WebPageRendererTest.testShouldPreserveClientUrlAndAjaxRequest:1007 \u00bb WicketRuntime", "WebPageRendererTest.testOnePassRenderAndAjaxRequest:201 \u00bb WicketRuntime There ...", "WebPageRendererTest.testSameUrlsAndRedirectToRender:266 \u00bb WicketRuntime There ...", "WebPageRendererTest.testRedirectToBufferStatefulPageAndSameUrls:928 \u00bb WicketRuntime", "WebPageRendererTest.testDifferentUrlsTemporarySessionAndStatelessPage:427 \u00bb WicketRuntime", "WebPageRendererTest.testRedirectToBufferStatelessPageAndRedirectIsDisabled:521 \u00bb WicketRuntime", "WebPageRendererTest.testSameUrlsAndStatefulPage:292 \u00bb WicketRuntime There is n...", "WebPageRendererTest.testDifferentUrlsAndNewPageInstance:448 \u00bb WicketRuntime Th...", "WebPageRendererTest.testRedirectToBufferStatelessPageAndRedirectIsEsabled:558 \u00bb WicketRuntime", "WebPageRendererTest.testShouldPreserveClientUrl:313 \u00bb WicketRuntime There is n...", "WebPageRendererTest.testSameUrlsAndAjaxRequest:380 \u00bb WicketRuntime There is no...", "WebPageRendererTest.testRedirectToRender:404 \u00bb WicketRuntime There is no appli...", "WebPageRendererTest.testShouldPreserveClientUrlOverruledByRedirectPolicyAlwaysRedirect:337 \u00bb WicketRuntime", "WebPageRendererTest.testRedirectToBufferStatefulPage:593 \u00bb WicketRuntime There...", "WebPageRendererTest.testOnePassRenderDifferentProtocols:141 \u00bb WicketRuntime Th...", "WebPageRendererTest.testOnePassRenderWithAlwaysRedirect:177 \u00bb WicketRuntime Th...", "WebPageRendererTest.testRedirectToBufferNoPageToRender:483 \u00bb WicketRuntime The...", "WebPageRendererTest.testNeverRedirectButAjaxRequest:1030 \u00bb WicketRuntime There...", "WebPageRendererTest.testOnePassRender:101 \u00bb WicketRuntime There is no applicat..."], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\nindex 52d41ca..0ff49bc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\n@@ -876,10 +876,12 @@ public boolean hasBufferedResponse(String sessionId, Url url)\n \t}\n \n \t/**\n+\t * Retrieves a stored buffered response for a given sessionId and url.\n \t *\n-\t * @param sessionId\n \t * @param url\n-\t * @return buffered response\n+\t *          The url used as a key\n+\t * @return the stored buffered response. {@code null} if there is no stored response for the given url\n+\t * @see org.apache.wicket.settings.IRequestCycleSettings.RenderStrategy#REDIRECT_TO_BUFFER\n \t */\n \tpublic BufferedWebResponse getAndRemoveBufferedResponse(String sessionId, Url url)\n \t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex aee0104..00a8ea2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -87,11 +87,6 @@ protected void storeBufferedResponse(Url url, BufferedWebResponse response)\n \t\tWebApplication.get().storeBufferedResponse(getSessionId(), url, response);\n \t}\n \t\n-\tprotected BufferedWebResponse getAndRemoveBufferedResponse(Url url)\n-\t{\n-\t\treturn WebApplication.get().getAndRemoveBufferedResponse(getSessionId(), url);\n-\t}\n-\n \t/**\n \t * Renders page to a {@link BufferedWebResponse}. All URLs in page will be rendered relative to\n \t * <code>targetUrl</code>\n@@ -195,17 +190,7 @@ public void respond(RequestCycle requestCycle)\n \t\t// 3 rendering strategies and two kind of requests (ajax and normal)\n \t\t//\n \n-\t\t// try to get an already rendered buffered response for current URL\n-\t\tBufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\n-\n-\t\tif (bufferedResponse != null)\n-\t\t{\n-\t\t\tlogger\n-\t\t\t\t.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\n-\t\t\t// if there is saved response for this URL render it\n-\t\t\tbufferedResponse.writeTo((WebResponse)requestCycle.getResponse());\n-\t\t}\n-\t\telse if (shouldRenderPageAndWriteResponse(requestCycle, currentUrl, targetUrl))\n+\t\tif (shouldRenderPageAndWriteResponse(requestCycle, currentUrl, targetUrl))\n \t\t{\n \t\t\tBufferedWebResponse response = renderPage(currentUrl, requestCycle);\n \t\t\tif (response != null)\n", "nb_test": 1679, "linesAdd": 1, "jira_id": "5689", "singleLine": false, "nb_skipped": 1, "commit": "2ac29d30", "nb_failure": 0, "linesRem": 14}, {"files": 2, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["test2(wicket.request.target.coding.PackageRequestTargetUrlCodingStrategyTest)", "test3(wicket.request.target.coding.PackageRequestTargetUrlCodingStrategyTest): Unable to load class with name: wicket.request.target.coding."], "patch": "diff --git a/jdk-1.4/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java b/jdk-1.4/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\nindex e8b8272..9580296 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\n@@ -968,6 +968,12 @@ public IRequestTargetUrlCodingStrategy strategyForPath(String path)\n \t\t\t\tfinal String key = (String)entry.getKey();\n \t\t\t\tif (path.startsWith(key))\n \t\t\t\t{\n+\t\t\t\t\t/*\n+\t\t\t\t\t * We need to match /mount/point or\n+\t\t\t\t\t * /mount/point/with/extra/path, but not /mount/pointXXX\n+\t\t\t\t\t */\n+\t\t\t\t\tString remainder = path.substring(key.length());\n+\t\t\t\t\tif (remainder.length() == 0 || remainder.startsWith(\"/\"))\n \t\t\t\t\t\treturn (IRequestTargetUrlCodingStrategy)entry.getValue();\n \t\t\t\t}\n \t\t\t}\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java b/jdk-1.4/wicket/src/main/java/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\nindex eaa6fd3..f18bf62 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\n@@ -16,6 +16,9 @@\n  */\n package wicket.request.target.coding;\n \n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n import wicket.IRequestTarget;\n import wicket.PageParameters;\n import wicket.Session;\n@@ -35,6 +38,7 @@\n  */\n public class PackageRequestTargetUrlCodingStrategy extends AbstractRequestTargetUrlCodingStrategy\n {\n+\tprivate static final Log log = LogFactory.getLog(PackageRequestTargetUrlCodingStrategy.class);\n \t/** package for this mount. */\n \tprivate final PackageName packageName;\n \n@@ -57,7 +61,9 @@ public PackageRequestTargetUrlCodingStrategy(final String path, PackageName pack\n \t */\n \tpublic IRequestTarget decode(RequestParameters requestParameters)\n \t{\n+\t\tlog.debug(\"path=\"+requestParameters.getPath());\n \t\tString remainder = requestParameters.getPath().substring(getMountPath().length());\n+\t\tlog.debug(\"remainder=\"+remainder);\n \t\tfinal String parametersFragment;\n \t\tint ix = remainder.indexOf('/', 1);\n \t\tif (ix == -1)\n@@ -75,7 +81,14 @@ public IRequestTarget decode(RequestParameters requestParameters)\n \t\t\tremainder = remainder.substring(1);\n \t\t\tix--;\n \t\t}\n+\t\telse\n+\t\t{\n+\t\t\t// There is nothing after the mount path!\n+\t\t\treturn null;\n+\t\t}\n \n+\t\tlog.debug(\"remainder=\"+remainder);\n+\t\tlog.debug(\"parametersFragment=\"+parametersFragment);\n \t\tfinal String bookmarkablePageClassName = packageName + \".\" + remainder.substring(0, ix);\n \t\tClass bookmarkablePageClass = Session.get().getClassResolver().resolveClass(\n \t\t\t\tbookmarkablePageClassName);\n", "nb_test": 408, "linesAdd": 14, "jira_id": "294", "singleLine": false, "nb_skipped": 0, "commit": "5c592d85", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOnePassRenderWithAlwaysRedirect(org.apache.wicket.request.handler.render.WebPageRendererTest):"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\nindex 022f95a..73a3463 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n@@ -601,7 +601,7 @@ public void setResponsePage(Class<? extends IRequestablePage> pageClass)\n \t{\n \t\tIPageProvider provider = new PageProvider(pageClass, null);\n \t\tscheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider,\n-\t\t\tRenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));\n+\t\t\tRenderPageRequestHandler.RedirectPolicy.ALWAYS_REDIRECT));\n \t}\n \n \n@@ -616,7 +616,7 @@ public void setResponsePage(Class<? extends IRequestablePage> pageClass,\n \t{\n \t\tIPageProvider provider = new PageProvider(pageClass, parameters);\n \t\tscheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider,\n-\t\t\tRenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));\n+\t\t\tRenderPageRequestHandler.RedirectPolicy.ALWAYS_REDIRECT));\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex 7d85405..3c84f2c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -164,7 +164,7 @@ public void respond(RequestCycle requestCycle)\n \t\t\tbufferedResponse.writeTo((WebResponse)requestCycle.getResponse());\n \t\t}\n \t\telse if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT ||\n-\t\t\t(isOnePassRender() && isAjax == false) //\n+\t\t\t(isOnePassRender() && isAjax == false && getRedirectPolicy() != RedirectPolicy.ALWAYS_REDIRECT) //\n \t\t\t||\n \t\t\t(!isAjax //\n \t\t\t\t&&\n", "nb_test": 1235, "linesAdd": 3, "jira_id": "4173", "singleLine": false, "nb_skipped": 2, "commit": "84bbbf68", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["TransparentWebMarkupContainerTest.ajaxRequestForComponentInTransparentWebMarkupContainerShouldntCauseStackOverflow3 \u00bb StackOverflow"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\nindex 6ba5b61..f1749af 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n@@ -21,6 +21,7 @@\n import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.markup.IMarkupFragment;\n import org.apache.wicket.markup.MarkupStream;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -96,7 +97,10 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t\t\treturn markup;\n \t\t}\n \t\t\n+\t\tif(!(child instanceof IComponentResolver)) \n+\t\t{\n \t\t\tmarkup = searchMarkupInTransparentResolvers(container, child);\n+\t\t}\n \t\t\n \t\treturn markup;\n \t}\n", "nb_test": 1751, "linesAdd": 4, "jira_id": "5898", "singleLine": false, "nb_skipped": 1, "commit": "b00920f3", "nb_failure": 0, "linesRem": 0}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["decode13(org.apache.wicket.core.request.mapper.BookmarkableMapperTest): A handler should be resolved for relative url to a bookmarkable page url!"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex 1fd71d6..a9fd212 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -190,6 +190,11 @@ else if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace,\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n+\t\t// baseUrl = 'bookmarkable/com.example.SomePage', requestUrl = 'bookmarkable/com.example.SomePage'\n+\t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, bookmarkableIdentifier) && url.getSegments().size() == 2 && urlStartsWith(url, bookmarkableIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n \t\t// baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n \t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))\n \t\t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\nindex 3789a9f..a034642 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n@@ -175,17 +175,19 @@ private boolean matches(final Request request)\n \t{\n \t\tboolean matches = false;\n \t\tUrl url = request.getUrl();\n+\t\tUrl baseUrl = request.getClientUrl();\n \t\tString namespace = getContext().getNamespace();\n \t\tString pageIdentifier = getContext().getPageIdentifier();\n+\n \t\tif (urlStartsWith(url, namespace, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n-\t\telse if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n+\t\telse if (urlStartsWith(baseUrl, namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n-\t\telse if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier))\n+\t\telse if (urlStartsWith(baseUrl, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n", "nb_test": 1495, "linesAdd": 8, "jira_id": "5071", "singleLine": false, "nb_skipped": 4, "commit": "d3d42d42", "nb_failure": 1, "linesRem": 2}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEventJavaScriptEscaped(org.apache.wicket.ajax.form.AjaxFormSubmitTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java b/wicket/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\nindex ca42719..7f6afe7 100644\n--- a/wicket/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n+++ b/wicket/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n@@ -108,10 +108,21 @@ protected void onComponentTag(final ComponentTag tag)\n \t\tComponent myComponent = getComponent();\n \t\tif (myComponent.isEnabledInHierarchy())\n \t\t{\n-\t\t\ttag.put(event, getEventHandler());\n+\t\t\ttag.put(event, escapeAttribute(getEventHandler()));\n \t\t}\n \t}\n \t\n+\tprivate CharSequence escapeAttribute(final CharSequence attr)\n+\t{\n+\t\tif(null == attr)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\t\tCharSequence escaped = Strings.escapeMarkup(attr.toString());\n+\t\t// No need to escape the apostrophe; it just clutters the markup\n+\t\treturn Strings.replaceAll(escaped, \"&#039;\", \"'\");\n+\t}\n+\n \t/**\n \t * \n \t * @return event handler\ndiff --git a/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormSubmitBehavior.java b/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormSubmitBehavior.java\nindex 5ae018a..5a226c0 100644\n--- a/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormSubmitBehavior.java\n+++ b/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormSubmitBehavior.java\n@@ -176,6 +176,6 @@ protected void onEvent(AjaxRequestTarget target)\n \t@Override\n \tprotected CharSequence getPreconditionScript()\n \t{\n-\t\treturn \"return Wicket.$$(this)&amp;&amp;Wicket.$$('\" + getForm().getMarkupId() + \"')\";\n+\t\treturn \"return Wicket.$$(this)&&Wicket.$$('\" + getForm().getMarkupId() + \"')\";\n \t}\n }\n", "nb_test": 792, "linesAdd": 12, "jira_id": "2033", "singleLine": false, "nb_skipped": 0, "commit": "420ac965", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["shouldDisableCaching(org.apache.wicket.DefaultExceptionMapperTest): (..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\nindex 1a787ea..eea361d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n@@ -17,21 +17,23 @@\n package org.apache.wicket;\n \n import org.apache.wicket.authorization.AuthorizationException;\n+import org.apache.wicket.core.request.handler.IPageRequestHandler;\n+import org.apache.wicket.core.request.handler.ListenerInvocationNotAllowedException;\n+import org.apache.wicket.core.request.handler.PageProvider;\n+import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n+import org.apache.wicket.core.request.mapper.StalePageException;\n import org.apache.wicket.markup.html.pages.ExceptionErrorPage;\n import org.apache.wicket.protocol.http.PageExpiredException;\n import org.apache.wicket.protocol.http.servlet.ResponseIOException;\n import org.apache.wicket.request.IExceptionMapper;\n import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.Request;\n+import org.apache.wicket.request.Response;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.handler.EmptyRequestHandler;\n-import org.apache.wicket.core.request.handler.IPageRequestHandler;\n-import org.apache.wicket.core.request.handler.ListenerInvocationNotAllowedException;\n-import org.apache.wicket.core.request.handler.PageProvider;\n-import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n import org.apache.wicket.request.http.WebRequest;\n+import org.apache.wicket.request.http.WebResponse;\n import org.apache.wicket.request.http.handler.ErrorCodeRequestHandler;\n-import org.apache.wicket.core.request.mapper.StalePageException;\n import org.apache.wicket.settings.IExceptionSettings;\n import org.apache.wicket.settings.IExceptionSettings.UnexpectedExceptionDisplay;\n import org.slf4j.Logger;\n@@ -51,6 +53,12 @@ public IRequestHandler map(Exception e)\n \t{\n \t\ttry\n \t\t{\n+\t\t\tResponse response = RequestCycle.get().getResponse();\n+\t\t\tif (response instanceof WebResponse)\n+\t\t\t{\n+\t\t\t\t// we don't wan't to cache an exceptional reply in the browser\n+\t\t\t\t((WebResponse)response).disableCaching();\n+\t\t\t}\n \t\t\treturn internalMap(e);\n \t\t}\n \t\tcatch (RuntimeException e2)\n", "nb_test": 1385, "linesAdd": 12, "jira_id": "4659", "singleLine": false, "nb_skipped": 5, "commit": "ccd74641", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["renderHomePage_13(org.apache.wicket.markup.html.basic.SimplePageTest): org/apache/wicket/markup/html/basic/SimplePageExpectedResult_13.html expected:<...1.IBehaviorListener.[0]-html\",\"e\":\"click\",\"...> but was:<...1.IBehaviorListener.[1]-html\",\"e\":\"click\",\"...>", "urlIndexRendering(org.apache.wicket.behavior.ImmutableBehaviorIdsTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Behaviors.java b/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\nindex a743e8b..3d406f2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\n@@ -63,7 +63,7 @@ public void add(Behavior... behaviors)\n \tprivate void internalAdd(final Behavior behavior)\r\n \t{\r\n \t\tcomponent.data_add(behavior);\r\n-\t\tif (behavior.getStatelessHint(component))\r\n+\t\tif (behavior.getStatelessHint(component) == false)\r\n \t\t{\r\n \t\t\tgetBehaviorId(behavior);\r\n \t\t}\r\n", "nb_test": 1529, "linesAdd": 1, "jira_id": "5400", "singleLine": false, "nb_skipped": 2, "commit": "6cefb9f8", "nb_failure": 2, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["AbstractRequestLoggerTest.foo:58 NullPointer"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/AbstractRequestLogger.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/AbstractRequestLogger.java\nindex d6a3287..34964d3 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/AbstractRequestLogger.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/AbstractRequestLogger.java\n@@ -160,20 +160,17 @@ public int getPeakSessions()\n \t */\n \tprivate void copyRequestsInOrder(RequestData[] copy)\n \t{\n+\t\tint destPos = 0;\n+\t\t\n \t\tif (hasBufferRolledOver())\n \t\t{\n-\t\t\t// first copy the oldest requests stored behind the cursor into the copy\n-\t\t\tint oldestPos = indexInWindow + 1;\n-\t\t\tif (oldestPos < requestWindow.length)\n-\t\t\t\tarraycopy(requestWindow, oldestPos, copy, 0, requestWindow.length - oldestPos);\n+\t\t\tdestPos = requestWindow.length - indexInWindow;\n \t\t\t\n-\t\t\t// then append the newer requests stored from index 0 til the cursor position.\n-\t\t\tarraycopy(requestWindow, 0, copy, requestWindow.length - oldestPos, indexInWindow);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tarraycopy(requestWindow, 0, copy, 0, indexInWindow);\n+\t\t\t// first copy the oldest requests stored behind the cursor into the copy\n+\t\t\tarraycopy(requestWindow, indexInWindow, copy, 0, destPos);\n \t\t}\n+\t\t\n+\t\tarraycopy(requestWindow, 0, copy, destPos, indexInWindow);\n \t}\n \n \t/**\n", "nb_test": 1719, "linesAdd": 6, "jira_id": "5784", "singleLine": false, "nb_skipped": 1, "commit": "b6259e5f", "nb_failure": 0, "linesRem": 8}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["dontParseMarkup(org.apache.wicket.extensions.markup.html.basic.DefaultLinkParserTest): expected:<<a href=\"[http://some.url]\">label</a>> but was:<<a href=\"[<a href=\"http://some.url\">http://some.url</a>]\">label</a>>"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/LinkParser.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/LinkParser.java\nindex ff1aa1b..8cf4356 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/LinkParser.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/LinkParser.java\n@@ -62,6 +62,10 @@ public String parse(final String text)\n \t\t}\n \n \t\tString work = text;\n+\n+\t\t// don't try to parse markup. just plain text. WICKET-4099\n+\t\tif (work.indexOf('<') == -1)\n+\t\t{\n \t\t\tfor (String pattern : renderStrategies.keySet())\n \t\t\t{\n \t\t\t\tILinkRenderStrategy strategy = renderStrategies.get(pattern);\n@@ -76,6 +80,7 @@ public String parse(final String text)\n \t\t\t\tmatcher.appendTail(buffer);\n \t\t\t\twork = buffer.toString();\n \t\t\t}\n+\t\t}\n \t\treturn work;\n \t}\n }\n", "nb_test": 16, "linesAdd": 4, "jira_id": "4099", "singleLine": false, "nb_skipped": 0, "commit": "1dcaec98", "nb_failure": 1, "linesRem": 0}, {"files": 4, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ajaxRenderOfTransparentlyResolvedLabel(org.apache.wicket.markup.resolver.issue3989.Issue3989Test): Markup not found for Component: [Component id = innerpanel]"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\nindex 30671b4..d8ac442 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n@@ -24,6 +24,7 @@\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n \n /**\n  * Implements boilerplate as needed by many markup sourcing strategies.\n@@ -42,6 +43,40 @@ public AbstractMarkupSourcingStrategy()\n \tpublic abstract IMarkupFragment getMarkup(final MarkupContainer container, final Component child);\n \n \t/**\n+\t * If the child has not been directly added to the container, but via a\n+\t * TransparentWebMarkupContainer, then we are in trouble. In general Wicket iterates over the\n+\t * markup elements and searches for associated components, not the other way around. Because of\n+\t * TransparentWebMarkupContainer (or more generally resolvers), there is no \"synchronous\" search\n+\t * possible.\n+\t * \n+\t * @param container\n+\t *            the parent container.\n+\t * @param child\n+\t *            The component to find the markup for.\n+\t * @return the markup fragment for the child, or {@code null}.\n+\t */\n+\tprotected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container,\n+\t\tfinal Component child)\n+\t{\n+\t\tIMarkupFragment markup = null;\n+\n+\t\tfor (Component ch : container)\n+\t\t{\n+\t\t\tif ((ch != child) && (ch instanceof MarkupContainer) &&\n+\t\t\t\t(ch instanceof IComponentResolver))\n+\t\t\t{\n+\t\t\t\tmarkup = ((MarkupContainer)ch).getMarkup(child);\n+\t\t\t\tif (markup != null)\n+\t\t\t\t{\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn markup;\n+\t}\n+\n+\t/**\n \t * Make sure we open up open-close tags to open-body-close\n \t */\n \tpublic void onComponentTag(final Component component, final ComponentTag tag)\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\nindex 3b61f97..d3196c6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\n@@ -119,6 +119,12 @@ public IMarkupFragment getMarkup(final MarkupContainer parent, final Component c\n \t\t\treturn associatedMarkup;\n \t\t}\n \n+\t\tassociatedMarkup = searchMarkupInTransparentResolvers(parent, child);\n+\t\tif (associatedMarkup != null)\n+\t\t{\n+\t\t\treturn associatedMarkup;\n+\t\t}\n+\n \t\treturn findMarkupInAssociatedFileHeader(parent, child);\n \t}\n \ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\nindex 9173181..24a09e9 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n@@ -23,7 +23,6 @@\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n import org.apache.wicket.markup.html.list.AbstractItem;\n-import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -32,7 +31,7 @@\n  * \n  * @author Juergen Donnerstag\n  */\n-public final class DefaultMarkupSourcingStrategy implements IMarkupSourcingStrategy\n+public final class DefaultMarkupSourcingStrategy extends AbstractMarkupSourcingStrategy\n {\n \t/** Log for reporting. */\n \tprivate static final Logger log = LoggerFactory.getLogger(DefaultMarkupSourcingStrategy.class);\n@@ -58,6 +57,7 @@ private DefaultMarkupSourcingStrategy()\n \t/**\n \t * Nothing to add to the response by default\n \t */\n+\t@Override\n \tpublic void onComponentTag(final Component component, final ComponentTag tag)\n \t{\n \t}\n@@ -65,6 +65,7 @@ public void onComponentTag(final Component component, final ComponentTag tag)\n \t/**\n \t * Invoke the component's onComponentTagBody().\n \t */\n+\t@Override\n \tpublic void onComponentTagBody(final Component component, final MarkupStream markupStream,\n \t\tfinal ComponentTag openTag)\n \t{\n@@ -74,6 +75,7 @@ public void onComponentTagBody(final Component component, final MarkupStream mar\n \t/**\n \t * Get the markup for the child component, which is assumed to be a child of 'container'.\n \t */\n+\t@Override\n \tpublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child)\n \t{\n \t\t// If the sourcing strategy did not provide one, than ask the component.\n@@ -96,23 +98,11 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t\t\treturn markup;\n \t\t}\n \n-\t\t// If the child has not been directly added to the container, but via a\n-\t\t// TransparentWebMarkupContainer, then we are in trouble. In general Wicket iterates over\n-\t\t// the markup elements and searches for associated components, not the other way around.\n-\t\t// Because of TransparentWebMarkupContainer (or more generally resolvers), there is no\n-\t\t// \"synchronous\" search possible.\n-\t\tfor (Component ch : container)\n-\t\t{\n-\t\t\tif ((ch != child) && (ch instanceof MarkupContainer) &&\n-\t\t\t\t(ch instanceof IComponentResolver))\n-\t\t\t{\n-\t\t\t\tmarkup = ((MarkupContainer)ch).getMarkup(child);\n+\t\tmarkup = searchMarkupInTransparentResolvers(container, child);\n \t\tif (markup != null)\n \t\t{\n \t\t\treturn markup;\n \t\t}\n-\t\t\t}\n-\t\t}\n \n \t\t// This is to make migration for Items from 1.4 to 1.5 more easy\n \t\tif (Character.isDigit(child.getId().charAt(0)))\n@@ -156,6 +146,7 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t/**\n \t * Empty: nothing will be added to the header by default\n \t */\n+\t@Override\n \tpublic void renderHead(final Component component, HtmlHeaderContainer container)\n \t{\n \t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java\nindex bfc2240..7cc8fb2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java\n@@ -22,6 +22,7 @@\n import org.apache.wicket.markup.IMarkupFragment;\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n \n /**\n  * Markup sourcing strategies determine whether a Component behaves like a \"Panel\" pulling its\n@@ -79,10 +80,11 @@ void onComponentTagBody(final Component component, final MarkupStream markupStre\n \t * @see MarkupContainer#getMarkup(Component)\n \t * \n \t * @param container\n-\t *            The parent containing the child. (@TODO Is container ever != child.getParent()??)\n+\t *            The parent containing the child. This is not the direct parent, transparent\n+\t *            component {@link IComponentResolver resolver} may be in the hierarchy between.\n \t * @param child\n \t *            The component to find the markup for.\n-\t * @return markup fragment\n+\t * @return the markup fragment for the child, or {@code null}.\n \t */\n \tIMarkupFragment getMarkup(final MarkupContainer container, final Component child);\n }\n", "nb_test": 1130, "linesAdd": 35, "jira_id": "3989", "singleLine": false, "nb_skipped": 2, "commit": "6a8fc1cc", "nb_failure": 0, "linesRem": 10}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDecorateScript(org.apache.wicket.ajax.AjaxPreprocessingCallDecoratorTest)", "testDecorateOnSuccessScript(org.apache.wicket.ajax.AjaxPreprocessingCallDecoratorTest)", "testDecorateOnFailureScript(org.apache.wicket.ajax.AjaxPreprocessingCallDecoratorTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/ajax/calldecorator/AjaxPreprocessingCallDecorator.java b/wicket/src/main/java/org/apache/wicket/ajax/calldecorator/AjaxPreprocessingCallDecorator.java\nindex f57a2d4..a37d6ed 100644\n--- a/wicket/src/main/java/org/apache/wicket/ajax/calldecorator/AjaxPreprocessingCallDecorator.java\n+++ b/wicket/src/main/java/org/apache/wicket/ajax/calldecorator/AjaxPreprocessingCallDecorator.java\n@@ -49,8 +49,9 @@ public AjaxPreprocessingCallDecorator(IAjaxCallDecorator delegate)\n \t */\n \tpublic CharSequence decorateScript(CharSequence script)\n \t{\n-\t\tCharSequence s = (delegate == null) ? script : delegate.decorateScript(script);\n-\t\treturn preDecorateScript(s);\n+\t\tCharSequence s = preDecorateScript(script);\n+\t\treturn (delegate == null) ? s : delegate.decorateScript(s);\n+\n \t}\n \n \t/**\n@@ -58,8 +59,8 @@ public CharSequence decorateScript(CharSequence script)\n \t */\n \tpublic CharSequence decorateOnSuccessScript(CharSequence script)\n \t{\n-\t\tCharSequence s = (delegate == null) ? script : delegate.decorateOnSuccessScript(script);\n-\t\treturn preDecorateOnSuccessScript(s);\n+\t\tCharSequence s = preDecorateOnSuccessScript(script);\n+\t\treturn (delegate == null) ? s : delegate.decorateOnSuccessScript(s);\n \t}\n \n \t/**\n@@ -67,8 +68,9 @@ public CharSequence decorateOnSuccessScript(CharSequence script)\n \t */\n \tpublic CharSequence decorateOnFailureScript(CharSequence script)\n \t{\n-\t\tCharSequence s = (delegate == null) ? script : delegate.decorateOnFailureScript(script);\n-\t\treturn preDecorateOnFailureScript(s);\n+\t\tCharSequence s = preDecorateOnFailureScript(script);\n+\n+\t\treturn (delegate == null) ? s : delegate.decorateOnFailureScript(s);\n \t}\n \n \n", "nb_test": 757, "linesAdd": 8, "jira_id": "2057", "singleLine": false, "nb_skipped": 0, "commit": "e2d88568", "nb_failure": 3, "linesRem": 6}, {"files": 2, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testDirectFieldSetWithDifferentTypeThanGetter(org.apache.wicket.util.lang.PropertyResolverTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/util/convert/ConverterLocator.java b/wicket/src/main/java/org/apache/wicket/util/convert/ConverterLocator.java\nindex fc09b99..0b9b093 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/convert/ConverterLocator.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/convert/ConverterLocator.java\n@@ -101,7 +101,7 @@ public Object convertToObject(String value, Locale locale)\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\tthrow new ConversionException(\"Could not convert value: \" + value +\n-\t\t\t\t\t\t\" to type: \" + theType.getName() + \"(Could not find compatible converter).\").setSourceValue(value);\n+\t\t\t\t\t\t\" to type: \" + theType.getName() + \". Could not find compatible converter.\").setSourceValue(value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception e)\ndiff --git a/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java b/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\nindex d83ba14..64a717b 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\n@@ -1094,6 +1094,9 @@ public final void setValue(final Object object, final Object value,\n \t\t\tClass type = null;\n \t\t\tif (setMethod != null)\n \t\t\t{\n+\t\t\t\t// getMethod is always there and if the value will be set through a setMethod then\n+\t\t\t\t// the getMethod return type will be its type. Else we have to look at the\n+\t\t\t\t// parameters if the setter but getting the return type is quicker\n \t\t\t\ttype = getMethod.getReturnType();\n \t\t\t}\n \t\t\telse if (field != null)\n@@ -1104,7 +1107,7 @@ else if (field != null)\n \t\t\tObject converted = null;\n \t\t\tif (type != null)\n \t\t\t{\n-\t\t\t\tconverted = converter.convert(value, getMethod.getReturnType());\n+\t\t\t\tconverted = converter.convert(value, type);\n \t\t\t\tif (converted == null)\n \t\t\t\t{\n \t\t\t\t\tif (value != null)\n", "nb_test": 940, "linesAdd": 2, "jira_id": "2624", "singleLine": false, "nb_skipped": 0, "commit": "ef880545", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["compact(org.apache.wicket.request.UrlTest): expected:<a/[]d> but was:<a/[b/../]d>"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 11f6b47..e950f6f 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -1219,18 +1219,22 @@ public Url canonical()\n \t\t\t// drop '.' from path\n \t\t\tif (\".\".equals(segment))\n \t\t\t{\n-\t\t\t\tcontinue;\n+\t\t\t\t// skip\n+\t\t\t}\n+\t\t\telse if (\"..\".equals(segment) && url.segments.isEmpty() == false)\n+\t\t\t{\n+\t\t\t\turl.segments.remove(url.segments.size() - 1);\n \t\t\t}\n-\n \t\t\t// skip segment if following segment is a '..'\n-\t\t\tif ((i + 1) < segments.size() && \"..\".equals(segments.get(i + 1)))\n+\t\t\telse if ((i + 1) < segments.size() && \"..\".equals(segments.get(i + 1)))\n \t\t\t{\n \t\t\t\ti++;\n-\t\t\t\tcontinue;\n \t\t\t}\n-\n+\t\t\telse\n+\t\t\t{\n \t\t\t\turl.segments.add(segment);\n \t\t\t}\n+\t\t}\n \t\treturn url;\n \t}\n }\n", "nb_test": 99, "linesAdd": 8, "jira_id": "5345", "singleLine": false, "nb_skipped": 0, "commit": "3fc7234e", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["requestAPageInAjaxButReceiveItInNonAjaxResponse(org.apache.wicket.RestartResponseAtInterceptPageExceptionInAjaxTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\nindex 69fe186..6c425c0 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n@@ -19,6 +19,7 @@\n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n \n@@ -27,11 +28,13 @@\n import org.apache.wicket.request.IWritableRequestParameters;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n+import org.apache.wicket.request.Url.QueryParameter;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.flow.ResetResponseException;\n import org.apache.wicket.request.handler.PageProvider;\n import org.apache.wicket.request.handler.RenderPageRequestHandler;\n import org.apache.wicket.request.handler.RenderPageRequestHandler.RedirectPolicy;\n+import org.apache.wicket.request.http.WebRequest;\n import org.apache.wicket.request.http.handler.RedirectRequestHandler;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n import org.apache.wicket.util.string.StringValue;\n@@ -110,9 +113,27 @@ public static void set()\n \t\t\tInterceptData data = new InterceptData();\n \t\t\tRequest request = RequestCycle.get().getRequest();\n \t\t\tdata.originalUrl = request.getOriginalUrl();\n+\t\t\tIterator<QueryParameter> itor = data.originalUrl.getQueryParameters().iterator();\n+\t\t\twhile (itor.hasNext())\n+\t\t\t{\n+\t\t\t\tQueryParameter parameter = itor.next();\n+\t\t\t\tString parameterName = parameter.getName();\n+\t\t\t\tif (WebRequest.PARAM_AJAX.equals(parameterName) ||\n+\t\t\t\t\tWebRequest.PARAM_AJAX_BASE_URL.equals(parameterName) ||\n+\t\t\t\t\tWebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE.equals(parameterName))\n+\t\t\t\t{\n+\t\t\t\t\titor.remove();\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tdata.postParameters = new HashMap<String, List<StringValue>>();\n \t\t\tfor (String s : request.getPostParameters().getParameterNames())\n \t\t\t{\n+\t\t\t\tif (WebRequest.PARAM_AJAX.equals(s) || WebRequest.PARAM_AJAX_BASE_URL.equals(s) ||\n+\t\t\t\t\tWebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE.equals(s))\n+\t\t\t\t{\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \t\t\t\tdata.postParameters.put(s, new ArrayList<StringValue>(request.getPostParameters()\n \t\t\t\t\t.getParameterValues(s)));\n \t\t\t}\n", "nb_test": 1274, "linesAdd": 21, "jira_id": "4251", "singleLine": false, "nb_skipped": 4, "commit": "53bcb78d", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testSerializationOutsideWicketLifecyle(org.apache.wicket.page.PersistentPageManagerTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/pageStore/DefaultPageStore.java b/wicket-core/src/main/java/org/apache/wicket/pageStore/DefaultPageStore.java\nindex 17a812b..675f320 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/pageStore/DefaultPageStore.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/pageStore/DefaultPageStore.java\n@@ -22,7 +22,6 @@\n import java.util.Iterator;\n import java.util.List;\n \n-import org.apache.wicket.Page;\n import org.apache.wicket.page.IManageablePage;\n import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Objects;\n@@ -275,7 +274,7 @@ public Object restoreAfterSerialization(final Serializable serializable)\n \t\t{\n \t\t\treturn null;\n \t\t}\n-\t\telse if (!storeAfterSessionReplication() || serializable instanceof Page)\n+\t\telse if (!storeAfterSessionReplication() || serializable instanceof IManageablePage)\n \t\t{\n \t\t\treturn serializable;\n \t\t}\n", "nb_test": 1084, "linesAdd": 1, "jira_id": "3420", "singleLine": false, "nb_skipped": 0, "commit": "be97d017", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTestLinks(org.apache.wicket.markup.html.link.BookmarkableHomePageLinksTest)", "testRenderHomePage_1(org.apache.wicket.markup.html.link.AutolinkTest)", "testRenderHomePage_2(org.apache.wicket.markup.html.link.AutolinkTest)", "testStatelessComponentPageWithParams(org.apache.wicket.stateless.StatelessComponentTest)", "testStatelessComponentPageWithParamsWithMount(org.apache.wicket.stateless.StatelessComponentTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/link/Link.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/link/Link.java\nindex f674c75..bc4b4f1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/link/Link.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/link/Link.java\n@@ -21,7 +21,6 @@\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.model.IModel;\n-import org.apache.wicket.util.string.Strings;\n \n /**\n  * Implementation of a hyperlink component. A link can be used with an anchor (&lt;a href...)\n@@ -368,7 +367,7 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\t\ttag.getName().equalsIgnoreCase(\"area\"))\n \t\t\t{\n \t\t\t\t// generate the href attribute\n-\t\t\t\ttag.put(\"href\", Strings.replaceAll(url, \"&\", \"&amp;\"));\n+\t\t\t\ttag.put(\"href\", url);\n \n \t\t\t\t// Add any popup script\n \t\t\t\tif (popupSettings != null)\n@@ -381,7 +380,7 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\telse if (tag.getName().equalsIgnoreCase(\"script\") ||\n \t\t\t\ttag.getName().equalsIgnoreCase(\"style\"))\n \t\t\t{\n-\t\t\t\ttag.put(\"src\", Strings.replaceAll(url, \"&\", \"&amp;\"));\n+\t\t\t\ttag.put(\"src\", url);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n@@ -401,7 +400,8 @@ else if (tag.getName().equalsIgnoreCase(\"script\") ||\n \t\t\t\t\t\t\"onclick\",\n \t\t\t\t\t\t\"var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; \" +\n \t\t\t\t\t\t\t\"if (win == window) { window.location.href='\" +\n-\t\t\t\t\t\t\tStrings.replaceAll(url, \"&\", \"&amp;\") + \"'; } ;return false\");\n+\t\t\t\t\t\t\turl +\n+\t\t\t\t\t\t\t\"'; } ;return false\");\n \t\t\t\t}\n \t\t\t}\n \n", "nb_test": 1050, "linesAdd": 4, "jira_id": "3333", "singleLine": false, "nb_skipped": 0, "commit": "ddf7e8a2", "nb_failure": 5, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["renderHomePage_12(org.apache.wicket.markup.html.basic.SimplePageTest): org/apache/wicket/markup/html/basic/SimplePageExpectedResult_12.html expected:<...ll;(..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\nindex dc5d080..42e63b6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\n@@ -30,12 +30,10 @@\n import org.apache.wicket.markup.WicketTag;\n import org.apache.wicket.markup.head.IHeaderResponse;\n import org.apache.wicket.markup.head.PageHeaderItem;\n-import org.apache.wicket.markup.head.StringHeaderItem;\n import org.apache.wicket.markup.head.internal.HeaderResponse;\n import org.apache.wicket.markup.html.TransparentWebMarkupContainer;\n import org.apache.wicket.markup.renderStrategy.AbstractHeaderRenderStrategy;\n import org.apache.wicket.request.Response;\n-import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.response.StringResponse;\n \n \n@@ -227,7 +225,7 @@ public void renderHeaderTagBody(HeaderStreamState headerStreamState)\n \t\t\tCharSequence bodyOutput = getCleanResponse(bodyResponse);\n \t\t\tif (bodyOutput.length() > 0)\n \t\t\t{\n-\t\t\t\tgetHeaderResponse().render(StringHeaderItem.forString(bodyOutput));\n+\t\t\t\tgetHeaderResponse().render(new PageHeaderItem(bodyOutput));\n \t\t\t}\n \t\t}\n \t\tfinally\n@@ -354,32 +352,6 @@ public IHeaderResponse getHeaderResponse()\n \t\treturn headerResponse;\n \t}\n \n-\t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.\n-\t * \n-\t * Temporarily replaces the response with a StringResponse to capture the header output for this\n-\t * part of the stream and pass it to {@link IHeaderResponse}.\n-\t * \n-\t * @see org.apache.wicket.MarkupContainer#renderNext(org.apache.wicket.markup.MarkupStream)\n-\t */\n-\t@Override\n-\tprotected final boolean renderNext(MarkupStream markupStream)\n-\t{\n-\t\tStringResponse markupHeaderResponse = new StringResponse();\n-\t\tResponse oldResponse = getResponse();\n-\t\tRequestCycle.get().setResponse(markupHeaderResponse);\n-\t\ttry\n-\t\t{\n-\t\t\tboolean ret = super.renderNext(markupStream);\n-\t\t\tgetHeaderResponse().render(new PageHeaderItem(markupHeaderResponse.getBuffer()));\n-\t\t\treturn ret;\n-\t\t}\n-\t\tfinally\n-\t\t{\n-\t\t\tRequestCycle.get().setResponse(oldResponse);\n-\t\t}\n-\t}\n-\n \t@Override\n \tpublic IMarkupFragment getMarkup()\n \t{\n", "nb_test": 1411, "linesAdd": 1, "jira_id": "4766", "singleLine": false, "nb_skipped": 5, "commit": "cda34428", "nb_failure": 1, "linesRem": 21}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testInsert(org.apache.wicket.util.string.AppendingStringBufferTest)"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/string/AppendingStringBuffer.java b/wicket-util/src/main/java/org/apache/wicket/util/string/AppendingStringBuffer.java\nindex a8abb5f..19e69a6 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/string/AppendingStringBuffer.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/string/AppendingStringBuffer.java\n@@ -37,6 +37,7 @@\n \r\n \tprivate static final AppendingStringBuffer NULL = new AppendingStringBuffer(\"null\");\r\n \tprivate static final StringBuilder SB_NULL = new StringBuilder(\"null\");\r\n+\tprivate static final StringBuffer SBF_NULL = new StringBuffer(\"null\");\r\n \r\n \t/**\r\n \t * The value is used for character storage.\r\n@@ -947,7 +948,11 @@ public AppendingStringBuffer insert(final int offset, final Object obj)\n \t\t}\r\n \t\telse if (obj instanceof StringBuffer)\r\n \t\t{\r\n-\t\t\treturn insert(offset, obj);\r\n+\t\t\treturn insert(offset, (StringBuffer)obj);\r\n+\t\t}\r\n+\t\telse if (obj instanceof StringBuilder)\r\n+\t\t{\r\n+\t\t\treturn insert(offset, (StringBuilder)obj);\r\n \t\t}\r\n \t\treturn insert(offset, String.valueOf(obj));\r\n \t}\r\n@@ -1010,9 +1015,9 @@ public AppendingStringBuffer insert(final int offset, String str)\n \t/**\r\n \t * Inserts the string into this string buffer.\r\n \t * <p>\r\n-\t * The characters of the <code>String</code> argument are inserted, in order, into this string\r\n-\t * buffer at the indicated offset, moving up any characters originally above that position and\r\n-\t * increasing the length of this string buffer by the length of the argument. If\r\n+\t * The characters of the <code>StringBuilder</code> argument are inserted, in order, into this\r\n+\t * string buffer at the indicated offset, moving up any characters originally above that\r\n+\t * position and increasing the length of this string buffer by the length of the argument. If\r\n \t * <code>str</code> is <code>null</code>, then the four characters <code>\"null\"</code> are\r\n \t * inserted into this string buffer.\r\n \t * <p>\r\n@@ -1063,6 +1068,61 @@ public AppendingStringBuffer insert(final int offset, StringBuilder str)\n \t}\r\n \r\n \t/**\r\n+\t * Inserts the string into this string buffer.\r\n+\t * <p>\r\n+\t * The characters of the <code>StringBuffer</code> argument are inserted, in order, into this\r\n+\t * string buffer at the indicated offset, moving up any characters originally above that\r\n+\t * position and increasing the length of this string buffer by the length of the argument. If\r\n+\t * <code>str</code> is <code>null</code>, then the four characters <code>\"null\"</code> are\r\n+\t * inserted into this string buffer.\r\n+\t * <p>\r\n+\t * The character at index <i>k</i> in the new character sequence is equal to:\r\n+\t * <ul>\r\n+\t * <li>the character at index <i>k</i> in the old character sequence, if <i>k</i> is less than\r\n+\t * <code>offset</code>\r\n+\t * <li>the character at index <i>k</i><code>-offset</code> in the argument <code>str</code>, if\r\n+\t * <i>k</i> is not less than <code>offset</code> but is less than\r\n+\t * <code>offset+str.length()</code>\r\n+\t * <li>the character at index <i>k</i><code>-str.length()</code> in the old character sequence,\r\n+\t * if <i>k</i> is not less than <code>offset+str.length()</code>\r\n+\t * </ul>\r\n+\t * <p>\r\n+\t * The offset argument must be greater than or equal to <code>0</code>, and less than or equal\r\n+\t * to the length of this string buffer.\r\n+\t * \r\n+\t * @param offset\r\n+\t *            the offset.\r\n+\t * @param str\r\n+\t *            a string.\r\n+\t * @return a reference to this <code>AppendingStringBuffer</code> object.\r\n+\t * @exception StringIndexOutOfBoundsException\r\n+\t *                if the offset is invalid.\r\n+\t * @see java.lang.StringBuffer#length()\r\n+\t */\r\n+\tpublic AppendingStringBuffer insert(final int offset, StringBuffer str)\r\n+\t{\r\n+\t\tif ((offset < 0) || (offset > count))\r\n+\t\t{\r\n+\t\t\tthrow new StringIndexOutOfBoundsException();\r\n+\t\t}\r\n+\r\n+\t\tif (str == null)\r\n+\t\t{\r\n+\t\t\tstr = SBF_NULL;\r\n+\t\t}\r\n+\t\tint len = str.length();\r\n+\t\tint newcount = count + len;\r\n+\t\tif (newcount > value.length)\r\n+\t\t{\r\n+\t\t\texpandCapacity(newcount);\r\n+\t\t}\r\n+\t\tSystem.arraycopy(value, offset, value, offset + len, count - offset);\r\n+\t\tstr.getChars(0, len, value, offset);\r\n+\t\tcount = newcount;\r\n+\t\treturn this;\r\n+\t}\r\n+\r\n+\t/**\r\n \t * Inserts the string representation of the <code>char</code> array argument into this string\r\n \t * buffer.\r\n \t * <p>\r\n", "nb_test": 141, "linesAdd": 29, "jira_id": "4184", "singleLine": false, "nb_skipped": 0, "commit": "a0150366", "nb_failure": 0, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["submitLinkInputNameNotEncodedIntoFormAction(org.apache.wicket.stateless.StatelessFormUrlTest)", "formComponentNameNotEncodedIntoFormAction(org.apache.wicket.stateless.StatelessFormUrlTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex a0f3654..46dbefc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -796,10 +796,6 @@ else if (hasError())\n \t */\n \tpublic void process(IFormSubmitter submittingComponent)\n \t{\n-\t\t// save the page in case the component is removed during submit\n-\t\tfinal Page page = getPage();\n-\t\tString hiddenFieldId = getHiddenFieldId();\n-\n \t\tif (!isEnabledInHierarchy() || !isVisibleInHierarchy())\n \t\t{\n \t\t\t// since process() can be called outside of the default form workflow, an additional\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/StatelessForm.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/StatelessForm.java\nindex 034519c..2442556 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/StatelessForm.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/StatelessForm.java\n@@ -17,6 +17,9 @@\n package org.apache.wicket.markup.html.form;\n \n import org.apache.wicket.model.IModel;\n+import org.apache.wicket.request.mapper.parameter.PageParameters;\n+import org.apache.wicket.util.visit.IVisit;\n+import org.apache.wicket.util.visit.IVisitor;\n \n /**\n  * This StatelessForm is the same as a normal form but with the statelesshint default to true. The\n@@ -72,4 +75,33 @@ protected CharSequence getActionUrl()\n \t{\n \t\treturn urlFor(IFormSubmitListener.INTERFACE, getPage().getPageParameters());\n \t}\n+\n+\t/**\n+\t * Remove the page parameters for all form component otherwise they get appended to action URL\n+\t *\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void process(IFormSubmitter submittingComponent)\n+\t{\n+\t\tsuper.process(submittingComponent);\n+\n+\t\tfinal PageParameters parameters = getPage().getPageParameters();\n+\t\tif (parameters != null)\n+\t\t{\n+\t\t\tvisitFormComponents(new IVisitor<FormComponent<?>, Void>()\n+\t\t\t{\n+\t\t\t\tpublic void component(final FormComponent<?> formComponent, final IVisit<Void> visit)\n+\t\t\t\t{\n+\t\t\t\t\tparameters.remove(formComponent.getInputName());\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tparameters.remove(getHiddenFieldId());\n+\t\t\tif (submittingComponent instanceof AbstractSubmitLink)\n+\t\t\t{\n+\t\t\t\tAbstractSubmitLink submitLink = (AbstractSubmitLink)submittingComponent;\n+\t\t\t\tparameters.remove(submitLink.getInputName());\n+\t\t\t}\n+\t\t}\n+\t}\n }\n", "nb_test": 1292, "linesAdd": 27, "jira_id": "4365", "singleLine": false, "nb_skipped": 4, "commit": "1485a856", "nb_failure": 2, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["wicket5203(org.apache.wicket.protocol.http.servlet.ServletWebRequestTest): expected:<[]any/source/of/error> but was:<[filterPath/]any/source/of/error>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\nindex 83df540..24947bb 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\n@@ -102,20 +102,7 @@ public ServletWebRequest(HttpServletRequest httpServletRequest, String filterPre\n \n \t\tforwardAttributes = ForwardAttributes.of(httpServletRequest, filterPrefix);\n \n-\t\tif (forwardAttributes != null || errorAttributes != null)\n-\t\t{\n-\t\t\tif (LOG.isDebugEnabled())\n-\t\t\t{\n-\t\t\t\tLOG.debug(\"Setting filterPrefix('{}') to '' because there is either an error or a forward. {}, {}\",\n-\t\t\t\t\t\tnew Object[] {filterPrefix, forwardAttributes, errorAttributes});\n-\t\t\t}\n-\t\t\t// the filter prefix is not needed when the current request is internal\n-\t\t\t// see WICKET-4387\n-\t\t\tthis.filterPrefix = \"\";\n-\t\t} else\n-\t\t{\n \t\tthis.filterPrefix = filterPrefix;\n-\t\t}\n \n \t\tif (url != null)\n \t\t{\n", "nb_test": 1474, "linesAdd": 0, "jira_id": "5203", "singleLine": false, "nb_skipped": 4, "commit": "2293764f", "nb_failure": 1, "linesRem": 11}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ignorePageFoundByIdIfItsClassDoesntMatch(org.apache.wicket.request.handler.PageProviderTest): expected:<class org.apache.wicket.MockPageWithLink> but was:<class org.apache.wicket.request.handler.PageProviderTest$TestPage>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\nindex f239c4d..50402f6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n@@ -294,18 +294,22 @@ private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePag\n \tprivate IRequestablePage getStoredPage(final int pageId)\n \t{\n \t\tIRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\n-\t\tif (storedPageInstance != null &&\n-\t\t\t(pageClass == null || pageClass.equals(storedPageInstance.getClass())))\n+\t\tif (storedPageInstance != null)\n+\t\t{\n+\t\t\tif (pageClass == null || pageClass.equals(storedPageInstance.getClass()))\n \t\t\t{\n \t\t\t\tpageInstance = storedPageInstance;\n \t\t\t\tpageInstanceIsFresh = false;\n-\t\t\tif (pageInstance != null)\n-\t\t\t{\n \t\t\t\tif (renderCount != null && pageInstance.getRenderCount() != renderCount)\n \t\t\t\t{\n \t\t\t\t\tthrow new StalePageException(pageInstance);\n \t\t\t\t}\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\t// the found page class doesn't match the requested one\n+\t\t\t\tstoredPageInstance = null;\n+\t\t\t}\n \t\t}\n \t\treturn storedPageInstance;\n \t}\n", "nb_test": 1325, "linesAdd": 7, "jira_id": "4488", "singleLine": false, "nb_skipped": 8, "commit": "e6582c52", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["test(org.apache.wicket.markup.RefreshingViewOnRemoveTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 422dc3f..beca6b1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -631,6 +631,7 @@ public final void removeAll()\n \n \t\t\t\t\t// Do not call remove() because the state change would than be\n \t\t\t\t\t// recorded twice.\n+\t\t\t\t\tchild.internalOnRemove();\n \t\t\t\t\tchild.detachModel();\n \t\t\t\t\tchild.setParent(null);\n \t\t\t\t}\n", "nb_test": 1067, "linesAdd": 1, "jira_id": "3455", "singleLine": true, "nb_skipped": 0, "commit": "f30bd1cb", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testShouldRenderPageAndWriteResponseVariation(org.apache.wicket.request.handler.render.WebPageRendererTest): ajax=true,onePassRender=false,redirectToRender=false,redirectPolicy=ALWAYS_REDIRECT,shouldPreserveClientUrl=true,targetEqualsCurrentUrl=false,newPageInstance=false,pageStateless=false, expected:<false> but was:<true>", "testNeverRedirectButAjaxRequest(org.apache.wicket.request.handler.render.WebPageRendererTest): (..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex 4b95e32..8c99c13 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -332,10 +332,16 @@ protected boolean shouldRedirectToTargetUrl(RequestCycle cycle, Url currentUrl,\n \tprotected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl,\n \t\tUrl targetUrl)\n \t{\n+\t\t// WICKET-5484 never render and write for Ajax requests\n+\t\tif (isAjax(cycle))\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n \t\treturn neverRedirect(getRedirectPolicy())\n-\t\t\t|| (!isAjax(cycle) && ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl\n+\t\t\t|| ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl\n \t\t\t\t.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(),\n-\t\t\t\tisPageStateless())))) || (targetUrl.equals(currentUrl) && isRedirectToRender())\n+\t\t\t\tisPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender())\n \t\t\t|| shouldPreserveClientUrl(cycle);\n \t}\n \n", "nb_test": 1566, "linesAdd": 7, "jira_id": "5484", "singleLine": false, "nb_skipped": 2, "commit": "ecdfc124", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["fileNameModel(org.apache.wicket.markup.html.link.DownloadLinkTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/link/DownloadLink.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/link/DownloadLink.java\nindex 3974b18..293a239 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/link/DownloadLink.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/link/DownloadLink.java\n@@ -135,7 +135,18 @@ public DownloadLink(String id, File file, String fileName)\n \tpublic DownloadLink(String id, IModel<File> fileModel, IModel<String> fileNameModel)\n \t{\n \t\tsuper(id, fileModel);\n-\t\tthis.fileNameModel = fileNameModel;\n+\t\tthis.fileNameModel = wrap(fileNameModel);\n+\t}\n+\n+\t@Override\n+\tpublic void detachModels()\n+\t{\n+\t\tsuper.detachModels();\n+\n+\t\tif (fileNameModel != null)\n+\t\t{\n+\t\t\tfileNameModel.detach();\n+\t\t}\n \t}\n \n \t@Override\n", "nb_test": 1404, "linesAdd": 12, "jira_id": "4738", "singleLine": false, "nb_skipped": 5, "commit": "a7ce7f91", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["isPageInstanceCreatedOnClassLinks(org.apache.wicket.request.handler.ListenerInterfaceRequestHandlerTest): Handler should not report a page instance is available"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\nindex a4b5817..0c497d5 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\n@@ -249,8 +249,16 @@ private void invokeListener()\n \n \tpublic final boolean isPageInstanceCreated()\n \t{\n-\t\t// this request handler always operates on a created page instance\n-\t\treturn true;\n+\t\t// FIXME wicket.next remove the workaround for page providers that don't implement the\n+\t\t// interface\n+\t\tif (!(pageComponentProvider instanceof IIntrospectablePageProvider))\n+\t\t{\n+\t\t\tLOG.warn(\n+\t\t\t\t\"{} used by this application does not implement {}, the request handler is falling back on using incorrect behavior\",\n+\t\t\t\tIPageProvider.class, IIntrospectablePageProvider.class);\n+\t\t\treturn !pageComponentProvider.isNewPageInstance();\n+\t\t}\n+\t\treturn ((IIntrospectablePageProvider)pageComponentProvider).hasPageInstance();\n \t}\n \n \tpublic final String getComponentPath()\n", "nb_test": 1239, "linesAdd": 8, "jira_id": "4185", "singleLine": false, "nb_skipped": 3, "commit": "5fd03973", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["test_1(org.apache.wicket.markup.resolver.border.WicketMessageResolverTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/resolver/WicketMessageResolver.java b/wicket-core/src/main/java/org/apache/wicket/markup/resolver/WicketMessageResolver.java\nindex 03d7acd..fa4122a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/resolver/WicketMessageResolver.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/resolver/WicketMessageResolver.java\n@@ -347,7 +348,8 @@ protected String getValue(final String variableName)\n \t\t\t\t\t// If it a tag like <wicket..> or <span wicket:id=\"...\" >\n \t\t\t\t\tif ((element instanceof ComponentTag) && !markupStream.atCloseTag())\n \t\t\t\t\t{\n-\t\t\t\t\t\tString id = ((ComponentTag)element).getId();\n+\t\t\t\t\t\tComponentTag currentTag = (ComponentTag)element;\n+\t\t\t\t\t\tString id = currentTag.getId();\n \n \t\t\t\t\t\t// Temporarily replace the web response with a String response\n \t\t\t\t\t\tfinal Response webResponse = getResponse();\n@@ -358,6 +360,18 @@ protected String getValue(final String variableName)\n \t\t\t\t\t\t\tgetRequestCycle().setResponse(response);\n \n \t\t\t\t\t\t\tComponent component = getParent().get(id);\n+\t\t\t\t\t\t\tif (component == null)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tcomponent = ComponentResolvers.resolve(getParent(), markupStream,\n+\t\t\t\t\t\t\t\t\tcurrentTag, null);\n+\n+\t\t\t\t\t\t\t\t// Must not be a Page and it must be connected to a parent.\n+\t\t\t\t\t\t\t\tif (component.getParent() == null)\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\tcomponent = null;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\n \t\t\t\t\t\t\tif (component != null)\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tcomponent.render();\n", "nb_test": 1066, "linesAdd": 13, "jira_id": "3454", "singleLine": false, "nb_skipped": 0, "commit": "f1e854b3", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDetachRemovedChildrenTree(org.apache.wicket.model.DetachableTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 17f43d7..b72702e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -644,7 +644,7 @@ public MarkupContainer removeAll()\n \t\t\t\t\t// Do not call remove() because the state change would than be\n \t\t\t\t\t// recorded twice.\n \t\t\t\t\tchild.internalOnRemove();\n-\t\t\t\t\tchild.detachModel();\n+\t\t\t\t\tchild.detach();\n \t\t\t\t\tchild.setParent(null);\n \t\t\t\t}\n \t\t\t}\n", "nb_test": 1247, "linesAdd": 1, "jira_id": "3872", "singleLine": false, "nb_skipped": 2, "commit": "3feb0e3a", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMinifiedNameDetectMinInName(org.apache.wicket.request.resource.PackageResourceReferenceTest): expected:<html5.min.[]js> but was:<html5.min.[min.]js>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\nindex cc72731..710eef2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n@@ -207,7 +207,14 @@ protected String getMinifiedName()\n \t\tif (idxOfExtension > -1)\n \t\t{\n \t\t\tString extension = name.substring(idxOfExtension);\n-\t\t\tminifiedName = name.substring(0, name.length() - extension.length() + 1) + \"min\" + extension;\n+            final String baseName = name.substring(0, name.length() - extension.length() + 1);\n+            if (!\".min\".equals(extension) && !baseName.endsWith(\".min.\"))\n+            {\n+                minifiedName = baseName + \"min\" + extension;\n+            } else\n+            {\n+                minifiedName = name;\n+            }\n \t\t} else\n \t\t{\n \t\t\tminifiedName = name + \".min\";\n", "nb_test": 1502, "linesAdd": 8, "jira_id": "5251", "singleLine": false, "nb_skipped": 3, "commit": "3d2393c7", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["test11(org.apache.wicket.markup.html.border.BoxBorderTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/Page.java b/wicket/src/main/java/org/apache/wicket/Page.java\nindex 756036f..7ec9bc2 100644\n--- a/wicket/src/main/java/org/apache/wicket/Page.java\n+++ b/wicket/src/main/java/org/apache/wicket/Page.java\n@@ -1067,7 +1067,7 @@ public Object component(final Component component)\n \t\t\t\t\t// If component never rendered\n \t\t\t\t\tif (renderedComponents == null || !renderedComponents.contains(component))\n \t\t\t\t\t{\n-\t\t\t\t\t\t// If auto component ...\n+\t\t\t\t\t\t// If not an auto component ...\n \t\t\t\t\t\tif (!component.isAuto() && component.isVisibleInHierarchy())\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\t// Increase number of unrendered components\n@@ -1106,8 +1106,7 @@ public Object component(final Component component)\n \t\t\t\trenderedComponents = null;\n \n \t\t\t\tIterator<Component> iterator = unrenderedComponents.iterator();\n-\n-\t\t\t\twhile (iterator.hasNext())\n+\t\t\t\touterWhile : while (iterator.hasNext())\n \t\t\t\t{\n \t\t\t\t\tComponent component = iterator.next();\n \t\t\t\t\t// Now first test if the component has a sibling that is a transparent resolver.\n@@ -1129,7 +1128,7 @@ public Object component(final Component component)\n \t\t\t\t\t\t\t\t\t\"Component {} wasn't rendered but most likely it has a transparent parent: {}\",\n \t\t\t\t\t\t\t\t\tcomponent, sibling);\n \t\t\t\t\t\t\t\titerator.remove();\n-\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\tcontinue outerWhile;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n", "nb_test": 799, "linesAdd": 2, "jira_id": "2368", "singleLine": false, "nb_skipped": 0, "commit": "fae1601b", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["itFailsToProcessAnExpiredPageIfShouldNotRecreateMountedPagesAfterExpiry(org.apache.wicket.core.request.mapper.AbstractBookmarkableMapperTest): Unexpected exception, expected<org.apache.wicket.protocol.http.PageExpiredException> but was<java.lang.AssertionError>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\nindex 86c64a6..56e27d4 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n@@ -24,6 +24,8 @@\n import org.apache.wicket.core.request.handler.PageAndComponentProvider;\n import org.apache.wicket.core.request.handler.PageProvider;\n import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n+import org.apache.wicket.protocol.http.PageExpiredException;\n+import org.apache.wicket.protocol.http.WebApplication;\n import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.IRequestHandlerDelegate;\n import org.apache.wicket.request.IRequestMapper;\n@@ -208,8 +210,17 @@ protected IRequestHandler processHybrid(PageInfo pageInfo,\n \t\tPageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters,\n \t\t\trenderCount);\n \t\tprovider.setPageSource(getContext());\n+\t\tif (provider.isNewPageInstance() &&\n+\t\t\t!WebApplication.get().getPageSettings().getRecreateMountedPagesAfterExpiry())\n+\t\t{\n+\t\t\tthrow new PageExpiredException(String.format(\"Bookmarkable page id '%d' has expired.\",\n+\t\t\t\tpageInfo.getPageId()));\n+\t\t}\n+\t\telse\n+\t\t{\n \t\t\treturn new RenderPageRequestHandler(provider);\n \t\t}\n+\t}\n \n \t/**\n \t * Creates a {@code IRequestHandler} that processes a listener request.\n", "nb_test": 1449, "linesAdd": 11, "jira_id": "4932", "singleLine": false, "nb_skipped": 5, "commit": "f20b2d70", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["stripJSessionId(org.apache.wicket.util.string.StringsTest): expected:<http://localhost/abc[;a=b;c=d]> but was:<http://localhost/abc[]>"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java b/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\nindex fceb499..27a9987 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\n@@ -22,6 +22,7 @@\n import java.security.PrivilegedAction;\r\n import java.util.ArrayList;\r\n import java.util.List;\r\n+import java.util.Locale;\r\n import java.util.regex.Matcher;\r\n import java.util.regex.Pattern;\r\n \r\n@@ -906,19 +907,19 @@ public static String stripEnding(final String s, final String ending)\n \t */\r\n \tpublic static String stripJSessionId(final String url)\r\n \t{\r\n-\t\tif (url == null)\r\n+\t\tif (Strings.isEmpty(url))\r\n \t\t{\r\n-\t\t\treturn null;\r\n+\t\t\treturn url;\r\n \t\t}\r\n \r\n \t\t// http://.../abc;jsessionid=...?param=...\r\n-\t\tint ixSemiColon = url.indexOf(\";\");\r\n+\t\tint ixSemiColon = url.toLowerCase(Locale.ENGLISH).indexOf(\";jsessionid=\");\r\n \t\tif (ixSemiColon == -1)\r\n \t\t{\r\n \t\t\treturn url;\r\n \t\t}\r\n \r\n-\t\tint ixQuestionMark = url.indexOf(\"?\");\r\n+\t\tint ixQuestionMark = url.indexOf('?');\r\n \t\tif (ixQuestionMark == -1)\r\n \t\t{\r\n \t\t\t// no query paramaters; cut off at \";\"\r\n", "nb_test": 164, "linesAdd": 5, "jira_id": "4816", "singleLine": false, "nb_skipped": 0, "commit": "66bfc885", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["DequeueingTransparentWebMarkupContainerTest.startSubPageWithTWMCinTheParentPage:29 \u00bb WicketRuntime"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 30293fb..55e3184 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -2178,9 +2178,13 @@ else if (wicketTag.isFragmentTag())\n \t\t\t{\n \t\t\t\treturn DequeueTagAction.SKIP;\n \t\t\t}\n+\t\t\telse if (wicketTag.isChildTag())\n+\t\t\t{\n+\t\t\t\treturn DequeueTagAction.DEQUEUE;\n+\t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\treturn null; // dont know\n+\t\t\t\treturn null; // don't know\n \t\t\t}\n \t\t}\n \t\treturn DequeueTagAction.DEQUEUE;\n", "nb_test": 1638, "linesAdd": 5, "jira_id": "5572", "singleLine": false, "nb_skipped": 2, "commit": "cd414fa5", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["OnChangeAjaxBehaviorTest.rendering:39->WicketTestCase.executeTest:99->Assert.assertEquals:115 org/apache/wicket/ajax/form/OnChangeAjaxBehaviorTestPage_expected.html expected:<...d1\",\"e\":\"inputchange[\"});;", "Wicket.Ajax.ajax({\"u\":\"./org.apache.wicket.ajax.form.OnChangeAjaxBehaviorTestPage?0-1.IBehaviorListener.0-form-dropDown\",\"m\":\"POST\",\"c\":\"dropDown2\",\"e\":\"]change\"});;", ";});", "/*]...> but was:<...d1\",\"e\":\"inputchange[ change\"});;", "Wicket.Ajax.ajax({\"u\":\"./org.apache.wicket.ajax.form.OnChangeAjaxBehaviorTestPage?0-1.IBehaviorListener.0-form-dropDown\",\"m\":\"POST\",\"c\":\"dropDown2\",\"e\":\"inputchange ]change\"});;", ";});", "/*]...>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\nindex 965ae56..863eded 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\n@@ -16,7 +16,11 @@\n  */\n package org.apache.wicket.ajax.form;\n \n+import org.apache.wicket.Component;\n+import org.apache.wicket.ajax.attributes.AjaxRequestAttributes;\n import org.apache.wicket.markup.html.form.FormComponent;\n+import org.apache.wicket.markup.html.form.TextArea;\n+import org.apache.wicket.markup.html.form.TextField;\n \n /**\n  * A behavior that updates the hosting {@link FormComponent} via Ajax when value of the component is\n@@ -42,14 +46,33 @@\n \t * for text input form component depending on the browser.\n \t * 'change' is used as a fallback for all other form component types.\n \t */\n-\tpublic static final String EVENT_NAME = \"inputchange change\";\n+\tpublic static final String EVENT_INPUTCHANGE = \"inputchange\";\n+\tpublic static final String EVENT_CHANGE = \"change\";\n \n \t/**\n \t * Constructor.\n \t */\n \tpublic OnChangeAjaxBehavior()\n \t{\n-\t\tsuper(EVENT_NAME);\n+\t\tsuper(EVENT_INPUTCHANGE + \" \" + EVENT_CHANGE);\n \t}\n \n+\t@Override\n+\tprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) \n+\t{\n+\t\tsuper.updateAjaxAttributes(attributes);\n+\t\t\n+\t\tComponent component = getComponent();\n+\t\t\n+\t\t//textfiels and textareas will trigger this behavior with event 'inputchange'\n+\t\t//while all the other components will use 'change'\n+\t\tif (component instanceof TextField || component instanceof TextArea) \n+\t\t{\n+\t\t\tattributes.setEventNames(EVENT_INPUTCHANGE);\n+\t\t} \n+\t\telse \n+\t\t{\n+\t\t\tattributes.setEventNames(EVENT_CHANGE);\n+\t\t}\n+\t}\n }\n", "nb_test": 1646, "linesAdd": 23, "jira_id": "5603", "singleLine": false, "nb_skipped": 2, "commit": "240ab3c3", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["DequeueingTransparentWebMarkupContainerTest.startSubPageWithTWMCinTheParentPage:38 \u00bb Markup"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 0a3cab4..3eef517 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -2096,7 +2096,7 @@ public void dequeue(DequeueContext dequeue)\n \t\t\t{\n \t\t\t\t// could not dequeue, or does not contain children\n \t\n-\t\t\t\tif (tag.isOpen())\n+\t\t\t\tif (tag.isOpen() && !tag.hasNoCloseTag())\n \t\t\t\t{\n \t\t\t\t\tdequeue.skipToCloseTag();\n \t\t\t\t}\n", "nb_test": 1705, "linesAdd": 1, "jira_id": "5728", "singleLine": false, "nb_skipped": 1, "commit": "3cc3fe95", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["mergeParameters(org.apache.wicket.request.mapper.parameter.PageParametersTest): expected:<val0> but was:<null>"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\nindex 5c5391f..956ea75 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\n@@ -456,9 +456,20 @@ public PageParameters mergeWith(final PageParameters other)\n \t\tif (this != other)\n \t\t{\n \t\t\tfor (int index = 0; index < other.getIndexedCount(); index++)\n+\t\t\t{\n+\t\t\t\tif (!other.get(index).isNull())\n+\t\t\t\t{\n \t\t\t\t\tset(index, other.get(index));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor (String name : other.getNamedKeys())\n+\t\t\t{\n+\t\t\t\tremove(name);\n+\t\t\t}\n \t\t\tfor (NamedPair curNamed : other.getAllNamed())\n-\t\t\t\tset(curNamed.getKey(), curNamed.getValue());\n+\t\t\t{\n+\t\t\t\tadd(curNamed.getKey(), curNamed.getValue());\n+\t\t\t}\n \t\t}\n \t\treturn this;\n \t}\n", "nb_test": 86, "linesAdd": 12, "jira_id": "4775", "singleLine": false, "nb_skipped": 0, "commit": "1ac05533", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["showNoExceptionPage(org.apache.wicket.DefaultExceptionMapperTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\nindex 2f71217..8d66d8a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n@@ -121,7 +121,7 @@ else if (IExceptionSettings.SHOW_INTERNAL_ERROR_PAGE.equals(unexpectedExceptionD\n \t\t\telse\n \t\t\t{\n \t\t\t\t// IExceptionSettings.SHOW_NO_EXCEPTION_PAGE\n-\t\t\t\treturn new EmptyRequestHandler();\n+\t\t\t\treturn new ErrorCodeRequestHandler(500);\n \t\t\t}\n \t\t}\n \t}\n", "nb_test": 1184, "linesAdd": 1, "jira_id": "3520", "singleLine": false, "nb_skipped": 1, "commit": "d1b62639", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testLazyClassResolution(org.apache.wicket.model.AbstractPropertyModelObjectClassTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/model/AbstractPropertyModel.java b/wicket/src/main/java/org/apache/wicket/model/AbstractPropertyModel.java\nindex b95679c..6df54fa 100644\n--- a/wicket/src/main/java/org/apache/wicket/model/AbstractPropertyModel.java\n+++ b/wicket/src/main/java/org/apache/wicket/model/AbstractPropertyModel.java\n@@ -247,8 +247,11 @@ else if (this.target instanceof IObjectClassAwareModel)\n \t\t{\n \t\t\ttry\n \t\t\t{\n-\t\t\t\treturn PropertyResolver.getPropertyClass(expression,\n-\t\t\t\t\t((IObjectClassAwareModel<?>)this.target).getObjectClass());\n+\t\t\t\tClass<?> targetClass = ((IObjectClassAwareModel<?>)this.target).getObjectClass();\n+\t\t\t\tif (targetClass != null)\n+\t\t\t\t{\n+\t\t\t\t\treturn PropertyResolver.getPropertyClass(expression, targetClass);\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcatch (WicketRuntimeException e)\n \t\t\t{\n", "nb_test": 1027, "linesAdd": 5, "jira_id": "3253", "singleLine": false, "nb_skipped": 0, "commit": "71b6e905", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["isVisa(org.apache.wicket.validation.validator.CreditCardValidatorTest): expected:<VISA> but was:<SWITCH>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java b/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\nindex df071d4..33c268e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n@@ -539,7 +539,7 @@ private CreditCard isVisa(String creditCardNumber)\n \t\t{\n \t\t\tif (creditCardNumber.startsWith(\"4\"))\n \t\t\t{\n-\t\t\t\treturn CreditCard.SWITCH;\n+\t\t\t\treturn CreditCard.VISA;\n \t\t\t}\n \t\t}\n \n", "nb_test": 1131, "linesAdd": 1, "jira_id": "3998", "singleLine": false, "nb_skipped": 2, "commit": "b76f9c44", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 5, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testIndexedUrlMountedPageWithComponentThatUsesUrlForResourceListener(org.apache.wicket.request.target.coding.IndexParamWithStatelessIFrameTest)", "testIndexedLink(org.apache.wicket.markup.html.link.IndexedParamUrlCodingTest)", "testStatelessDefaultUrlCodingStrategy(org.apache.wicket.request.target.coding.StatelessStatefullUrlCodingStrategyTest)", "testStatefullDefaultUrlCodingStrategy(org.apache.wicket.request.target.coding.StatelessStatefullUrlCodingStrategyTest)", "testStatelessIndexedUrlCodingStrategy(org.apache.wicket.request.target.coding.StatelessStatefullUrlCodingStrategyTest)", "testStatefullIndexedUrlCodingStrategy(org.apache.wicket.request.target.coding.StatelessStatefullUrlCodingStrategyTest)", "testStatelessHybridUrlCodingStrategy(org.apache.wicket.request.target.coding.StatelessStatefullUrlCodingStrategyTest)", "testStatefullHybridUrlCodingStrategy(org.apache.wicket.request.target.coding.StatelessStatefullUrlCodingStrategyTest)", "testAppendParametersAppendingStringBufferMap1(org.apache.wicket.request.target.coding.MixedParamUrlCodingStrategyTest)", "testAppendParametersAppendingStringBufferMap2(org.apache.wicket.request.target.coding.MixedParamUrlCodingStrategyTest)", "testAppendParametersAppendingStringBufferMap5(org.apache.wicket.request.target.coding.MixedParamUrlCodingStrategyTest)", "testAppendParametersAppendingStringBufferMap6(org.apache.wicket.request.target.coding.MixedParamUrlCodingStrategyTest)", "testPage(org.apache.wicket.util.parse.metapattern.parsers.IndexedParamTest)", "testStatelessComponentPageWithMount(org.apache.wicket.stateless.StatelessComponentTest)", "testStatelessComponentPageWithParamsWithMount(org.apache.wicket.stateless.StatelessComponentTest)", "testStatelessComponentPageWithParamsWithIndexMount(org.apache.wicket.stateless.StatelessComponentTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/request/target/coding/AbstractRequestTargetUrlCodingStrategy.java b/wicket/src/main/java/org/apache/wicket/request/target/coding/AbstractRequestTargetUrlCodingStrategy.java\nindex b1d26e9..5631502 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/coding/AbstractRequestTargetUrlCodingStrategy.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/coding/AbstractRequestTargetUrlCodingStrategy.java\n@@ -99,9 +99,11 @@ protected void appendParameters(AppendingStringBuffer url, Map<?,?> parameters)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tappendValue(url, ((Entry<?, ?>)entry1).getKey().toString(), value1);\n \t\t\t\t\t\t}\n-\t\t\t\t\t} else\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n \t\t\t\t\t{\n-\t\t\t\t\t\tappendValue(url, ((Entry<?, ?>) entry1).getKey().toString(), value.toString());\n+\t\t\t\t\t\tappendValue(url, ((Entry<?, ?>)entry1).getKey().toString(),\n+\t\t\t\t\t\t\tvalue.toString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n@@ -117,7 +119,7 @@ private void appendValue(AppendingStringBuffer url, String key, String value)\n \t\t\t{\n \t\t\t\turl.append(\"/\");\n \t\t\t}\n-\t\t\turl.append(key).append(\"/\").append(escapedValue).append(\"/\");\n+\t\t\turl.append(key).append(\"/\").append(escapedValue);\n \t\t}\n \t}\n \ndiff --git a/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedHybridUrlCodingStrategy.java b/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedHybridUrlCodingStrategy.java\nindex 4a46b34..2f3ae49 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedHybridUrlCodingStrategy.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedHybridUrlCodingStrategy.java\n@@ -45,6 +45,7 @@ public IndexedHybridUrlCodingStrategy(String mountPath, Class pageClass)\n \t\tsuper(mountPath, pageClass);\r\n \t}\r\n \r\n+\t@Override\r\n \tprotected void appendParameters(AppendingStringBuffer url, Map parameters)\r\n \t{\r\n \t\tint i = 0;\r\n@@ -55,7 +56,7 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t{\r\n \t\t\t\turl.append(\"/\");\r\n \t\t\t}\r\n-\t\t\turl.append(urlEncodePathComponent(value)).append(\"/\");\r\n+\t\t\turl.append(urlEncodePathComponent(value));\r\n \t\t\ti++;\r\n \t\t}\r\n \r\n@@ -68,8 +69,8 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t{\r\n \t\t\t\turl.append(\"/\");\r\n \t\t\t}\r\n-\t\t\turl.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(urlEncodePathComponent(pageMap))\r\n-\t\t\t\t\t.append(\"/\");\r\n+\t\t\turl.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(\r\n+\t\t\t\turlEncodePathComponent(pageMap));\r\n \t\t}\r\n \r\n \t\tif (i != parameters.size())\r\n@@ -80,6 +81,7 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t}\r\n \t}\r\n \r\n+\t@Override\r\n \tprotected ValueMap decodeParameters(String urlFragment, Map urlParameters)\r\n \t{\r\n \t\tPageParameters params = new PageParameters();\r\n@@ -102,8 +104,8 @@ protected ValueMap decodeParameters(String urlFragment, Map urlParameters)\n \t\t\tif (WebRequestCodingStrategy.PAGEMAP.equals(parts[i]))\r\n \t\t\t{\r\n \t\t\t\ti++;\r\n-\t\t\t\tparams.put(WebRequestCodingStrategy.PAGEMAP, WebRequestCodingStrategy\r\n-\t\t\t\t\t\t.decodePageMapName(urlDecodePathComponent(parts[i])));\r\n+\t\t\t\tparams.put(WebRequestCodingStrategy.PAGEMAP,\r\n+\t\t\t\t\tWebRequestCodingStrategy.decodePageMapName(urlDecodePathComponent(parts[i])));\r\n \t\t\t}\r\n \t\t\telse\r\n \t\t\t{\r\ndiff --git a/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedParamUrlCodingStrategy.java b/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedParamUrlCodingStrategy.java\nindex 5c97510..d6c5c1b 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedParamUrlCodingStrategy.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedParamUrlCodingStrategy.java\n@@ -90,7 +90,7 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t{\n \t\t\t\turl.append(\"/\");\n \t\t\t}\n-\t\t\turl.append(urlEncodePathComponent(value)).append(\"/\");\n+\t\t\turl.append(urlEncodePathComponent(value));\n \t\t\ti++;\n \t\t}\n \n@@ -104,7 +104,7 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t\turl.append(\"/\");\n \t\t\t}\n \t\t\turl.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(\n-\t\t\t\turlEncodePathComponent(pageMap)).append(\"/\");\n+\t\t\t\turlEncodePathComponent(pageMap));\n \t\t}\n \n \t\tString intface = (String)parameters.get(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n@@ -116,7 +116,7 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t\turl.append(\"/\");\n \t\t\t}\n \t\t\turl.append(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME).append(\"/\").append(\n-\t\t\t\turlEncodePathComponent(intface)).append(\"/\");\n+\t\t\t\turlEncodePathComponent(intface));\n \t\t}\n \t\tif (i != parameters.size())\n \t\t{\ndiff --git a/wicket/src/main/java/org/apache/wicket/request/target/coding/MixedParamUrlCodingStrategy.java b/wicket/src/main/java/org/apache/wicket/request/target/coding/MixedParamUrlCodingStrategy.java\nindex 9788196..388a0df 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/coding/MixedParamUrlCodingStrategy.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/coding/MixedParamUrlCodingStrategy.java\n@@ -129,7 +129,11 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t\t{\r\n \t\t\t\t\tvalue = \"\";\r\n \t\t\t\t}\r\n-\t\t\t\turl.append(urlEncodePathComponent(value)).append(\"/\");\r\n+\t\t\t\tif (!url.endsWith(\"/\"))\r\n+\t\t\t\t{\r\n+\t\t\t\t\turl.append(\"/\");\r\n+\t\t\t\t}\r\n+\t\t\t\turl.append(urlEncodePathComponent(value));\r\n \t\t\t\tparameterNamesToAdd.remove(parameterName);\r\n \t\t\t}\r\n \t\t}\r\ndiff --git a/wicket/src/main/java/org/apache/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java b/wicket/src/main/java/org/apache/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\nindex 9519fe8..1808f3a 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\n@@ -39,8 +39,7 @@\n  */\n public class PackageRequestTargetUrlCodingStrategy extends AbstractRequestTargetUrlCodingStrategy\n {\n-\tprivate static final Logger log = LoggerFactory\n-\t\t\t.getLogger(PackageRequestTargetUrlCodingStrategy.class);\n+\tprivate static final Logger log = LoggerFactory.getLogger(PackageRequestTargetUrlCodingStrategy.class);\n \n \t/** package for this mount. */\n \tprivate final PackageName packageName;\n@@ -110,8 +109,7 @@ public IRequestTarget decode(RequestParameters requestParameters)\n \t\t// do some extra work for checking whether this is a normal request to a\n \t\t// bookmarkable page, or a request to a stateless page (in which case a\n \t\t// wicket:interface parameter should be available\n-\t\tfinal String interfaceParameter = (String)parameters\n-\t\t\t\t.remove(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n+\t\tfinal String interfaceParameter = (String)parameters.remove(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n \n \t\tif (interfaceParameter != null)\n \t\t{\n@@ -139,13 +137,13 @@ public final CharSequence encode(IRequestTarget requestTarget)\n \t\tAppendingStringBuffer url = new AppendingStringBuffer(40);\n \t\turl.append(getMountPath());\n \t\tIBookmarkablePageRequestTarget target = (IBookmarkablePageRequestTarget)requestTarget;\n-\t\turl.append(\"/\").append(Classes.simpleName(target.getPageClass())).append(\"/\");\n+\t\turl.append(\"/\").append(Classes.simpleName(target.getPageClass()));\n \n \t\tPageParameters pageParameters = target.getPageParameters();\n \t\tif (target.getPageMapName() != null)\n \t\t{\n-\t\t\tpageParameters.put(WebRequestCodingStrategy.PAGEMAP, WebRequestCodingStrategy\n-\t\t\t\t\t.encodePageMapName(target.getPageMapName()));\n+\t\t\tpageParameters.put(WebRequestCodingStrategy.PAGEMAP,\n+\t\t\t\tWebRequestCodingStrategy.encodePageMapName(target.getPageMapName()));\n \t\t}\n \n \t\tappendParameters(url, pageParameters);\n@@ -171,6 +169,7 @@ public boolean matches(IRequestTarget requestTarget)\n \t/**\n \t * @see java.lang.Object#toString()\n \t */\n+\t@Override\n \tpublic String toString()\n \t{\n \t\treturn \"PackageEncoder[package=\" + packageName + \"]\";\n", "nb_test": 763, "linesAdd": 26, "jira_id": "2065", "singleLine": false, "nb_skipped": 0, "commit": "9da430fb", "nb_failure": 16, "linesRem": 19}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testBug(org.apache.wicket.stateless.pages.StatelessFormTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java b/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java\nindex 097d44b..892b17a 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java\n@@ -117,11 +117,11 @@ public void processEvents(RequestCycle requestCycle)\n \t\tif (page == null)\r\n \t\t{\r\n \t\t\tpage = Session.get().getPage(getPageMapName(), componentPath, -1);\r\n-\t\t\tif (page != null)\n+\t\t\tif (page != null && page.getClass() == getPageClass())\r\n \t\t\t{\r\n \t\t\t\tsetPage(page);\r\n \t\t\t}\r\n-\t\t\telse if (page == null)\n+\t\t\telse\r\n \t\t\t{\r\n \t\t\t\tpage = getPage(requestCycle);\r\n \t\t\t}\r\n", "nb_test": 794, "linesAdd": 2, "jira_id": "1897", "singleLine": false, "nb_skipped": 0, "commit": "8ee095bf", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testComponentUseCheck(org.apache.wicket.markup.html.border.ComponentBorderTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/Page.java b/wicket/src/main/java/org/apache/wicket/Page.java\nindex eaf188d..b6f0290 100644\n--- a/wicket/src/main/java/org/apache/wicket/Page.java\n+++ b/wicket/src/main/java/org/apache/wicket/Page.java\n@@ -33,6 +33,7 @@\n import org.apache.wicket.markup.MarkupException;\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.WebPage;\n+import org.apache.wicket.markup.html.border.Border;\n import org.apache.wicket.markup.html.form.Form;\n import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.apache.wicket.model.IModel;\n@@ -1133,6 +1134,29 @@ public Object component(final Component component)\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\n+\t\t\t\t\t// Check if this component is a child of a border whose body is invisible and if\n+\t\t\t\t\t// so ignore it\n+\t\t\t\t\tBorder border = component.findParent(Border.class);\n+\t\t\t\t\tif (border != null && !border.getBodyContainer().isVisibleInHierarchy())\n+\t\t\t\t\t{\n+\n+\t\t\t\t\t\t// Suppose:\n+\t\t\t\t\t\t//\t\t\t\t\t\t  \n+\t\t\t\t\t\t// <div wicket:id=\"border\"><div wicket:id=\"label\"></div> suppose\n+\t\t\t\t\t\t// border->label and border's body is hidden.\n+\t\t\t\t\t\t//\t\t\t\t\t\t  \n+\t\t\t\t\t\t// The label is added to border not to its hidden body so as far as wicket\n+\t\t\t\t\t\t// is concerned label is visible in hierarchy, but when rendering label wont\n+\t\t\t\t\t\t// be rendered because in the markup it is inside the border's hidden body.\n+\t\t\t\t\t\t// Thus component use check will fail even though it shouldnt - make sure it\n+\t\t\t\t\t\t// doesnt.\n+\t\t\t\t\t\t//\t\t\t\t\t\t \n+\n+\t\t\t\t\t\t// TODO it would be more accurate to determine that this component is inside\n+\t\t\t\t\t\t// the border parent's markup not the border's itself\n+\t\t\t\t\t\titerator.remove();\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\t// if still > 0\n \t\t\t\tif (unrenderedComponents.size() > 0)\n", "nb_test": 764, "linesAdd": 9, "jira_id": "2079", "singleLine": false, "nb_skipped": 0, "commit": "ceac38b1", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAddToAjaxUpdate(wicket.ajax.AjaxTimerBehaviorTest): There should be 1 and only 1 script in the markup for this behavior,but 0 were found expected:<1> but was:<0>", "testAddToWebPage(wicket.ajax.AjaxTimerBehaviorTest): There should be 1 and only 1 script in the markup for this behavior,but 0 were found expected:<1> but was:<0>"], "patch": "diff --git a/wicket/src/main/java/wicket/ajax/AbstractAjaxTimerBehavior.java b/wicket/src/main/java/wicket/ajax/AbstractAjaxTimerBehavior.java\nindex a297a5f..59eeabc 100644\n--- a/wicket/src/main/java/wicket/ajax/AbstractAjaxTimerBehavior.java\n+++ b/wicket/src/main/java/wicket/ajax/AbstractAjaxTimerBehavior.java\n@@ -16,6 +16,7 @@\n  */\n package wicket.ajax;\n \n+import wicket.RequestCycle;\n import wicket.markup.html.IHeaderResponse;\n import wicket.markup.html.WebPage;\n import wicket.util.time.Duration;\n@@ -66,10 +67,16 @@ public void renderHead(IHeaderResponse response)\n \t\tif (this.attachedBodyOnLoadModifier == false)\n \t\t{\n \t\t\tthis.attachedBodyOnLoadModifier = true;\n+\t\t\tif (RequestCycle.get().getRequestTarget() instanceof AjaxRequestTarget) {\n+\t\t\t\tresponse.renderJavascript(getJsTimeoutCall(updateInterval), getComponent().getMarkupId());\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n \t\t\t\t((WebPage)getComponent().getPage()).getBodyContainer().addOnLoadModifier(\n \t\t\t\t\t\tgetJsTimeoutCall(updateInterval), getComponent());\n \t\t\t}\n \t\t}\n+\t}\n \n \t/**\n \t * @param updateInterval\n@@ -78,7 +85,8 @@ public void renderHead(IHeaderResponse response)\n \t */\n \tprotected final String getJsTimeoutCall(final Duration updateInterval)\n \t{\n-\t\treturn \"setTimeout(function() { \" + getCallbackScript(false, true) + \" }, \"\n+\t\t// this might look strange, but it is necessary for IE not to leak :(\n+\t\treturn \"setTimeout(\\\"\" + getCallbackScript(false, true) + \"\\\", \"\n \t\t\t\t+ updateInterval.getMilliseconds() + \");\";\n \t}\n \n@@ -92,11 +100,7 @@ protected final void respond(final AjaxRequestTarget target)\n \n \t\tif (!stopped)\n \t\t{\n-\t\t\t// this might look strange, but it is necessary for IE not to leak\n-\t\t\tString js = \"setTimeout(\\\"\" + getCallbackScript(false, true) + \"\\\", \"\n-\t\t\t\t\t+ updateInterval.getMilliseconds() + \");\";\n-\n-\t\t\ttarget.appendJavascript(js);\n+\t\t\ttarget.appendJavascript(getJsTimeoutCall(updateInterval));\n \t\t}\n \t}\n \n", "nb_test": 377, "linesAdd": 9, "jira_id": "208", "singleLine": false, "nb_skipped": 0, "commit": "b224bad8", "nb_failure": 2, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testWriteToTempFile(org.apache.wicket.markup.html.form.upload.FileUploadTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/upload/FileUpload.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/upload/FileUpload.java\nindex 3f895d3..6bc50c4 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/upload/FileUpload.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/upload/FileUpload.java\n@@ -27,6 +27,7 @@\n import org.apache.wicket.IClusterable;\n import org.apache.wicket.Session;\n import org.apache.wicket.WicketRuntimeException;\n+import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.util.file.Files;\n import org.apache.wicket.util.io.IOUtils;\n import org.apache.wicket.util.lang.Args;\n@@ -247,8 +248,10 @@ public void writeTo(final File file) throws IOException\n \t */\n \tpublic final File writeToTempFile() throws IOException\n \t{\n-\t\tFile temp = File.createTempFile(Session.get().getId(),\n-\t\t\tFiles.cleanupFilename(item.getFieldName()));\n+\t\tSession.get();\n+\t\tString sessionId = Session.exists() ? Session.get().getId() : \"\";\n+\t\tString tempFileName = sessionId + \"_\" + RequestCycle.get().getStartTime();\n+\t\tFile temp = File.createTempFile(tempFileName, Files.cleanupFilename(item.getFieldName()));\n \t\twriteTo(temp);\n \t\treturn temp;\n \t}\n", "nb_test": 1174, "linesAdd": 5, "jira_id": "3715", "singleLine": false, "nb_skipped": 0, "commit": "557de7bc", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testDecode1(org.apache.wicket.request.mapper.BookmarkableMapperTest)", "testDecode2(org.apache.wicket.request.mapper.BookmarkableMapperTest)", "testDecode3(org.apache.wicket.request.mapper.BookmarkableMapperTest)", "testDecode4(org.apache.wicket.request.mapper.BookmarkableMapperTest)", "testDecode5(org.apache.wicket.request.mapper.BookmarkableMapperTest)", "testDecode6(org.apache.wicket.request.mapper.BookmarkableMapperTest)", "testDecode7(org.apache.wicket.request.mapper.BookmarkableMapperTest)", "testDecode8(org.apache.wicket.request.mapper.BookmarkableMapperTest)", "testDecode9(org.apache.wicket.request.mapper.BookmarkableMapperTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/request/mapper/BookmarkableMapper.java b/wicket/src/main/java/org/apache/wicket/request/mapper/BookmarkableMapper.java\nindex 1b82594..1b0edf9 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/mapper/BookmarkableMapper.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/mapper/BookmarkableMapper.java\n@@ -16,7 +16,6 @@\n  */\n package org.apache.wicket.request.mapper;\n \n-import org.apache.wicket.Page;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n@@ -103,7 +102,7 @@ protected UrlInfo parseRequest(Request request)\n \t\t\tString className = url.getSegments().get(2);\n \t\t\tClass<? extends IRequestablePage> pageClass = getPageClass(className);\n \n-\t\t\tif (Page.class.isAssignableFrom(pageClass))\n+\t\t\tif (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass))\n \t\t\t{\n \n \t\t\t\t// extract the PageParameters from URL if there are any\n", "nb_test": 902, "linesAdd": 1, "jira_id": "2993", "singleLine": false, "nb_skipped": 1, "commit": "0b4f78cc", "nb_failure": 8, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["decode11(org.apache.wicket.core.request.mapper.BookmarkableMapperTest): A handler should be resolved for relative url to a bookmarkable page!", "decode12(org.apache.wicket.core.request.mapper.BookmarkableMapperTest): A handler should be resolved for relative url to a page instance url!"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex b1418bf..1fd71d6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.wicket.core.request.mapper;\n \n+import java.util.List;\n+\n import org.apache.wicket.Application;\n import org.apache.wicket.core.request.handler.PageProvider;\n import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n@@ -93,14 +95,26 @@ protected Url buildUrl(UrlInfo info)\n \t@Override\n \tprotected UrlInfo parseRequest(Request request)\n \t{\n-\t\tUrl url = request.getUrl();\n-\t\tif (matches(url))\n+\t\tif (matches(request))\n \t\t{\n+\t\t\tUrl url = request.getUrl();\n+\n \t\t\t// try to extract page and component information from URL\n \t\t\tPageComponentInfo info = getPageComponentInfo(url);\n \n+\t\t\tList<String> segments = url.getSegments();\n+\n \t\t\t// load the page class\n-\t\t\tString className = url.getSegments().get(2);\n+\t\t\tString className;\n+\t\t\tif (segments.size() >= 3)\n+\t\t\t{\n+\t\t\t\tclassName = segments.get(2);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tclassName = segments.get(1);\n+\t\t\t}\n+\n \t\t\tClass<? extends IRequestablePage> pageClass = getPageClass(className);\n \n \t\t\tif (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass))\n@@ -111,13 +125,13 @@ protected UrlInfo parseRequest(Request request)\n \n \t\t\t\t\tif (application.getSecuritySettings().getEnforceMounts())\n \t\t\t\t\t{\n-\t\t\t\t\t\t// we make an excepion if the homepage itself was mounted, see WICKET-1898\n+\t\t\t\t\t\t// we make an exception if the homepage itself was mounted, see WICKET-1898\n \t\t\t\t\t\tif (!pageClass.equals(application.getHomePage()))\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\t// WICKET-5094 only enforce mount if page is mounted\n \t\t\t\t\t\t\tUrl reverseUrl = application.getRootRequestMapper().mapHandler(\n \t\t\t\t\t\t\t\tnew RenderPageRequestHandler(new PageProvider(pageClass)));\n-\t\t\t\t\t\t\tif (!matches(reverseUrl))\n+\t\t\t\t\t\t\tif (!matches(request.cloneWithUrl(reverseUrl)))\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n@@ -151,17 +165,37 @@ protected boolean pageMustHaveBeenCreatedBookmarkable()\n \tpublic int getCompatibilityScore(Request request)\n \t{\n \t\tint score = 0;\n-\t\tUrl url = request.getUrl();\n-\t\tif (matches(url))\n+\t\tif (matches(request))\n \t\t{\n \t\t\tscore = Integer.MAX_VALUE;\n \t\t}\n \t\treturn score;\n \t}\n \n-\tprivate boolean matches(final Url url)\n+\tprivate boolean matches(final Request request)\n+\t{\n+\t\tboolean matches = false;\n+\t\tUrl url = request.getUrl();\n+\t\tUrl baseUrl = request.getClientUrl();\n+\t\tString namespace = getContext().getNamespace();\n+\t\tString bookmarkableIdentifier = getContext().getBookmarkableIdentifier();\n+\t\tString pageIdentifier = getContext().getPageIdentifier();\n+\n+\t\tif (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n+\t\t// baseUrl = 'wicket/bookmarkable/com.example.SomePage[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n+\t\telse if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n+\t\t// baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n+\t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))\n \t\t{\n-\t\treturn (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(),\n-\t\t\tgetContext().getBookmarkableIdentifier()));\n+\t\t\tmatches = true;\n+\t\t}\n+\n+\t\treturn matches;\n \t}\n }\n", "nb_test": 1473, "linesAdd": 41, "jira_id": "5071", "singleLine": false, "nb_skipped": 4, "commit": "6e794ad0", "nb_failure": 2, "linesRem": 9}, {"files": 3, "project": "wicket", "nb_error": 38, "classification": {"singleLine": false}, "failing_tests": ["testFormIsSubmitted(org.apache.wicket.markup.html.link.submitLink.FormPageTest)", "testProcessingOrder(org.apache.wicket.markup.html.form.FormComponentPanelProcessingTest)", "testSessionIsTemporary(org.apache.wicket.stateless.TemporarySessionTest)", "testInternalDetach(org.apache.wicket.markup.html.form.upload.FileUploadFieldTest)", "testFileUploadCanBeValidated(org.apache.wicket.markup.html.form.upload.FileUploadFieldTest)", "testRender9a(org.apache.wicket.markup.html.internal.EnclosureTest)", "testFormIsSubmitted(org.apache.wicket.markup.html.link.submitLink.FormPage2Test)", "testDropDownEvent(org.apache.wicket.FormDispatchEventTest)", "test_1(org.apache.wicket.util.tester.apps_4.FormTesterTest)", "testCreateBook_validateFail(org.apache.wicket.util.tester.WicketTesterTest)", "testCreateBook_validatePass(org.apache.wicket.util.tester.WicketTesterTest)", "test_1979(org.apache.wicket.markup.html.form.DropDownChoiceTest)", "testMiddleFormDisabledErrorOnOuterFormSubmitOuterForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testErrorOnInnerFormDisabledMiddleFormSubmitOuterForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testAllFormsEnabledSubmitOuterForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testAllFormsEnabledSubmitMiddleForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testAllFormsEnabledSubmitInnerForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testMiddleFormDisabledSubmitOuterForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testInnerFormDisabledSubmitOuterForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testSubmitDisabledOuterForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testErrorOnInnerFormSubmitOuterForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testErrorOnMiddleFormSubmitOuterForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testErrorOnMiddleFormSubmitMiddleForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testErrorOnInnerFormSubmitMiddleForm(org.apache.wicket.markup.html.form.FormSubmitTest)", "testFormSubmit(org.apache.wicket.markup.html.form.login.InterceptTest)", "testSingleChoice(org.apache.wicket.util.tester.apps_3.FormTesterTest)", "testSingleChoice_toggle(org.apache.wicket.util.tester.apps_3.FormTesterTest)", "testSelectMultiple(org.apache.wicket.util.tester.apps_3.FormTesterTest)", "testMultipleChoiceComponent_cumulate(org.apache.wicket.util.tester.apps_3.FormTesterTest)", "testMultipleButtonSubmit(org.apache.wicket.util.tester.apps_3.FormTesterTest)", "testInitialValues(org.apache.wicket.util.tester.apps_3.FormTesterTest)", "testFormTester(org.apache.wicket.util.tester.FormTesterTest)", "testCheckboxValuesCanBeSelectedWithBoolean(org.apache.wicket.util.tester.FormTesterTest)", "testAddFile(org.apache.wicket.util.tester.FormTesterTest)", "testAddBinaryFile(org.apache.wicket.util.tester.FormTesterTest)", "testSubmitWithoutUploadFile(org.apache.wicket.util.tester.FormTesterTest)", "testSubmitMultipartForm(org.apache.wicket.util.tester.FormTesterTest)", "testLogin(org.apache.wicket.stateless.StatelessFormTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex a5d3b39..806e3a5 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -376,7 +376,10 @@ public String getQueryString()\n \tprivate Bytes maxSize = null;\n \n \t/** True if the form has enctype of multipart/form-data */\n-\tprivate boolean multiPart = false;\n+\tprivate short multiPart = 0;\n+\n+\tprivate static short MULTIPART_HARD = 0x01;\n+\tprivate static short MULTIPART_HINT = 0x02;\n \n \t/**\n \t * Constructs a form with no validation.\n@@ -1051,7 +1054,14 @@ public void setMaxSize(final Bytes maxSize)\n \t */\n \tpublic void setMultiPart(boolean multiPart)\n \t{\n-\t\tthis.multiPart = multiPart;\n+\t\tif (multiPart)\n+\t\t{\n+\t\t\tthis.multiPart |= MULTIPART_HARD;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tthis.multiPart &= ~MULTIPART_HARD;\n+\t\t}\n \t}\n \n \t/**\n@@ -1399,7 +1409,7 @@ protected boolean getStatelessHint()\n \n \tprivate boolean isMultiPart()\n \t{\n-\t\tif (multiPart)\n+\t\tif (multiPart != 0)\n \t\t{\n \t\t\treturn true;\n \t\t}\n@@ -1411,7 +1421,7 @@ private boolean isMultiPart()\n \n \t\t\t\tpublic Object component(Form<?> form)\n \t\t\t\t{\n-\t\t\t\t\tif (form.multiPart)\n+\t\t\t\t\tif (form.multiPart != 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tanyEmbeddedMultipart[0] = true;\n \t\t\t\t\t\treturn STOP_TRAVERSAL;\n@@ -1788,6 +1798,9 @@ protected void onError()\n \t@Override\n \tprotected void onRender()\n \t{\n+\t\t// clear multipart hint, it will be set if necessary by the visitor\n+\t\tthis.multiPart &= ~MULTIPART_HINT;\n+\n \t\t// Force multi-part on if any child form component is multi-part\n \t\tvisitFormComponents(new FormComponent.AbstractVisitor()\n \t\t{\n@@ -1796,7 +1809,7 @@ public void onFormComponent(FormComponent<?> formComponent)\n \t\t\t{\n \t\t\t\tif (formComponent.isVisible() && formComponent.isMultiPart())\n \t\t\t\t{\n-\t\t\t\t\tsetMultiPart(true);\n+\t\t\t\t\tmultiPart |= MULTIPART_HINT;\n \t\t\t\t}\n \t\t\t}\n \t\t});\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/upload/MultiFileUploadField.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/upload/MultiFileUploadField.java\nindex ef2b286..9b49e7a 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/upload/MultiFileUploadField.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/upload/MultiFileUploadField.java\n@@ -193,9 +193,13 @@ protected void onBeforeRender()\n \t\t\tthrow new IllegalStateException(\"Component \" + getClass().getName() + \" must have a \" +\n \t\t\t\tForm.class.getName() + \" component above in the hierarchy\");\n \t\t}\n-\t\tform.setMultiPart(true);\n \t}\n \n+\t@Override\n+\tpublic boolean isMultiPart()\n+\t{\n+\t\treturn true;\n+\t}\n \n \t/**\n \t * @see org.apache.wicket.markup.html.IHeaderContributor#renderHead(org.apache.wicket.markup.html.IHeaderResponse)\ndiff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequest.java b/wicket/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequest.java\nindex 6c95e95..b4ce08b 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequest.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequest.java\n@@ -110,7 +110,8 @@ public MultipartServletWebRequest(HttpServletRequest request, Bytes maxSize,\n \t\tfinal boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n \t\tif (!isMultipart)\n \t\t{\n-\t\t\tthrow new IllegalStateException(\"ServletRequest does not contain multipart content\");\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\"ServletRequest does not contain multipart content. One possible solution is to explicitly call Form.setMultipart(true), Wicket tries its best to auto-detect multipart forms but there are certain situation where it cannot.\");\n \t\t}\n \n \n", "nb_test": 937, "linesAdd": 24, "jira_id": "2621", "singleLine": false, "nb_skipped": 0, "commit": "c849f986", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testModelObjectClassInference(org.apache.wicket.extensions.ajax.markup.html.AjaxEditableTest)"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/ajax/markup/html/AjaxEditableLabel.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/ajax/markup/html/AjaxEditableLabel.java\nindex 15dc1c1..ee3006e 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/ajax/markup/html/AjaxEditableLabel.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/ajax/markup/html/AjaxEditableLabel.java\n@@ -30,6 +30,7 @@\n import org.apache.wicket.markup.html.form.TextField;\n import org.apache.wicket.markup.html.panel.Panel;\n import org.apache.wicket.model.IModel;\n+import org.apache.wicket.model.IObjectClassAwareModel;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.util.convert.IConverter;\n import org.apache.wicket.util.string.JavaScriptUtils;\n@@ -391,7 +392,7 @@ protected String getLabelAjaxEvent()\n \t{\n \t\tif (editor == null)\n \t\t{\n-\t\t\tinitLabelAndEditor(getDelegatingParentModel());\n+\t\t\tinitLabelAndEditor(new WrapperModel());\n \t\t}\n \t\treturn editor;\n \t}\n@@ -405,7 +406,7 @@ protected final Component getLabel()\n \t{\n \t\tif (label == null)\n \t\t{\n-\t\t\tinitLabelAndEditor(getDelegatingParentModel());\n+\t\t\tinitLabelAndEditor(new WrapperModel());\n \t\t}\n \t\treturn label;\n \t}\n@@ -420,7 +421,7 @@ protected void onBeforeRender()\n \t\t// lazily add label and editor\n \t\tif (editor == null)\n \t\t{\n-\t\t\tinitLabelAndEditor(getDelegatingParentModel());\n+\t\t\tinitLabelAndEditor(new WrapperModel());\n \t\t}\n \t\t// obsolete with WICKET-1919\n \t\t// label.setEnabled(isEnabledInHierarchy());\n@@ -510,16 +511,11 @@ private void initLabelAndEditor(final IModel<T> model)\n \t}\n \n \t/**\n-\t * get a model that accesses the parent model lazily. this is required since we eventually\n-\t * request the parents model before the component is added to the parent.\n-\t * \n-\t * @return model\n+\t * Model that accesses the parent model lazily. this is required since we eventually request the\n+\t * parents model before the component is added to the parent.\n \t */\n-\tprivate IModel<T> getDelegatingParentModel()\n-\t{\n-\t\treturn new IModel<T>()\n+\tprivate class WrapperModel implements IModel<T>, IObjectClassAwareModel<T>\n \t{\n-\t\t\tprivate static final long serialVersionUID = 1L;\n \n \t\tpublic T getObject()\n \t\t{\n@@ -534,10 +530,21 @@ public void setObject(final T object)\n \t\tpublic void detach()\n \t\t{\n \t\t\tgetParentModel().detach();\n-\t\t\t}\n-\t\t};\n+\n \t\t}\n \n+\t\tpublic Class<T> getObjectClass()\n+\t\t{\n+\t\t\tif (getParentModel() instanceof IObjectClassAwareModel)\n+\t\t\t{\n+\t\t\t\treturn ((IObjectClassAwareModel)getParentModel()).getObjectClass();\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t}\n \n \t/**\n \t * @return Gets the parent model in case no explicit model was specified.\n", "nb_test": 22, "linesAdd": 18, "jira_id": "4259", "singleLine": false, "nb_skipped": 0, "commit": "1f128536", "nb_failure": 1, "linesRem": 9}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["enforceMounts(org.apache.wicket.settings.ISecuritySettingsTest): page was null"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex f8c7ffe..b1418bf 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -17,6 +17,8 @@\n package org.apache.wicket.core.request.mapper;\n \n import org.apache.wicket.Application;\n+import org.apache.wicket.core.request.handler.PageProvider;\n+import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n@@ -91,14 +93,6 @@ protected Url buildUrl(UrlInfo info)\n \t@Override\n \tprotected UrlInfo parseRequest(Request request)\n \t{\n-\t\tif (Application.exists())\n-\t\t{\n-\t\t\tif (Application.get().getSecuritySettings().getEnforceMounts())\n-\t\t\t{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n \t\tUrl url = request.getUrl();\n \t\tif (matches(url))\n \t\t{\n@@ -111,6 +105,25 @@ protected UrlInfo parseRequest(Request request)\n \n \t\t\tif (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass))\n \t\t\t{\n+\t\t\t\tif (Application.exists())\n+\t\t\t\t{\n+\t\t\t\t\tApplication application = Application.get();\n+\n+\t\t\t\t\tif (application.getSecuritySettings().getEnforceMounts())\n+\t\t\t\t\t{\n+\t\t\t\t\t\t// we make an excepion if the homepage itself was mounted, see WICKET-1898\n+\t\t\t\t\t\tif (!pageClass.equals(application.getHomePage()))\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t// WICKET-5094 only enforce mount if page is mounted\n+\t\t\t\t\t\t\tUrl reverseUrl = application.getRootRequestMapper().mapHandler(\n+\t\t\t\t\t\t\t\tnew RenderPageRequestHandler(new PageProvider(pageClass)));\n+\t\t\t\t\t\t\tif (!matches(reverseUrl))\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n \n \t\t\t\t// extract the PageParameters from URL if there are any\n \t\t\t\tPageParameters pageParameters = extractPageParameters(request, 3,\n", "nb_test": 1463, "linesAdd": 19, "jira_id": "5094", "singleLine": false, "nb_skipped": 3, "commit": "74e77676", "nb_failure": 1, "linesRem": 8}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["RerenderPageTest.wicket5960:70 pattern '<!-- I should be present 2 -->' not found in:", "<!DOCTYPE html>", "<html>", "<body></body>", "</html>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\nindex 1ce6809..e906560 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\n@@ -314,9 +314,8 @@ public boolean okToRenderComponent(final String scope, final String id)\n \t}\n \n \t@Override\n-\tprotected void onDetach()\n-\t{\n-\t\tsuper.onDetach();\n+\tprotected void onAfterRender() {\n+\t\tsuper.onAfterRender();\n \n \t\trenderedComponentsPerScope = null;\n \t\theaderResponse = null;\n", "nb_test": 1792, "linesAdd": 2, "jira_id": "5960", "singleLine": false, "nb_skipped": 1, "commit": "03663750", "nb_failure": 1, "linesRem": 3}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["SpringBeanTest.beanNotExists:103->Assert.assertNull:656->Assert.assertNull:646->Assert.failNotNull:664->Assert.fail:88 expected null, but was:<org.apache.wicket.proxy.LazyInitProxyFactory$CGLibInterceptor@524e19c1>"], "patch": "diff --git a/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java b/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\nindex a022792..a279126 100644\n--- a/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\n+++ b/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\n@@ -19,6 +19,7 @@\n import java.lang.ref.WeakReference;\n \n import org.apache.wicket.proxy.IProxyTargetLocator;\n+import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Objects;\n import org.apache.wicket.core.util.lang.WicketObjects;\n import org.springframework.beans.factory.NoSuchBeanDefinitionException;\n@@ -73,14 +74,8 @@ public SpringBeanLocator(final Class<?> beanType, final ISpringContextLocator lo\n \tpublic SpringBeanLocator(final String beanName, final Class<?> beanType,\n \t\tfinal ISpringContextLocator locator)\n \t{\n-\t\tif (locator == null)\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"[locator] argument cannot be null\");\n-\t\t}\n-\t\tif (beanType == null)\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"[beanType] argument cannot be null\");\n-\t\t}\n+\t\tArgs.notNull(locator, \"locator\");\n+\t\tArgs.notNull(beanType, \"beanType\");\n \n \t\tbeanTypeCache = new WeakReference<Class<?>>(beanType);\n \t\tbeanTypeName = beanType.getName();\n@@ -122,9 +117,6 @@ public boolean isSingletonBean()\n \t\treturn clazz;\n \t}\n \n-\t/**\n-\t * @see org.apache.wicket.proxy.IProxyTargetLocator#locateProxyTarget()\n-\t */\n \t@Override\n \tpublic Object locateProxyTarget()\n \t{\n@@ -174,11 +166,10 @@ public final ISpringContextLocator getSpringContextLocator()\n \t *            bean name\n \t * @param clazz\n \t *            bean class\n-\t * @throws IllegalStateException\n+\t * @throws java.lang.IllegalStateException\n \t * @return found bean\n \t */\n-\tprivate static Object lookupSpringBean(final ApplicationContext ctx, final String name,\n-\t\tfinal Class<?> clazz)\n+\tprivate Object lookupSpringBean(ApplicationContext ctx, String name, Class<?> clazz)\n \t{\n \t\ttry\n \t\t{\n@@ -194,7 +185,7 @@ private static Object lookupSpringBean(final ApplicationContext ctx, final Strin\n \t\tcatch (NoSuchBeanDefinitionException e)\n \t\t{\n \t\t\tthrow new IllegalStateException(\"bean with name [\" + name + \"] and class [\" +\n-\t\t\t\tclazz.getName() + \"] not found\");\n+\t\t\t\tclazz.getName() + \"] not found\", e);\n \t\t}\n \t}\n \ndiff --git a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\nindex 648d2c7..6b7d071 100644\n--- a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n+++ b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n@@ -110,7 +110,23 @@ public Object getFieldValue(final Field field, final Object fieldOwner)\n \t{\n \t\tif (supportsField(field))\n \t\t{\n-\t\t\tString beanName = getBeanName(field);\n+\t\t\tSpringBean annot = field.getAnnotation(SpringBean.class);\n+\n+\t\t\tString name;\n+\t\t\tboolean required;\n+\t\t\tif (annot != null)\n+\t\t\t{\n+\t\t\t\tname = annot.name();\n+\t\t\t\trequired = annot.required();\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tNamed named = field.getAnnotation(Named.class);\n+\t\t\t\tname = named != null ? named.value() : \"\";\n+\t\t\t\trequired = false;\n+\t\t\t}\n+\n+\t\t\tString beanName = getBeanName(field, name, required);\n \n \t\t\tif (beanName == null)\n \t\t\t{\n@@ -128,13 +144,26 @@ public Object getFieldValue(final Field field, final Object fieldOwner)\n \t\t\t}\n \n \t\t\tObject target;\n-\t\t\tif (wrapInProxies)\n+\t\t\ttry\n \t\t\t{\n-\t\t\t\ttarget = LazyInitProxyFactory.createProxy(field.getType(), locator);\n+\t\t\t\t// check whether there is a bean with the provided properties\n+\t\t\t\ttarget = locator.locateProxyTarget();\n+\t\t\t}\n+\t\t\tcatch (IllegalStateException isx)\n+\t\t\t{\n+\t\t\t\tif (required)\n+\t\t\t\t{\n+\t\t\t\t\tthrow isx;\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n-\t\t\t\ttarget = locator.locateProxyTarget();\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (wrapInProxies)\n+\t\t\t{\n+\t\t\t\ttarget = LazyInitProxyFactory.createProxy(field.getType(), locator);\n \t\t\t}\n \n \t\t\t// only put the proxy into the cache if the bean is a singleton\n@@ -156,31 +185,20 @@ public Object getFieldValue(final Field field, final Object fieldOwner)\n \t * @param field\n \t * @return bean name\n \t */\n-\tprivate String getBeanName(final Field field)\n+\tprivate String getBeanName(final Field field, String name, boolean required)\n \t{\n-\t\tSpringBean annot = field.getAnnotation(SpringBean.class);\n-\t\t\n-\t\tString name;\n-\t\tboolean required;\n-\t\tif (annot != null) {\n-\t\t\tname = annot.name();\n-\t\t\trequired = annot.required();\n-\t\t} else {\n-\t\t\tNamed named = field.getAnnotation(Named.class);\n-\t\t\tname = named != null ? named.value() : \"\";\n-\t\t\trequired = false;\n-\t\t}\n \n \t\tif (Strings.isEmpty(name))\n \t\t{\n-\t\t\tname = beanNameCache.get(field.getType());\n+\t\t\tClass<?> fieldType = field.getType();\n+\t\t\tname = beanNameCache.get(fieldType);\n \t\t\tif (name == null)\n \t\t\t{\n-\t\t\t\tname = getBeanNameOfClass(contextLocator.getSpringContext(), field.getType(), required);\n+\t\t\t\tname = getBeanNameOfClass(contextLocator.getSpringContext(), fieldType, required);\n \n \t\t\t\tif (name != null)\n \t\t\t\t{\n-\t\t\t\t\tString tmpName = beanNameCache.putIfAbsent(field.getType(), name);\n+\t\t\t\t\tString tmpName = beanNameCache.putIfAbsent(fieldType, name);\n \t\t\t\t\tif (tmpName != null)\n \t\t\t\t\t{\n \t\t\t\t\t\tname = tmpName;\n", "nb_test": 24, "linesAdd": 42, "jira_id": "5662", "singleLine": false, "nb_skipped": 0, "commit": "9aec4f33", "nb_failure": 1, "linesRem": 31}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FencedFeedbackPanelTest.reAdding:187 null"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java b/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java\nindex f7df59e..42e1344 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java\n@@ -29,13 +29,13 @@\n  * the nesting of these panels to work correctly without displaying the same feedback message twice.\n  * A constructor that does not takes a fencing component creates a catch-all panel that shows\n  * messages that do not come from inside any fence or from the {@link Session}.\n- * \n+ * <p/>\n  * <h2>IN DEPTH EXPLANATION</h2>\n  * <p>\n  * It is often very useful to have feedback panels that show feedback that comes from inside a\n  * certain container only. For example given a page with the following structure:\n  * </p>\n- * \n+ * <p/>\n  * <pre>\n  * Page\n  *   Form1\n@@ -112,10 +112,9 @@ public FencedFeedbackPanel(String id, Component fence)\n \t/**\n \t * Creates a catch-all instance with a filter.\n \t *\n-\t * @see #FencedFeedbackPanel(String)\n-\t * \n \t * @param id\n \t * @param filter\n+\t * @see #FencedFeedbackPanel(String)\n \t */\n \tpublic FencedFeedbackPanel(String id, IFeedbackMessageFilter filter)\n \t{\n@@ -125,11 +124,10 @@ public FencedFeedbackPanel(String id, IFeedbackMessageFilter filter)\n \t/**\n \t * Creates a fenced feedback panel with a filter.\n \t *\n-\t * @see #FencedFeedbackPanel(String, Component)\n-\t * \n \t * @param id\n \t * @param fence\n \t * @param filter\n+\t * @see #FencedFeedbackPanel(String, Component)\n \t */\n \tpublic FencedFeedbackPanel(String id, Component fence, IFeedbackMessageFilter filter)\n \t{\n@@ -137,11 +135,16 @@ public FencedFeedbackPanel(String id, Component fence, IFeedbackMessageFilter fi\n \t\tthis.fence = fence;\n \t\tif (fence != null)\n \t\t{\n+\t\t\tincrementFenceCount();\n+\t\t}\n+\t}\n+\n+\tprivate void incrementFenceCount()\n+\t{\n \t\tInteger count = fence.getMetaData(FENCE_KEY);\n \t\tcount = count == null ? 1 : count + 1;\n \t\tfence.setMetaData(FENCE_KEY, count);\n \t}\n-\t}\n \n \t@Override\n \tprotected void onRemove()\n@@ -151,11 +154,16 @@ protected void onRemove()\n \t\t{\n \t\t\t// decrement the fence count\n \n+\t\t\tdecrementFenceCount();\n+\t\t}\n+\t}\n+\n+\tprivate void decrementFenceCount()\n+\t{\n \t\tInteger count = fence.getMetaData(FENCE_KEY);\n \t\tcount = (count == null || count == 1) ? null : count - 1;\n \t\tfence.setMetaData(FENCE_KEY, count);\n \t}\n-\t}\n \n \t@Override\n \tprotected FeedbackMessagesModel newFeedbackMessagesModel()\n@@ -177,7 +185,7 @@ protected FeedbackMessagesModel newFeedbackMessagesModel()\n \t\t\t\t\t\t@Override\n \t\t\t\t\t\tprotected boolean shouldRecurseInto(Component component)\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn component.getMetaData(FENCE_KEY) == null;\n+\t\t\t\t\t\t\treturn !componentIsMarkedAsFence(component);\n \t\t\t\t\t\t}\n \t\t\t\t\t}.collect(filter);\n \t\t\t\t}\n@@ -191,12 +199,29 @@ protected boolean shouldRecurseInto(Component component)\n \t\t\t\t\t\tprotected boolean shouldRecurseInto(Component component)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\t// only recurse into components that are not fences\n-\n-\t\t\t\t\t\t\treturn component.getMetaData(FENCE_KEY) == null;\n+\t\t\t\t\t\t\treturn !componentIsMarkedAsFence(component);\n \t\t\t\t\t\t}\n \t\t\t\t\t}.setIncludeSession(false).collect(filter);\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \t}\n+\n+\tprivate boolean componentIsMarkedAsFence(Component component)\n+\t{\n+\t\treturn component.getMetaData(FENCE_KEY) != null;\n+\t}\n+\n+\t@Override\n+\tprotected void onReAdd()\n+\t{\n+\t\tif (this.fence != null)\n+\t\t{\n+\t\t\t// The fence mark is removed when the feedback panel is removed from the hierarchy.\n+\t\t\t// see onRemove().\n+\t\t\t// when the panel is re-added, we recreate the fence mark.\n+\t\t\tincrementFenceCount();\n+\t\t}\n+\t\tsuper.onReAdd();\n+\t}\n }\n", "nb_test": 1688, "linesAdd": 29, "jira_id": "5265", "singleLine": false, "nb_skipped": 1, "commit": "0eb596df", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testPage1(org.apache.wicket.resource.aggregator.ResourceAggregatorRenderTest): org/apache/wicket/resource/aggregator/ResourceAggregatorTest1Page_results.html expected:<.../1999/xhtml\">(..)", "testPage2(org.apache.wicket.resource.aggregator.ResourceAggregatorRenderTest): org/apache/wicket/resource/aggregator/ResourceAggregatorTest2Page_results.html expected:<.../1999/xhtml\">(..)", "headerScoping2(org.apache.wicket.markup.html.header.HeaderScopingTest): org/apache/wicket/markup/html/header/MyPage2_ExpectedResult.html expected:<...EN\">(..)", "testAllMarkup(org.apache.wicket.markup.html.header.response.HeaderResponseTest): org/apache/wicket/markup/html/header/response/ExpectedResult.html expected:<...lWithHeader</title>(..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/renderStrategy/ChildFirstHeaderRenderStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/renderStrategy/ChildFirstHeaderRenderStrategy.java\nindex cf4d8da..8938182 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/renderStrategy/ChildFirstHeaderRenderStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/renderStrategy/ChildFirstHeaderRenderStrategy.java\n@@ -80,8 +80,11 @@ protected void renderChildHeaders(final HtmlHeaderContainer headerContainer,\n \t\t\t\t@Override\n \t\t\t\tpublic void component(final Component component, final IVisit<Void> visit)\n \t\t\t\t{\n+\t\t\t\t\tif (component != rootComponent)\n+\t\t\t\t\t{\n \t\t\t\t\t\tcomponent.renderHead(headerContainer);\n \t\t\t\t\t}\n+\t\t\t\t}\n \n \t\t\t\t@Override\n \t\t\t\tpublic boolean preCheck(Component component)\n", "nb_test": 1279, "linesAdd": 3, "jira_id": "4000", "singleLine": false, "nb_skipped": 4, "commit": "38e928c1", "nb_failure": 4, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["errorOnInnerFormSubmitOuterForm(org.apache.wicket.markup.html.form.FormSubmitTest): not onError'd in expected order! expected:<[innerFormmiddleFormout]erForm> but was:<[outerFormmiddleForminn]erForm>", "errorOnMiddleFormSubmitOuterForm(org.apache.wicket.markup.html.form.FormSubmitTest): not onError'd in expected order! expected:<[middleFormouter]Form> but was:<[outerFormmiddle]Form>", "errorOnInnerFormSubmitMiddleForm(org.apache.wicket.markup.html.form.FormSubmitTest): not onError'd in expected order! expected:<[innerFormmiddle]Form> but was:<[middleForminner]Form>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 35ac561..53898a6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -928,18 +928,19 @@ public void process(IFormSubmitter submittingComponent)\n \t */\n \tprotected void callOnError(IFormSubmitter submitter)\n \t{\n+\t\tfinal Form<?> processingForm = findFormToProcess(submitter);\n+\n \t\tif (submitter != null)\n \t\t{\n \t\t\tsubmitter.onError();\n \t\t}\n-\t\tonError();\n-\t\t// call onError on nested forms\n-\t\tvisitChildren(Form.class, new IVisitor<Component, Void>()\n+\n+\t\t// invoke Form#onSubmit(..) going from innermost to outermost\n+\t\tVisits.visitPostOrder(processingForm, new IVisitor<Form<?>, Void>()\n \t\t{\n \t\t\t@Override\n-\t\t\tpublic void component(final Component component, final IVisit<Void> visit)\n+\t\t\tpublic void component(Form<?> form, IVisit<Void> visit)\n \t\t\t{\n-\t\t\t\tfinal Form<?> form = (Form<?>)component;\n \t\t\t\tif (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy())\n \t\t\t\t{\n \t\t\t\t\tvisit.dontGoDeeper();\n@@ -950,7 +951,7 @@ public void component(final Component component, final IVisit<Void> visit)\n \t\t\t\t\tform.onError();\n \t\t\t\t}\n \t\t\t}\n-\t\t});\n+\t\t}, new ClassVisitFilter(Form.class));\n \t}\n \n \n@@ -1208,8 +1209,8 @@ protected void beforeUpdateFormComponentModels()\n \t * processing to clients.\n \t * <p>\n \t * This implementation first finds out whether the form processing was triggered by a nested\n-\t * IFormSubmittingComponent of this form. If that is the case, that component's onSubmit is\n-\t * called first.\n+\t * IFormSubmittingComponent of this form. If that is the case, that component's\n+\t * onSubmitBefore/AfterForm methods are called appropriately..\n \t * </p>\n \t * <p>\n \t * Regardless of whether a submitting component was found, the form's onSubmit method is called\n", "nb_test": 1372, "linesAdd": 6, "jira_id": "4616", "singleLine": false, "nb_skipped": 5, "commit": "dd1df04b", "nb_failure": 3, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testExceptionRequestHandlers(org.apache.wicket.request.cycle.RequestCycleListenerTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\nindex d4a45d2..f1208b6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n@@ -668,6 +668,9 @@ public void scheduleRequestHandlerAfterCurrent(IRequestHandler handler)\n \t{\n \t\t// just delegating the call to {@link IRequestHandlerExecutor} and invoking listeners\n \t\trequestHandlerExecutor.schedule(handler);\n+\n+\t\t// only forward calls to the listeners when handler is null\n+\t\tif (handler != null)\n \t\t\tlisteners.onRequestHandlerScheduled(handler);\n \t}\n \n", "nb_test": 1119, "linesAdd": 2, "jira_id": "3646", "singleLine": false, "nb_skipped": 0, "commit": "12124902", "nb_failure": 1, "rtElixir": true, "linesRem": 0}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDecorateResponse(org.apache.wicket.request.resource.caching.QueryStringWithVersionResourceCachingStrategyTest): expected:<1 hour> but was:<365 days>", "testDecorateResponse(org.apache.wicket.request.resource.caching.FilenameWithVersionResourceCachingStrategyTest): expected:<1 hour> but was:<365 days>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/FilenameWithVersionResourceCachingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/FilenameWithVersionResourceCachingStrategy.java\nindex 2125f35..087ea13 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/FilenameWithVersionResourceCachingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/FilenameWithVersionResourceCachingStrategy.java\n@@ -196,7 +196,12 @@ public void undecorateUrl(ResourceUrl url)\n \t@Override\n \tpublic void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource)\n \t{\n+\t\tString requestedVersion = RequestCycle.get().getMetaData(URL_VERSION);\n+\t\tString calculatedVersion = this.resourceVersion.getVersion(resource);\n+\t\tif (calculatedVersion != null && calculatedVersion.equals(requestedVersion))\n+\t\t{\n \t\t\tresponse.setCacheDurationToMaximum();\n \t\t\tresponse.setCacheScope(WebResponse.CacheScope.PUBLIC);\n \t\t}\n \t}\n+}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/QueryStringWithVersionResourceCachingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/QueryStringWithVersionResourceCachingStrategy.java\nindex 292f159..e40e082 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/QueryStringWithVersionResourceCachingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/QueryStringWithVersionResourceCachingStrategy.java\n@@ -127,7 +127,12 @@ public void undecorateUrl(ResourceUrl url)\n \t@Override\n \tpublic void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource)\n \t{\n+\t\tString requestedVersion = RequestCycle.get().getMetaData(URL_VERSION);\n+\t\tString calculatedVersion = this.resourceVersion.getVersion(resource);\n+\t\tif (calculatedVersion != null && calculatedVersion.equals(requestedVersion))\n+\t\t{\n \t\t\tresponse.setCacheDurationToMaximum();\n \t\t\tresponse.setCacheScope(WebResponse.CacheScope.PUBLIC);\n \t\t}\n \t}\n+}\n", "nb_test": 1544, "linesAdd": 10, "jira_id": "5441", "singleLine": false, "nb_skipped": 2, "commit": "8ccb1f6d", "nb_failure": 2, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["AjaxCallbackFunctionTest.testCallbackFunctionWithAll:163->Assert.assertEquals:144->Assert.assertEquals:115 expected:<....0-\"};", "var params = [[{\"name\":\"explicit\",\"value\":explicit},{\"name\":\"resolved\",\"value\":window.location.href},{\"name\":\"converted\",\"value\":converted.substring(0, 3)}];", "attrs.ep = params.concat(attrs.ep)];", "Wicket.Ajax.ajax(a...> but was:<....0-\"};", "var params = [{'explicit': explicit,'resolved': window.location.href,'converted': converted.substring(0, 3)};", "attrs.ep = params];", "Wicket.Ajax.ajax(a...>", "AjaxCallbackFunctionTest.testCallbackFunctionWithContext:58->Assert.assertEquals:144->Assert.assertEquals:115 expected:<....0-\"};", "var params = [[];", "attrs.ep = params.concat(attrs.ep)];", "Wicket.Ajax.ajax(a...> but was:<....0-\"};", "var params = [{};", "attrs.ep = params];", "Wicket.Ajax.ajax(a...>", "AjaxCallbackFunctionTest.testCallbackFunctionWithConverted:133->Assert.assertEquals:144->Assert.assertEquals:115 expected:<....0-\"};", "var params = [[{\"name\":\"converted\",\"value\":converted.substring(0, 3)}];", "attrs.ep = params.concat(attrs.ep)];", "Wicket.Ajax.ajax(a...> but was:<....0-\"};", "var params = [{'converted': converted.substring(0, 3)};", "attrs.ep = params];", "Wicket.Ajax.ajax(a...>", "AjaxCallbackFunctionTest.testCallbackFunctionWithExplicit:82->Assert.assertEquals:144->Assert.assertEquals:115 expected:<....0-\"};", "var params = [[{\"name\":\"explicit\",\"value\":explicit}];", "attrs.ep = params.concat(attrs.ep)];", "Wicket.Ajax.ajax(a...> but was:<....0-\"};", "var params = [{'explicit': explicit};", "attrs.ep = params];", "Wicket.Ajax.ajax(a...>", "AjaxCallbackFunctionTest.testCallbackFunctionWithResolved:105->Assert.assertEquals:144->Assert.assertEquals:115 expected:<....0-\"};", "var params = [[{\"name\":\"resolved\",\"value\":window.location.href}];", "attrs.ep = params.concat(attrs.ep)];", "Wicket.Ajax.ajax(a...> but was:<....0-\"};", "var params = [{'resolved': window.location.href};", "attrs.ep = params];", "Wicket.Ajax.ajax(a...>", "AjaxCallbackFunctionTest.testDefaultCallbackFunction:34->Assert.assertEquals:144->Assert.assertEquals:115 expected:<....0-\"};", "var params = [[];", "attrs.ep = params.concat(attrs.ep)];", "Wicket.Ajax.ajax(a...> but was:<....0-\"};", "var params = [{};", "attrs.ep = params];", "Wicket.Ajax.ajax(a...>", "AjaxCallbackFunctionTest.testJQueryUIEvent:201->Assert.assertEquals:144->Assert.assertEquals:115 expected:<....0-\"};", "var params = [[{\"name\":\"sortIndex\",\"value\":$(this).find(':data(sortable-item)').index(ui.item)},{\"name\":\"sortItemId\",\"value\":$(ui.item).attr('id')},{\"name\":\"sortSenderId\",\"value\":$(ui.sender).attr('id')}];", "attrs.ep = params.concat(attrs.ep)];", "Wicket.Ajax.ajax(a...> but was:<....0-\"};", "var params = [{'sortIndex': $(this).find(':data(sortable-item)').index(ui.item),'sortItemId': $(ui.item).attr('id'),'sortSenderId': $(ui.sender).attr('id')};", "attrs.ep = params];", "Wicket.Ajax.ajax(a...>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractDefaultAjaxBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractDefaultAjaxBehavior.java\nindex a309635..bc0989d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractDefaultAjaxBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractDefaultAjaxBehavior.java\n@@ -504,30 +504,28 @@ public CharSequence getCallbackFunctionBody(CallbackParameter... extraParameters\n \t\tsb.append(\"var attrs = \");\n \t\tsb.append(attrsJson);\n \t\tsb.append(\";\\n\");\n-\t\tsb.append(\"var params = {\");\n-\t\tboolean first = true;\n+\t\tJSONArray jsonArray = new JSONArray();\n \t\tfor (CallbackParameter curExtraParameter : extraParameters)\n \t\t{\n \t\t\tif (curExtraParameter.getAjaxParameterName() != null)\n \t\t\t{\n-\t\t\t\tif (!first)\n-\t\t\t\t\tsb.append(',');\n-\t\t\t\telse\n-\t\t\t\t\tfirst = false;\n-\t\t\t\tsb.append('\\'').append(curExtraParameter.getAjaxParameterName()).append(\"': \")\n-\t\t\t\t\t.append(curExtraParameter.getAjaxParameterCode());\n-\t\t\t}\n-\t\t}\n-\t\tsb.append(\"};\\n\");\n-\t\tif (attributes.getExtraParameters().isEmpty())\n+\t\t\t\ttry\n \t\t\t\t{\n-\t\t\tsb.append(\"attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS).append(\" = params;\\n\");\n+\t\t\t\t\tJSONObject object = new JSONObject();\n+\t\t\t\t\tobject.put(\"name\", curExtraParameter.getAjaxParameterName());\n+\t\t\t\t\tobject.put(\"value\", new JsonFunction(curExtraParameter.getAjaxParameterCode()));\n+\t\t\t\t\tjsonArray.put(object);\n \t\t\t\t}\n-\t\telse\n+\t\t\t\tcatch (JSONException e)\n \t\t\t\t{\n-\t\t\tsb.append(\"attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS).append(\" = Wicket.merge(attrs.\")\n-\t\t\t\t\t.append(AjaxAttributeName.EXTRA_PARAMETERS).append(\", params);\\n\");\n+\t\t\t\t\tthrow new WicketRuntimeException(e);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n+\t\tsb.append(\"var params = \").append(jsonArray).append(\";\\n\");\n+\t\tsb.append(\"attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS)\n+\t\t\t\t.append(\" = params.concat(attrs.\")\n+\t\t\t\t.append(AjaxAttributeName.EXTRA_PARAMETERS).append(\");\\n\");\n \t\tsb.append(\"Wicket.Ajax.ajax(attrs);\\n\");\n \t\treturn sb;\n \t}\n", "nb_test": 1706, "linesAdd": 14, "jira_id": "5759", "singleLine": false, "nb_skipped": 1, "commit": "0374c040", "nb_failure": 7, "linesRem": 16}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["CreditCardValidatorTest.isChinaUnionPay:168->Assert.assertEquals:144->Assert.assertEquals:118->Assert.failNotEquals:834->Assert.fail:88 expected:<CHINA_UNIONPAY> but was:<INVALID>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java b/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\nindex 28225c2..eeff47b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n@@ -322,7 +322,7 @@ private CreditCard isChinaUnionPay(String creditCardNumber)\n \t\tif ((creditCardNumber.length() >= 16 && creditCardNumber.length() <= 19) &&\n \t\t\t(creditCardNumber.startsWith(\"622\")))\n \t\t{\n-\t\t\tint firstDigits = Integer.parseInt(creditCardNumber.substring(0, 5));\n+\t\t\tint firstDigits = Integer.parseInt(creditCardNumber.substring(0, 6));\n \t\t\tif (firstDigits >= 622126 && firstDigits <= 622925)\n \t\t\t{\n \t\t\t\treturn CreditCard.CHINA_UNIONPAY;\n", "nb_test": 1746, "linesAdd": 1, "jira_id": "5891", "singleLine": false, "nb_skipped": 1, "commit": "2d9ebf9a", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ResourceUtilsTest.getLocaleFromFilename:39->Assert.assertThat:832->Assert.assertThat:865", "Expected: is \"some.ext\"", "but: was \"some\""], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java b/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\nindex e7ec95a..3216707 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\n@@ -33,10 +33,10 @@\n {\r\n \tprivate static final Pattern LOCALE_PATTERN = Pattern.compile(\"_([a-z]{2})(_([A-Z]{2})(_([^_]+))?)?$\");\r\n \r\n-\tprivate final static Set<String> isoCountries = new ConcurrentHashSet<String>(\r\n+\tprivate final static Set<String> isoCountries = new ConcurrentHashSet<>(\r\n \t\tArrays.asList(Locale.getISOCountries()));\r\n \r\n-\tprivate final static Set<String> isoLanguages = new ConcurrentHashSet<String>(\r\n+\tprivate final static Set<String> isoLanguages = new ConcurrentHashSet<>(\r\n \t\tArrays.asList(Locale.getISOLanguages()));\r\n \r\n \t/**\r\n@@ -56,7 +56,7 @@ private ResourceUtils()\n \tpublic static PathLocale getLocaleFromFilename(String path)\r\n \t{\r\n \t\tString extension = \"\";\r\n-\t\tint pos = path.indexOf('.');\r\n+\t\tint pos = path.lastIndexOf('.');\r\n \t\tif (pos != -1)\r\n \t\t{\r\n \t\t\textension = path.substring(pos);\r\n@@ -104,7 +104,7 @@ public static PathLocale getLocaleFromFilename(String path)\n \t\t\t}\r\n \t\t} // else skip the whole thing... probably user specific underscores used\r\n \r\n-\t\treturn new PathLocale(path, null);\r\n+\t\treturn new PathLocale(path + extension, null);\r\n \t}\r\n \r\n \t/**\r\n", "nb_test": 180, "linesAdd": 4, "jira_id": "5706", "singleLine": false, "nb_skipped": 2, "commit": "0f8a6d75", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["MarkupContainerTest.getIndexedOutOfBounds Expected exception: java.lang.ArrayIndexOutOfBoundsException"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 7941203..b739d47 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -1016,15 +1016,17 @@ public void component(final Component component, final IVisit<Void> visit)\n \t@Deprecated\n \tpublic final Component get(int index)\n \t{\n+\t\tfinal int requestedIndex = index;\n \t\tComponent childAtIndex = null;\n \t\tIterator<Component> childIterator = iterator();\n-\t\twhile (index-- >= 0 && childIterator.hasNext())\n+\t\twhile (index >= 0 && childIterator.hasNext())\n \t\t{\n \t\t\tchildAtIndex = childIterator.next();\n+\t\t\tindex--;\n \t\t}\n-\t\tif(childAtIndex == null) \n+\t\tif(index >= 0 || childAtIndex == null)\n \t\t{\n-\t\t\tthrow new ArrayIndexOutOfBoundsException(Integer.toString(index));\n+\t\t\tthrow new ArrayIndexOutOfBoundsException(Integer.toString(requestedIndex));\n \t\t}\n \t\treturn childAtIndex;\n \t}\n", "nb_test": 1870, "linesAdd": 5, "jira_id": "5981", "singleLine": false, "nb_skipped": 1, "commit": "eb125865", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testHideableBorder(org.apache.wicket.markup.html.border.ComponentBorderTest)", "testAjaxHeaderContribution(org.apache.wicket.ajax.AjaxHeaderContributionTest)", "testDoubleAjaxHeaderContribution(org.apache.wicket.ajax.AjaxHeaderContributionTest)", "test_1(org.apache.wicket.markup.html.header.HeaderScopingTest)", "testEventJavaScriptEscaped(org.apache.wicket.ajax.form.AjaxFormSubmitTest)", "testInlinePanel_7(org.apache.wicket.markup.html.panel.PanelTest)", "testInlinePanel_8(org.apache.wicket.markup.html.panel.PanelTest)", "testScript(org.apache.wicket.markup.MarkupParserTest)", "testScript1(org.apache.wicket.markup.MarkupParserTest)", "testRenderHomePage_2(org.apache.wicket.ajax.markup.html.componentMap.SimpleTestPanelTest)", "testRenderHomePage_1(org.apache.wicket.ajax.markup.html.ajaxLink.AjaxLinkTest)", "testRenderHomePage_2(org.apache.wicket.ajax.markup.html.ajaxLink.AjaxLinkTest)", "testPage_2(org.apache.wicket.ajax.markup.html.ajaxLink.AjaxLinkTest)", "test_1(org.apache.wicket.markup.html.header.testing.HeaderTest)", "testRenderHomePage_12(org.apache.wicket.markup.html.basic.SimplePageTest)", "testRenderHomePage_13(org.apache.wicket.markup.html.basic.SimplePageTest)", "testRendering(org.apache.wicket.ajax.form.OnChangeAjaxBehaviorTest)", "testHeaderContribution1(org.apache.wicket.ajax.AjaxRequestTargetTest)", "test_2(org.apache.wicket.markup.html.header.inheritance.InheritanceHeadTest)", "testDomReadyOrder(org.apache.wicket.ajax.DomReadyOrderTest)", "testDomReadyOrder2(org.apache.wicket.ajax.DomReadyOrderTest)", "testDetachPage(org.apache.wicket.ComponentTest)", "testDetachPageAjaxRequest(org.apache.wicket.ComponentTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/util/string/JavaScriptUtils.java b/wicket-core/src/main/java/org/apache/wicket/util/string/JavaScriptUtils.java\nindex 6101006..8897e62 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/util/string/JavaScriptUtils.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/util/string/JavaScriptUtils.java\n@@ -27,22 +27,22 @@\n public class JavaScriptUtils\n {\n \t/** Script open tag */\n-\tpublic final static String SCRIPT_OPEN_TAG = \"<script type=\\\"text/javascript\\\"><!--/*--><![CDATA[/*><!--*/\\n\";\n+\tpublic final static String SCRIPT_OPEN_TAG = \"<script type=\\\"text/javascript\\\">\\n/*<![CDATA[*/\\n\";\n \n \t/** Script close tag */\n-\tpublic final static String SCRIPT_CLOSE_TAG = \"\\n/*-->]]>*/</script>\\n\";\n+\tpublic final static String SCRIPT_CLOSE_TAG = \"\\n/*]]>*/\\n</script>\\n\";\n \n \t/**\n \t * Script open tag. If this tag is changed, also update Wicket.Head.Contributor.processScript()\n \t * function from wicket-ajax.js\n \t */\n-\tpublic final static String SCRIPT_CONTENT_PREFIX = \"<!--/*--><![CDATA[/*><!--*/\\n\";\n+\tpublic final static String SCRIPT_CONTENT_PREFIX = \"\\n/*<![CDATA[*/\\n\";\n \n \t/**\n \t * Script close tag. If this tag is changed, also update Wicket.Head.Contributor.processScript()\n \t * function from wicket-ajax.js\n \t */\n-\tpublic final static String SCRIPT_CONTENT_SUFFIX = \"\\n/*-->]]>*/\";\n+\tpublic final static String SCRIPT_CONTENT_SUFFIX = \"\\n/*]]>*/\\n\";\n \n \n \t/** The response object */\n", "nb_test": 1077, "linesAdd": 4, "jira_id": "3597", "singleLine": false, "nb_skipped": 0, "commit": "5e2c6702", "nb_failure": 23, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["UrlTest.parseIp6Address:1088 \u00bb NumberFormat For input string: \"1]\""], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 9d5b401..be49640 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -290,7 +290,11 @@ public static Url parse(CharSequence _url, Charset charset, boolean isFullHint)\n \t\t\t}\n \n \t\t\tfinal int credentialsAt = hostAndPort.lastIndexOf('@') + 1;\n-\t\t\tfinal int portAt = hostAndPort.substring(credentialsAt).lastIndexOf(':');\n+\t\t\t//square brackets are used for ip6 URLs\n+\t\t\tfinal int closeSqrBracketAt = hostAndPort.lastIndexOf(']') + 1;\n+\t\t\tfinal int portAt = hostAndPort.substring(credentialsAt)\n+\t\t\t\t\t\t\t\t\t\t  .substring(closeSqrBracketAt)\n+\t\t\t\t\t\t\t\t\t      .lastIndexOf(':');\n \n \t\t\tif (portAt == -1)\n \t\t\t{\n@@ -299,8 +303,10 @@ public static Url parse(CharSequence _url, Charset charset, boolean isFullHint)\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tresult.host = hostAndPort.substring(0, portAt + credentialsAt);\n-\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portAt + credentialsAt + 1));\n+\t\t\t\tfinal int portOffset = portAt + credentialsAt + closeSqrBracketAt;\n+\t\t\t\t\n+\t\t\t\tresult.host = hostAndPort.substring(0, portOffset);\n+\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portOffset + 1));\n \t\t\t}\n \n \t\t\tif (relativeAt < 0)\n", "nb_test": 106, "linesAdd": 8, "jira_id": "5809", "singleLine": false, "nb_skipped": 0, "commit": "b1f4e6a3", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["CompoundRequestMapperTest.unmountNested:81->Assert.assertEquals:542->Assert.assertEquals:555->Assert.assertEquals:118->Assert.failNotEquals:743->Assert.fail:88 expected:<1> but was:<0>"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/CompoundRequestMapper.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/CompoundRequestMapper.java\nindex bbd6277..94635b3 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/CompoundRequestMapper.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/CompoundRequestMapper.java\n@@ -251,7 +251,12 @@ public void unmount(String path)\n \n \t\tfor (IRequestMapper mapper : this)\n \t\t{\n-\t\t\tif (mapper.mapRequest(request) != null)\n+\t\t\tif (mapper instanceof ICompoundRequestMapper)\n+\t\t\t{\n+\t\t\t\tICompoundRequestMapper inner = (ICompoundRequestMapper) mapper;\n+\t\t\t\tinner.unmount(path);\n+\t\t\t}\n+\t\t\telse if (mapper.mapRequest(request) != null)\n \t\t\t{\n \t\t\t\tremove(mapper);\n \t\t\t}\n", "nb_test": 103, "linesAdd": 6, "jira_id": "5698", "singleLine": false, "nb_skipped": 0, "commit": "f45ce896", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["encode5(org.apache.wicket.core.request.mapper.PackageMapperTest): expected:<MockPage/i1/i2?15&a=b&b=c> but was:<null>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\nindex 54729e9..63e5914 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n@@ -216,7 +216,7 @@ protected String transformForUrl(final String className)\n \t@Override\n \tprotected boolean pageMustHaveBeenCreatedBookmarkable()\n \t{\n-\t\treturn true;\n+\t\treturn false;\n \t}\n \n \t/**\n", "nb_test": 1547, "linesAdd": 1, "jira_id": "5043", "singleLine": false, "nb_skipped": 2, "commit": "2b1ce91d", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["noData(org.apache.wicket.request.resource.ByteArrayResourceTest): ByteArrayResource's data cannot be 'null'."], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\nindex d11cab8..544f7ad 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\n@@ -21,6 +21,8 @@\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.util.time.Time;\n \n+import javax.servlet.http.HttpServletResponse;\n+\n /**\n  * An {@link IResource} for byte arrays. The byte array can be static - passed to the constructor,\n  * or dynamic - by overriding\n@@ -119,8 +121,10 @@ protected ResourceResponse newResourceResponse(final Attributes attributes)\n \t\tfinal byte[] data = getData(attributes);\n \t\tif (data == null)\n \t\t{\n-\t\t\tthrow new WicketRuntimeException(\"ByteArrayResource's data cannot be 'null'.\");\n+\t\t\tresponse.setError(HttpServletResponse.SC_NOT_FOUND);\n \t\t}\n+\t\telse\n+\t\t{\n \t\t\tresponse.setContentLength(data.length);\n \n \t\t\tif (response.dataNeedsToBeWritten(attributes))\n@@ -146,6 +150,7 @@ public void writeData(final Attributes attributes)\n \n \t\t\t\tconfigureResponse(response, attributes);\n \t\t\t}\n+\t\t}\n \n \t\treturn response;\n \t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/DynamicImageResource.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/DynamicImageResource.java\nindex 472ff45..9e023d0 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/DynamicImageResource.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/DynamicImageResource.java\n@@ -167,9 +167,10 @@ public void writeData(final Attributes attributes)\n \t\t\t\t\t\tattributes.getResponse().write(imageData);\n \t\t\t\t\t}\n \t\t\t\t});\n-\t\t\t}\n+\n \t\t\t\tconfigureResponse(response, attributes);\n \t\t\t}\n+\t\t}\n \n \t\treturn response;\n \t}\n", "nb_test": 1275, "linesAdd": 8, "jira_id": "4301", "singleLine": false, "nb_skipped": 4, "commit": "50b52742", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["detachSubstituteModelFromAssignmentWrapper(org.apache.wicket.model.StringResourceModelTest): Expected: <null> but was: org.apache.wicket.model.StringResourceModelTest$WeatherStation@1285384a"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java b/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\nindex fe74c2f..573a162 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\n@@ -233,6 +233,15 @@ public void detach()\n \t\t}\n \n \t\t@Override\n+\t\tprotected void onDetach()\n+\t\t{\n+\t\t\tif (StringResourceModel.this.component == null)\n+\t\t\t{\n+\t\t\t\tStringResourceModel.this.onDetach();\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n \t\tprotected String load()\n \t\t{\n \t\t\tif (StringResourceModel.this.component != null)\n@@ -582,6 +591,8 @@ protected String load()\n \t@Override\n \tprotected final void onDetach()\n \t{\n+\t\tsuper.onDetach();\n+\n \t\t// detach any model\n \t\tif (model != null)\n \t\t{\n", "nb_test": 1281, "linesAdd": 11, "jira_id": "4323", "singleLine": false, "nb_skipped": 4, "commit": "e24874da", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["decode9(org.apache.wicket.core.request.mapper.PageInstanceMapperTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\nindex 776e546..fb9b3bd 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n@@ -59,9 +59,9 @@ public PageInstanceMapper()\n \t@Override\n \tpublic IRequestHandler mapRequest(Request request)\n \t{\n-\t\tUrl url = request.getUrl();\n-\t\tif (matches(url))\n+\t\tif (matches(request))\n \t\t{\n+\t\t\tUrl url = request.getUrl();\n \t\t\tPageComponentInfo info = getPageComponentInfo(url);\n \t\t\tif (info != null && info.getPageInfo().getPageId() != null)\n \t\t\t{\n@@ -153,16 +153,38 @@ else if (requestHandler instanceof ListenerInterfaceRequestHandler)\n \tpublic int getCompatibilityScore(final Request request)\n \t{\n \t\tint score = 0;\n-\t\tUrl url = request.getUrl();\n-\t\tif (matches(url))\n+\t\tif (matches(request))\n \t\t{\n \t\t\tscore = Integer.MAX_VALUE;\n \t\t}\n \t\treturn score;\n \t}\n \n-\tprivate boolean matches(final Url url)\n+\t/**\n+\t * Matches when the request url starts with\n+\t * {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n+\t * or when the base url starts with {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}\n+\t * and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n+\n+\t * @param request\n+\t *      the request to check\n+\t * @return {@code true} if the conditions match\n+\t */\n+\tprivate boolean matches(final Request request)\n \t{\n-\t\treturn urlStartsWith(url, getContext().getNamespace(), getContext().getPageIdentifier());\n+\t\tboolean matches = false;\n+\t\tUrl url = request.getUrl();\n+\t\tString namespace = getContext().getNamespace();\n+\t\tString pageIdentifier = getContext().getPageIdentifier();\n+\t\tif (urlStartsWith(url, namespace, pageIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n+\t\telse if (urlStartsWith(request.getClientUrl(), namespace) && urlStartsWith(url, pageIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n+\n+\t\treturn matches;\n \t}\n }\n", "nb_test": 1470, "linesAdd": 19, "jira_id": "5071", "singleLine": false, "nb_skipped": 4, "commit": "a2f848f2", "nb_failure": 0, "linesRem": 6}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEncode__bookmarkablePage_nonAsciiClassNames(wicket.protocol.http.request.AbstractWebRequestCodingStrategyTest)"], "patch": "diff --git a/wicket/src/main/java/wicket/protocol/http/request/AbstractWebRequestCodingStrategy.java b/wicket/src/main/java/wicket/protocol/http/request/AbstractWebRequestCodingStrategy.java\nindex 35342cd..dadc062 100644\n--- a/wicket/src/main/java/wicket/protocol/http/request/AbstractWebRequestCodingStrategy.java\n+++ b/wicket/src/main/java/wicket/protocol/http/request/AbstractWebRequestCodingStrategy.java\n@@ -333,7 +333,26 @@ protected CharSequence encode(RequestCycle requestCycle,\n \n \n \t\t\t// Add <page-map-name>:<bookmarkable-page-class>\n-\t\t\turl.append(pageMapName + Component.PATH_SEPARATOR + pageClass.getName());\n+\t\t\tString pageClassName = pageClass.getName();\n+\n+\t\t\t/*\n+\t\t\t * Encode the url so it is correct even for class names containing\n+\t\t\t * non ASCII characters, like \u00e4, \u00e6, \u00f8, \u00e5 etc.\n+\t\t\t * \n+\t\t\t * The reason for this is that when redirecting to these\n+\t\t\t * bookmarkable pages, we need to have the url encoded correctly\n+\t\t\t * because we can't rely on the browser to interpret the unencoded\n+\t\t\t * url correctly.\n+\t\t\t */\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tpageClassName = URLEncoder.encode(pageClassName, \"UTF-8\");\n+\t\t\t}\n+\t\t\tcatch (UnsupportedEncodingException e)\n+\t\t\t{\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t\turl.append(pageMapName + Component.PATH_SEPARATOR + pageClassName);\n \t\t}\n \n \t\t// Is it a bookmarkable interface listener?\n", "nb_test": 372, "linesAdd": 11, "jira_id": "16", "singleLine": false, "nb_skipped": 0, "commit": "3431e60d", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["getSetUnmodifiableCollection(org.apache.wicket.markup.html.form.CollectionFormComponentTest)", "getUnmodifiableFails(org.apache.wicket.markup.html.form.CollectionFormComponentTest): Unexpected exception, expected<org.apache.wicket.WicketRuntimeException> but was<java.lang.UnsupportedOperationException>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\nindex fdeb8c6..cb4ad05 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n@@ -1610,8 +1610,8 @@ public final void updateAutoLabels(AjaxRequestTarget target)\n \t * @param formComponent\n \t *            the form component to update\n \t * @see FormComponent#updateModel()\n-\t * @throws UnsupportedOperationException\n-\t *             if the existing model object Collection cannot be modified\n+\t * @throws WicketRuntimeException\n+\t *             if the existing model object collection is unmodifiable and no setter exists\n \t */\n \tpublic static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent)\n \t{\n@@ -1625,23 +1625,42 @@ public final void updateAutoLabels(AjaxRequestTarget target)\n \t\t}\n \t\telse\n \t\t{\n+\t\t\tException failure;\n+\n \t\t\tformComponent.modelChanging();\n+\t\t\t\n+\t\t\ttry {\n \t\t\t\tcollection.clear();\n \t\t\t\tif (convertedInput != null)\n \t\t\t\t{\n \t\t\t\t\tcollection.addAll(convertedInput);\n \t\t\t\t}\n-\t\t\tformComponent.modelChanged();\n+\t\t\t\tfailure = null;\n+\t\t\t} catch (UnsupportedOperationException unmodifiable) {\n+\t\t\t\tlogger.debug(\"An error occurred while trying to change the collection attached to \" + formComponent, unmodifiable);\n+\n+\t\t\t\tfailure = unmodifiable;\n+\t\t\t\tcollection = new ArrayList<>(convertedInput); \n+\t\t\t}\n \t\t\t\n \t\t\ttry\n \t\t\t{\n \t\t\t\tformComponent.getModel().setObject(collection);\n+\t\t\t\tfailure = null;\n \t\t\t}\n-\t\t\tcatch (Exception e)\n+\t\t\tcatch (Exception noSetter)\n \t\t\t{\n-\t\t\t\t// ignore this exception because it could be that there\n-\t\t\t\t// is not setter for this collection.\n-\t\t\t\tlogger.info(\"An error occurred while trying to set the new value for the property attached to \" + formComponent, e);\n+\t\t\t\tlogger.debug(\"An error occurred while trying to set the collection attached to \" + formComponent, noSetter);\n+\t\t\t\t\n+\t\t\t\tif (failure != null) {\n+\t\t\t\t\tfailure = noSetter;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\tif (failure == null) {\n+\t\t\t\tformComponent.modelChanged();\n+\t\t\t} else {\n+\t\t\t\tthrow new WicketRuntimeException(\"Unable to update the collection attached to \" + formComponent); \n \t\t\t}\n \t\t}\n \t}\n", "nb_test": 1616, "linesAdd": 24, "jira_id": "5518", "singleLine": false, "nb_skipped": 2, "commit": "c2e12216", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSubmitMultipartForm(org.apache.wicket.util.tester.FormTesterTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java b/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\nindex e282be1..c521441 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\n@@ -487,8 +487,6 @@ public String getHeader(final String name)\n \t */\n \tpublic ServletInputStream getInputStream() throws IOException\n \t{\n-\t\tif (uploadedFiles != null && uploadedFiles.size() > 0)\n-\t\t{\n \t\tbyte[] request = buildRequest();\n \n \t\t// Ok lets make an input stream to return\n@@ -503,18 +501,6 @@ public int read()\n \t\t\t}\n \t\t};\n \t}\n-\t\telse\n-\t\t{\n-\t\t\treturn new ServletInputStream()\n-\t\t\t{\n-\t\t\t\t@Override\n-\t\t\t\tpublic int read()\n-\t\t\t\t{\n-\t\t\t\t\treturn -1;\n-\t\t\t\t}\n-\t\t\t};\n-\t\t}\n-\t}\n \n \t/**\n \t * Get the given header as an int.\n", "nb_test": 723, "linesAdd": 0, "jira_id": "1931", "singleLine": false, "nb_skipped": 0, "commit": "986848f7", "nb_failure": 1, "linesRem": 14}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["decode12(org.apache.wicket.core.request.mapper.MountedMapperTest): expected:<2> but was:<0>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\nindex 668d0a4..93c22d2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n@@ -246,9 +246,14 @@ protected IRequestHandler processListener(PageComponentInfo pageComponentInfo,\n \n \t\tif (listenerInterface != null)\n \t\t{\n-\t\t\t// WICKET-4594 - ignore the parsed parameters as they have nothing to do with the page\n+\t\t\tif (pageInfo.getPageId() != null)\n+\t\t\t{\n+\t\t\t\t// WICKET-4594 - ignore the parsed parameters for stateful pages\n+\t\t\t\tpageParameters = null;\n+\t\t\t}\n+\n \t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(),\n-\t\t\t\tpageClass, null, renderCount, componentInfo.getComponentPath());\n+\t\t\t\tpageClass, pageParameters, renderCount, componentInfo.getComponentPath());\n \n \t\t\tprovider.setPageSource(getContext());\n \n", "nb_test": 1460, "linesAdd": 6, "jira_id": "4594", "singleLine": false, "nb_skipped": 3, "commit": "5e1bf8d8", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEncode__bookmarkablePage_nonAsciiClassNames(wicket.protocol.http.request.WebRequestCodingStrategyTest)"], "patch": "diff --git a/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java b/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\nindex 7d45266..93d5d96 100644\n--- a/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\n+++ b/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\n@@ -563,7 +563,25 @@ protected CharSequence encode(RequestCycle requestCycle,\n \n \n \t\t\t// Add <page-map-name>:<bookmarkable-page-class>\n-\t\t\turl.append(pageMapName + Component.PATH_SEPARATOR + pageClass.getName());\n+\t\t\tString pageClassName = pageClass.getName();\n+\t\t\t/*\n+\t\t\t * Encode the url so it is correct even for class names containing\n+\t\t\t * non ASCII characters, like \u00e4, \u00e6, \u00f8, \u00e5 etc.\n+\t\t\t * \n+\t\t\t * The reason for this is that when redirecting to these\n+\t\t\t * bookmarkable pages, we need to have the url encoded correctly\n+\t\t\t * because we can't rely on the browser to interpret the unencoded\n+\t\t\t * url correctly.\n+\t\t\t */\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tpageClassName = URLEncoder.encode(pageClassName, \"UTF-8\");\n+\t\t\t}\n+\t\t\tcatch (UnsupportedEncodingException e)\n+\t\t\t{\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t\turl.append(pageMapName + Component.PATH_SEPARATOR + pageClassName);\n \t\t}\n \n \t\t// Get page parameters\n", "nb_test": 362, "linesAdd": 10, "jira_id": "16", "singleLine": false, "nb_skipped": 0, "commit": "6c5083b4", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["exact(org.apache.wicket.validation.validator.RangeValidatorTest): expected:<1> but was:<null>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/validation/validator/AbstractRangeValidator.java b/wicket-core/src/main/java/org/apache/wicket/validation/validator/AbstractRangeValidator.java\nindex babc170..f6ba851 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/validation/validator/AbstractRangeValidator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/validation/validator/AbstractRangeValidator.java\n@@ -109,7 +109,8 @@ public void validate(IValidatable<V> validatable)\n \t\tfinal R max = getMaximum();\r\n \t\tif ((min != null && value.compareTo(min) < 0) || (max != null && value.compareTo(max) > 0))\r\n \t\t{\r\n-\t\t\tValidationError error = new ValidationError(this, getMode().getVariation());\r\n+\t\t\tMode mode = getMode();\r\n+\t\t\tValidationError error = new ValidationError(this, mode.getVariation());\r\n \t\t\tif (min != null)\r\n \t\t\t{\r\n \t\t\t\terror.setVariable(\"minimum\", min);\r\n@@ -118,6 +119,10 @@ public void validate(IValidatable<V> validatable)\n \t\t\t{\r\n \t\t\t\terror.setVariable(\"maximum\", max);\r\n \t\t\t}\r\n+\t\t\tif (mode == Mode.EXACT)\r\n+\t\t\t{\r\n+\t\t\t\terror.setVariable(\"exact\", max);\r\n+\t\t\t}\r\n \t\t\tvalidatable.error(decorate(error, validatable));\r\n \t\t}\r\n \t}\r\n", "nb_test": 1393, "linesAdd": 6, "jira_id": "4717", "singleLine": false, "nb_skipped": 5, "commit": "6a1b2f61", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["parseAbsoluteUrl(org.apache.wicket.request.UrlTest)"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 6d77f1d..247197e 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -116,10 +116,11 @@ public static Url parse(final String url)\n \t * Parses the given URL string.\n \t * \n \t * @param url\n+\t *           full absolute or relative url with query string\n \t * @param charset\n \t * @return Url object\n \t */\n-\tpublic static Url parse(final String url, Charset charset)\n+\tpublic static Url parse(String url, Charset charset)\n \t{\n \t\tArgs.notNull(url, \"url\");\n \n@@ -128,36 +129,79 @@ public static Url parse(final String url, Charset charset)\n \t\t// the url object resolved the charset, use that\n \t\tcharset = result.getCharset();\n \n-\t\tString segments;\n-\t\tString query;\n+\t\t// extract query string part\n+\t\tfinal String queryString;\n+\t\tfinal String absoluteUrl;\n \n-\t\tint qIndex = url.indexOf('?');\n+\t\tint queryAt = url.indexOf('?');\n \n-\t\tif (qIndex == -1)\n+\t\tif (queryAt == -1)\n \t\t{\n-\t\t\tsegments = url;\n-\t\t\tquery = \"\";\n+\t\t\tqueryString = \"\";\n+\t\t\tabsoluteUrl = url;\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tsegments = url.substring(0, qIndex);\n-\t\t\tquery = url.substring(qIndex + 1);\n+\t\t\tabsoluteUrl = url.substring(0, queryAt);\n+\t\t\tqueryString = url.substring(queryAt + 1);\n \t\t}\n \t\t\n-\t\tif (segments.length() > 0)\n+\t\t// get absolute / relative part of url\n+\t\tString relativeUrl;\n+\n+\t\t// absolute urls contain a scheme://\n+\t\tfinal int protocolAt = absoluteUrl.indexOf(\"://\");\n+\n+\t\tif (protocolAt != -1)\n \t\t{\n+\t\t\tresult.protocol = absoluteUrl.substring(0, protocolAt);\n+\t\t\tfinal String afterProto = absoluteUrl.substring(protocolAt + 3);\n+\t\t\tfinal String hostAndPort;\n+\n+\t\t\tint relativeAt = afterProto.indexOf('/');\n \n+\t\t\tif (relativeAt == -1)\n+\t\t\t{\n+\t\t\t\trelativeUrl = \"\";\n+\t\t\t\thostAndPort = afterProto;\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\trelativeUrl = afterProto.substring(relativeAt);\n+\t\t\t\thostAndPort = afterProto.substring(0, relativeAt);\n+\t\t\t}\n+\n+\t\t\tint portAt = hostAndPort.indexOf(':');\n+\n+\t\t\tif (portAt == -1)\n+\t\t\t{\n+\t\t\t\tresult.host = hostAndPort;\n+\t\t\t\tresult.port = null;\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tresult.host = hostAndPort.substring(0, portAt);\n+\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n+\t\t\t}\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\trelativeUrl = absoluteUrl;\n+\t\t}\n+\n+\t\tif (relativeUrl.length() > 0)\n+\t\t{\n \t\t\tboolean removeLast = false;\n-\t\t\tif (segments.endsWith(\"/\"))\n+\t\t\tif (relativeUrl.endsWith(\"/\"))\n \t\t\t{\n \t\t\t\t// we need to append something and remove it after splitting\n \t\t\t\t// because otherwise the\n \t\t\t\t// trailing slashes will be lost\n-\t\t\t\tsegments += \"/x\";\n+\t\t\t\trelativeUrl += \"/x\";\n \t\t\t\tremoveLast = true;\n \t\t\t}\n \n-\t\t\tString segmentArray[] = Strings.split(segments, '/');\n+\t\t\tString segmentArray[] = Strings.split(relativeUrl, '/');\n \n \t\t\tif (removeLast)\n \t\t\t{\n@@ -173,9 +217,9 @@ public static Url parse(final String url, Charset charset)\n \t\t\t}\n \t\t}\n \n-\t\tif (query.length() > 0)\n+\t\tif (queryString.length() > 0)\n \t\t{\n-\t\t\tString queryArray[] = Strings.split(query, '&');\n+\t\t\tString queryArray[] = Strings.split(queryString, '&');\n \t\t\tfor (String s : queryArray)\n \t\t\t{\n \t\t\t\tresult.parameters.add(parseQueryParameter(s, charset));\n", "nb_test": 10, "linesAdd": 55, "jira_id": "3834", "singleLine": false, "nb_skipped": 0, "commit": "30255f11", "nb_failure": 1, "linesRem": 15}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["expand(org.apache.wicket.markup.parser.filter.OpenCloseTagExpanderTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/OpenCloseTagExpander.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/OpenCloseTagExpander.java\nindex f737c74..9e3abf8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/OpenCloseTagExpander.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/OpenCloseTagExpander.java\n@@ -37,6 +37,10 @@\n  */\r\n public class OpenCloseTagExpander extends AbstractMarkupFilter\r\n {\r\n+\t// A list of elements which should not be expanded from TagType.OPEN_CLOSE to TagType.OPEN + TagType.CLOSE\r\n+\t// http://www.w3.org/TR/html-markup/syntax.html#void-element\r\n+\t// area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr\r\n+\r\n \tprivate static final List<String> replaceForTags = Arrays.asList(\"a\", \"q\", \"sub\", \"sup\",\r\n \t\t\"abbr\", \"acronym\", \"cite\", \"code\", \"del\", \"dfn\", \"em\", \"ins\", \"kbd\", \"samp\", \"var\",\r\n \t\t\"label\", \"textarea\", \"tr\", \"td\", \"th\", \"caption\", \"thead\", \"tbody\", \"tfoot\", \"dl\", \"dt\",\r\n@@ -52,12 +56,9 @@\n \t\t\"b\",\r\n \t\t\"e\",\r\n \t\t\"select\",\r\n-\t\t\"col\",\r\n \r\n-\t\t// New HTML5 elements (excluding: open-close tags:\r\n-\t\t// wbr, source, time, embed, keygen\r\n \t\t// @TODO by now an exclude list is probably shorter\r\n-\t\t\"article\", \"aside\", \"command\", \"details\", \"summary\", \"figure\", \"figcaption\", \"footer\",\r\n+\t\t\"article\", \"aside\", \"details\", \"summary\", \"figure\", \"figcaption\", \"footer\",\r\n \t\t\"header\", \"hgroup\", \"mark\", \"meter\", \"nav\", \"progress\", \"ruby\", \"rt\", \"rp\", \"section\",\r\n \t\t\"audio\", \"video\", \"canvas\", \"datalist\", \"output\");\r\n \r\n", "nb_test": 1498, "linesAdd": 2, "jira_id": "5237", "singleLine": false, "nb_skipped": 4, "commit": "b61fe92c", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 8, "classification": {"singleLine": false}, "failing_tests": ["idGeneratedWhenComponentNotAddedToPage(org.apache.wicket.markup.html.ComponentMarkupIdTest)", "idGeneratedWhenPanelNotAddedToPage(org.apache.wicket.markup.html.ComponentMarkupIdTest)", "idFromMarkupRetrievedWhenPanelAddedToPage(org.apache.wicket.markup.html.ComponentMarkupIdTest)", "idFromMarkupRetrievedWhenLabelAddedToPage(org.apache.wicket.markup.html.ComponentMarkupIdTest)", "generatedIdOverridesIdFromMarkupWhenLabelAddedToPage(org.apache.wicket.markup.html.ComponentMarkupIdTest)", "generatedIdOverridesIdFromMarkup(org.apache.wicket.markup.html.ComponentMarkupIdTest)", "fixedIdFromJavaForLabelOverridesIdFromMarkup(org.apache.wicket.markup.html.ComponentMarkupIdTest)", "fixedIdFromJavaForPanelOverridesIdFromMarkup(org.apache.wicket.markup.html.ComponentMarkupIdTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 6644c24..e81ffa5 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -1499,18 +1499,20 @@ public final ValueMap getMarkupAttributes()\n \t */\n \tpublic final Object getMarkupIdImpl()\n \t{\n-\t\tString id = getMarkupIdFromMarkup();\n-\t\tif (id != null)\n-\t\t{\n-\t\t\treturn id;\n-\t\t}\n-\n \t\tif (generatedMarkupId != -1)\n \t\t{\n \t\t\treturn generatedMarkupId;\n \t\t}\n \n-\t\treturn getMetaData(MARKUP_ID_KEY);\n+\t\tString id = getMetaData(MARKUP_ID_KEY);\n+\n+\t\t// if still no markup id is found, and the component has been attached to a page, try to\n+\t\t// retrieve the id from the markup file.\n+\t\tif (id == null && findPage() != null)\n+\t\t{\n+\t\t\tid = getMarkupIdFromMarkup();\n+\t\t}\n+\t\treturn id;\n \t}\n \n \t/**\n", "nb_test": 1127, "linesAdd": 7, "jira_id": "3647", "singleLine": false, "nb_skipped": 0, "commit": "1b57b51c", "nb_failure": 0, "linesRem": 7}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["getSessionFromNonMockHttpSession(org.apache.wicket.protocol.http.mock.MockHttpServletRequestTest): MockHttpServletRequest knows how to work only with MockHttpSession", "getSessionDefaultFromMockHttpSession(org.apache.wicket.protocol.http.mock.MockHttpServletRequestTest): HttpSession should be created! expected same:<org.apache.wicket.protocol.http.mock.MockHttpSession@66b98ed9> was not:<null>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletRequest.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletRequest.java\nindex a93eb7f..73dc26f 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletRequest.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletRequest.java\n@@ -1068,11 +1068,7 @@ public String getServletPath()\n \t@Override\r\n \tpublic HttpSession getSession()\r\n \t{\r\n-\t\tif (session instanceof MockHttpSession && ((MockHttpSession)session).isTemporary())\r\n-\t\t{\r\n-\t\t\treturn null;\r\n-\t\t}\r\n-\t\treturn session;\r\n+\t\treturn getSession(true);\r\n \t}\r\n \r\n \t/**\r\n@@ -1085,11 +1081,21 @@ public HttpSession getSession()\n \t@Override\r\n \tpublic HttpSession getSession(boolean b)\r\n \t{\r\n-\t\tif (b && session instanceof MockHttpSession)\r\n+\t\tHttpSession sess = null;\r\n+\t\tif (session instanceof MockHttpSession)\r\n+\t\t{\r\n+\t\t\tMockHttpSession mockHttpSession = (MockHttpSession) session;\r\n+\t\t\tif (b)\r\n \t\t\t{\r\n-\t\t\t((MockHttpSession)session).setTemporary(false);\r\n+\t\t\t\tmockHttpSession.setTemporary(false);\r\n+\t\t\t}\r\n+\r\n+\t\t\tif (mockHttpSession.isTemporary() == false)\r\n+\t\t\t{\r\n+\t\t\t\tsess = session;\r\n+\t\t\t}\r\n \t\t}\r\n-\t\treturn getSession();\r\n+\t\treturn sess;\r\n \t}\r\n \r\n \t/**\r\n", "nb_test": 1296, "linesAdd": 14, "jira_id": "4370", "singleLine": false, "nb_skipped": 4, "commit": "7ca927c1", "nb_failure": 2, "linesRem": 8}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PackageMapperTest.testGetCompatibilityScore:658->Assert.assertEquals:542->Assert.assertEquals:555->Assert.assertEquals:118->Assert.failNotEquals:743->Assert.fail:88 expected:<2> but was:<0>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\nindex ad15d6d..2037356 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n@@ -225,7 +225,13 @@ protected boolean pageMustHaveBeenCreatedBookmarkable()\n \t@Override\n \tpublic int getCompatibilityScore(Request request)\n \t{\n-\t\t// always return 0 here so that the mounts have higher priority\n+\t\tif (urlStartsWith(request.getUrl(), mountSegments))\n+\t\t{\n+\t\t    return mountSegments.length;\n+\t\t}\n+\t\telse\n+\t\t{\n \t\t    return 0;\n \t\t}\n \t}\n+}\n", "nb_test": 1637, "linesAdd": 7, "jira_id": "5565", "singleLine": false, "nb_skipped": 2, "commit": "44f4782a", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "wicket", "nb_error": 6, "classification": {"singleLine": false}, "failing_tests": ["testFactory(org.apache.wicket.spring.injection.annot.AnnotProxyFieldValueFactoryTest)", "testCache(org.apache.wicket.spring.injection.annot.AnnotProxyFieldValueFactoryTest)", "testLookupByClass(org.apache.wicket.spring.SpringBeanLocatorTest)", "testLookupByClassAfterDeserialization(org.apache.wicket.spring.SpringBeanLocatorTest)", "testLookupByClassTooManyFound(org.apache.wicket.spring.SpringBeanLocatorTest)", "testEqualsAndHashcode(org.apache.wicket.spring.SpringBeanLocatorTest)"], "patch": "diff --git a/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java b/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\nindex 35d3be3..dfa2181 100644\n--- a/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\n+++ b/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\n@@ -26,9 +26,11 @@\n import org.apache.wicket.util.lang.Objects;\n import org.apache.wicket.util.lang.WicketObjects;\n import org.apache.wicket.util.string.Strings;\n+import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryUtils;\n import org.springframework.beans.factory.NoSuchBeanDefinitionException;\n import org.springframework.beans.factory.config.BeanDefinition;\n+import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n import org.springframework.beans.factory.support.AbstractBeanDefinition;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.support.AbstractApplicationContext;\n@@ -120,14 +122,17 @@ private final String getBeanNameOfClass(final ApplicationContext ctx, final Clas\n \t\twhile (it.hasNext())\n \t\t{\n \t\t\tfinal String possibility = it.next();\n-\t\t\tBeanDefinition beanDef = ((AbstractApplicationContext)ctx).getBeanFactory()\n-\t\t\t\t\t.getBeanDefinition(possibility);\n+\t\t\tif (ctx instanceof AbstractApplicationContext)\n+\t\t\t{\n+\t\t\t\tBeanDefinition beanDef = getBeanDefinition(((AbstractApplicationContext)ctx)\n+\t\t\t\t\t\t.getBeanFactory(), possibility);\n \t\t\t\tif (BeanFactoryUtils.isFactoryDereference(possibility) ||\n \t\t\t\t\t\tpossibility.startsWith(\"scopedTarget.\") || !beanDef.isAutowireCandidate())\n \t\t\t\t{\n \t\t\t\t\tit.remove();\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n \n \t\tif (names.isEmpty())\n \t\t{\n@@ -137,18 +142,23 @@ else if (names.size() > 1)\n \t\t{\n \t\t\tif (ctx instanceof AbstractApplicationContext)\n \t\t\t{\n+\t\t\t\tList<String> primaries = new ArrayList<String>();\n \t\t\t\tfor (String name : names)\n \t\t\t\t{\n-\t\t\t\t\tBeanDefinition beanDef = ((AbstractApplicationContext)ctx).getBeanFactory()\n-\t\t\t\t\t\t\t.getBeanDefinition(name);\n+\t\t\t\t\tBeanDefinition beanDef = getBeanDefinition(((AbstractApplicationContext)ctx)\n+\t\t\t\t\t\t\t.getBeanFactory(), name);\n \t\t\t\t\tif (beanDef instanceof AbstractBeanDefinition)\n \t\t\t\t\t{\n \t\t\t\t\t\tif (((AbstractBeanDefinition)beanDef).isPrimary())\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn name;\n+\t\t\t\t\t\t\tprimaries.add(name);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tif (primaries.size() == 1)\n+\t\t\t\t{\n+\t\t\t\t\treturn primaries.get(0);\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tStringBuilder msg = new StringBuilder();\n@@ -166,6 +176,28 @@ else if (names.size() > 1)\n \t\t}\n \t}\n \n+\tprivate BeanDefinition getBeanDefinition(ConfigurableListableBeanFactory beanFactory,\n+\t\t\tString name)\n+\t{\n+\t\tif (beanFactory.containsBeanDefinition(name))\n+\t\t{\n+\t\t\treturn beanFactory.getBeanDefinition(name);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tBeanFactory parent = beanFactory.getParentBeanFactory();\n+\t\t\tif (parent != null && parent instanceof ConfigurableListableBeanFactory)\n+\t\t\t{\n+\t\t\t\treturn getBeanDefinition(beanFactory, name);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n \t/**\n \t * @return returns whether the bean (the locator is supposed to istantiate) is a singleton or\n \t *         not\ndiff --git a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\nindex 5cf9d0e..6b36295 100644\n--- a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n+++ b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n@@ -29,8 +29,10 @@\n import org.apache.wicket.spring.SpringBeanLocator;\n import org.apache.wicket.util.lang.Generics;\n import org.apache.wicket.util.string.Strings;\n+import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryUtils;\n import org.springframework.beans.factory.config.BeanDefinition;\n+import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n import org.springframework.beans.factory.support.AbstractBeanDefinition;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.support.AbstractApplicationContext;\n@@ -187,14 +189,17 @@ private final String getBeanNameOfClass(ApplicationContext ctx, Class< ? > clazz\n \t\twhile (it.hasNext())\n \t\t{\n \t\t\tfinal String possibility = it.next();\n-\t\t\tBeanDefinition beanDef = ((AbstractApplicationContext)ctx).getBeanFactory()\n-\t\t\t\t\t.getBeanDefinition(possibility);\n+\t\t\tif (ctx instanceof AbstractApplicationContext)\n+\t\t\t{\n+\t\t\t\tBeanDefinition beanDef = getBeanDefinition(((AbstractApplicationContext)ctx)\n+\t\t\t\t\t\t.getBeanFactory(), possibility);\n \t\t\t\tif (BeanFactoryUtils.isFactoryDereference(possibility) ||\n \t\t\t\t\t\tpossibility.startsWith(\"scopedTarget.\") || !beanDef.isAutowireCandidate())\n \t\t\t\t{\n \t\t\t\t\tit.remove();\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n \n \t\tif (names.isEmpty())\n \t\t{\n@@ -204,17 +209,22 @@ else if (names.size() > 1)\n \t\t{\n \t\t\tif (ctx instanceof AbstractApplicationContext)\n \t\t\t{\n+\t\t\t\tList<String> primaries = new ArrayList<String>();\n \t\t\t\tfor (String name : names)\n \t\t\t\t{\n-\t\t\t\t\tBeanDefinition beanDef = ((AbstractApplicationContext)ctx).getBeanFactory()\n-\t\t\t\t\t\t\t.getBeanDefinition(name);\n+\t\t\t\t\tBeanDefinition beanDef = getBeanDefinition(((AbstractApplicationContext)ctx)\n+\t\t\t\t\t\t\t.getBeanFactory(), name);\n \t\t\t\t\tif (beanDef instanceof AbstractBeanDefinition)\n \t\t\t\t\t{\n \t\t\t\t\t\tif (((AbstractBeanDefinition)beanDef).isPrimary())\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn name;\n+\t\t\t\t\t\t\tprimaries.add(name);\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tif (primaries.size() == 1)\n+\t\t\t\t{\n+\t\t\t\t\treturn primaries.get(0);\n \t\t\t\t}\n \t\t\t}\n \t\t\tStringBuilder msg = new StringBuilder();\n@@ -232,6 +242,28 @@ else if (names.size() > 1)\n \t\t}\n \t}\n \n+\tprivate BeanDefinition getBeanDefinition(ConfigurableListableBeanFactory beanFactory,\n+\t\t\tString name)\n+\t{\n+\t\tif (beanFactory.containsBeanDefinition(name))\n+\t\t{\n+\t\t\treturn beanFactory.getBeanDefinition(name);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tBeanFactory parent = beanFactory.getParentBeanFactory();\n+\t\t\tif (parent != null && parent instanceof ConfigurableListableBeanFactory)\n+\t\t\t{\n+\t\t\t\treturn getBeanDefinition(beanFactory, name);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n \t/**\n \t * @see org.apache.wicket.injection.IFieldValueFactory#supportsField(java.lang.reflect.Field)\n \t */\n", "nb_test": 15, "linesAdd": 74, "jira_id": "2900", "singleLine": false, "nb_skipped": 0, "commit": "0e70ce39", "nb_failure": 0, "linesRem": 10}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testIsValid(org.apache.wicket.validation.validator.UrlValidatorTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java b/wicket/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\nindex cf42f3e..b9db5ee 100644\n--- a/wicket/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n+++ b/wicket/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n@@ -484,7 +484,7 @@ protected boolean isValidPath(String path)\n \t\t}\n \n \t\tint slashCount = countToken(\"/\", path);\n-\t\tint dot2Count = countToken(\"..\", path);\n+\t\tint dot2Count = countToken(\"/..\", path);\n \t\tif (dot2Count > 0)\n \t\t{\n \t\t\tif ((slashCount - slash2Count - 1) <= dot2Count)\n", "nb_test": 1013, "linesAdd": 1, "jira_id": "3196", "singleLine": false, "nb_skipped": 0, "commit": "f1c0f263", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["toOptionalXyzWithEmptyString(org.apache.wicket.util.string.StringValueTest)"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java b/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\nindex de5206c..fa5ba54 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\n@@ -592,69 +592,69 @@ public final Long toLongObject() throws StringValueConversionException\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Boolean toOptionalBoolean() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toBooleanObject();\r\n+\t\treturn Strings.isEmpty(text) ? null : toBooleanObject();\r\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Character toOptionalCharacter() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toCharacter();\r\n+\t\treturn Strings.isEmpty(text) ? null : toCharacter();\r\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Double toOptionalDouble() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toDoubleObject();\r\n+\t\treturn Strings.isEmpty(text) ? null : toDoubleObject();\r\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Duration toOptionalDuration() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toDuration();\r\n+\t\treturn Strings.isEmpty(text) ? null : toDuration();\r\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Integer toOptionalInteger() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toInteger();\r\n+\t\treturn Strings.isEmpty(text) ? null : toInteger();\r\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Long toOptionalLong() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toLongObject();\r\n+\t\treturn Strings.isEmpty(text) ? null : toLongObject();\r\n \t}\r\n \r\n \t/**\r\n@@ -668,14 +668,14 @@ public final String toOptionalString()\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Time toOptionalTime() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toTime();\r\n+\t\treturn Strings.isEmpty(text) ? null : toTime();\r\n \t}\r\n \r\n \t/**\r\n", "nb_test": 141, "linesAdd": 7, "jira_id": "4309", "singleLine": false, "nb_skipped": 0, "commit": "b4274415", "nb_failure": 1, "linesRem": 7}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ResourceUtilsTest.getLocaleFromFilename:52->Assert.assertThat:923->Assert.assertThat:956", "Expected: is \"some.min.ext\"", "but: was \"some_fr_CA.min.ext\""], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java b/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\nindex edcd96c..ac1d025 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\n@@ -34,7 +34,8 @@\n \t/** The default postfix for minified names (ex: /css/mystyle.min.css) **/\r\n \tpublic static final String MIN_POSTFIX_DEFAULT = \"min\";\r\n \t/** Regular expression patter to extract the locale from the filename (ex: de_DE) **/\r\n-\tprivate static final Pattern LOCALE_PATTERN = Pattern.compile(\"_([a-z]{2})(_([A-Z]{2})(_([^_]+))?)?$\");\r\n+\tprivate static final Pattern LOCALE_MIN_PATTERN = Pattern\r\n+\t\t.compile(\"_([a-z]{2})(_([A-Z]{2})(_([^_\\\\.]+))?)?(\\\\.min)?$\");\r\n \t/** Stores standard ISO country codes from {@code java.util.Locale} **/\r\n \tprivate final static Set<String> isoCountries = new HashSet<>(\r\n \t\tArrays.asList(Locale.getISOCountries()));\r\n@@ -77,7 +78,12 @@ public static String getMinifiedName(String name, String minPostfix)\n \t}\r\n \t\r\n \t/**\r\n-\t * Extract the locale from the filename\r\n+\t * Extract the locale from the filename taking into account possible minimized resource name.\r\n+\t * \r\n+\t * E.g. {@code file_us_EN.min.js} will correctly determine a locale of {@code us_EN} by\r\n+\t * stripping the {@code .min} from the filename, the filename returned will be\r\n+\t * {@code file.min.js}, if you want the {@code .min} to be removed as well, use\r\n+\t * {@link #getLocaleFromMinifiedFilename(String)} instead.\r\n \t * \r\n \t * @param path\r\n \t *            The file path\r\n@@ -86,7 +92,8 @@ public static String getMinifiedName(String name, String minPostfix)\n \tpublic static PathLocale getLocaleFromFilename(String path)\r\n \t{\r\n \t\tString extension = \"\";\r\n-\t\tint pos = path.lastIndexOf('.');\r\n+\r\n+\t\tfinal int pos = path.lastIndexOf('.');\r\n \t\tif (pos != -1)\r\n \t\t{\r\n \t\t\textension = path.substring(pos);\r\n@@ -94,12 +101,13 @@ public static PathLocale getLocaleFromFilename(String path)\n \t\t}\r\n \r\n \t\tString filename = Strings.lastPathComponent(path, '/');\r\n-\t\tMatcher matcher = LOCALE_PATTERN.matcher(filename);\r\n+\t\tMatcher matcher = LOCALE_MIN_PATTERN.matcher(filename);\r\n \t\tif (matcher.find())\r\n \t\t{\r\n \t\t\tString language = matcher.group(1);\r\n \t\t\tString country = matcher.group(3);\r\n \t\t\tString variant = matcher.group(5);\r\n+\t\t\tString min = matcher.group(6);\r\n \r\n \t\t\t// did we find a language?\r\n \t\t\tif (language != null)\r\n@@ -124,8 +132,9 @@ public static PathLocale getLocaleFromFilename(String path)\n \r\n \t\t\tif (language != null)\r\n \t\t\t{\r\n-\t\t\t\tpos = path.length() - filename.length() + matcher.start();\r\n-\t\t\t\tString basePath = path.substring(0, pos) + extension;\r\n+\t\t\t\tint languagePos = path.length() - filename.length() + matcher.start();\r\n+\t\t\t\tString basePath = path.substring(0, languagePos) + (min == null ? \"\" : min) +\r\n+\t\t\t\t\textension;\r\n \r\n \t\t\t\tLocale locale = new Locale(language, country != null ? country : \"\",\r\n \t\t\t\t\tvariant != null ? variant : \"\");\r\n", "nb_test": 188, "linesAdd": 9, "jira_id": "5966", "singleLine": false, "nb_skipped": 2, "commit": "d547fcd4", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["testOnValidateModelObjects(org.apache.wicket.markup.html.form.FormTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 17fe546..e97e0b1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -797,6 +797,7 @@ public void process(IFormSubmitter submittingComponent)\n \t\t\tif (hasError())\n \t\t\t{\n \t\t\t\tcallOnError(submittingComponent);\n+\t\t\t\treturn;\n \t\t\t}\n \n \t\t\t// Form has no error\n", "nb_test": 1196, "linesAdd": 1, "jira_id": "4070", "singleLine": true, "nb_skipped": 2, "commit": "d450acb0", "nb_failure": 1, "linesRem": 0}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["FormValidationDisabledFormComponentTest.formSubmitsEvenWithInvalidButDisabledFormComponent:110->Assert.assertTrue:52->Assert.assertTrue:41->Assert.fail:86 null", "FormValidationDisabledFormComponentTest.formSubmitsEvenWithInvalidButInvisibleFormComponent:88->Assert.assertTrue:52->Assert.assertTrue:41->Assert.fail:86 null"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/feedback/IFeedbackMessageFilter.java b/wicket-core/src/main/java/org/apache/wicket/feedback/IFeedbackMessageFilter.java\nindex 83706e5..fdd3057 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/feedback/IFeedbackMessageFilter.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/feedback/IFeedbackMessageFilter.java\n@@ -28,7 +28,7 @@\n \t/**\n \t * Filter that returns simply all available messages.\n \t */\n-\tpublic static final IFeedbackMessageFilter ALL = new IFeedbackMessageFilter()\n+\tIFeedbackMessageFilter ALL = new IFeedbackMessageFilter()\n \t{\n \t\tprivate static final long serialVersionUID = 1L;\n \n@@ -42,7 +42,7 @@ public boolean accept(FeedbackMessage message)\n \t/**\n \t * Filter that does not match any message\n \t */\n-\tpublic static final IFeedbackMessageFilter NONE = new IFeedbackMessageFilter()\n+\tIFeedbackMessageFilter NONE = new IFeedbackMessageFilter()\n \t{\n \t\tprivate static final long serialVersionUID = 1L;\n \ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 93adebe..aa6ba63 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -1145,7 +1145,7 @@ private boolean anyFormComponentError()\n \t\t\t@Override\n \t\t\tpublic void component(final Component component, final IVisit<Boolean> visit)\n \t\t\t{\n-\t\t\t\tif (component.hasErrorMessage())\n+\t\t\t\tif (component.isVisibleInHierarchy() && component.isEnabledInHierarchy() && component.hasErrorMessage())\n \t\t\t\t{\n \t\t\t\t\tvisit.stop(true);\n \t\t\t\t}\n", "nb_test": 1744, "linesAdd": 3, "jira_id": "5883", "singleLine": false, "nb_skipped": 1, "commit": "cd3b9234", "nb_failure": 2, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testLinkOnExpiredPage(org.apache.wicket.markup.html.link.MountedPageLinkTest): pattern 'param=value' found"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\nindex 50402f6..a5ae4f2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n@@ -265,7 +265,17 @@ private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePag\n \t\t{\n \t\t\tif (pageClass != null)\n \t\t\t{\n-\t\t\t\tpage = getPageSource().newPageInstance(pageClass, pageParameters);\n+\t\t\t\tPageParameters parameters;\n+\t\t\t\tif (pageId != null)\n+\t\t\t\t{\n+\t\t\t\t\t// WICKET-4594 - re-creating an expired page. Ignore the parsed parameters for the callback url\n+\t\t\t\t\tparameters = new PageParameters();\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tparameters = pageParameters;\n+\t\t\t\t}\n+\t\t\t\tpage = getPageSource().newPageInstance(pageClass, parameters);\n \t\t\t\tfreshCreated = true;\n \t\t\t}\n \t\t}\n", "nb_test": 1369, "linesAdd": 10, "jira_id": "4594", "singleLine": false, "nb_skipped": 8, "commit": "556a2236", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMinifiedNameDetectMinInName(org.apache.wicket.request.resource.PackageResourceReferenceTest): expected:<html5.min.[]js> but was:<html5.min.[min.]js>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\nindex cc72731..710eef2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n@@ -207,7 +207,14 @@ protected String getMinifiedName()\n \t\tif (idxOfExtension > -1)\n \t\t{\n \t\t\tString extension = name.substring(idxOfExtension);\n-\t\t\tminifiedName = name.substring(0, name.length() - extension.length() + 1) + \"min\" + extension;\n+            final String baseName = name.substring(0, name.length() - extension.length() + 1);\n+            if (!\".min\".equals(extension) && !baseName.endsWith(\".min.\"))\n+            {\n+                minifiedName = baseName + \"min\" + extension;\n+            } else\n+            {\n+                minifiedName = name;\n+            }\n \t\t} else\n \t\t{\n \t\t\tminifiedName = name + \".min\";\n", "nb_test": 1500, "linesAdd": 8, "jira_id": "5251", "singleLine": false, "nb_skipped": 3, "commit": "6ce34ccf", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testResourceKeyGenerationForAnonymousEnums(org.apache.wicket.markup.html.form.EnumChoiceRendererTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/EnumChoiceRenderer.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/EnumChoiceRenderer.java\nindex 3af4e49..9181c8e 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/EnumChoiceRenderer.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/EnumChoiceRenderer.java\n@@ -94,7 +94,7 @@ public final Object getDisplayValue(T object)\n \t */\r\n \tprotected String resourceKey(T object)\r\n \t{\r\n-\t\treturn object.getClass().getSimpleName() + \".\" + object.name();\r\n+\t\treturn object.getDeclaringClass().getSimpleName() + \".\" + object.name();\r\n \t}\r\n \r\n \t/**\r\n", "nb_test": 935, "linesAdd": 1, "jira_id": "2609", "singleLine": false, "nb_skipped": 0, "commit": "7da4ad17", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOnePassRenderDifferentProtocols(org.apache.wicket.request.handler.render.WebPageRendererTest): (..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex 1b98bed..0b5dee4 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -33,6 +33,7 @@\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.http.WebRequest;\n import org.apache.wicket.request.http.WebResponse;\n+import org.apache.wicket.util.lang.Objects;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -338,11 +339,12 @@ protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url curre\n \t\t\treturn false;\n \t\t}\n \n-\t\treturn neverRedirect(getRedirectPolicy())\n+\t\treturn (compatibleProtocols(currentUrl.getProtocol(), targetUrl.getProtocol())) &&\n+\t\t\t\t(neverRedirect(getRedirectPolicy())\n \t\t\t|| ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl\n \t\t\t\t.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(),\n \t\t\t\tisPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender())\n-\t\t\t|| (shouldPreserveClientUrl(cycle) && notForcedRedirect(getRedirectPolicy()));\n+\t\t\t|| (shouldPreserveClientUrl(cycle) && notForcedRedirect(getRedirectPolicy())));\n \t}\n \n \tprivate static boolean notNewAndNotStatelessPage(boolean newPageInstance, boolean pageStateless)\n@@ -365,4 +367,23 @@ private static boolean notForcedRedirect(RedirectPolicy redirectPolicy)\n \t\treturn !alwaysRedirect(redirectPolicy);\n \t}\n \n+\t/**\n+\t * Compares the protocols of two {@link Url}s\n+\t *\n+\t * @param p1\n+\t *      the first protocol\n+\t * @param p2\n+\t *      the second protocol\n+\t * @return {@code false} if the protocols are both non-null and not equal,\n+\t *          {@code true} - otherwise\n+\t */\n+\tprotected boolean compatibleProtocols(String p1, String p2)\n+\t{\n+\t\tif (p1 != null && p2 != null)\n+\t\t{\n+\t\t\treturn Objects.equal(p1, p2);\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n }\n", "nb_test": 1634, "linesAdd": 13, "jira_id": "5522", "singleLine": false, "nb_skipped": 2, "commit": "5b730c0b", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["hour(org.apache.wicket.util.time.TimeTest): expected:<21> but was:<9>"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/time/Time.java b/wicket-util/src/main/java/org/apache/wicket/util/time/Time.java\nindex cc5f630..2aac2be 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/time/Time.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/time/Time.java\n@@ -349,7 +349,7 @@ public int getHour()\n \t */\r\n \tpublic int getHour(final Calendar calendar)\r\n \t{\r\n-\t\treturn get(calendar, Calendar.HOUR);\r\n+\t\treturn get(calendar, Calendar.HOUR_OF_DAY);\r\n \t}\r\n \r\n \t/**\r\n", "nb_test": 179, "linesAdd": 1, "jira_id": "5442", "singleLine": false, "nb_skipped": 0, "commit": "a382917f", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["removedComponent(org.apache.wicket.core.request.handler.ListenerInterfaceRequestHandlerTest): expected:<Co[mponent 'foo' has been removed from page.]> but was:<Co[uld not find component 'foo' on page 'class org.apache.wicket.resource.DummyPage]>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/ListenerInterfaceRequestHandler.java b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/ListenerInterfaceRequestHandler.java\nindex 84592d7..1e24206 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/ListenerInterfaceRequestHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/ListenerInterfaceRequestHandler.java\n@@ -172,9 +172,12 @@ public void respond(final IRequestCycle requestCycle)\n \t\t\tcomponent = null;\n \t\t}\n \n-\t\tif ((component == null && freshPage) ||\n-\t\t\t(component != null && getComponent().getPage() == page))\n+\t\tif ((component == null && !freshPage) || (component != null && component.getPage() != page))\n \t\t{\n+\t\t\tthrow new WicketRuntimeException(\"Component '\" + getComponentPath()\n+\t\t\t\t+ \"' has been removed from page.\");\n+\t\t}\n+\n \t\tif (page instanceof Page)\n \t\t{\n \t\t\t// initialize the page to be able to check whether it is stateless\n@@ -182,7 +185,8 @@ public void respond(final IRequestCycle requestCycle)\n \t\t}\n \t\tfinal boolean isStateless = page.isPageStateless();\n \n-\t\t\tRedirectPolicy policy = isStateless ? RedirectPolicy.NEVER_REDIRECT\n+\t\tRedirectPolicy policy = isStateless\n+\t\t\t? RedirectPolicy.NEVER_REDIRECT\n \t\t\t: RedirectPolicy.AUTO_REDIRECT;\n \t\tfinal IPageProvider pageProvider = new PageProvider(page);\n \n@@ -224,13 +228,6 @@ public void respond(final IRequestCycle requestCycle)\n \t\t}\n \n \t\tinvokeListener();\n-\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new WicketRuntimeException(\"Component \" + getComponent() +\n-\t\t\t\t\" has been removed from page.\");\n-\t\t}\n \t}\n \n \tprivate void invokeListener()\n", "nb_test": 1552, "linesAdd": 7, "jira_id": "5466", "singleLine": false, "nb_skipped": 2, "commit": "c1c1f794", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": true}, "failing_tests": ["componentsAreInitialized(org.apache.wicket.core.util.string.ComponentRendererTest): Exception in rendering component: [EnclosurePanel [Component id = compId]]"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/util/string/ComponentRenderer.java b/wicket-core/src/main/java/org/apache/wicket/core/util/string/ComponentRenderer.java\nindex 308b548..41704a6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/util/string/ComponentRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/util/string/ComponentRenderer.java\n@@ -100,6 +100,7 @@ public static CharSequence renderComponent(final Component component)\n \n \t\t\tRenderPage page = new RenderPage();\n \t\t\tpage.add(component);\n+\t\t\tpage.internalInitialize();\n \n \t\t\tcomponent.render();\n \t\t}\n", "nb_test": 1476, "linesAdd": 1, "jira_id": "5209", "singleLine": true, "nb_skipped": 4, "commit": "55eb5212", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["LoadableDetachableModelTest.recursiveGetObjectDoesntCauseInfiteLoop \u00bb StackOverflow"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/model/LoadableDetachableModel.java b/wicket-core/src/main/java/org/apache/wicket/model/LoadableDetachableModel.java\nindex c172678..e3a7fc0 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/model/LoadableDetachableModel.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/model/LoadableDetachableModel.java\n@@ -23,8 +23,8 @@\n \n /**\n  * Model that makes working with detachable models a breeze. LoadableDetachableModel holds a\n- * temporary, transient model object, that is set when {@link #getObject()} is called by\n- * calling abstract method 'load', and that will be reset/ set to null on {@link #detach()}.\n+ * temporary, transient model object, that is set when {@link #getObject()} is called by calling\n+ * abstract method 'load', and that will be reset/ set to null on {@link #detach()}.\n  * \n  * A usage example:\n  * \n@@ -60,8 +60,40 @@\n \t/** Logger. */\n \tprivate static final Logger log = LoggerFactory.getLogger(LoadableDetachableModel.class);\n \n+\tprivate enum AttachingState \n+\t{\n+\t\tDETACHED(false, false),\n+\t\tATTACHING(true, false), \n+\t\tATTACHED(true, true);\n+\n+\t\tprivate boolean attaching;\n+\t\tprivate boolean attached;\n+\n+\t\tprivate AttachingState(boolean attaching, boolean attached)\n+\t\t{\n+\t\t\tthis.attached = attached;\n+\t\t\tthis.attaching = attaching;\n+\t\t}\n+\t\t\n+\t\tpublic boolean isAttached() \n+\t\t{\n+\t\t\treturn attached;\n+\t\t}\n+\n+\t\tpublic boolean isAttaching() \n+\t\t{\n+\t\t\treturn attaching;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic String toString()\n+\t\t{\n+\t\t\treturn name().toLowerCase();\n+\t\t}\n+\t}\n+\n \t/** keeps track of whether this model is attached or detached */\n-\tprivate transient boolean attached = false;\n+\tprivate transient AttachingState attached = AttachingState.DETACHED;\n \n \t/** temporary, transient object. */\n \tprivate transient T transientModelObject;\n@@ -83,7 +115,7 @@ public LoadableDetachableModel()\n \tpublic LoadableDetachableModel(T object)\n \t{\n \t\tthis.transientModelObject = object;\n-\t\tattached = true;\n+\t\tattached = AttachingState.ATTACHED;\n \t}\n \n \t/**\n@@ -92,7 +124,7 @@ public LoadableDetachableModel(T object)\n \t@Override\n \tpublic void detach()\n \t{\n-\t\tif (attached)\n+\t\tif (attached == AttachingState.ATTACHED)\n \t\t{\n \t\t\ttry\n \t\t\t{\n@@ -100,7 +132,7 @@ public void detach()\n \t\t\t}\n \t\t\tfinally\n \t\t\t{\n-\t\t\t\tattached = false;\n+\t\t\t\tattached = AttachingState.DETACHED;\n \t\t\t\ttransientModelObject = null;\n \n \t\t\t\tlog.debug(\"removed transient object for {}, requestCycle {}\", this,\n@@ -115,8 +147,11 @@ public void detach()\n \t@Override\n \tpublic final T getObject()\n \t{\n-\t\tif (!attached)\n+\t\tif (attached == AttachingState.DETACHED)\n \t\t{\n+\t\t\t// prevent infinite attachment loops\n+\t\t\tattached = AttachingState.ATTACHING;\n+\n \t\t\ttransientModelObject = load();\n \n \t\t\tif (log.isDebugEnabled())\n@@ -125,7 +160,7 @@ public final T getObject()\n \t\t\t\t\t\", requestCycle \" + RequestCycle.get());\n \t\t\t}\n \n-\t\t\tattached = true;\n+\t\t\tattached = AttachingState.ATTACHED;\n \t\t\tonAttach();\n \t\t}\n \t\treturn transientModelObject;\n@@ -138,7 +173,7 @@ public final T getObject()\n \t */\n \tpublic final boolean isAttached()\n \t{\n-\t\treturn attached;\n+\t\treturn attached.isAttached();\n \t}\n \n \t/**\n@@ -148,8 +183,11 @@ public final boolean isAttached()\n \tpublic String toString()\n \t{\n \t\tStringBuilder sb = new StringBuilder(super.toString());\n-\t\tsb.append(\":attached=\").append(attached).append(\":tempModelObject=[\").append(\n-\t\t\tthis.transientModelObject).append(\"]\");\n+\t\tsb.append(\":attached=\")\n+\t\t\t.append(isAttached())\n+\t\t\t.append(\":tempModelObject=[\")\n+\t\t\t.append(this.transientModelObject)\n+\t\t\t.append(\"]\");\n \t\treturn sb.toString();\n \t}\n \n@@ -187,8 +225,7 @@ protected void onDetach()\n \t@Override\n \tpublic void setObject(final T object)\n \t{\n-\t\tattached = true;\n+\t\tattached = AttachingState.ATTACHED;\n \t\ttransientModelObject = object;\n \t}\n-\n }\n", "nb_test": 1758, "linesAdd": 47, "jira_id": "5916", "singleLine": false, "nb_skipped": 1, "commit": "def03add", "nb_failure": 0, "linesRem": 11}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["wicket4038(org.apache.wicket.request.mapper.UrlInfoTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\nindex d66f32e..ad48cf1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\n@@ -98,6 +98,11 @@ private PageParameters cleanPageParameters(final PageParameters originalParamete\n \t\t\t\tcleanParameters.remove(WebRequest.PARAM_AJAX);\n \t\t\t\tcleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\n \t\t\t\tcleanParameters.remove(WebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE);\n+\n+\t\t\t\tif (cleanParameters.isEmpty())\n+\t\t\t\t{\n+\t\t\t\t\tcleanParameters = null;\n+\t\t\t\t}\n \t\t\t}\n \t\t\treturn cleanParameters;\n \t\t}\n", "nb_test": 1301, "linesAdd": 5, "jira_id": "4384", "singleLine": false, "nb_skipped": 4, "commit": "614e3b50", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDecode4(org.apache.wicket.request.mapper.PackageMapperTest): expected:<0> but was:<2>", "testDecode6(org.apache.wicket.request.mapper.PackageMapperTest): expected:<0> but was:<2>", "testDecode4(org.apache.wicket.request.mapper.BookmarkableMapperTest): expected:<0> but was:<2>", "testDecode6(org.apache.wicket.request.mapper.BookmarkableMapperTest): expected:<0> but was:<2>", "testDecode4(org.apache.wicket.request.mapper.MountedMapperTest): expected:<0> but was:<2>", "testDecode6(org.apache.wicket.request.mapper.MountedMapperTest): expected:<0> but was:<2>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\nindex ed01ddb..f000bad 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n@@ -292,12 +292,6 @@ private IRequestablePage getStoredPage(final int pageId)\n \t\t\t(pageClass == null || pageClass.equals(storedPageInstance.getClass())))\n \t\t{\n \t\t\tpageInstance = storedPageInstance;\n-\n-\t\t\tif (pageParameters != null)\n-\t\t\t{\n-\t\t\t\tstoredPageInstance.getPageParameters().overwriteWith(pageParameters);\n-\t\t\t}\n-\n \t\t}\n \t\treturn storedPageInstance;\n \t}\n", "nb_test": 1201, "linesAdd": 0, "jira_id": "4109", "singleLine": false, "nb_skipped": 2, "commit": "8f7805f8", "nb_failure": 6, "linesRem": 6}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test_1(org.apache.wicket.util.tester.apps_4.FormTesterTest): expected:<[wrong email address pattern for email]> but was:<[ValidationErrorFeedback{message=wrong email address pattern for email}]>", "test1(org.apache.wicket.markup.html.form.ValidatorPropertiesTest): expected:<[text1label is required]> but was:<[ValidationErrorFeedback{message=text1label is required}]>", "wicket891(org.apache.wicket.markup.html.form.LocalizedErrorMessageTest): (..)", "wicket_1927(org.apache.wicket.markup.html.form.LocalizedErrorMessageTest): (..)", "innerFeedback(org.apache.wicket.markup.html.form.validation.innerfeedback.InnerFeedbackTest): (..)", "testActAsValidator(org.apache.wicket.validation.ValidatorBehaviorTest): expected:<[MAX]> but was:<[ValidationErrorFeedback{message=MAX}]>", "submitWithoutUploadFile(org.apache.wicket.util.tester.FormTesterTest): (..)", "createBook_validateFail(org.apache.wicket.util.tester.WicketTesterTest): (..)", "interfaceValidator(org.apache.wicket.resource.loader.ValidatorStringResourceLoaderTest): (..)", "classValidator(org.apache.wicket.resource.loader.ValidatorStringResourceLoaderTest): (..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/ValidationErrorFeedback.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/ValidationErrorFeedback.java\nindex f6e1ce7..48b8d0b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/ValidationErrorFeedback.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/ValidationErrorFeedback.java\n@@ -78,8 +78,6 @@ public Serializable getMessage()\n \t@Override\n \tpublic String toString()\n \t{\n-\t\treturn \"ValidationErrorFeedback{\" +\n-\t\t\t\t\"message=\" + message +\n-\t\t\t\t'}';\n+\t\treturn message != null ? message.toString() : \"\";\n \t}\n }\n", "nb_test": 1343, "linesAdd": 1, "jira_id": "4548", "singleLine": false, "nb_skipped": 8, "commit": "9a6a06be", "nb_failure": 10, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testAddChildOnRootAtAnOnRootLessTree(org.apache.wicket.markup.html.tree.TreeTest)", "testAddGrandchildOnRootAtAnRootLessTree(org.apache.wicket.markup.html.tree.TreeTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java\nindex ed9843a..2547853 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java\n@@ -832,13 +832,17 @@ public final void treeNodesInserted(TreeModelEvent e)\n \t\t\t{\n \t\t\t\twasLeaf = eventChildren.contains(getChildAt(parentNode, i));\n \t\t\t}\n-\n-\t\t\tif (wasLeaf)\n+\t\t\t// if parent was a leaf, testing if wasn't an not presented root\n+\t\t\tif (wasLeaf && !(parentItem.getParentItem() == null && isRootLess()))\n \t\t\t{\n-\t\t\t\t// parentNode now has children for the first time, so we need to invalidate\n+\t\t\t\t// parentNode now has children for the first time, so we may need to invalidate\n \t\t\t\t// grandparent so that parentNode's junctionLink gets rebuilt with a plus/minus link\n \t\t\t\tObject grandparentNode = getParentNode(parentNode);\n+\t\t\t\t// not invalidating if the grandparent is a not presented root\n+\t\t\t\tif (!(getParentNode(grandparentNode) == null && isRootLess()))\n+\t\t\t\t{\n \t\t\t\t\tinvalidateNodeWithChildren(grandparentNode);\n+\t\t\t\t}\n \t\t\t\tgetTreeState().expandNode(parentNode);\n \t\t\t}\n \t\t\telse\n", "nb_test": 1045, "linesAdd": 4, "jira_id": "3309", "singleLine": false, "nb_skipped": 0, "commit": "debca73b", "nb_failure": 2, "linesRem": 2}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["decode6(org.apache.wicket.core.request.mapper.PackageMapperTest): expected:<0> but was:<2>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\nindex 0be5d76..2c015a4 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n@@ -259,12 +259,6 @@ private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePag\n \t\tif (pageId != null)\n \t\t{\n \t\t\tpage = getStoredPage(pageId);\n-\n-\t\t\tif (page == null)\n-\t\t\t{\n-\t\t\t\t// WICKET-4594 - ignore the parsed parameters for stateful pages\n-\t\t\t\tpageParameters = null;\n-\t\t\t}\n \t\t}\n \n \t\tif (page == null)\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\nindex 1569468..8a30578 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n@@ -271,11 +271,11 @@ protected IRequestHandler processListener(PageComponentInfo pageComponentInfo,\n \n \t\tif (listenerInterface != null)\n \t\t{\n-//\t\t\tif (pageInfo.getPageId() != null)\n-//\t\t\t{\n-//\t\t\t\t// WICKET-4594 - ignore the parsed parameters for stateful pages\n-//\t\t\t\tpageParameters = null;\n-//\t\t\t}\n+\t\t\tif (pageInfo.getPageId() != null)\n+\t\t\t{\n+\t\t\t\t// WICKET-4594 - ignore the parsed parameters for stateful pages\n+\t\t\t\tpageParameters = null;\n+\t\t\t}\n \n \t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(),\n \t\t\t\tpageClass, pageParameters, renderCount, componentInfo.getComponentPath());\n", "nb_test": 1549, "linesAdd": 4, "jira_id": "4686", "singleLine": false, "nb_skipped": 2, "commit": "89184b79", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["InheritedModelTest.testResetInheritedModelFlag2:129->Assert.assertEquals:144->Assert.assertEquals:115 expected:<[bar]> but was:<[foo]>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex c1d1826..d998680 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -2977,6 +2977,9 @@ public Component setDefaultModel(final IModel<?> model)\n \t\t\tmodelChanging();\n \t\t\tsetModelImpl(wrap(model));\n \t\t\tmodelChanged();\n+\n+\t\t\t// WICKET-3413 reset 'inherited model' when model is explicitely set\n+\t\t\tsetFlag(FLAG_INHERITABLE_MODEL, false);\n \t\t}\n \n \t\treturn this;\n@@ -3005,12 +3008,6 @@ void setModelImpl(IModel<?> model)\n \t\t\tif (model != null)\n \t\t\t{\n \t\t\t\tdata_set(0, model);\n-\t\t\t\t// WICKET-3413 reset 'inherited model' flag if model changed\n-\t\t\t\t// and a new one is not IComponentInheritedModel\n-\t\t\t\tif (getFlag(FLAG_INHERITABLE_MODEL) && !(model instanceof IComponentInheritedModel))\n-\t\t\t\t{\n-\t\t\t\t\tsetFlag(FLAG_INHERITABLE_MODEL, false);\n-\t\t\t\t}\n \t\t\t}\n \t\t\telse\n \t\t\t{\n", "nb_test": 1679, "linesAdd": 2, "jira_id": "5655", "singleLine": false, "nb_skipped": 2, "commit": "d558004b", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ISecuritySettingsTest.enforceMountsWithCryptoMapper:120->Assert.assertNull:656->Assert.assertNull:646->Assert.failNotNull:664->Assert.fail:88 expected null, but was:<[Page class = org.apache.wicket.settings.ISecuritySettingsTest$UnknownPage, id = 2, render count = 1]>", "CryptoMapperTest.pageParameters:448->Assert.assertEquals:144->Assert.assertEquals:115 expected:<...59/yPr6a/5L6ae/OxF2c[]> but was:<...59/yPr6a/5L6ae/OxF2c[/7Exe9]>", "CryptoMapperTest.pageInstanceDecrypt:274->Assert.assertNotNull:631->Assert.assertNotNull:621->Assert.assertTrue:41->Assert.fail:86 null", "CryptoMapperTest.bookmarkablePageDecrypt:197->Assert.assertNotNull:631->Assert.assertNotNull:621->Assert.assertTrue:41->Assert.fail:86 null", "CryptoMapperTest.pageInstanceEncrypt:263->Assert.assertEquals:144->Assert.assertEquals:115 expected:<...trOhokHCzsQS6Q/fyBce[]> but was:<...trOhokHCzsQS6Q/fyBce[/HCz3e]>", "CryptoMapperTest.compatabilityScore:410->Assert.assertEquals:542->Assert.assertEquals:555->Assert.assertEquals:118->Assert.failNotEquals:743->Assert.fail:88 expected:<2147483647> but was:<0>", "CryptoMapperTest.mountedPageRequestListenerParameter:346->Assert.assertNull:656->Assert.assertNull:646->Assert.failNotNull:664->Assert.fail:88 expected null, but was:<org.apache.wicket.core.request.handler.ListenerInterfaceRequestHandler@7d075672>", "CryptoMapperTest.pageInstanceForceEncryption:305->Assert.assertNull:656->Assert.assertNull:646->Assert.failNotNull:664->Assert.fail:88 expected null, but was:<org.apache.wicket.core.request.handler.RenderPageRequestHandler@5343c8cb>", "CryptoMapperTest.pageInstanceDecryptMultipleCryptoMapper:291->Assert.assertNotNull:631->Assert.assertNotNull:621->Assert.assertTrue:41->Assert.fail:86 null", "CryptoMapperTest.bookmarkablePageEncrypt:185->Assert.assertEquals:144->Assert.assertEquals:115 expected:<...8AyCyA-A/L7E59/5y7f2[]> but was:<...8AyCyA-A/L7E59/5y7f2[/i87b7]>", "CryptoMapperTest.homePageForceEncryptionOfRequestListener:168->Assert.assertNull:656->Assert.assertNull:646->Assert.failNotNull:664->Assert.fail:88 expected null, but was:<org.apache.wicket.core.request.handler.RequestSettingRequestHandler@4c2503d9>", "CryptoMapperTest.bookmarkablePageForceEncryption:234->Assert.assertNull:656->Assert.assertNull:646->Assert.failNotNull:664->Assert.fail:88 expected null, but was:<org.apache.wicket.core.request.handler.RenderPageRequestHandler@29a65093>", "CryptoMapperTest.bookmarkablePageDecryptMultipleCryptoMapper:218->Assert.assertNotNull:631->Assert.assertNotNull:621->Assert.assertTrue:41->Assert.fail:86 null", "CryptoMapperTest.bookmarkablePageForceEncryptionOfRequestListener:250->Assert.assertNull:656->Assert.assertNull:646->Assert.failNotNull:664->Assert.fail:88 expected null, but was:<org.apache.wicket.core.request.handler.ListenerInterfaceRequestHandler@3d9e61c9>", "CryptoMapperTest.mountedPage:316->Assert.assertEquals:144->Assert.assertEquals:115 expected:<[path/to/mounted/page]> but was:<[adgqhGD9vbs5u8t2bPOwlglPnCBgDwpP/adgf3/adgf3/adgf3/adgf3]>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\nindex 05e7c30..99f7afc 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n@@ -16,6 +16,7 @@\n  */\r\n package org.apache.wicket.core.request.mapper;\r\n \r\n+import java.util.Iterator;\r\n import java.util.List;\r\n \r\n import org.apache.wicket.Application;\r\n@@ -25,6 +26,7 @@\n import org.apache.wicket.request.Request;\r\n import org.apache.wicket.request.Url;\r\n import org.apache.wicket.request.mapper.IRequestMapperDelegate;\r\n+import org.apache.wicket.request.mapper.info.PageComponentInfo;\r\n import org.apache.wicket.util.IProvider;\r\n import org.apache.wicket.util.crypt.ICrypt;\r\n import org.apache.wicket.util.crypt.ICryptFactory;\r\n@@ -34,16 +37,37 @@\n import org.slf4j.LoggerFactory;\r\n \r\n /**\r\n- * Request mapper that encrypts urls generated by another mapper. The original URL (both segments\r\n- * and parameters) is encrypted and is represented as URL segment. To be able to handle relative\r\n- * URLs for images in .css file the same amount of URL segments that the original URL had are\r\n- * appended to the encrypted URL. Each segment has a precise 5 character value, calculated using a\r\n- * checksum. This helps in calculating the relative distance from the original URL. When a URL is\r\n- * returned by the browser, we iterate through these checksummed placeholder URL segments. If the\r\n- * segment matches the expected checksum, then the segment it deemed to be the corresponding segment\r\n- * in the encrypted URL. If the segment does not match the expected checksum, then the segment is\r\n- * deemed a plain text sibling of the corresponding segment in the encrypted URL, and all subsequent\r\n+ * <p>\r\n+ * A request mapper that encrypts URLs generated by another mapper. This mapper encrypts the segments\r\n+ * and query parameters of URLs starting with {@code /wicket/}, and the just the {@link PageComponentInfo}\r\n+ * parameter for mounted URLs.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * This mapper can be mounted before or after mounting other pages, but will only encrypt URLs for\r\n+ * pages mounted before the {@link CryptoMapper}. If required, multiple {@link CryptoMapper}s may be\r\n+ * installed in an {@link Application}.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * When encrypting URLs in the Wicket namespace (starting with {@code /wicket/}), the entire URL, including\r\n+ * segments and parameters, is encrypted, with the encrypted form stored in the first segment of the encrypted URL.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * To be able to handle relative URLs, like for image URLs in a CSS file, checksum segments are appended to the\r\n+ * encrypted URL until the encrypted URL has the same number of segments as the original URL had.\r\n+ * Each checksum segment has a precise 5 character value, calculated using a checksum. This helps in calculating\r\n+ * the relative distance from the original URL. When a URL is returned by the browser, we iterate through these\r\n+ * checksummed placeholder URL segments. If the segment matches the expected checksum, then the segment it deemed\r\n+ * to be the corresponding segment in the original URL. If the segment does not match the expected checksum, then\r\n+ * the segment is deemed a plain text sibling of the corresponding segment in the original URL, and all subsequent\r\n  * segments are considered plain text children of the current segment.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * When encrypting mounted URLs, we look for the {@link PageComponentInfo} parameter, and encrypt only that parameter.\r\n+ * </p>\r\n  * \r\n  * @author igor.vaynberg\r\n  * @author Jesse Long\r\n@@ -53,6 +77,11 @@\n {\r\n \tprivate static final Logger log = LoggerFactory.getLogger(CryptoMapper.class);\r\n \r\n+\t/**\r\n+\t * Name of the parameter which contains encrypted page component info.\r\n+\t */\r\n+\tprivate static final String ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER = \"wicket\";\r\n+\r\n \tprivate final IRequestMapper wrappedMapper;\r\n \tprivate final IProvider<ICrypt> cryptProvider;\r\n \r\n@@ -87,12 +116,34 @@ public CryptoMapper(final IRequestMapper wrappedMapper, final IProvider<ICrypt>\n \t\tthis.cryptProvider = Args.notNull(cryptProvider, \"cryptProvider\");\r\n \t}\r\n \r\n+\t/**\r\n+\t * {@inheritDoc}\r\n+\t * <p>\r\n+\t * This implementation decrypts the URL and passes the decrypted URL to the wrapped mapper.\r\n+\t * </p>\r\n+\t * @param request\r\n+\t *\t\tThe request for which to get a compatability score.\r\n+\t * \r\n+\t * @return The compatability score.\r\n+\t */\r\n \t@Override\r\n \tpublic int getCompatibilityScore(final Request request)\r\n \t{\r\n-\t\treturn wrappedMapper.getCompatibilityScore(request);\r\n+\t\tUrl decryptedUrl = decryptUrl(request, request.getUrl());\r\n+\r\n+\t\tif (decryptedUrl == null)\r\n+\t\t{\r\n+\t\t\treturn 0;\r\n \t\t}\r\n \r\n+\t\tRequest decryptedRequest = request.cloneWithUrl(decryptedUrl);\r\n+\r\n+\t\treturn wrappedMapper.getCompatibilityScore(decryptedRequest);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * {@inheritDoc}\r\n+\t */\r\n \t@Override\r\n \tpublic Url mapHandler(final IRequestHandler requestHandler)\r\n \t{\r\n@@ -112,6 +163,9 @@ public Url mapHandler(final IRequestHandler requestHandler)\n \t\treturn encryptUrl(url);\r\n \t}\r\n \r\n+\t/**\r\n+\t * {@inheritDoc}\r\n+\t */\r\n \t@Override\r\n \tpublic IRequestHandler mapRequest(final Request request)\r\n \t{\r\n@@ -119,7 +173,7 @@ public IRequestHandler mapRequest(final Request request)\n \r\n \t\tif (url == null)\r\n \t\t{\r\n-\t\t\treturn wrappedMapper.mapRequest(request);\r\n+\t\t\treturn null;\r\n \t\t}\r\n \r\n \t\tRequest decryptedRequest = request.cloneWithUrl(url);\r\n@@ -152,18 +206,44 @@ public final IRequestMapper getDelegateMapper()\n \t\treturn wrappedMapper;\r\n \t}\r\n \r\n+\t/**\r\n+\t * Encrypts a URL. This method should return a new, encrypted instance of the URL. If the URL starts with {@code /wicket/},\r\n+\t * the entire URL is encrypted.\r\n+\t * \r\n+\t * @param url\r\n+\t *\t\tThe URL to encrypt.\r\n+\t * \r\n+\t * @return A new, encrypted version of the URL.\r\n+\t */\r\n \tprotected Url encryptUrl(final Url url)\r\n \t{\r\n-\t\tif (url.getSegments().isEmpty())\r\n+\t\tif (url.getSegments().size() > 0\r\n+\t\t\t&& url.getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))\r\n \t\t{\r\n-\t\t\treturn url;\r\n+\t\t\treturn encryptEntireUrl(url);\r\n \t\t}\r\n+\t\telse\r\n+\t\t{\r\n+\t\t\treturn encryptRequestListenerParameter(url);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Encrypts an entire URL, segments and query parameters.\r\n+\t * \r\n+\t * @param url\r\n+\t *\t\tThe URL to encrypt.\r\n+\t * \r\n+\t * @return An encrypted form of the URL.\r\n+\t */\r\n+\tprotected Url encryptEntireUrl(final Url url)\r\n+\t{\r\n \t\tString encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());\r\n \r\n \t\tUrl encryptedUrl = new Url(url.getCharset());\r\n \t\tencryptedUrl.getSegments().add(encryptedUrlString);\r\n \r\n-\t\tint numberOfSegments = url.getSegments().size();\r\n+\t\tint numberOfSegments = url.getSegments().size() - 1;\r\n \t\tHashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n \t\tfor (int segNo = 0; segNo < numberOfSegments; segNo++)\r\n \t\t{\r\n@@ -172,25 +252,108 @@ protected Url encryptUrl(final Url url)\n \t\treturn encryptedUrl;\r\n \t}\r\n \r\n+\t/**\r\n+\t * Encrypts the {@link PageComponentInfo} query parameter in the URL, if any is found.\r\n+\t * \r\n+\t * @param url\r\n+\t *\t\tThe URL to encrypt.\r\n+\t * \r\n+\t * @return An encrypted form of the URL.\r\n+\t */\r\n+\tprotected Url encryptRequestListenerParameter(final Url url)\r\n+\t{\r\n+\t\tUrl encryptedUrl = new Url(url);\r\n+\r\n+\t\tfor (Iterator<Url.QueryParameter> it = encryptedUrl.getQueryParameters().iterator(); it.hasNext();)\r\n+\t\t{\r\n+\t\t\tUrl.QueryParameter qp = it.next();\r\n+\r\n+\t\t\tif (Strings.isEmpty(qp.getValue()) == true && Strings.isEmpty(qp.getName()) == false)\r\n+\t\t\t{\r\n+\t\t\t\tif (PageComponentInfo.parse(qp.getName()) != null)\r\n+\t\t\t\t{\r\n+\t\t\t\t\tit.remove();\r\n+\t\t\t\t\tString encryptedParameterValue = getCrypt().encryptUrlSafe(qp.getName());\r\n+\t\t\t\t\tUrl.QueryParameter encryptedParameter\r\n+\t\t\t\t\t\t= new Url.QueryParameter(ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER, encryptedParameterValue);\r\n+\t\t\t\t\tencryptedUrl.getQueryParameters().add(0, encryptedParameter);\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t\treturn encryptedUrl;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Decrypts a {@link Url}. This method should return {@code null} if the URL is not decryptable, or if the\r\n+\t * URL should have been encrypted but was not. Returning {@code null} results in a 404 error.\r\n+\t * \r\n+\t * @param request\r\n+\t *\t\tThe {@link Request}.\r\n+\t * @param encryptedUrl\r\n+\t *\t\tThe encrypted {@link Url}.\r\n+\t * \r\n+\t * @return Returns a decrypted {@link Url}.\r\n+\t */\r\n \tprotected Url decryptUrl(final Request request, final Url encryptedUrl)\r\n \t{\r\n+\t\tUrl url = decryptEntireUrl(request, encryptedUrl);\r\n+\r\n+\t\tif (url == null)\r\n+\t\t{\r\n+\t\t\tif (encryptedUrl.getSegments().size() > 0\r\n+\t\t\t\t&& encryptedUrl.getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))\r\n+\t\t\t{\r\n \t\t\t\t/*\r\n-\t\t * If the encrypted URL has no segments it is the home page URL, and does not need\r\n-\t\t * decrypting.\r\n+\t\t\t\t * This URL should have been encrypted, but was not. We should refuse to handle this, except when\r\n+\t\t\t\t * there is more than one CryptoMapper installed, and the request was decrypted by some other\r\n+\t\t\t\t * CryptoMapper.\r\n \t\t\t\t */\r\n-\t\tif (encryptedUrl.getSegments().isEmpty())\r\n+\t\t\t\tif (request.getOriginalUrl().getSegments().size() > 0\r\n+\t\t\t\t\t&& request.getOriginalUrl().getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))\r\n+\t\t\t\t{\r\n+\t\t\t\t\treturn null;\r\n+\t\t\t\t}\r\n+\t\t\t\telse\r\n \t\t\t\t{\r\n \t\t\t\t\treturn encryptedUrl;\r\n \t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n \r\n-\t\tList<String> encryptedSegments = encryptedUrl.getSegments();\r\n+\t\tif (url == null)\r\n+\t\t{\r\n+\t\t\turl = decryptRequestListenerParameter(request, encryptedUrl);\r\n+\t\t}\r\n \r\n+\t\treturn url;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Decrypts an entire URL, which was previously encrypted by {@link #encryptEntireUrl(org.apache.wicket.request.Url)}.\r\n+\t * This method should return {@code null} if the URL is not decryptable.\r\n+\t * \r\n+\t * @param request\r\n+\t *\t\tThe request that was made.\r\n+\t * @param encryptedUrl\r\n+\t *\t\tThe encrypted URL.\r\n+\t * \r\n+\t * @return A decrypted form of the URL, or {@code null} if the URL is not decryptable.\r\n+\t */\r\n+\tprotected Url decryptEntireUrl(final Request request, final Url encryptedUrl)\r\n+\t{\r\n \t\tUrl url = new Url(request.getCharset());\r\n-\t\ttry\r\n+\r\n+\t\tList<String> encryptedSegments = encryptedUrl.getSegments();\r\n+\r\n+\t\tif (encryptedSegments.isEmpty())\r\n \t\t{\r\n+\t\t\treturn null;\r\n+\t\t}\r\n+\r\n \t\t/*\r\n-\t\t\t * The first encrypted segment contains an encrypted version of the entire plain text\r\n-\t\t\t * url.\r\n+\t\t * The first encrypted segment contains an encrypted version of the entire plain text url.\r\n \t\t */\r\n \t\tString encryptedUrlString = encryptedSegments.get(0);\r\n \t\tif (Strings.isEmpty(encryptedUrlString))\r\n@@ -198,7 +361,17 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\treturn null;\r\n \t\t}\r\n \r\n-\t\t\tString decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n+\t\tString decryptedUrl;\r\n+\t\ttry\r\n+\t\t{\r\n+\t\t\tdecryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n+\t\t}\r\n+\t\tcatch (Exception e)\r\n+\t\t{\r\n+\t\t\tlog.error(\"Error decrypting URL\", e);\r\n+\t\t\treturn null;\r\n+\t\t}\r\n+\r\n \t\tif (decryptedUrl == null)\r\n \t\t{\r\n \t\t\treturn null;\r\n@@ -208,6 +382,28 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\tint originalNumberOfSegments = originalUrl.getSegments().size();\r\n \t\tint encryptedNumberOfSegments = encryptedUrl.getSegments().size();\r\n \r\n+\t\tif (originalNumberOfSegments > 0)\r\n+\t\t{\r\n+\t\t\t/*\r\n+\t\t\t * This should always be true. Home page URLs are the only ones without\r\n+\t\t\t * segments, and we dont encrypt those with this method.\r\n+\t\t\t * \r\n+\t\t\t * We always add the first segment of the URL, because we encrypt a URL like:\r\n+\t\t\t *\t/path/to/something\r\n+\t\t\t * to:\r\n+\t\t\t *\t/encrypted_full/hash/hash\r\n+\t\t\t * \r\n+\t\t\t * Notice the consistent number of segments. If we applied the following relative URL:\r\n+\t\t\t *\t../../something\r\n+\t\t\t * then the resultant URL would be:\r\n+\t\t\t *\t/something\r\n+\t\t\t * \r\n+\t\t\t * Hence, the mere existence of the first, encrypted version of complete URL, segment\r\n+\t\t\t * tells us that the first segment of the original URL is still to be used.\r\n+\t\t\t */\r\n+\t\t\turl.getSegments().add(originalUrl.getSegments().get(0));\r\n+\t\t}\r\n+\r\n \t\tHashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n \t\tint segNo = 1;\r\n \t\tfor (; segNo < encryptedNumberOfSegments; segNo++)\r\n@@ -222,18 +418,18 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\tif (!next.equals(encryptedSegment))\r\n \t\t\t{\r\n \t\t\t\t/*\r\n-\t\t\t\t\t * This segment received from the browser is not the same as the expected\r\n-\t\t\t\t\t * segment generated by the HashSegmentGenerator. Hence it, and all subsequent\r\n-\t\t\t\t\t * segments are considered plain text siblings of the original encrypted url.\r\n+\t\t\t\t * This segment received from the browser is not the same as the expected segment generated\r\n+\t\t\t\t * by the HashSegmentGenerator. Hence it, and all subsequent segments are considered plain\r\n+\t\t\t\t * text siblings of the original encrypted url.\r\n \t\t\t\t */\r\n \t\t\t\tbreak;\r\n \t\t\t}\r\n \r\n \t\t\t/*\r\n-\t\t\t\t * This segments matches the expected checksum, so we add the corresponding segment\r\n-\t\t\t\t * from the original URL.\r\n+\t\t\t * This segments matches the expected checksum, so we add the corresponding segment from the\r\n+\t\t\t * original URL.\r\n \t\t\t */\r\n-\t\t\t\turl.getSegments().add(originalUrl.getSegments().get(segNo - 1));\r\n+\t\t\turl.getSegments().add(originalUrl.getSegments().get(segNo));\r\n \t\t}\r\n \t\t/*\r\n \t\t * Add all remaining segments from the encrypted url as plain text segments.\r\n@@ -247,11 +443,83 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\turl.getQueryParameters().addAll(originalUrl.getQueryParameters());\r\n \t\t// WICKET-4923 additional parameters\r\n \t\turl.getQueryParameters().addAll(encryptedUrl.getQueryParameters());\r\n+\r\n+\t\treturn url;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Decrypts a URL which may contain an encrypted {@link PageComponentInfo} query parameter.\r\n+\t * \r\n+\t * @param request\r\n+\t *\t\tThe request that was made.\r\n+\t * @param encryptedUrl\r\n+\t *\t\tThe (potentially) encrypted URL.\r\n+\t * \r\n+\t * @return A decrypted form of the URL.\r\n+\t */\r\n+\tprotected Url decryptRequestListenerParameter(final Request request, Url encryptedUrl)\r\n+\t{\r\n+\t\tUrl url = new Url(encryptedUrl);\r\n+\r\n+\t\turl.getQueryParameters().clear();\r\n+\r\n+\t\tfor (Url.QueryParameter qp : encryptedUrl.getQueryParameters())\r\n+\t\t{\r\n+\t\t\tif (Strings.isEmpty(qp.getValue()) && Strings.isEmpty(qp.getName()) == false)\r\n+\t\t\t{\r\n+\t\t\t\tif (PageComponentInfo.parse(qp.getName()) != null)\r\n+\t\t\t\t{\r\n+\t\t\t\t\t/*\r\n+\t\t\t\t\t * Plain text request listener parameter found. This should have been encrypted, so we\r\n+\t\t\t\t\t * refuse to map the request unless the original URL did not include this parameter, which\r\n+\t\t\t\t\t * case there are likely to be multiple cryptomappers installed.\r\n+\t\t\t\t\t */\r\n+\t\t\t\t\tif (request.getOriginalUrl().getQueryParameter(qp.getName()) == null)\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\treturn null;\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\telse if (ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER.equals(qp.getName()))\r\n+\t\t\t{\r\n+\t\t\t\tString encryptedValue = qp.getValue();\r\n+\r\n+\t\t\t\tif (Strings.isEmpty(encryptedValue))\r\n+\t\t\t\t{\r\n+\t\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t\t}\r\n+\t\t\t\telse\r\n+\t\t\t\t{\r\n+\t\t\t\t\tString decryptedValue = null;\r\n+\r\n+\t\t\t\t\ttry\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\tdecryptedValue = getCrypt().decryptUrlSafe(encryptedValue);\r\n \t\t\t\t\t}\r\n \t\t\t\t\tcatch (Exception e)\r\n \t\t\t\t\t{\r\n-\t\t\tlog.error(\"Error decrypting URL\", e);\r\n-\t\t\turl = null;\r\n+\t\t\t\t\t\tlog.error(\"Error decrypting encrypted request listener query parameter\", e);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\tif (Strings.isEmpty(decryptedValue))\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\tUrl.QueryParameter decryptedParamter = new Url.QueryParameter(decryptedValue, \"\");\r\n+\t\t\t\t\t\turl.getQueryParameters().add(0, decryptedParamter);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\telse\r\n+\t\t\t{\r\n+\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t}\r\n \t\t}\r\n \r\n \t\treturn url;\r\n", "nb_test": 1703, "linesAdd": 159, "jira_id": "5326", "singleLine": false, "nb_skipped": 1, "commit": "ded3c583", "nb_failure": 15, "linesRem": 12}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PropertyValidatorRequiredTest.testResolveComposedConstraints:84 null"], "patch": "diff --git a/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java b/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\nindex e8e6376..a2486c7 100644\n--- a/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\n+++ b/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\n@@ -10,6 +10,7 @@\n import javax.validation.ConstraintViolation;\n import javax.validation.Validator;\n import javax.validation.constraints.NotNull;\n+import javax.validation.groups.Default;\n import javax.validation.metadata.ConstraintDescriptor;\n \n import org.apache.wicket.Component;\n@@ -100,11 +101,10 @@ private Property getProperty()\n \t\t\tif (property_ == null)\n \t\t\t{\n \t\t\t\tthrow new IllegalStateException(\n-\t\t\t\t\t\"Could not resolve Property from component: \" +\n-\t\t\t\t\t\tcomponent +\n-\t\t\t\t\t\t\". Either specify the Property in the constructor or use a model that works in combination with a \" +\n-\t\t\t\t\t\tIPropertyResolver.class.getSimpleName() +\n-\t\t\t\t\t\t\" to resolve the Property automatically\");\n+\t\t\t\t\t\"Could not resolve Property from component: \" + component\n+\t\t\t\t\t\t+ \". Either specify the Property in the constructor or use a model that works in combination with a \"\n+\t\t\t\t\t\t+ IPropertyResolver.class.getSimpleName()\n+\t\t\t\t\t\t+ \" to resolve the Property automatically\");\n \t\t\t}\n \t\t}\n \t\treturn property_;\n@@ -126,14 +126,15 @@ public void bind(Component component)\n \t\tif (this.component != null)\n \t\t{\n \t\t\tthrow new IllegalStateException( //\n-\t\t\t\t\"This validator has already been added to component: \" + this.component +\n-\t\t\t\t\t\". This validator does not support reusing instances, please create a new one\");\n+\t\t\t\t\"This validator has already been added to component: \"\n+\t\t\t\t\t+ this.component\n+\t\t\t\t\t+ \". This validator does not support reusing instances, please create a new one\");\n \t\t}\n \n \t\tif (!(component instanceof FormComponent))\n \t\t{\n-\t\t\tthrow new IllegalStateException(getClass().getSimpleName() +\n-\t\t\t\t\" can only be added to FormComponents\");\n+\t\t\tthrow new IllegalStateException(getClass().getSimpleName()\n+\t\t\t\t+ \" can only be added to FormComponents\");\n \t\t}\n \n \t\t// TODO add a validation key that appends the type so we can have\n@@ -208,7 +209,7 @@ boolean isRequired()\n \n \t\tfor (NotNull constraint : constraints)\n \t\t{\n-\t\t\tif (constraint.groups().length == 0 && validatorGroups.isEmpty())\n+\t\t\tif (canApplyToDefaultGroup(constraint) && validatorGroups.isEmpty())\n \t\t\t{\n \t\t\t\treturn true;\n \t\t\t}\n@@ -225,6 +226,14 @@ boolean isRequired()\n \t\treturn false;\n \t}\n \n+\tprivate boolean canApplyToDefaultGroup(NotNull constraint)\n+\t{\n+\t\tList<Class<?>> groups = Arrays.asList(constraint.groups());\n+\t\t//the constraint can be applied to default group either if its group array is empty\n+\t\t//or if it contains javax.validation.groups.Default\n+\t\treturn groups.size() == 0 || groups.contains(Default.class);\n+\t}\n+\n \t@Override\n \t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n \tpublic void onComponentTag(Component component, ComponentTag tag)\n", "nb_test": 8, "linesAdd": 17, "jira_id": "5656", "singleLine": false, "nb_skipped": 0, "commit": "f539c18c", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testIsValid(org.apache.wicket.validation.validator.UrlValidatorTest): http://go.local:80/test1?action=view expected:<true> but was:<false>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java b/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\nindex 9cc917c..a259c51 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n@@ -427,7 +427,7 @@ protected boolean isValidAuthority(String authority)\n \t\t\tif (segmentCount > 1)\n \t\t\t{\n \t\t\t\tString topLevel = domainSegment[segmentCount - 1];\n-\t\t\t\tif (topLevel.length() < 2 || topLevel.length() > 4)\n+\t\t\t\tif (topLevel.length() < 2)\n \t\t\t\t{\n \t\t\t\t\treturn false;\n \t\t\t\t}\n", "nb_test": 1251, "linesAdd": 1, "jira_id": "4255", "singleLine": false, "nb_skipped": 3, "commit": "c250db9c", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEmailWithPlusChar(org.apache.wicket.extensions.markup.html.basic.DefaultLinkParserTest)"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\nindex 2c95610..ff824a1 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\n@@ -29,7 +29,7 @@\n public class DefaultLinkParser extends LinkParser\n {\n \t/** Email address pattern */\n-\tprivate static final String emailPattern = \"[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\";\n+\tprivate static final String emailPattern = \"[\\\\w\\\\.-\\\\\\\\+]+@[\\\\w\\\\.-]+\";\n \n \t/** URL pattern */\n \tprivate static final String urlPattern = \"([a-zA-Z]+://[\\\\w\\\\.\\\\-\\\\:\\\\/~]+)[\\\\w\\\\.:\\\\-/?&=%]*\";\n", "nb_test": 10, "linesAdd": 1, "jira_id": "3174", "singleLine": false, "nb_skipped": 0, "commit": "0cf14725", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["sendRedirect(org.apache.wicket.protocol.http.servlet.ServletWebResponseTest): (..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\nindex 27b52b1..2296e34 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n@@ -227,6 +227,14 @@ public void sendRedirect(String url)\n \t\t\t}\n \t\t\telse\n \t\t\t{\n+\t\t\t\tif (url.startsWith(\"./\"))\n+\t\t\t\t{\n+\t\t\t\t\t/*\n+\t\t\t\t\t * WICKET-4260 Tomcat does not canonalize urls, which leads to problems with IE\n+\t\t\t\t\t * when url is relative and starts with a dot\n+\t\t\t\t\t */\n+\t\t\t\t\turl = url.substring(2);\n+\t\t\t\t}\n \t\t\t\thttpServletResponse.sendRedirect(url);\n \t\t\t}\n \t\t}\n", "nb_test": 1324, "linesAdd": 4, "jira_id": "4260", "singleLine": false, "nb_skipped": 8, "commit": "925cae5c", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testIsEqual(org.apache.wicket.protocol.http.mock.CookiesTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/Cookies.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/Cookies.java\nindex 68f3083..d3a8a6e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/Cookies.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/Cookies.java\n@@ -19,6 +19,7 @@\n import javax.servlet.http.Cookie;\n \n import org.apache.wicket.util.lang.Args;\n+import org.apache.wicket.util.lang.Objects;\n \n /**\n  * A helper class for dealing with cookies\n@@ -59,7 +60,7 @@ public static boolean isEqual(Cookie c1, Cookie c2)\n \t\tArgs.notNull(c2, \"c2\");\n \n \t\treturn c1.getName().equals(c2.getName()) &&\n-\t\t\t\t((c1.getPath() == null && c2.getPath() == null) || (c1.getPath().equals(c2.getPath()))) &&\n-\t\t\t\t((c1.getDomain() == null && c2.getDomain() == null) || (c1.getDomain().equals(c2.getDomain())));\n+\t\t\t\tObjects.isEqual(c1.getPath(), c2.getPath()) &&\n+\t\t\t\tObjects.isEqual(c1.getDomain(), c2.getDomain());\n \t}\n }\n", "nb_test": 1458, "linesAdd": 3, "jira_id": "5072", "singleLine": false, "nb_skipped": 3, "commit": "381b90fd", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDecode7(org.apache.wicket.request.mapper.MountedMapperTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractComponentMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractComponentMapper.java\nindex 0512fad..5757332 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractComponentMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractComponentMapper.java\n@@ -80,18 +80,24 @@ protected RequestListenerInterface requestListenerInterfaceFromString(String int\n \t * \n \t * @return PageComponentInfo instance if one was encoded in URL, <code>null</code> otherwise.\n \t */\n-\tprotected PageComponentInfo getPageComponentInfo(Url url)\n+\tprotected PageComponentInfo getPageComponentInfo(final Url url)\n \t{\n \t\tif (url == null)\n \t\t{\n \t\t\tthrow new IllegalStateException(\"Argument 'url' may not be null.\");\n \t\t}\n-\t\tif (url.getQueryParameters().size() > 0)\n+\t\telse\n \t\t{\n-\t\t\tQueryParameter param = url.getQueryParameters().get(0);\n-\t\t\tif (Strings.isEmpty(param.getValue()))\n+\t\t\tfor (QueryParameter queryParameter : url.getQueryParameters())\n \t\t\t{\n-\t\t\t\treturn PageComponentInfo.parse(param.getName());\n+\t\t\t\tif (Strings.isEmpty(queryParameter.getValue()))\n+\t\t\t\t{\n+\t\t\t\t\tPageComponentInfo pageComponentInfo = PageComponentInfo.parse(queryParameter.getName());\n+\t\t\t\t\tif (pageComponentInfo != null)\n+\t\t\t\t\t{\n+\t\t\t\t\t\treturn pageComponentInfo;\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn null;\n", "nb_test": 1038, "linesAdd": 11, "jira_id": "3272", "singleLine": false, "nb_skipped": 0, "commit": "c86b972a", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["unrenderedFeedbackMessages(org.apache.wicket.markup.html.form.FormValidationTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 9d46baf..d3c9b8b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -170,8 +170,7 @@ public void component(final FormComponent<?> formComponent, final IVisit<Void> v\n \t\t\t\treturn;\n \t\t\t}\n \n-\t\t\tif (formComponent.isVisibleInHierarchy() && formComponent.isValid() &&\n-\t\t\t\tformComponent.isEnabledInHierarchy())\n+\t\t\tif (formComponent.isVisibleInHierarchy() && formComponent.isEnabledInHierarchy())\n \t\t\t{\n \t\t\t\tvalidate(formComponent);\n \t\t\t}\n", "nb_test": 1408, "linesAdd": 1, "jira_id": "4757", "singleLine": false, "nb_skipped": 5, "commit": "fd910746", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["inlineEnclosurePage_1(org.apache.wicket.markup.html.internal.InlineEnclosureTest): org/apache/wicket/markup/html/internal/InlineEnclosurePageExpectedResult_1.html expected:<...tomInlineEnclosureId[7]\"><span>Test Label 1...> but was:<...tomInlineEnclosureId[]\"><span>Test Label 1...>", "inlineEnclosureWithWicketMessageVisible(org.apache.wicket.markup.html.internal.InlineEnclosureTest): org/apache/wicket/markup/html/internal/InlineEnclosureWithWicketMessagePage_visible_expected.html expected:<...v id=\"_message_attr_[1]\" title=\"Some title\"...> but was:<...v id=\"_message_attr_[]\" title=\"Some title\"...>", "inlineEnclosureWithWicketMessageInvisible(org.apache.wicket.markup.html.internal.InlineEnclosureTest): org/apache/wicket/markup/html/internal/InlineEnclosureWithWicketMessagePage_invisible_expected.html expected:<...v id=\"_message_attr_[1]\" style=\"display:non...> but was:<...v id=\"_message_attr_[]\" style=\"display:non...>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\nindex 06a193a..e059657 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n@@ -176,11 +176,7 @@ public Component resolve(final MarkupContainer container, final MarkupStream mar\n \t\tString inlineEnclosureChildId = getInlineEnclosureAttribute(tag);\r\n \t\tif (Strings.isEmpty(inlineEnclosureChildId) == false)\r\n \t\t{\r\n-\t\t\tString id = tag.getId();\r\n-\t\t\tif (id.equals(INLINE_ENCLOSURE_ID_PREFIX))\r\n-\t\t\t{\r\n-\t\t\t\tid = id + container.getPage().getAutoIndex();\r\n-\t\t\t}\r\n+\t\t\tString id = tag.getId() + container.getPage().getAutoIndex();\r\n \t\t\t// Yes, we handled the tag\r\n \t\t\treturn new InlineEnclosure(id, inlineEnclosureChildId);\r\n \t\t}\r\n", "nb_test": 1333, "linesAdd": 1, "jira_id": "4520", "singleLine": false, "nb_skipped": 8, "commit": "ccb8fc9e", "nb_failure": 3, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testHomePageWithParameters(org.apache.wicket.request.mapper.CryptoMapperTest): null expected:<...UNwbtLuXgDePMclxSbks[]> but was:<...UNwbtLuXgDePMclxSbks[/0lh9b]>", "testCSSResource(org.apache.wicket.request.mapper.CryptoMapperTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\nindex 4e632f8..bc2b297 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\n@@ -125,10 +125,6 @@ private Url encryptUrl(final Url url)\n \t\tencryptedUrl.getSegments().add(encryptedUrlString);\r\n \r\n \t\tint numberOfSegments = url.getSegments().size();\r\n-\t\tif (numberOfSegments == 0 && !url.getQueryParameters().isEmpty())\r\n-\t\t{\r\n-\t\t\tnumberOfSegments = 1;\r\n-\t\t}\r\n \t\tchar[] encryptedChars = encryptedUrlString.toCharArray();\r\n \t\tint hash = 0;\r\n \t\tfor (int segNo = 0; segNo < numberOfSegments; segNo++)\r\n@@ -157,7 +153,7 @@ private Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t}\r\n \r\n \t\tList<String> segments = encryptedUrl.getSegments();\r\n-\t\tif (segments.size() < 2)\r\n+\t\tif (segments.size() < 1)\r\n \t\t{\r\n \t\t\treturn null;\r\n \t\t}\r\n@@ -175,11 +171,6 @@ private Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\tUrl originalUrl = Url.parse(decryptedUrl, request.getCharset());\r\n \r\n \t\t\tint originalNumberOfSegments = originalUrl.getSegments().size();\r\n-\t\t\tif (originalNumberOfSegments == 0 &&\r\n-\t\t\t\toriginalUrl.getQueryParameters().isEmpty() == false)\r\n-\t\t\t{\r\n-\t\t\t\toriginalNumberOfSegments = 1;\r\n-\t\t\t}\r\n \t\t\tint numberOfSegments = encryptedUrl.getSegments().size();\r\n \r\n \t\t\tchar[] encryptedChars = encryptedUrlString.toCharArray();\r\n@@ -207,6 +198,12 @@ private Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\t\t}\r\n \t\t\t\telse\r\n \t\t\t\t{\r\n+\t\t\t\t\t// append new segments from browser\r\n+\t\t\t\t\twhile (segNo < numberOfSegments)\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\turl.getSegments().add(encryptedUrl.getSegments().get(segNo));\r\n+\t\t\t\t\t\tsegNo++;\r\n+\t\t\t\t\t}\r\n \t\t\t\t\tbreak;\r\n \t\t\t\t}\r\n \t\t\t}\r\n", "nb_test": 1142, "linesAdd": 6, "jira_id": "3514", "singleLine": false, "nb_skipped": 2, "commit": "2b6da516", "nb_failure": 2, "linesRem": 10}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBufferedResponsePostponeWriteResponseAction(org.apache.wicket.protocol.http.BufferedWebResponseTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\nindex 2ec9997..83c0556 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n@@ -20,6 +20,7 @@\n import java.io.IOException;\n import java.io.OutputStream;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n \n import javax.servlet.http.Cookie;\n@@ -88,9 +89,14 @@ public String encodeURL(CharSequence url)\n \t\t}\n \t}\n \n-\tprivate static abstract class Action\n+\tprivate static abstract class Action implements Comparable<Action>\n \t{\n \t\tprotected abstract void invoke(WebResponse response);\n+\n+\t\tpublic int compareTo(Action o)\n+\t\t{\n+\t\t\treturn 0;\n+\t\t}\n \t}\n \n \t/**\n@@ -100,6 +106,12 @@ public String encodeURL(CharSequence url)\n \t */\n \tprivate static abstract class MetaDataAction extends Action\n \t{\n+\t\t@Override\n+\t\tpublic int compareTo(Action o)\n+\t\t{\n+\t\t\t// write first in response\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n \t}\n \n \tprivate static class WriteCharSequenceAction extends Action\n@@ -135,6 +147,13 @@ protected void invoke(WebResponse response)\n \t\t\t}\n \t\t\tresponse.write(builder);\n \t\t}\n+\n+\t\t@Override\n+\t\tpublic int compareTo(Action o)\n+\t\t{\n+\t\t\t// needs to be invoked after set header actions\n+\t\t\treturn Integer.MAX_VALUE;\n+\t\t}\n \t}\n \n \tprivate static class WriteDataAction extends Action\n@@ -163,6 +182,13 @@ protected void invoke(WebResponse response)\n \t\t{\n \t\t\twriteStream(response, stream);\n \t\t}\n+\n+\t\t@Override\n+\t\tpublic int compareTo(Action o)\n+\t\t{\n+\t\t\t// needs to be invoked after set header actions\n+\t\t\treturn Integer.MAX_VALUE;\n+\t\t}\n \t}\n \n \tprivate static class CloseAction extends Action\n@@ -242,7 +268,7 @@ protected void invoke(WebResponse response)\n \t\t}\n \t}\n \n-\tprivate static class SetContentLengthAction extends Action\n+\tprivate static class SetContentLengthAction extends MetaDataAction\n \t{\n \t\tprivate final long contentLength;\n \n@@ -258,7 +284,7 @@ protected void invoke(WebResponse response)\n \t\t}\n \t}\n \n-\tprivate static class SetContentTypeAction extends Action\n+\tprivate static class SetContentTypeAction extends MetaDataAction\n \t{\n \t\tprivate final String contentType;\n \n@@ -482,6 +508,8 @@ public void writeTo(final WebResponse response)\n \t{\n \t\tArgs.notNull(response, \"response\");\n \n+\t\tCollections.sort(actions);\n+\n \t\tfor (Action action : actions)\n \t\t{\n \t\t\taction.invoke(response);\n", "nb_test": 1107, "linesAdd": 28, "jira_id": "3618", "singleLine": false, "nb_skipped": 0, "commit": "fbfd17e6", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["additionalParameters(org.apache.wicket.core.request.mapper.CryptoMapperTest): expected:<foo> but was:<null>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\nindex 86c551a..bb65517 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n@@ -234,6 +234,8 @@ private Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\t}\r\n \r\n \t\t\turl.getQueryParameters().addAll(originalUrl.getQueryParameters());\r\n+\t\t\t// WICKET-4923 additional parameters\r\n+\t\t\turl.getQueryParameters().addAll(encryptedUrl.getQueryParameters());\r\n \t\t}\r\n \t\tcatch (Exception e)\r\n \t\t{\r\n", "nb_test": 1438, "linesAdd": 1, "jira_id": "4923", "singleLine": true, "nb_skipped": 5, "commit": "d78132be", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["encodingOfString(org.apache.wicket.markup.parser.XmlPullParserTest): expected:<umlaut-[\u00e4\u00f6\u00fc]> but was:<umlaut-[\u00c3\u00a4\u00c3\u00b6\u00c3\u00bc]>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\nindex 262b795..377138a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\n@@ -17,9 +17,9 @@\n package org.apache.wicket.markup.parser;\n \n import java.io.BufferedInputStream;\n-import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.StringReader;\n import java.text.ParseException;\n \n import org.apache.wicket.markup.parser.XmlTag.TagType;\n@@ -48,10 +48,9 @@\n \tpublic static final String SCRIPT = \"script\";\n \n \t/**\n-\t * Reads the xml data from an input stream and converts the chars according to its encoding\n-\t * (<?xml ... encoding=\"...\" ?>)\n+\t * The encoding of the XML.\n \t */\n-\tprivate XmlReader xmlReader;\n+\tprivate String encoding;\n \n \t/**\n \t * A XML independent reader which loads the whole source data into memory and which provides\n@@ -84,7 +83,7 @@ public XmlPullParser()\n \t@Override\n \tpublic final String getEncoding()\n \t{\n-\t\treturn xmlReader.getEncoding();\n+\t\treturn encoding;\n \t}\n \n \t@Override\n@@ -544,7 +543,10 @@ else if (charAt == ch)\n \t@Override\n \tpublic void parse(final CharSequence string) throws IOException\n \t{\n-\t\tparse(new ByteArrayInputStream(string.toString().getBytes()), null);\n+\t\tArgs.notNull(string, \"string\");\n+\n+\t\tthis.input = new FullyBufferedReader(new StringReader(string.toString()));\n+\t\tthis.encoding = null;\n \t}\n \n \t/**\n@@ -554,6 +556,8 @@ public void parse(final CharSequence string) throws IOException\n \t * @param in\n \t *            The input stream to read and parse\n \t * @throws IOException\n+\t * \n+\t * @see {@link #parse(InputStream, String)}\n \t */\n \t@Override\n \tpublic void parse(final InputStream in) throws IOException\n@@ -563,7 +567,9 @@ public void parse(final InputStream in) throws IOException\n \t}\n \n \t/**\n-\t * Reads and parses markup from an input stream\n+\t * Reads and parses markup from an input stream.\n+\t * <p>\n+\t * Note: The input is closed after parsing.\n \t * \n \t * @param inputStream\n \t *            The input stream to read and parse\n@@ -578,13 +584,14 @@ public void parse(final InputStream inputStream, final String encoding) throws I\n \n \t\ttry\n \t\t{\n-\t\t\txmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000), encoding);\n-\t\t\tinput = new FullyBufferedReader(xmlReader);\n+\t\t\tXmlReader xmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000),\n+\t\t\t\tencoding);\n+\t\t\tthis.input = new FullyBufferedReader(xmlReader);\n+\t\t\tthis.encoding = xmlReader.getEncoding();\n \t\t}\n \t\tfinally\n \t\t{\n \t\t\tIOUtils.closeQuietly(inputStream);\n-\t\t\tIOUtils.closeQuietly(xmlReader);\n \t\t}\n \t}\n \n", "nb_test": 1526, "linesAdd": 11, "jira_id": "5398", "singleLine": false, "nb_skipped": 2, "commit": "19e7c1cd", "nb_failure": 1, "linesRem": 7}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["onBeforeRenderNotCalledOnVetoedComponents(org.apache.wicket.authorization.ComponentIsRenderedAllowedTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex e9e5a60..1d2ccc3 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -971,6 +971,9 @@ private final void internalBeforeRender()\n \t{\n \t\tconfigure();\n \n+\t\t// check authorization\n+\t\tsetRenderAllowed();\n+\n \t\tif ((determineVisibility()) && !getFlag(FLAG_RENDERING) &&\n \t\t\t!getFlag(FLAG_PREPARED_FOR_RENDER))\n \t\t{\n@@ -2210,11 +2213,6 @@ public void internalPrepareForRender(boolean setRenderingFlag)\n \t\t}\n \n \t\tmarkRendering(setRenderingFlag);\n-\n-\t\t// check authorization\n-\t\t// first the component itself\n-\t\t// (after attach as otherwise list views etc wont work)\n-\t\tsetRenderAllowed();\n \t}\n \n \t/**\n", "nb_test": 1251, "linesAdd": 2, "jira_id": "4256", "singleLine": false, "nb_skipped": 3, "commit": "09166ea8", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testResolveRelative_NoSegmentsInBase(org.apache.wicket.request.UrlTest): -1", "testResolveRelative_NoSegmentsInBase2(org.apache.wicket.request.UrlTest): -1"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 2c3289b..6950de2 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -592,8 +592,8 @@ public String toString()\n \t}\n \n \t/**\n-\t * render full representation of url (including protocol, host and port) \n-\t * into string representation\n+\t * render full representation of url (including protocol, host and port) into string\n+\t * representation\n \t */\n \tpublic String toAbsoluteString()\n \t{\n@@ -601,8 +601,8 @@ public String toAbsoluteString()\n \t}\n \n \t/**\n-\t * render full representation of url (including protocol, host and port) \n-\t * into string representation\n+\t * render full representation of url (including protocol, host and port) into string\n+\t * representation\n \t * \n \t * @param charset\n \t * \n@@ -880,9 +880,11 @@ public String toString(final Charset charset)\n \t */\n \tpublic void resolveRelative(final Url relative)\n \t{\n+\t\tif (getSegments().size() > 0)\n+\t\t{\n \t\t\t// strip the first non-folder segment\n \t\t\tgetSegments().remove(getSegments().size() - 1);\n-\n+\t\t}\n \t\t// remove all './' (current folder) from the relative url\n \t\tif (!relative.getSegments().isEmpty() && \".\".equals(relative.getSegments().get(0)))\n \t\t{\n", "nb_test": 52, "linesAdd": 3, "jira_id": "4072", "singleLine": false, "nb_skipped": 0, "commit": "7d5b8645", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testDateFieldsWithDateModels(org.apache.wicket.extensions.yui.calendar.DatePickerTest): expected:<1[4].06.11> but was:<1[5].06.11>"], "patch": "diff --git a/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java b/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\nindex 2534f48..13b9cb8 100644\n--- a/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\n+++ b/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\n@@ -435,19 +435,15 @@ protected void onBeforeRender()\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tMutableDateTime mDate;\n+\t\t\tMutableDateTime mDate = new MutableDateTime(modelObject);\n \t\t\t// convert date to the client's time zone if we have that info\n \t\t\tTimeZone zone = getClientTimeZone();\n \t\t\tif (zone != null)\n \t\t\t{\n-\t\t\t\tmDate = new MutableDateTime(modelObject, DateTimeZone.forTimeZone(zone));\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tmDate = new MutableDateTime(modelObject);\n+\t\t\t\tmDate.setZone(DateTimeZone.forTimeZone(zone));\n \t\t\t}\n \n-\t\t\tdate = mDate.toDate();\n+\t\t\tdate = mDate.toDateTime().toLocalDate().toDate();\n \n \t\t\tif (use12HourFormat)\n \t\t\t{\n", "nb_test": 17, "linesAdd": 3, "jira_id": "5204", "singleLine": false, "nb_skipped": 0, "commit": "9e6efa61", "nb_failure": 1, "linesRem": 7}, {"files": 2, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["callToStringFromConstructor(org.apache.wicket.MarkupContainerTest): Can not determine Markup. Component is not yet connected to a parent. [ToStringComponent [Component id = id]]"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 13b32cb..5f0a97d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -3207,23 +3207,22 @@ public String toString(final boolean detailed)\n \t{\n \t\ttry\n \t\t{\n+\t\t\tfinal StringBuilder buffer = new StringBuilder();\n+\t\t\tbuffer.append(\"[Component id = \").append(getId());\n+\n \t\t\tif (detailed)\n \t\t\t{\n \t\t\t\tfinal Page page = findPage();\n \t\t\t\tif (page == null)\n \t\t\t\t{\n-\t\t\t\t\treturn new StringBuilder(\"[Component id = \").append(getId())\n-\t\t\t\t\t\t.append(\", page = <No Page>, path = \")\n+\t\t\t\t\tbuffer.append(\", page = <No Page>, path = \")\n \t\t\t\t\t\t.append(getPath())\n \t\t\t\t\t\t.append('.')\n-\t\t\t\t\t\t.append(Classes.simpleName(getClass()))\n-\t\t\t\t\t\t.append(']')\n-\t\t\t\t\t\t.toString();\n+\t\t\t\t\t\t.append(Classes.simpleName(getClass()));\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n-\t\t\t\t\treturn new StringBuilder(\"[Component id = \").append(getId())\n-\t\t\t\t\t\t.append(\", page = \")\n+\t\t\t\t\tbuffer.append(\", page = \")\n \t\t\t\t\t\t.append(getPage().getClass().getName())\n \t\t\t\t\t\t.append(\", path = \")\n \t\t\t\t\t\t.append(getPath())\n@@ -3232,15 +3231,18 @@ public String toString(final boolean detailed)\n \t\t\t\t\t\t.append(\", isVisible = \")\n \t\t\t\t\t\t.append((determineVisibility()))\n \t\t\t\t\t\t.append(\", isVersioned = \")\n-\t\t\t\t\t\t.append(isVersioned())\n-\t\t\t\t\t\t.append(']')\n-\t\t\t\t\t\t.toString();\n-\t\t\t\t}\n+\t\t\t\t\t\t.append(isVersioned());\n \t\t\t\t}\n-\t\t\telse\n+\n+\t\t\t\tif (markup != null)\n \t\t\t\t{\n-\t\t\t\treturn \"[Component id = \" + getId() + ']';\n+\t\t\t\t\tbuffer.append(\", markup = \").append(new MarkupStream(getMarkup()).toString());\n+\t\t\t\t}\n \t\t\t}\n+\n+\t\t\tbuffer.append(']');\n+\n+\t\t\treturn buffer.toString();\n \t\t}\n \t\tcatch (Exception e)\n \t\t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 056d483..f992264 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -860,17 +860,11 @@ public String toString()\n \tpublic String toString(final boolean detailed)\n \t{\n \t\tfinal StringBuilder buffer = new StringBuilder();\n-\t\tbuffer.append(\"[\").append(this.getClass().getSimpleName()).append(\" \");\n+\t\tbuffer.append('[').append(this.getClass().getSimpleName()).append(' ');\n \t\tbuffer.append(super.toString(detailed));\n-\t\tif (detailed)\n+\t\tif (detailed && children_size() != 0)\n \t\t{\n-\t\t\tif (getMarkup() != null)\n-\t\t\t{\n-\t\t\t\tbuffer.append(\", markup = \").append(new MarkupStream(getMarkup()).toString());\n-\t\t\t}\n \n-\t\t\tif (children_size() != 0)\n-\t\t\t{\n \t\t\tbuffer.append(\", children = \");\n \n \t\t\t// Loop through child components\n@@ -885,7 +879,7 @@ public String toString(final boolean detailed)\n \t\t\t\t}\n \t\t\t\tbuffer.append(child.toString());\n \t\t\t}\n-\t\t\t}\n+\n \t\t}\n \t\tbuffer.append(']');\n \t\treturn buffer.toString();\n", "nb_test": 1180, "linesAdd": 18, "jira_id": "4016", "singleLine": false, "nb_skipped": 2, "commit": "f1c9cef2", "nb_failure": 0, "linesRem": 22}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["AjaxTimerBehaviorTest.addedInAjaxSetsTimout:78->assertMatches:362->Assert.assertEquals:542->Assert.assertEquals:555->Assert.assertEquals:118->Assert.failNotEquals:743->Assert.fail:88 expected:<1> but was:<0>", "AjaxTimerBehaviorTest.ajaxUpdateDoesNotSetTimeout:149->assertMatches:362->Assert.assertEquals:542->Assert.assertEquals:555->Assert.assertEquals:118->Assert.failNotEquals:743->Assert.fail:88 expected:<1> but was:<0>", "AjaxTimerBehaviorTest.setDisabledClearsTimeout:239->assertMatches:362->Assert.assertEquals:542->Assert.assertEquals:555->Assert.assertEquals:118->Assert.failNotEquals:743->Assert.fail:88 expected:<1> but was:<0>", "AjaxTimerBehaviorTest.setVisibleSetsTimeout:198->assertMatches:362->Assert.assertEquals:542->Assert.assertEquals:555->Assert.assertEquals:118->Assert.failNotEquals:743->Assert.fail:88 expected:<1> but was:<0>", "AjaxTimerBehaviorTest.restartResultsInAddTimeout:324->assertMatches:362->Assert.assertEquals:542->Assert.assertEquals:555->Assert.assertEquals:118->Assert.failNotEquals:743->Assert.fail:88 expected:<1> but was:<0>", "AjaxTimerBehaviorTest.pageRenderSetsTimeout:112->assertMatches:362->Assert.assertEquals:542->Assert.assertEquals:555->Assert.assertEquals:118->Assert.failNotEquals:743->Assert.fail:88 expected:<1> but was:<0>", "SimpleTestPanelTest.renderHomePage_2:38->WicketTestCase.executeTest:99->Assert.assertEquals:115 org/apache/wicket/ajax/markup/html/componentMap/SimpleTestPageExpectedResult.html expected:<...;", "/*]]>*/", "</script>", "[", "<title>ajax-test</title>", "<script type=\"text/javascript\" >", "/*<![CDATA[*/", "Wicket.Event.add(window, \"load\", function(event) {", "Wicket.Timer.set('linja11', function(){Wicket.Ajax.ajax({\"u\":\"./org.apache.wicket.ajax.markup.html.componentMap.SimpleTestPage?0-1.IBehaviorListener.0-testPanel-baseSpan-linja1\",\"c\":\"linja11\"});}, 2000);];", ";});", "/*]]>*/", "</scr...> but was:<...;", "/*]]>*/", "</script>", "[<script type=\"text/javascript\" id=\"AbstractAjaxTimerBehavior-timers\">", "/*<![CDATA[*/", "if (typeof(Wicket.TimerHandles) === 'undefined') {Wicket.TimerHandles = {}}", "/*]]>*/", "</script>", "<title>ajax-test</title>", "<script type=\"text/javascript\" >", "/*<![CDATA[*/", "Wicket.Event.add(window, \"load\", function(event) {", "Wicket.TimerHandles['linja11'] = setTimeout('Wicket.Ajax.ajax({\\\"u\\\":\\\"./org.apache.wicket.ajax.markup.html.componentMap.SimpleTestPage?0-1.IBehaviorListener.0-testPanel-baseSpan-linja1\\\",\\\"c\\\":\\\"linja11\\\"});', 2000)];", ";});", "/*]]>*/", "</scr...>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxTimerBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxTimerBehavior.java\nindex 39c3cc6..5ecf56e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxTimerBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxTimerBehavior.java\n@@ -18,9 +18,7 @@\n \n import org.apache.wicket.Component;\n import org.apache.wicket.Page;\n-import org.apache.wicket.core.util.string.JavaScriptUtils;\n import org.apache.wicket.markup.head.IHeaderResponse;\n-import org.apache.wicket.markup.head.JavaScriptHeaderItem;\n import org.apache.wicket.markup.head.OnLoadHeaderItem;\n import org.apache.wicket.util.time.Duration;\n \n@@ -36,7 +34,6 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n-\tprivate static final String WICKET_TIMERS_ID = AbstractAjaxTimerBehavior.class.getSimpleName() + \"-timers\";\n \t/** The update interval */\n \tprivate Duration updateInterval;\n \n@@ -88,10 +85,6 @@ public void renderHead(Component component, IHeaderResponse response)\n \t{\n \t\tsuper.renderHead(component, response);\n \n-\t\tresponse.render(JavaScriptHeaderItem.forScript(\n-\t\t\t\"if (typeof(Wicket.TimerHandles) === 'undefined') {Wicket.TimerHandles = {}}\",\n-\t\t\tWICKET_TIMERS_ID));\n-\n \t\tif (component.getRequestCycle().find(AjaxRequestTarget.class) == null)\n \t\t{\n \t\t\t// complete page is rendered, so timeout has to be rendered again\n@@ -112,19 +105,9 @@ public void renderHead(Component component, IHeaderResponse response)\n \tprotected final String getJsTimeoutCall(final Duration updateInterval)\n \t{\n \t\tCharSequence js = getCallbackScript();\n-\t\tjs = JavaScriptUtils.escapeQuotes(js);\n-\n-\t\tString timeoutHandle = getTimeoutHandle();\n-\t\t// this might look strange, but it is necessary for IE not to leak :(\n-\t\treturn timeoutHandle+\" = setTimeout('\" + js + \"', \" +\n-\t\t\tupdateInterval.getMilliseconds() + ')';\n-\t}\n \n-\t/**\n-\t * @return the name of the handle that is used to stop any scheduled timer\n-\t */\n-\tprivate String getTimeoutHandle() {\n-\t\treturn \"Wicket.TimerHandles['\"+getComponent().getMarkupId() + \"']\";\n+\t\treturn String.format(\"Wicket.Timer.set('%s', function(){%s}, %d);\",\n+\t\t\t\tgetComponent().getMarkupId(), js, updateInterval.getMilliseconds());\n \t}\n \n \t/**\n@@ -218,9 +201,7 @@ private void clearTimeout(IHeaderResponse headerResponse)\n \t\t{\n \t\t\thasTimeout = false;\n \n-\t\t\tString timeoutHandle = getTimeoutHandle();\n-\t\t\theaderResponse.render(OnLoadHeaderItem.forScript(\"clearTimeout(\" + timeoutHandle\n-\t\t\t\t+ \"); delete \" + timeoutHandle + \";\"));\n+\t\t\theaderResponse.render(OnLoadHeaderItem.forScript(\"Wicket.Timer.clear('\" + getComponent().getMarkupId() + \"');\"));\n \t\t}\n \t}\n \n", "nb_test": 1636, "linesAdd": 3, "jira_id": "5570", "singleLine": false, "nb_skipped": 2, "commit": "57d8f051", "nb_failure": 7, "linesRem": 18}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testEncode9(org.apache.wicket.request.mapper.BasicResourceReferenceMapperTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractResourceReferenceMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractResourceReferenceMapper.java\nindex b0b40ec..ce4896c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractResourceReferenceMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractResourceReferenceMapper.java\n@@ -47,14 +47,22 @@ protected static String encodeResourceReferenceAttributes(\n \t\t\t{\n \t\t\t\tres.append(attributes.getLocale().toString());\n \t\t\t}\n-\t\t\tif (!Strings.isEmpty(attributes.getStyle()))\n+\t\t\tboolean styleEmpty = Strings.isEmpty(attributes.getStyle());\n+\t\t\tif (!styleEmpty)\n \t\t\t{\n-\t\t\t\tres.append(\"-\");\n+\t\t\t\tres.append('-');\n \t\t\t\tres.append(attributes.getStyle());\n \t\t\t}\n \t\t\tif (!Strings.isEmpty(attributes.getVariation()))\n \t\t\t{\n-\t\t\t\tres.append(\"-\");\n+\t\t\t\tif (styleEmpty)\n+\t\t\t\t{\n+\t\t\t\t\tres.append(\"--\");\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tres.append('-');\n+\t\t\t\t}\n \t\t\t\tres.append(attributes.getVariation());\n \t\t\t}\n \t\t\treturn res.toString();\n", "nb_test": 1038, "linesAdd": 11, "jira_id": "3297", "singleLine": false, "nb_skipped": 0, "commit": "71499e17", "nb_failure": 1, "linesRem": 3}, {"files": 3, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["PackageMapperTest.testGetCompatibilityScore:658->Assert.assertEquals:542->Assert.assertEquals:555->Assert.assertEquals:118->Assert.failNotEquals:743->Assert.fail:88 expected:<4> but was:<2>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\nindex e9ad89c..e38d956 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n@@ -204,7 +204,25 @@ public AbstractBookmarkableMapper(String mountPath, IPageParametersEncoder pageP\n \t * @see IRequestMapper#getCompatibilityScore(Request)\n \t */\n \t@Override\n-\tpublic abstract int getCompatibilityScore(Request request);\n+\tpublic int getCompatibilityScore(Request request)\n+\t{\n+\t\tif (urlStartsWith(request.getUrl(), mountSegments))\n+\t\t{\n+\t\t\t/* see WICKET-5056 - alter score with pathSegment type */\n+\t\t\tint countOptional = 0;\n+\t\t\tint fixedSegments = 0;\n+\t\t\tfor (MountPathSegment pathSegment : pathSegments)\n+\t\t\t{\n+\t\t\t\tfixedSegments += pathSegment.getFixedPartSize();\n+\t\t\t\tcountOptional += pathSegment.getOptionalParameters();\n+\t\t\t}\n+\t\t\treturn mountSegments.length - countOptional + fixedSegments;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\treturn 0;\n+\t\t}\n+\t}\n \n \t/**\n \t * Creates a {@code IRequestHandler} that processes a bookmarkable request.\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\nindex da6c4c4..fdf1dc2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n@@ -268,30 +268,6 @@ protected boolean pageMustHaveBeenCreatedBookmarkable()\n \t}\n \n \t/**\n-\t * @see AbstractBookmarkableMapper#getCompatibilityScore(org.apache.wicket.request.Request)\n-\t */\n-\t@Override\n-\tpublic int getCompatibilityScore(Request request)\n-\t{\n-\t\tif (urlStartsWith(request.getUrl(), mountSegments))\n-\t\t{\n-\t\t\t/* see WICKET-5056 - alter score with pathSegment type */\n-\t\t\tint countOptional = 0;\n-\t\t\tint fixedSegments = 0;\n-\t\t\tfor (MountPathSegment pathSegment : pathSegments)\n-\t\t\t{\n-\t\t\t\tfixedSegments += pathSegment.getFixedPartSize();\n-\t\t\t\tcountOptional += pathSegment.getOptionalParameters();\n-\t\t\t}\n-\t\t\treturn mountSegments.length - countOptional + fixedSegments;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn 0;\n-\t\t}\n-\t}\n-\n-\t/**\n \t * @see AbstractBookmarkableMapper#checkPageClass(java.lang.Class)\n \t */\n \t@Override\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\nindex 2037356..ff8b81a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n@@ -221,17 +221,4 @@ protected boolean pageMustHaveBeenCreatedBookmarkable()\n \t{\n \t\treturn false;\n \t}\n-\n-\t@Override\n-\tpublic int getCompatibilityScore(Request request)\n-\t{\n-\t\tif (urlStartsWith(request.getUrl(), mountSegments))\n-\t\t{\n-\t\t    return mountSegments.length;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t    return 0;\n-\t\t}\n-\t}\n }\n", "nb_test": 1637, "linesAdd": 18, "jira_id": "5565", "singleLine": false, "nb_skipped": 2, "commit": "204849bc", "nb_failure": 1, "linesRem": 34}, {"files": 4, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["decodePostParameters(org.apache.wicket.request.mapper.parameter.PageParametersEncoderTest): expected:<1> but was:<null>"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\nindex 2312995..5687a71 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\n@@ -16,9 +16,13 @@\n  */\n package org.apache.wicket.request.mapper.parameter;\n \n+import java.util.List;\n+\n+import org.apache.wicket.request.IRequestParameters;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.Url.QueryParameter;\n+import org.apache.wicket.util.string.StringValue;\n \n /**\n  * Simple encoder with direct indexed/named parameters mapping.\n@@ -48,9 +52,14 @@ public PageParameters decodePageParameters(final Request request)\n \t\t\t++i;\n \t\t}\n \t\t\n-\t\tfor (QueryParameter p : request.getUrl().getQueryParameters())\n+\t\tIRequestParameters requestParameters = request.getRequestParameters();\n+\t\tfor (String paramName : requestParameters.getParameterNames())\n+\t\t{\n+\t\t\tList<StringValue> parameterValues = requestParameters.getParameterValues(paramName);\n+\t\t\tfor (StringValue paramValue : parameterValues)\n \t\t\t{\n-\t\t\tparameters.add(p.getName(), p.getValue());\n+\t\t\t\tparameters.add(paramName, paramValue);\n+\t\t\t}\n \t\t}\n \n \t\treturn parameters.isEmpty() ? null : parameters;\ndiff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/UrlPathPageParametersEncoder.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/UrlPathPageParametersEncoder.java\nindex db3ea51..f31f5c1 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/UrlPathPageParametersEncoder.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/UrlPathPageParametersEncoder.java\n@@ -25,9 +25,12 @@\n \r\n \r\n /**\r\n+ * <p>\r\n  * Encodes page parameters into Url path fragments instead of the query string like the default\r\n  * {@link PageParametersEncoder}. The parameters are encoded in the following format:\r\n  * {@code /param1Name/param1Value/param2Name/param2Value}.\r\n+ * </p>\r\n+ * <strong>Note</strong>: Because of the nature of the encoder it doesn't support POST request parameters.\r\n  * <p>\r\n  * This used to be the default way of encoding page parameters in 1.4.x applications. Newer 1.5.x+\r\n  * applications use the query string, by default. This class facilitates backwards compatibility and\r\ndiff --git a/wicket-request/src/main/java/org/apache/wicket/request/parameter/CombinedRequestParametersAdapter.java b/wicket-request/src/main/java/org/apache/wicket/request/parameter/CombinedRequestParametersAdapter.java\nindex e895f3b..b5792cc 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/parameter/CombinedRequestParametersAdapter.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/parameter/CombinedRequestParametersAdapter.java\n@@ -19,10 +19,12 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashSet;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n \n import org.apache.wicket.request.IRequestParameters;\n+import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.string.StringValue;\n \n /**\n@@ -41,11 +43,7 @@\n \t */\n \tpublic CombinedRequestParametersAdapter(final IRequestParameters... parameters)\n \t{\n-\t\tif (parameters == null)\n-\t\t{\n-\t\t\tthrow new IllegalStateException(\"Argument 'parameters' may not be null\");\n-\t\t}\n-\t\tthis.parameters = parameters;\n+\t\tthis.parameters = Args.notNull(parameters, \"parameters\");\n \t}\n \n \t/**\n@@ -53,7 +51,7 @@ public CombinedRequestParametersAdapter(final IRequestParameters... parameters)\n \t */\n \tpublic Set<String> getParameterNames()\n \t{\n-\t\tSet<String> result = new HashSet<String>();\n+\t\tSet<String> result = new LinkedHashSet<String>();\n \t\tfor (IRequestParameters p : parameters)\n \t\t{\n \t\t\tresult.addAll(p.getParameterNames());\ndiff --git a/wicket-request/src/main/java/org/apache/wicket/request/parameter/UrlRequestParametersAdapter.java b/wicket-request/src/main/java/org/apache/wicket/request/parameter/UrlRequestParametersAdapter.java\nindex d65d1d6..bbdd1da 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/parameter/UrlRequestParametersAdapter.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/parameter/UrlRequestParametersAdapter.java\n@@ -18,7 +18,7 @@\n \n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n \n@@ -55,7 +55,7 @@ public UrlRequestParametersAdapter(final Url url)\n \t */\n \tpublic Set<String> getParameterNames()\n \t{\n-\t\tSet<String> result = new HashSet<String>();\n+\t\tSet<String> result = new LinkedHashSet<String>();\n \t\tfor (QueryParameter parameter : url.getQueryParameters())\n \t\t{\n \t\t\tresult.add(parameter.getName());\n", "nb_test": 66, "linesAdd": 17, "jira_id": "4338", "singleLine": false, "nb_skipped": 0, "commit": "9decad35", "nb_failure": 1, "linesRem": 10}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["equals(org.apache.wicket.util.string.StringValueTest): invalid comparison: java.util.Locale and java.util.Locale"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java b/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\nindex fa5bbbd..2887f95 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\n@@ -361,8 +361,8 @@ public final CharSequence replaceAll(final CharSequence searchFor,\n \t\t\treturn (T)toEnum((Class)type);\n \t\t}\n \n-\t\tthrow new StringValueConversionException(\"Cannot convert '\" + toString() + \"'to type \" +\n-\t\t\ttype);\n+\t\tthrow new StringValueConversionException(\"Cannot convert '\" + toString() + \"'to type \"\n+\t\t\t+ type);\n \t}\n \n \t/**\n@@ -394,7 +394,8 @@ public final boolean toBoolean() throws StringValueConversionException\n \t * \n \t * @param defaultValue\n \t *            the default value\n-\t * @return the converted text as a boolean or the default value if text is empty or inconvertible\n+\t * @return the converted text as a boolean or the default value if text is empty or\n+\t *         inconvertible\n \t * @see Strings#isTrue(String)\n \t */\n \tpublic final boolean toBoolean(final boolean defaultValue)\n@@ -410,7 +411,8 @@ public final boolean toBoolean(final boolean defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a boolean: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a boolean: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -444,7 +446,8 @@ public final char toChar() throws StringValueConversionException\n \t * \n \t * @param defaultValue\n \t *            the default value\n-\t * @return the converted text as a primitive char or the default value if text is not a single character\n+\t * @return the converted text as a primitive char or the default value if text is not a single\n+\t *         character\n \t */\n \tpublic final char toChar(final char defaultValue)\n \t{\n@@ -459,7 +462,8 @@ public final char toChar(final char defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a character: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a character: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -491,8 +495,8 @@ public final double toDouble() throws StringValueConversionException\n \t\t}\n \t\tcatch (ParseException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to a double value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to a double value\", e);\n \t\t}\n \t}\n \n@@ -516,7 +520,8 @@ public final double toDouble(final double defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a double: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a double: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -551,7 +556,8 @@ public final Duration toDuration() throws StringValueConversionException\n \t * \n \t * @param defaultValue\n \t *            the default value\n-\t * @return the converted text as a duration or the default value if text is empty or inconvertible\n+\t * @return the converted text as a duration or the default value if text is empty or\n+\t *         inconvertible\n \t * @see Duration#valueOf(String, java.util.Locale)\n \t */\n \tpublic final Duration toDuration(final Duration defaultValue)\n@@ -567,7 +573,8 @@ public final Duration toDuration(final Duration defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a Duration: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a Duration: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -588,8 +595,8 @@ public final int toInt() throws StringValueConversionException\n \t\t}\n \t\tcatch (NumberFormatException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to an int value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to an int value\", e);\n \t\t}\n \t}\n \n@@ -613,7 +620,8 @@ public final int toInt(final int defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to an integer: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to an integer: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -634,8 +642,8 @@ public final Integer toInteger() throws StringValueConversionException\n \t\t}\n \t\tcatch (NumberFormatException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to an Integer value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to an Integer value\", e);\n \t\t}\n \t}\n \n@@ -653,8 +661,8 @@ public final long toLong() throws StringValueConversionException\n \t\t}\n \t\tcatch (NumberFormatException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to a long value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to a long value\", e);\n \t\t}\n \t}\n \n@@ -663,7 +671,8 @@ public final long toLong() throws StringValueConversionException\n \t * \n \t * @param defaultValue\n \t *            the default value\n-\t * @return the converted text as a long integer or the default value if text is empty or inconvertible\n+\t * @return the converted text as a long integer or the default value if text is empty or\n+\t *         inconvertible\n \t */\n \tpublic final long toLong(final long defaultValue)\n \t{\n@@ -678,7 +687,8 @@ public final long toLong(final long defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a long: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a long: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -699,8 +709,8 @@ public final Long toLongObject() throws StringValueConversionException\n \t\t}\n \t\tcatch (NumberFormatException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to a Long value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to a Long value\", e);\n \t\t}\n \t}\n \n@@ -826,8 +836,8 @@ public final Time toTime() throws StringValueConversionException\n \t\t}\n \t\tcatch (ParseException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to a Time value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to a Time value\", e);\n \t\t}\n \t}\n \n@@ -851,7 +861,8 @@ public final Time toTime(final Time defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a Time: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a Time: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -968,8 +979,7 @@ public boolean equals(final Object obj)\n \t\tif (obj instanceof StringValue)\n \t\t{\n \t\t\tStringValue stringValue = (StringValue)obj;\n-\t\t\treturn Objects.isEqual(text, stringValue.text) &&\n-\t\t\t\tObjects.isEqual(locale, stringValue.locale);\n+\t\t\treturn Objects.isEqual(text, stringValue.text) && locale.equals(stringValue.locale);\n \t\t}\n \t\telse\n \t\t{\n", "nb_test": 169, "linesAdd": 29, "jira_id": "5359", "singleLine": false, "nb_skipped": 0, "commit": "61122bab", "nb_failure": 0, "rtElixir": true, "linesRem": 23}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testResetInheritedModelFlag(org.apache.wicket.model.InheritedModelTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex f94cf41..7a3df6a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -2956,6 +2956,12 @@ void setModelImpl(IModel<?> model)\n \t\t\tif (model != null)\n \t\t\t{\n \t\t\t\tdata_set(0, model);\n+\t\t\t\t// WICKET-3413 reset 'inherited model' flag if model changed\n+\t\t\t\t// and a new one is not IComponentInheritedModel\n+\t\t\t\tif (getFlag(FLAG_INHERITABLE_MODEL) && !(model instanceof IComponentInheritedModel))\n+\t\t\t\t{\n+\t\t\t\t\tsetFlag(FLAG_INHERITABLE_MODEL, false);\n+\t\t\t\t}\n \t\t\t}\n \t\t\telse\n \t\t\t{\n", "nb_test": 1064, "linesAdd": 4, "jira_id": "3413", "singleLine": false, "nb_skipped": 0, "commit": "499a9c6b", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["writeJavaScriptUrl(org.apache.wicket.core.util.string.JavaScriptUtilsTest): expected:<...essionid=1234?p1=v1&[]p2=v2\"></script>(..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptUtils.java b/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptUtils.java\nindex f07d515..42d9274 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptUtils.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptUtils.java\n@@ -143,7 +143,7 @@ public static void writeJavaScriptUrl(final Response response, final CharSequenc\n \t\t\tresponse.write(\"charset=\\\"\" + Strings.escapeMarkup(charset) + \"\\\" \");\n \t\t}\n \t\tresponse.write(\"src=\\\"\");\n-\t\tresponse.write(Strings.escapeMarkup(url));\n+\t\tresponse.write(url);\n \t\tresponse.write(\"\\\"></script>\");\n \t\tresponse.write(\"\\n\");\n \t}\n@@ -201,7 +201,7 @@ public static void writeOpenTag(final Response response, String id)\n \t\tresponse.write(\"<script type=\\\"text/javascript\\\" \");\n \t\tif (id != null)\n \t\t{\n-\t\t\tresponse.write(\"id=\\\"\" + id + \"\\\"\");\n+\t\t\tresponse.write(\"id=\\\"\" + Strings.escapeMarkup(id) + \"\\\"\");\n \t\t}\n \t\tresponse.write(\">\");\n \t\tresponse.write(SCRIPT_CONTENT_PREFIX);\n", "nb_test": 1410, "linesAdd": 2, "jira_id": "4777", "singleLine": false, "nb_skipped": 5, "commit": "eccb3b11", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["OnChangeAjaxBehaviorTest.rendering:39->WicketTestCase.executeTest:99->Assert.assertEquals:115 org/apache/wicket/ajax/form/OnChangeAjaxBehaviorTestPage_expected.html expected:<...d1\",\"e\":\"inputchange[ change]\"});;", "Wicket.Ajax.aj...> but was:<...d1\",\"e\":\"inputchange[]\"});;", "Wicket.Ajax.aj...>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\nindex f363cd8..27c229c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\n@@ -47,7 +47,8 @@\n \t * for text input form component depending on the browser.\n \t * 'change' is used as a fallback for all other form component types.\n \t */\n-\tpublic static final String EVENT_INPUTCHANGE = \"inputchange\";\n+\tpublic static final String EVENT_NAME = \"inputchange change\";\n+\n \tpublic static final String EVENT_CHANGE = \"change\";\n \n \t/**\n@@ -55,7 +56,7 @@\n \t */\n \tpublic OnChangeAjaxBehavior()\n \t{\n-\t\tsuper(EVENT_INPUTCHANGE + \" \" + EVENT_CHANGE);\n+\t\tsuper(EVENT_NAME);\n \t}\n \n \t@Override\n@@ -65,13 +66,9 @@ protected void updateAjaxAttributes(AjaxRequestAttributes attributes)\n \n \t\tComponent component = getComponent();\n \n-\t\t//textfiels and textareas will trigger this behavior with event 'inputchange'\n-\t\t//while all the other components will use 'change'\n-\t\tif (component instanceof TextField || component instanceof TextArea) \n-\t\t{\n-\t\t\tattributes.setEventNames(EVENT_INPUTCHANGE);\n-\t\t} \n-\t\telse \n+\t\t// textfiels and textareas will trigger this behavior with either 'inputchange' or 'change' events\n+\t\t// all the other components will use just 'change'\n+\t\tif (!(component instanceof TextField || component instanceof TextArea))\n \t\t{\n \t\t\tattributes.setEventNames(EVENT_CHANGE);\n \t\t}\n", "nb_test": 1690, "linesAdd": 4, "jira_id": "5711", "singleLine": false, "nb_skipped": 1, "commit": "5837817c", "nb_failure": 1, "linesRem": 7}, {"files": 1, "project": "wicket", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["testAtomicity(org.apache.wicket.ComponentInitializationTest)", "testPageInitialization(org.apache.wicket.ComponentInitializationTest)", "testPropagation(org.apache.wicket.ComponentInitializationTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/Component.java b/wicket/src/main/java/org/apache/wicket/Component.java\nindex 380637b..f71a97a 100644\n--- a/wicket/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket/src/main/java/org/apache/wicket/Component.java\n@@ -967,8 +967,8 @@ void initialize()\n \t{\n \t\tif (!getFlag(FLAG_INITIALIZED))\n \t\t{\n-\t\t\tonInitialize();\n \t\t\tsetFlag(FLAG_INITIALIZED, true);\n+\t\t\tonInitialize();\n \t\t}\n \t}\n \n", "nb_test": 891, "linesAdd": 1, "jira_id": "2961", "singleLine": false, "nb_skipped": 1, "commit": "3d8c9d75", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["toStringValues(org.apache.wicket.util.time.DurationTest): expected:<[1] millisecond> but was:<[0] millisecond>"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/time/Duration.java b/wicket-util/src/main/java/org/apache/wicket/util/time/Duration.java\nindex fc232bf..c366990 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/time/Duration.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/time/Duration.java\n@@ -526,7 +526,7 @@ public String toString(final Locale locale)\n \t\t\t\treturn unitString(seconds(), \"second\", locale);\r\n \t\t\t}\r\n \r\n-\t\t\treturn unitString(seconds(), \"millisecond\", locale);\r\n+\t\t\treturn unitString(getMilliseconds(), \"millisecond\", locale);\r\n \t\t}\r\n \t\telse\r\n \t\t{\r\n", "nb_test": 156, "linesAdd": 1, "jira_id": "4597", "singleLine": false, "nb_skipped": 0, "commit": "9dab1bb5", "nb_failure": 1, "linesRem": 1}, {"files": 4, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["inlineEnclosureWithWicketMessageVisible(org.apache.wicket.markup.html.internal.InlineEnclosureTest): org/apache/wicket/markup/html/internal/InlineEnclosureWithWicketMessagePage_visible_expected.html expected:<.../head>(..)", "inlineEnclosureWithWicketMessageInvisible(org.apache.wicket.markup.html.internal.InlineEnclosureTest): org/apache/wicket/markup/html/internal/InlineEnclosureWithWicketMessagePage_invisible_expected.html expected:<.../head>(..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Application.java b/wicket-core/src/main/java/org/apache/wicket/Application.java\nindex 6cd4445..98078ea 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Application.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Application.java\n@@ -685,11 +685,11 @@ protected void internalInit()\n \t\tpageSettings.addComponentResolver(new HtmlHeaderResolver());\n \t\tpageSettings.addComponentResolver(new WicketLinkTagHandler());\n \t\tpageSettings.addComponentResolver(new WicketMessageResolver());\n-\t\tpageSettings.addComponentResolver(new WicketMessageTagHandler());\n \t\tpageSettings.addComponentResolver(new FragmentResolver());\n \t\tpageSettings.addComponentResolver(new RelativePathPrefixHandler());\n \t\tpageSettings.addComponentResolver(new EnclosureHandler());\n \t\tpageSettings.addComponentResolver(new InlineEnclosureHandler());\n+\t\tpageSettings.addComponentResolver(new WicketMessageTagHandler());\n \t\tpageSettings.addComponentResolver(new WicketContainerResolver());\n \n \t\t// Install button image resource factory\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/MarkupParser.java b/wicket-core/src/main/java/org/apache/wicket/markup/MarkupParser.java\nindex d84383f..4720314 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/MarkupParser.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/MarkupParser.java\n@@ -150,6 +150,7 @@ protected MarkupFilterList initializeMarkupFilters(final Markup markup)\n \t\tfilters.add(new WicketLinkTagHandler());\n \t\tfilters.add(new AutoLabelTagHandler());\n \t\tfilters.add(new WicketNamespaceHandler(markupResourceStream));\n+\t\tfilters.add(new WicketMessageTagHandler(markupResourceStream));\n \n \t\t// Provided the wicket component requesting the markup is known ...\n \t\tif ((markupResourceStream != null) && (markupResourceStream.getResource() != null))\n@@ -157,8 +158,6 @@ protected MarkupFilterList initializeMarkupFilters(final Markup markup)\n \t\t\tfinal ContainerInfo containerInfo = markupResourceStream.getContainerInfo();\n \t\t\tif (containerInfo != null)\n \t\t\t{\n-\t\t\t\tfilters.add(new WicketMessageTagHandler(markupResourceStream));\n-\n \t\t\t\t// Pages require additional handlers\n \t\t\t\tif (Page.class.isAssignableFrom(containerInfo.getContainerClass()))\n \t\t\t\t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\nindex ab7e609..06a193a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n@@ -43,7 +43,6 @@\n  * enclosure is identified by the 'child' attribute value which must be equal to the relative child\r\n  * id path.\r\n  * \r\n- * @see EnclosureResolver\r\n  * @see InlineEnclosure\r\n  * \r\n  * @author Joonas Hamalainen\r\n@@ -96,7 +95,7 @@ protected MarkupElement onComponentTag(final ComponentTag tag) throws ParseExcep\n \t\t\t\t\t\t\ttag.toString(), tag.getPos());\r\n \t\t\t\t}\r\n \r\n-\t\t\t\t// if it doesn't have a wicket-id already, than assign one now.\r\n+\t\t\t\t// if it doesn't have a wicket-id already, then assign one now.\r\n \t\t\t\tif (Strings.isEmpty(tag.getId()))\r\n \t\t\t\t{\r\n \t\t\t\t\tif (Strings.isEmpty(htmlId))\r\n@@ -129,7 +128,7 @@ protected MarkupElement onComponentTag(final ComponentTag tag) throws ParseExcep\n \t\t// Are we within an enclosure?\r\n \t\telse if ((enclosures != null) && (enclosures.size() > 0))\r\n \t\t{\r\n-\t\t\t// In case the enclosure tag did not provide a child component id, than assign the\r\n+\t\t\t// In case the enclosure tag did not provide a child component id, then assign the\r\n \t\t\t// first ComponentTag's id found as the controlling child to the enclosure.\r\n \t\t\tif (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) &&\r\n \t\t\t\t!tag.isAutoComponentTag())\r\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/WicketMessageTagHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/WicketMessageTagHandler.java\nindex acda0a6..5044128 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/WicketMessageTagHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/WicketMessageTagHandler.java\n@@ -83,7 +83,7 @@ protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseExcep\n \t\tfinal String wicketMessageAttribute = tag.getAttributes().getString(\n \t\t\tgetWicketMessageAttrName());\n \n-\t\tif ((wicketMessageAttribute != null) && (wicketMessageAttribute.trim().length() > 0))\n+\t\tif (Strings.isEmpty(wicketMessageAttribute) == false)\n \t\t{\n \t\t\t// check if this tag is raw markup\n \t\t\tif (tag.getId() == null)\n@@ -165,7 +165,7 @@ public Component resolve(MarkupContainer container, MarkupStream markupStream, C\n \t\t// localize any raw markup that has wicket:message attrs\n \t\tif ((tag != null) && (tag.getId().startsWith(WICKET_MESSAGE_CONTAINER_ID)))\n \t\t{\n-\t\t\tComponent wc = null;\n+\t\t\tComponent wc;\n \t\t\tint autoIndex = container.getPage().getAutoIndex();\n \t\t\tString id = WICKET_MESSAGE_CONTAINER_ID + autoIndex;\n \n", "nb_test": 1332, "linesAdd": 4, "jira_id": "4520", "singleLine": false, "nb_skipped": 8, "commit": "b91154ea", "nb_failure": 2, "linesRem": 5}, {"files": 3, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testReattach(wicket.versioning.ReattachVersioningTest)"], "patch": "diff --git a/wicket/src/main/java/wicket/MarkupContainer.java b/wicket/src/main/java/wicket/MarkupContainer.java\nindex 3234316..395943c 100644\n--- a/wicket/src/main/java/wicket/MarkupContainer.java\n+++ b/wicket/src/main/java/wicket/MarkupContainer.java\n@@ -90,7 +90,7 @@\n  * @see MarkupStream\n  * @author Jonathan Locke\n  */\n-public abstract class MarkupContainer<T> extends Component<T> implements Iterable<Component>\n+public abstract class MarkupContainer<T> extends Component<T> implements Iterable<Component<?>>\n {\n \tprivate static final long serialVersionUID = 1L;\n \n@@ -124,7 +124,7 @@\n \t/**\n \t * @see wicket.Component#Component(MarkupContainer,String)\n \t */\n-\tpublic MarkupContainer(MarkupContainer parent, final String id)\n+\tpublic MarkupContainer(MarkupContainer<?> parent, final String id)\n \t{\n \t\tsuper(parent, id);\n \t}\n@@ -132,7 +132,7 @@ public MarkupContainer(MarkupContainer parent, final String id)\n \t/**\n \t * @see wicket.Component#Component(MarkupContainer,String, IModel)\n \t */\n-\tpublic MarkupContainer(MarkupContainer parent, final String id, IModel<T> model)\n+\tpublic MarkupContainer(MarkupContainer<?> parent, final String id, IModel<T> model)\n \t{\n \t\tsuper(parent, id, model);\n \t}\n@@ -166,7 +166,7 @@ public MarkupFragment getMarkupFragment(final String id)\n \t *             operation.\n \t * @return This\n \t */\n-\tfinal MarkupContainer add(final Component<?> child)\n+\tfinal MarkupContainer<?> add(final Component<?> child)\n \t{\n \t\tif (child == null)\n \t\t{\n@@ -180,8 +180,7 @@ final MarkupContainer add(final Component<?> child)\n \t\t}\n \n \t\t// Add to map\n-\t\taddedComponent(child);\n-\t\tComponent replaced = put(child);\n+\t\tComponent<?> replaced = put(child);\n \t\tchild.setFlag(FLAG_REMOVED_FROM_PARENT, false);\n \t\tif (replaced != null)\n \t\t{\n@@ -195,6 +194,8 @@ final MarkupContainer add(final Component<?> child)\n \t\t\tString replacedId = (replaced.hasMarkupIdMetaData()) ? replaced.getMarkupId() : null;\n \t\t\tchild.setMarkupIdMetaData(replacedId);\n \t\t}\n+\t\t// now call addedComponent (after removedComponent)\n+\t\taddedComponent(child);\n \n \t\treturn this;\n \t}\n@@ -229,7 +230,7 @@ final MarkupContainer add(final Component<?> child)\n \t *            True if all descendents should be considered\n \t * @return True if the component is contained in this container\n \t */\n-\tpublic final boolean contains(final Component component, final boolean recurse)\n+\tpublic final boolean contains(final Component<?> component, final boolean recurse)\n \t{\n \t\tif (component == null)\n \t\t{\n@@ -239,10 +240,10 @@ public final boolean contains(final Component component, final boolean recurse)\n \t\tif (recurse)\n \t\t{\n \t\t\t// Start at component and continue while we're not out of parents\n-\t\t\tfor (Component current = component; current != null;)\n+\t\t\tfor (Component<?> current = component; current != null;)\n \t\t\t{\n \t\t\t\t// Get parent\n-\t\t\t\tfinal MarkupContainer parent = current.getParent();\n+\t\t\t\tfinal MarkupContainer<?> parent = current.getParent();\n \n \t\t\t\t// If this container is the parent, then the component is\n \t\t\t\t// recursively contained by this container\n@@ -274,7 +275,7 @@ public final boolean contains(final Component component, final boolean recurse)\n \t * @return The component at the path\n \t */\n \t@Override\n-\tpublic final Component get(final String path)\n+\tpublic final Component<?> get(final String path)\n \t{\n \t\t// Reference to this container\n \t\tif (path == null || path.trim().equals(\"\"))\n@@ -286,7 +287,7 @@ public final Component get(final String path)\n \t\tfinal String id = Strings.firstPathComponent(path, Component.PATH_SEPARATOR);\n \n \t\t// Get child by id\n-\t\tComponent child = children_get(id);\n+\t\tComponent<?> child = children_get(id);\n \n \t\t// If the container is transparent, than ask its parent.\n \t\t// ParentResolver does something quite similar, but because of <head>,\n@@ -341,7 +342,7 @@ public String getMarkupType()\n \t *             Thrown if a child with the same id is replaced by the add\n \t *             operation.\n \t */\n-\tpublic void internalAdd(final Component child)\n+\tpublic void internalAdd(final Component<?> child)\n \t{\n \t\tif (log.isDebugEnabled())\n \t\t{\n@@ -372,7 +373,7 @@ public void internalAttach()\n \t\t\tfor (int i = 0; i < size; i++)\n \t\t\t{\n \t\t\t\t// Get next child\n-\t\t\t\tfinal Component child = children_get(i);\n+\t\t\t\tfinal Component<?> child = children_get(i);\n \n \t\t\t\t// Ignore feedback as that was done in Page\n \t\t\t\tif (!(child instanceof IFeedback))\n@@ -409,7 +410,7 @@ public void internalDetach()\n \t\tsuper.internalDetach();\n \n \t\t// Loop through child components\n-\t\tfor (Component child : this)\n+\t\tfor (Component<?> child : this)\n \t\t{\n \t\t\t// Call end request on the child\n \t\t\tchild.internalDetach();\n@@ -420,9 +421,9 @@ public void internalDetach()\n \t * @return Iterator that iterates through children in the order they were\n \t *         added\n \t */\n-\tpublic final Iterator<Component> iterator()\n+\tpublic final Iterator<Component<?>> iterator()\n \t{\n-\t\treturn new Iterator<Component>()\n+\t\treturn new Iterator<Component<?>>()\n \t\t{\n \t\t\tint index = 0;\n \n@@ -431,7 +432,7 @@ public boolean hasNext()\n \t\t\t\treturn index < children_size();\n \t\t\t}\n \n-\t\t\tpublic Component next()\n+\t\t\tpublic Component<?> next()\n \t\t\t{\n \t\t\t\treturn children_get(index++);\n \t\t\t}\n@@ -449,9 +450,9 @@ public void remove()\n \t * @return Iterator that iterates over children in the order specified by\n \t *         comparator\n \t */\n-\tpublic final Iterator<Component> iterator(Comparator<Component> comparator)\n+\tpublic final Iterator<Component<?>> iterator(Comparator<Component<?>> comparator)\n \t{\n-\t\tfinal List<Component> sorted;\n+\t\tfinal List<Component<?>> sorted;\n \t\tif (children == null)\n \t\t{\n \t\t\tsorted = Collections.emptyList();\n@@ -460,12 +461,12 @@ public void remove()\n \t\t{\n \t\t\tif (children instanceof Component)\n \t\t\t{\n-\t\t\t\tsorted = new ArrayList<Component>(1);\n-\t\t\t\tsorted.add((Component)children);\n+\t\t\t\tsorted = new ArrayList<Component<?>>(1);\n+\t\t\t\tsorted.add((Component<?>)children);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tsorted = Arrays.asList((Component[])children);\n+\t\t\t\tsorted = Arrays.asList((Component<?>[])children);\n \t\t\t}\n \t\t}\n \t\tCollections.sort(sorted, comparator);\n@@ -476,7 +477,7 @@ public void remove()\n \t * @param component\n \t *            Component to remove from this container\n \t */\n-\tpublic void remove(final Component component)\n+\tpublic void remove(final Component<?> component)\n \t{\n \t\tif (component == null)\n \t\t{\n@@ -503,7 +504,7 @@ public final void remove(final String id)\n \t\t\tthrow new IllegalArgumentException(\"argument id may not be null\");\n \t\t}\n \n-\t\tfinal Component component = get(id);\n+\t\tfinal Component<?> component = get(id);\n \t\tif (component != null)\n \t\t{\n \t\t\tremove(component);\n@@ -685,7 +686,7 @@ public String toString(final boolean detailed)\n \t\t\t\tfor (int i = 0; i < size; i++)\n \t\t\t\t{\n \t\t\t\t\t// Get next child\n-\t\t\t\t\tfinal Component child = children_get(i);\n+\t\t\t\t\tfinal Component<?> child = children_get(i);\n \t\t\t\t\tif (i != 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tbuffer.append(' ');\n@@ -709,7 +710,7 @@ public String toString(final boolean detailed)\n \t * @return The return value from a visitor which halted the traversal, or\n \t *         null if the entire traversal occurred\n \t */\n-\tpublic final Object visitChildren(final Class clazz, final IVisitor visitor)\n+\tpublic final Object visitChildren(final Class<?> clazz, final IVisitor visitor)\n \t{\n \t\tif (visitor == null)\n \t\t{\n@@ -720,7 +721,7 @@ public final Object visitChildren(final Class clazz, final IVisitor visitor)\n \t\tfor (int i = 0; i < children_size(); i++)\n \t\t{\n \t\t\t// Get next child component\n-\t\t\tfinal Component child = children_get(i);\n+\t\t\tfinal Component<?> child = children_get(i);\n \t\t\tObject value = null;\n \n \t\t\t// Is the child of the correct class (or was no class specified)?\n@@ -780,7 +781,7 @@ public final Object visitChildren(final IVisitor visitor)\n \tprotected final MarkupStream findMarkupStream()\n \t{\n \t\t// Start here\n-\t\tMarkupContainer c = this;\n+\t\tMarkupContainer<?> c = this;\n \n \t\t// Walk up hierarchy until markup found\n \t\twhile (c.getMarkupStream() == null)\n@@ -1025,7 +1026,7 @@ private final void addedComponent(final Component component)\n \t * @param child\n \t *            Child to add\n \t */\n-\tprivate final void children_add(final Component child)\n+\tprivate final void children_add(final Component<?> child)\n \t{\n \t\tif (this.children == null)\n \t\t{\n@@ -1037,7 +1038,7 @@ private final void children_add(final Component child)\n \t\t\tfinal int size = children_size();\n \n \t\t\t// Create array that holds size + 1 elements\n-\t\t\tfinal Component[] children = new Component[size + 1];\n+\t\t\tfinal Component<?>[] children = new Component[size + 1];\n \n \t\t\t// Loop through existing children copying them\n \t\t\tfor (int i = 0; i < size; i++)\n@@ -1059,7 +1060,7 @@ private final void children_add(final Component child)\n \t\t{\n \t\t\tif (children instanceof Component)\n \t\t\t{\n-\t\t\t\treturn (Component)children;\n+\t\t\t\treturn (Component<?>)children;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n@@ -1072,11 +1073,11 @@ private final void children_add(final Component child)\n \t\t}\n \t}\n \n-\tprivate final Component children_get(final String id)\n+\tprivate final Component<?> children_get(final String id)\n \t{\n \t\tif (children instanceof Component)\n \t\t{\n-\t\t\tfinal Component component = (Component)children;\n+\t\t\tfinal Component<?> component = (Component<?>)children;\n \t\t\tif (component.getId().equals(id))\n \t\t\t{\n \t\t\t\treturn component;\n@@ -1086,8 +1087,8 @@ private final Component children_get(final String id)\n \t\t{\n \t\t\tif (children != null)\n \t\t\t{\n-\t\t\t\tfinal Component[] components = (Component[])children;\n-\t\t\t\tfor (Component element : components)\n+\t\t\t\tfinal Component<?>[] components = (Component[])children;\n+\t\t\t\tfor (Component<?> element : components)\n \t\t\t\t{\n \t\t\t\t\tif (element.getId().equals(id))\n \t\t\t\t\t{\n@@ -1099,11 +1100,49 @@ private final Component children_get(final String id)\n \t\treturn null;\n \t}\n \n+\t/**\n+\t * Will search for this specific child instance in the current\n+\t * children. So it will do a identity check, it will not look if the\n+\t * id is already present in the children. Use indexOf(String) for that. \n+\t * @param child\n+\t * @return The index of this child.\n+\t */\n \tprivate final int children_indexOf(Component<?> child)\n \t{\n \t\tif (children instanceof Component)\n \t\t{\n-\t\t\tif (((Component)children).getId().equals(child.getId()))\n+\t\t\tif (children == child)\n+\t\t\t{\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tif (children != null)\n+\t\t\t{\n+\t\t\t\tfinal Component<?>[] components = (Component[])children;\n+\t\t\t\tfor (int i = 0; i < components.length; i++)\n+\t\t\t\t{\n+\t\t\t\t\tif (components[i] == child)\n+\t\t\t\t\t{\n+\t\t\t\t\t\treturn i;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn -1;\n+\t}\n+\n+\t/**\n+\t * Will search for the id if it is found in the current children.\n+\t * @param id The id to search for.\n+\t * @return The index of this child.\n+\t */\n+\tprivate final int children_indexOf(String id)\n+\t{\n+\t\tif (children instanceof Component)\n+\t\t{\n+\t\t\tif (((Component<?>)children).getId().equals(id))\n \t\t\t{\n \t\t\t\treturn 0;\n \t\t\t}\n@@ -1112,10 +1151,10 @@ private final int children_indexOf(Component<?> child)\n \t\t{\n \t\t\tif (children != null)\n \t\t\t{\n-\t\t\t\tfinal Component[] components = (Component[])children;\n+\t\t\t\tfinal Component<?>[] components = (Component[])children;\n \t\t\t\tfor (int i = 0; i < components.length; i++)\n \t\t\t\t{\n-\t\t\t\t\tif (components[i].getId().equals(child.getId()))\n+\t\t\t\t\tif (components[i].getId().equals(id))\n \t\t\t\t\t{\n \t\t\t\t\t\treturn i;\n \t\t\t\t\t}\n@@ -1125,7 +1164,7 @@ private final int children_indexOf(Component<?> child)\n \t\treturn -1;\n \t}\n \n-\tprivate final Component children_remove(Component<?> component)\n+\tprivate final Component<?> children_remove(Component<?> component)\n \t{\n \t\tint index = children_indexOf(component);\n \t\tif (index != -1)\n@@ -1135,13 +1174,13 @@ private final Component children_remove(Component<?> component)\n \t\treturn null;\n \t}\n \n-\tprivate final Component children_remove(int index)\n+\tprivate final Component<?> children_remove(int index)\n \t{\n \t\tif (children instanceof Component)\n \t\t{\n \t\t\tif (index == 0)\n \t\t\t{\n-\t\t\t\tfinal Component removed = (Component)children;\n+\t\t\t\tfinal Component<?> removed = (Component<?>)children;\n \t\t\t\tthis.children = null;\n \t\t\t\treturn removed;\n \t\t\t}\n@@ -1152,8 +1191,8 @@ private final Component children_remove(int index)\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tComponent[] c = ((Component[])children);\n-\t\t\tfinal Component removed = c[index];\n+\t\t\tComponent<?>[] c = ((Component[])children);\n+\t\t\tfinal Component<?> removed = c[index];\n \t\t\tif (c.length == 2)\n \t\t\t{\n \t\t\t\tif (index == 0)\n@@ -1171,7 +1210,7 @@ else if (index == 1)\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tComponent[] newChildren = new Component[c.length - 1];\n+\t\t\t\tComponent<?>[] newChildren = new Component[c.length - 1];\n \t\t\t\tint j = 0;\n \t\t\t\tfor (int i = 0; i < c.length; i++)\n \t\t\t\t{\n@@ -1186,19 +1225,19 @@ else if (index == 1)\n \t\t}\n \t}\n \n-\tprivate final Component children_set(int index, Component child)\n+\tprivate final Component<?> children_set(int index, Component<?> child)\n \t{\n-\t\tfinal Component replaced;\n+\t\tfinal Component<?> replaced;\n \t\tif (index < children_size())\n \t\t{\n \t\t\tif (children == null || children instanceof Component)\n \t\t\t{\n-\t\t\t\treplaced = (Component)children;\n+\t\t\t\treplaced = (Component<?>)children;\n \t\t\t\tchildren = child;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tfinal Component[] children = (Component[])this.children;\n+\t\t\t\tfinal Component<?>[] children = (Component[])this.children;\n \t\t\t\treplaced = children[index];\n \t\t\t\tchildren[index] = child;\n \t\t\t}\n@@ -1234,9 +1273,12 @@ private final int children_size()\n \t *            The child to put into the map\n \t * @return Any component that was replaced\n \t */\n-\tprivate final Component put(final Component<?> child)\n+\tprivate final Component<?> put(final Component<?> child)\n \t{\n-\t\tint index = children_indexOf(child);\n+\t\t// search for the child by id. So that it will\n+\t\t// find the right index for the id instead of looking\n+\t\t// if the component itself is already children.\n+\t\tint index = children_indexOf(child.getId());\n \t\tif (index == -1)\n \t\t{\n \t\t\tchildren_add(child);\n@@ -1410,7 +1452,7 @@ public void renderHead(final IHeaderResponse response)\n \t\t{\n \t\t\tsuper.renderHead(response);\n \n-\t\t\tfor (Component child : this)\n+\t\t\tfor (Component<?> child : this)\n \t\t\t{\n \t\t\t\tchild.renderHead(response);\n \t\t\t}\ndiff --git a/wicket/src/main/java/wicket/markup/repeater/RefreshingView.java b/wicket/src/main/java/wicket/markup/repeater/RefreshingView.java\nindex 87d61fe..29fe8c4 100644\n--- a/wicket/src/main/java/wicket/markup/repeater/RefreshingView.java\n+++ b/wicket/src/main/java/wicket/markup/repeater/RefreshingView.java\n@@ -170,7 +170,7 @@ protected void internalOnAttach()\n \t */\r\n \tpublic Iterator<Item<T>> getItems()\r\n \t{\r\n-\t\tfinal Iterator<Component> iterator = iterator();\r\n+\t\tfinal Iterator<Component<?>> iterator = iterator();\r\n \t\treturn new Iterator<Item<T>>()\r\n \t\t{\r\n \t\t\tpublic boolean hasNext()\r\ndiff --git a/wicket/src/main/java/wicket/markup/repeater/data/GridView.java b/wicket/src/main/java/wicket/markup/repeater/data/GridView.java\nindex 1f306fc..d1984e8 100644\n--- a/wicket/src/main/java/wicket/markup/repeater/data/GridView.java\n+++ b/wicket/src/main/java/wicket/markup/repeater/data/GridView.java\n@@ -303,7 +303,7 @@ protected void addItems(Iterator<Item<T>> items)\n \t */\r\n \tprivate static class ItemsIterator<T> implements Iterator<Item<T>>\r\n \t{\r\n-\t\tprivate Iterator<Component> rows;\r\n+\t\tprivate Iterator<Component<?>> rows;\r\n \t\tprivate Iterator<Item<T>> cells;\r\n \r\n \t\tprivate Item<T> next;\r\n@@ -312,7 +312,7 @@ protected void addItems(Iterator<Item<T>> items)\n \t\t * @param rows\r\n \t\t *            iterator over child row views\r\n \t\t */\r\n-\t\tpublic ItemsIterator(Iterator<Component> rows)\r\n+\t\tpublic ItemsIterator(Iterator<Component<?>> rows)\r\n \t\t{\r\n \t\t\tthis.rows = rows;\r\n \t\t\tfindNext();\r\n", "nb_test": 384, "linesAdd": 80, "jira_id": "172", "singleLine": false, "nb_skipped": 0, "commit": "99e22ce4", "nb_failure": 1, "linesRem": 54}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["addDuplicateCookie(org.apache.wicket.protocol.http.mock.MockHttpServletResponseTest): expected:<1> but was:<2>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\nindex eb8262a..01581ef 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\n@@ -27,6 +27,7 @@\n import java.util.Collections;\n import java.util.Date;\n import java.util.GregorianCalendar;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Locale;\n import java.util.Set;\n@@ -102,7 +103,18 @@ public MockHttpServletResponse(MockHttpServletRequest servletRequest)\n \tpublic void addCookie(final Cookie cookie)\n \t{\n \t\t// remove any potential duplicates\n-\t\tcookies.remove(cookie);\n+\t\t// see http://www.ietf.org/rfc/rfc2109.txt, p.4.3.3\n+\t\tIterator<Cookie> iterator = cookies.iterator();\n+\t\twhile (iterator.hasNext())\n+\t\t{\n+\t\t\tCookie old = iterator.next();\n+\t\t\tif (cookie.getName().equals(old.getName()) &&\n+\t\t\t\t((cookie.getPath() == null && old.getPath() == null) || (cookie.getPath().equals(old.getPath()))) &&\n+\t\t\t\t((cookie.getDomain() == null && old.getDomain() == null) || (cookie.getDomain().equals(old.getDomain()))))\n+\t\t\t{\n+\t\t\t\titerator.remove();\n+\t\t\t}\n+\t\t}\n \t\tcookies.add(cookie);\n \t}\n \n", "nb_test": 1260, "linesAdd": 12, "jira_id": "4292", "singleLine": false, "nb_skipped": 3, "commit": "9cb617ae", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["disabledCheckGroup(org.apache.wicket.markup.html.form.CheckGroupTest): org/apache/wicket/markup/html/form/CheckGroupDisabledTestPage_expected.html expected:<... disabled=\"disabled\"[>check1</input>(..)", "rendering(org.apache.wicket.markup.html.form.CheckGroupTest): org/apache/wicket/markup/html/form/CheckGroupTestPage1_expected.html expected:<...roup\" value=\"check1\"[>check1</input>(..)", "disabledRadioGroup(org.apache.wicket.markup.html.form.RadioGroupTest): org/apache/wicket/markup/html/form/RadioGroupDisabledTestPage_expected.html expected:<... disabled=\"disabled\"[>radio1</input>(..)", "radioGroupTestPage3(org.apache.wicket.markup.html.form.RadioGroupTest): org/apache/wicket/markup/html/form/RadioGroupTestPage3_expected.html expected:<...1\" checked=\"checked\"[>Yes(..)", "rendering(org.apache.wicket.markup.html.form.RadioGroupTest): org/apache/wicket/markup/html/form/RadioGroupTestPage1_expected.html expected:<...roup\" value=\"radio1\"[>radio1</input>(..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Check.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Check.java\nindex 5d09f6f..bc5c77b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Check.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Check.java\n@@ -219,19 +219,6 @@ else if (collection.contains(getDefaultModelObject()))\n \t\t\ttag.put(ATTR_DISABLED, ATTR_DISABLED);\n \t\t}\n \n-\t\t// put group id into the class so we can easily identify all radios belonging to the group\n-\t\tfinal String marker = \"wicket-\" + getGroup().getMarkupId();\n-\t\tString clazz = tag.getAttribute(\"class\");\n-\t\tif (Strings.isEmpty(clazz))\n-\t\t{\n-\t\t\tclazz = marker;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tclazz = clazz + \" \" + marker;\n-\t\t}\n-\t\ttag.put(\"class\", clazz);\n-\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Radio.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Radio.java\nindex d1bebbc..282b711 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Radio.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Radio.java\n@@ -23,7 +23,6 @@\n import org.apache.wicket.markup.html.WebMarkupContainer;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n-import org.apache.wicket.util.string.Strings;\n \n /**\n  * Component representing a single radio choice in a org.apache.wicket.markup.html.form.RadioGroup.\n@@ -205,19 +204,6 @@ else if (group.getModelComparator().compare(group, getDefaultModelObject()))\n \t\t\ttag.put(ATTR_DISABLED, ATTR_DISABLED);\n \t\t}\n \n-\t\t// put group id into the class so we can easily identify all radios belonging to the group\n-\t\tfinal String marker = \"wicket-\" + getGroup().getMarkupId();\n-\t\tString clazz = tag.getAttribute(\"class\");\n-\t\tif (Strings.isEmpty(clazz))\n-\t\t{\n-\t\t\tclazz = marker;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tclazz = clazz + \" \" + marker;\n-\t\t}\n-\t\ttag.put(\"class\", clazz);\n-\n \t}\n \n \t/**\n", "nb_test": 1564, "linesAdd": 0, "jira_id": "5476", "singleLine": false, "nb_skipped": 2, "commit": "813d8bee", "nb_failure": 5, "linesRem": 25}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["detachEvenNotAttached(org.apache.wicket.model.StringResourceModelTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java b/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\nindex 95b37f8..35ef7bb 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\n@@ -590,13 +590,10 @@ protected final String load()\n \t\treturn getString();\n \t}\n \n-\t/**\n-\t * @see org.apache.wicket.model.IDetachable#detach()\n-\t */\n \t@Override\n-\tprotected final void onDetach()\n+\tpublic final void detach()\n \t{\n-\t\tsuper.onDetach();\n+\t\tsuper.detach();\n \n \t\t// detach any model\n \t\tif (model != null)\n", "nb_test": 1471, "linesAdd": 2, "jira_id": "5176", "singleLine": false, "nb_skipped": 4, "commit": "34634266", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTableHeaderFooterBody(org.apache.wicket.extensions.markup.html.repeater.data.table.DataTableTest)"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\nindex caa2f9e..f2e4618 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\n@@ -204,7 +204,15 @@ protected String getCssClass()\n \t */\n \tprotected WebMarkupContainer newBodyContainer(final String id)\n \t{\n-\t\treturn new WebMarkupContainer(id);\n+\t\treturn new WebMarkupContainer(id)\n+\t\t{\n+\t\t\t@Override\n+\t\t\tprotected void onConfigure()\n+\t\t\t{\n+\t\t\t\tsuper.onConfigure();\n+\t\t\t\tsetVisible(getRowCount() > 0);\n+\t\t\t}\n+\t\t};\n \t}\n \n \t/**\n", "nb_test": 18, "linesAdd": 9, "jira_id": "4153", "singleLine": false, "nb_skipped": 0, "commit": "2737d7c7", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["CollectionFormComponentTest.getModelCollectionIsNullInCaseOfNoConvertedInput:231 \u00bb NullPointer", "CollectionFormComponentTest.getUnmodifiableInCaseOfNoConvertedInput:208 \u00bb NullPointer"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\nindex 88c5350..c0f4f10 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n@@ -1613,6 +1613,9 @@ public final void updateAutoLabels(AjaxRequestTarget target)\n \tpublic static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent)\n \t{\n \t\tCollection<S> convertedInput = formComponent.getConvertedInput();\n+\t\tif (convertedInput == null) {\n+\t\t\tconvertedInput = Collections.emptyList();\n+\t\t}\n \n \t\tCollection<S> collection = formComponent.getModelObject();\n \t\tif (collection == null)\n@@ -1629,10 +1632,7 @@ public final void updateAutoLabels(AjaxRequestTarget target)\n \t\t\ttry\n \t\t\t{\n \t\t\t\tcollection.clear();\n-\t\t\t\tif (convertedInput != null)\n-\t\t\t\t{\n \t\t\t\tcollection.addAll(convertedInput);\n-\t\t\t\t}\n \t\t\t\tmodified = true;\n \t\t\t}\n \t\t\tcatch (UnsupportedOperationException unmodifiable)\n", "nb_test": 1742, "linesAdd": 3, "jira_id": "5881", "singleLine": false, "nb_skipped": 1, "commit": "8c83c5c5", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["detectionGroups(org.apache.wicket.protocol.http.request.UserAgentTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/request/UserAgent.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/request/UserAgent.java\nindex 4c663d3..b6c028a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/request/UserAgent.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/request/UserAgent.java\n@@ -96,16 +96,20 @@ public boolean matches(String userAgent)\n \n \t\tfor (List<String> detectionGroup : detectionStrings)\n \t\t{\n+\t\t\tboolean groupPassed = true;\n \t\t\tfor (String detectionString : detectionGroup)\n \t\t\t{\n \t\t\t\tif (!userAgent.contains(detectionString))\n \t\t\t\t{\n-\t\t\t\t\treturn false;\n+\t\t\t\t\tgroupPassed = false;\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\n+\t\t\tif (groupPassed)\n+\t\t\t{\n \t\t\t\treturn true;\n \t\t\t}\n+\t\t}\n \n \t\treturn false;\n \t}\n", "nb_test": 1176, "linesAdd": 6, "jira_id": "3713", "singleLine": false, "nb_skipped": 0, "commit": "e1168a57", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 2, "classification": {"singleLine": true}, "failing_tests": ["sendRedirect(org.apache.wicket.protocol.http.servlet.ServletWebResponseTest)", "sendRedirectAjax(org.apache.wicket.protocol.http.servlet.ServletWebResponseTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\nindex a1d0312..c5bc8c7 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n@@ -241,7 +241,6 @@ public void sendRedirect(String url)\n \t\ttry\n \t\t{\n \t\t\tredirect = true;\n-\t\t\turl = getAbsoluteURL(url);\n \t\t\turl = encodeRedirectURL(url);\n \n \t\t\t// wicket redirects should never be cached\n", "nb_test": 1170, "linesAdd": 0, "jira_id": "3885", "singleLine": true, "nb_skipped": 2, "commit": "beb9086d", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["rawInputKeepsSelectionOnError(org.apache.wicket.extensions.markup.html.form.select.SelectTest)"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/select/Select.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/select/Select.java\nindex 56fec8d..8284d59 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/select/Select.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/select/Select.java\n@@ -214,7 +214,7 @@ public void updateModel()\n \t * Checks if the specified option is selected based on raw input\n \t * \n \t * @param option\n-\t * @return true} iff the option is selected\n+\t * @return {@code true} if the option is selected, {@code false} otherwise\n \t */\n \tboolean isSelected(final SelectOption<?> option)\n \t{\n@@ -223,12 +223,13 @@ boolean isSelected(final SelectOption<?> option)\n \t\t// if the raw input is specified use that, otherwise use model\n \t\tif (hasRawInput())\n \t\t{\n-\t\t\tString[] paths = getInputAsArray();\n-\t\t\tif ((paths != null) && (paths.length > 0))\n+\t\t\tString[] values = getInputAsArray();\n+\t\t\tif (values != null && values.length > 0)\n \t\t\t{\n-\t\t\t\tfor (String path : paths)\n+\t\t\t\tfor (int i = 0; i < values.length; i++)\n \t\t\t\t{\n-\t\t\t\t\tif (path.equals(option.getPath()))\n+\t\t\t\t\tString value = values[i];\n+\t\t\t\t\tif (value.equals(option.getValue()))\n \t\t\t\t\t{\n \t\t\t\t\t\treturn true;\n \t\t\t\t\t}\n", "nb_test": 23, "linesAdd": 5, "jira_id": "4276", "singleLine": false, "nb_skipped": 0, "commit": "32c76c4a", "nb_failure": 1, "rtElixir": true, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 2, "classification": {"singleLine": true}, "failing_tests": ["testWithQueryParameters(org.apache.wicket.request.mapper.HomePageMapperTest)", "testNoSegmentsNoQueryParameters(org.apache.wicket.request.mapper.HomePageMapperTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/request/mapper/HomePageMapper.java b/wicket/src/main/java/org/apache/wicket/request/mapper/HomePageMapper.java\nindex e4f6c8b..b44207d 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/mapper/HomePageMapper.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/mapper/HomePageMapper.java\n@@ -87,6 +87,7 @@ public IRequestHandler mapRequest(Request request)\n \t\t\t{\n \t\t\t\tpageProvider = new PageProvider(homePageClass);\n \t\t\t}\n+\t\t\tpageProvider.setPageSource(getContext());\n \n \t\t\treturn new RenderPageRequestHandler(pageProvider);\n \t\t}\n", "nb_test": 963, "linesAdd": 1, "jira_id": "3065", "singleLine": true, "nb_skipped": 1, "commit": "b293b75c", "nb_failure": 0, "linesRem": 0}, {"files": 4, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testRenderPage11(org.apache.wicket.markup.html.internal.EnclosureTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\nindex c2d8431..a7a1964 100644\n--- a/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -34,6 +34,7 @@\n import org.apache.wicket.markup.MarkupType;\n import org.apache.wicket.markup.RawMarkup;\n import org.apache.wicket.markup.WicketTag;\n+import org.apache.wicket.markup.html.border.Border;\n import org.apache.wicket.markup.resolver.ComponentResolvers;\n import org.apache.wicket.model.IComponentInheritedModel;\n import org.apache.wicket.model.IModel;\n@@ -138,6 +139,24 @@ public MarkupContainer add(final Component... childs)\n \t\t\t\tthrow new IllegalArgumentException(\"argument child may not be null\");\n \t\t\t}\n \n+\t\t\tMarkupContainer parent = getParent();\n+\t\t\twhile (parent != null)\n+\t\t\t{\n+\t\t\t\tif (child == parent)\n+\t\t\t\t{\n+\t\t\t\t\tString msg = \"You can not add a component's parent as child to the component (loop): Component: \" +\n+\t\t\t\t\t\tthis.toString(false) + \"; parent == child: \" + parent.toString(false);\n+\t\t\t\t\tif (child instanceof Border.BorderBodyContainer)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tmsg += \". Please consider using Border.addToBorder(new \" +\n+\t\t\t\t\t\t\tthis.getClass().getSimpleName() + \"(\\\"\" + this.getId() +\n+\t\t\t\t\t\t\t\"\\\", ...) instead of add(...)\";\n+\t\t\t\t\t}\n+\t\t\t\t\tthrow new WicketRuntimeException(msg);\n+\t\t\t\t}\n+\t\t\t\tparent = parent.getParent();\n+\t\t\t}\n+\n \t\t\tcheckHierarchyChange(child);\n \n \t\t\tif (log.isDebugEnabled())\n@@ -955,10 +973,7 @@ private final void addedComponent(final Component child)\n \t\tif (page != null)\n \t\t{\n \t\t\tchild.initialize();\n-\t\t}\n \n-\t\tif (page != null)\n-\t\t{\n \t\t\t// Tell the page a component has been added\n \t\t\tpage.componentAdded(child);\n \t\t}\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java b/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\nindex 4398671..e2f0076 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n@@ -23,12 +23,14 @@\n import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.markup.MarkupException;\n import org.apache.wicket.markup.MarkupStream;\n-import org.apache.wicket.markup.html.TransparentWebMarkupContainer;\n+import org.apache.wicket.markup.html.WebMarkupContainer;\n import org.apache.wicket.markup.html.basic.EnclosureContainer;\n import org.apache.wicket.markup.html.form.Form;\n import org.apache.wicket.markup.html.form.FormComponent;\n import org.apache.wicket.markup.html.form.IFormSubmittingComponent;\n import org.apache.wicket.markup.parser.filter.EnclosureHandler;\n+import org.apache.wicket.markup.resolver.ComponentResolvers;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.apache.wicket.request.Response;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.response.NullResponse;\n@@ -82,7 +84,7 @@\n  * @author Juergen Donnerstag\n  * @since 1.3\n  */\n-public class Enclosure extends TransparentWebMarkupContainer\n+public class Enclosure extends WebMarkupContainer implements IComponentResolver\n {\n \tprivate static final long serialVersionUID = 1L;\n \n@@ -114,6 +116,25 @@ public Enclosure(final String id, final CharSequence childId)\n \t}\n \n \t/**\n+\t * @see org.apache.wicket.Component#onInitialize()\n+\t */\n+\t@Override\n+\tprotected void onInitialize()\n+\t{\n+\t\tsuper.onInitialize();\n+\n+\t\t// enclosure's parent container\n+\t\tMarkupContainer container = getEnclosureParent();\n+\n+\t\t// clear the cache\n+\t\tchildComponent = null;\n+\n+\t\t// get Child Component. If not \"added\", ask a resolver to find it.\n+\t\tchildComponent = getChildComponent(new MarkupStream(getMarkup()), container);\n+\t\tcheckChildComponent(childComponent);\n+\t}\n+\n+\t/**\n \t * Get the real parent container\n \t * \n \t * @return enclosure's parent markup container\n@@ -121,7 +142,7 @@ public Enclosure(final String id, final CharSequence childId)\n \tprivate MarkupContainer getEnclosureParent()\n \t{\n \t\tMarkupContainer parent = getParent();\n-\t\twhile (parent.isAuto())\n+\t\twhile ((parent != null) && parent.isAuto())\n \t\t{\n \t\t\tparent = parent.getParent();\n \t\t}\n@@ -139,16 +160,11 @@ private MarkupContainer getEnclosureParent()\n \t *      org.apache.wicket.markup.ComponentTag)\n \t */\n \t@Override\n-\tprotected void onComponentTagBody(MarkupStream markupStream, ComponentTag openTag)\n+\tprotected void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)\n \t{\n-\t\t// enclosure's parent container\n-\t\tMarkupContainer container = getEnclosureParent();\n-\n-\t\tComponent controller = container.get(childId.toString());\n-\t\tcheckChildComponent(controller);\n-\n+\t\t// TODO this is where I wish we had something like \"enum(TAG, BODY, NONE, ALL) isVisible()\"\n \t\t// set the enclosure visibility\n-\t\tboolean visible = controller.determineVisibility();\n+\t\tboolean visible = childComponent.determineVisibility();\n \n \t\t// We want to know which components are rendered inside the enclosure\n \t\tfinal IComponentOnAfterRenderListener listener = new EnclosureListener(this);\n@@ -186,6 +202,59 @@ protected void onComponentTagBody(MarkupStream markupStream, ComponentTag openTa\n \t}\n \n \t/**\n+\t * @param markupStream\n+\t * @param container\n+\t * @return The component associated with the\n+\t */\n+\tprivate Component getChildComponent(final MarkupStream markupStream, MarkupContainer container)\n+\t{\n+\t\tComponent controller = container.get(childId.toString());\n+\t\tif (controller == null)\n+\t\t{\n+\t\t\tint orgIndex = markupStream.getCurrentIndex();\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\twhile (markupStream.hasMore())\n+\t\t\t\t{\n+\t\t\t\t\tmarkupStream.next();\n+\t\t\t\t\tif (markupStream.skipUntil(ComponentTag.class))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tComponentTag tag = markupStream.getTag();\n+\t\t\t\t\t\tif ((tag != null) && (tag.isOpen() || tag.isOpenClose()))\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tif (childId.equals(tag.getId()))\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tcontroller = ComponentResolvers.resolveByComponentHierarchy(\n+\t\t\t\t\t\t\t\t\tcontainer, markupStream, tag);\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tmarkupStream.setCurrentIndex(orgIndex);\n+\t\t\t}\n+\t\t}\n+\t\treturn controller;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @see org.apache.wicket.markup.resolver.IComponentResolver#resolve(org.apache.wicket.MarkupContainer,\n+\t *      org.apache.wicket.markup.MarkupStream, org.apache.wicket.markup.ComponentTag)\n+\t */\n+\tpublic Component resolve(MarkupContainer container, MarkupStream markupStream, ComponentTag tag)\n+\t{\n+\t\tif (childId.equals(tag.getId()))\n+\t\t{\n+\t\t\treturn childComponent;\n+\t\t}\n+\t\treturn getEnclosureParent().get(tag.getId());\n+\t}\n+\n+\t/**\n \t * \n \t * @param controller\n \t */\n@@ -218,6 +287,7 @@ private EnclosureListener(final Enclosure enclosure)\n \t\t/**\n \t\t * @see org.apache.wicket.application.IComponentOnBeforeRenderListener#onBeforeRender(org.apache.wicket.Component)\n \t\t */\n+\t\t@SuppressWarnings(\"unchecked\")\n \t\tpublic void onAfterRender(final Component component)\n \t\t{\n \t\t\tif (log.isWarnEnabled())\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/resolver/ComponentResolvers.java b/wicket/src/main/java/org/apache/wicket/markup/resolver/ComponentResolvers.java\nindex d94dc48..daf1ab6 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/resolver/ComponentResolvers.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/resolver/ComponentResolvers.java\n@@ -50,34 +50,67 @@ public static Component resolve(final MarkupContainer container,\n \t\tfinal MarkupStream markupStream, final ComponentTag tag)\r\n \t{\r\n \t\t// try to resolve using component hierarchy\r\n+\t\tComponent component = resolveByComponentHierarchy(container, markupStream, tag);\r\n \r\n-\t\tComponent cursor = container;\r\n-\t\twhile (cursor != null)\r\n+\t\tif (component == null)\r\n \t\t{\r\n-\t\t\tif (cursor instanceof IComponentResolver)\r\n+\t\t\t// fallback to application-level resolvers\r\n+\t\t\tcomponent = resolveByApplication(container, markupStream, tag);\r\n+\t\t}\r\n+\r\n+\t\treturn component;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Attempts to resolve a component via application registered resolvers.\r\n+\t * \r\n+\t * @param container\r\n+\t * @param markupStream\r\n+\t * @param tag\r\n+\t * @return Null, if no component was found\r\n+\t */\r\n+\tpublic static Component resolveByApplication(final MarkupContainer container,\r\n+\t\tfinal MarkupStream markupStream, final ComponentTag tag)\r\n+\t{\r\n+\t\tfor (final IComponentResolver resolver : Application.get()\r\n+\t\t\t.getPageSettings()\r\n+\t\t\t.getComponentResolvers())\r\n \t\t{\r\n-\t\t\t\tIComponentResolver resolver = (IComponentResolver)cursor;\r\n \t\t\tComponent component = resolver.resolve(container, markupStream, tag);\r\n \t\t\tif (component != null)\r\n \t\t\t{\r\n \t\t\t\treturn component;\r\n \t\t\t}\r\n \t\t}\r\n-\t\t\tcursor = cursor.getParent();\r\n-\t\t}\r\n \r\n-\t\t// fallback to application-level resolvers\r\n+\t\treturn null;\r\n+\t}\r\n \r\n-\t\tfor (final IComponentResolver resolver : Application.get()\r\n-\t\t\t.getPageSettings()\r\n-\t\t\t.getComponentResolvers())\r\n+\t/**\r\n+\t * Attempts to resolve a component via the component hierarchy using resolvers.\r\n+\t * \r\n+\t * @param container\r\n+\t * @param markupStream\r\n+\t * @param tag\r\n+\t * @return Null, if no component was found\r\n+\t */\r\n+\tpublic static Component resolveByComponentHierarchy(final MarkupContainer container,\r\n+\t\tfinal MarkupStream markupStream, final ComponentTag tag)\r\n+\t{\r\n+\t\tComponent cursor = container;\r\n+\t\twhile (cursor != null)\r\n \t\t{\r\n+\t\t\tif (cursor instanceof IComponentResolver)\r\n+\t\t\t{\r\n+\t\t\t\tIComponentResolver resolver = (IComponentResolver)cursor;\r\n \t\t\t\tComponent component = resolver.resolve(container, markupStream, tag);\r\n \t\t\t\tif (component != null)\r\n \t\t\t\t{\r\n \t\t\t\t\treturn component;\r\n \t\t\t\t}\r\n \t\t\t}\r\n+\t\t\tcursor = cursor.getParent();\r\n+\t\t}\r\n \r\n \t\treturn null;\r\n \t}\r\ndiff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java b/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\nindex 983dc58..7bb4948 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n@@ -493,4 +493,13 @@ public void write(byte[] b, int off, int len) throws IOException\n \t\t\tresponse.write(stream.toByteArray());\n \t\t}\n \t}\n+\n+\t/**\n+\t * @see java.lang.Object#toString()\n+\t */\n+\t@Override\n+\tpublic String toString()\n+\t{\n+\t\treturn charSequenceAction.builder.toString();\n+\t}\n }\n", "nb_test": 887, "linesAdd": 115, "jira_id": "2882", "singleLine": false, "nb_skipped": 1, "commit": "ebe56869", "nb_failure": 0, "linesRem": 22}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["parseQueryStringWithEqualsSignInParameterValue(org.apache.wicket.request.UrlTest): expected:<[a=b%3Dc, d=e%3Df]> but was:<[a=b, d=e]>"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 6aa6e25..5297857 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -337,15 +337,16 @@ public static Url parse(CharSequence _url, Charset charset)\n \t */\n \tprivate static QueryParameter parseQueryParameter(final String qp, final Charset charset)\n \t{\n-\t\tif (qp.indexOf('=') == -1)\n+\t\tint idxOfEquals = qp.indexOf('=');\n+\t\tif (idxOfEquals == -1)\n \t\t{\n \t\t\t// name => empty value\n \t\t\treturn new QueryParameter(decodeParameter(qp, charset), \"\");\n \t\t}\n \n-\t\tString parts[] = Strings.split(qp, '=');\n-\t\treturn new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1],\n-\t\t\tcharset));\n+\t\tString parameterName = qp.substring(0, idxOfEquals);\n+\t\tString parameterValue = qp.substring(idxOfEquals + 1);\n+\t\treturn new QueryParameter(decodeParameter(parameterName, charset), decodeParameter(parameterValue, charset));\n \t}\n \n \t/**\n", "nb_test": 96, "linesAdd": 5, "jira_id": "5157", "singleLine": false, "nb_skipped": 0, "commit": "961f2477", "nb_failure": 1, "linesRem": 4}, {"files": 3, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testCSSResourceReferenceRespectsMinifiedResourcesDetection(org.apache.wicket.request.resource.PackageResourceReferenceTest): Already minified resource should got its compress flag set to false", "testJavaScriptResourceReferenceRespectsMinifiedResourcesDetection(org.apache.wicket.request.resource.PackageResourceReferenceTest): Already minified resource should got its compress flag set to false"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/CssResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/CssResourceReference.java\nindex 55955d7..7d15d61 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/CssResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/CssResourceReference.java\n@@ -76,8 +76,10 @@ public CssResourceReference(Key key)\n \t@Override\n \tpublic CssPackageResource getResource()\n \t{\n-\t\treturn new CssPackageResource(getScope(), getName(), getLocale(), getStyle(),\n+        final CssPackageResource resource = new CssPackageResource(getScope(), getName(), getLocale(), getStyle(),\n                 getVariation());\n+        removeCompressFlagIfUnnecessary(resource);\n+        return resource;\n \t}\n \n }\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/JavaScriptResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/JavaScriptResourceReference.java\nindex 43e4a0d..d320f59 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/JavaScriptResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/JavaScriptResourceReference.java\n@@ -78,7 +78,9 @@ public JavaScriptResourceReference(Key key)\n \t@Override\n \tpublic JavaScriptPackageResource getResource()\n \t{\n-\t\treturn new JavaScriptPackageResource(getScope(), getName(), getLocale(), getStyle(),\n+        final JavaScriptPackageResource resource = new JavaScriptPackageResource(getScope(), getName(), getLocale(), getStyle(),\n                 getVariation());\n+        removeCompressFlagIfUnnecessary(resource);\n+        return resource;\n \t}\n }\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\nindex ca248a0..a127aa7 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n@@ -129,13 +129,27 @@ else if (JAVASCRIPT_EXTENSION.equals(extension))\n \t\t\t\tgetVariation());\n \t\t}\n \n+        removeCompressFlagIfUnnecessary(resource);\n+\n+        return resource;\n+    }\n+\n+    /**\n+     * Method allowing to remove the compress flag if the resource has been detected as a minified one\n+     * (i.e. ending with .min.EXT)\n+     * This method is to be called by subclasses overriding <code>getResource</code>\n+     * if they want to rely on default minification detection handling\n+     *\n+     * see WICKET-5250 for further explanation\n+     * @param resource resource to check\n+     */\n+    protected void removeCompressFlagIfUnnecessary(final PackageResource resource)\n+    {\n         String minifiedName = MINIFIED_NAMES_CACHE.get(this);\n         if (minifiedName != null && minifiedName != NO_MINIFIED_NAME)\n         {\n             resource.setCompress(false);\n         }\n-\n-\t\treturn resource;\n     }\n \n     private ResourceReference.UrlAttributes getUrlAttributes(Locale locale, String style, String variation)\n", "nb_test": 1504, "linesAdd": 13, "jira_id": "5250", "singleLine": false, "nb_skipped": 3, "commit": "6122df49", "nb_failure": 2, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testRender(org.apache.wicket.markup.html.internal.EnclosureTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java b/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\nindex 11d40a2..b90c80e 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n@@ -180,22 +180,36 @@ protected void onComponentTagBody(final MarkupStream markupStream, ComponentTag\n \t\t}\n \t}\n \n+\t/**\n+\t * \n+\t * @param container\n+\t * @param markupStream\n+\t * @param enclosureOpenTag\n+\t */\n \tprivate void applyEnclosureVisibilityToChildren(final MarkupContainer container,\n-\t\tfinal MarkupStream markupStream, ComponentTag enclosureOpenTag)\n+\t\tfinal MarkupStream markupStream, final ComponentTag enclosureOpenTag)\n \t{\n \t\tDirectChildTagIterator it = new DirectChildTagIterator(markupStream, enclosureOpenTag);\n \t\twhile (it.hasNext())\n \t\t{\n \t\t\tfinal ComponentTag tag = it.next();\n+\t\t\tif (tag.isAutoComponentTag() == false)\n+\t\t\t{\n \t\t\t\tfinal Component child = container.get(tag.getId());\n+\n \t\t\t\t// record original visiblity allowed value, will restore later\n \t\t\t\tchanges.put(child, child.isVisibilityAllowed());\n \t\t\t\tchild.setVisibilityAllowed(isVisible());\n \t\t\t}\n+\t\t}\n \t\tit.rewind();\n \t}\n \n-\tprivate void checkChildComponent(Component controller)\n+\t/**\n+\t * \n+\t * @param controller\n+\t */\n+\tprivate void checkChildComponent(final Component controller)\n \t{\n \t\tif (controller == null)\n \t\t{\n@@ -209,6 +223,12 @@ else if (controller == this)\n \t\t}\n \t}\n \n+\t/**\n+\t * \n+\t * @param container\n+\t * @param markupStream\n+\t * @param enclosureOpenTag\n+\t */\n \tprivate void ensureAllChildrenPresent(final MarkupContainer container,\n \t\tfinal MarkupStream markupStream, ComponentTag enclosureOpenTag)\n \t{\n@@ -217,6 +237,8 @@ private void ensureAllChildrenPresent(final MarkupContainer container,\n \t\t{\n \t\t\tfinal ComponentTag tag = it.next();\n \n+\t\t\tif (tag.isAutoComponentTag() == false)\n+\t\t\t{\n \t\t\t\tComponent child = container.get(tag.getId());\n \t\t\t\tif (child == null)\n \t\t\t\t{\n@@ -224,7 +246,8 @@ private void ensureAllChildrenPresent(final MarkupContainer container,\n \t\t\t\t\t// resolvers\n \t\t\t\t\tfinal int tagIndex = it.getCurrentIndex();\n \n-\t\t\t\t// because the resolvers can auto-add and therefore immediately render the component\n+\t\t\t\t\t// because the resolvers can auto-add and therefore immediately render the\n+\t\t\t\t\t// component\n \t\t\t\t\t// we have to buffer the output since we do not yet know the visibility of the\n \t\t\t\t\t// enclosure\n \t\t\t\t\tCharSequence buffer = new ResponseBufferZone(getRequestCycle(), markupStream)\n@@ -242,7 +265,8 @@ protected void executeInsideBufferedZone()\n \n \t\t\t\t\tif (buffer.length() > 0)\n \t\t\t\t\t{\n-\t\t\t\t\t// we have already rendered this child component, insert a stub component that\n+\t\t\t\t\t\t// we have already rendered this child component, insert a stub component\n+\t\t\t\t\t\t// that\n \t\t\t\t\t\t// will dump the markup during the normal render process if the enclosure is\n \t\t\t\t\t\t// visible\n \t\t\t\t\t\tfinal Component stub = new AutoMarkupLabel(child.getId(), buffer);\n@@ -250,10 +274,13 @@ protected void executeInsideBufferedZone()\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n \t\tit.rewind();\n \t}\n \n-\n+\t/**\n+\t * @see org.apache.wicket.Component#onDetach()\n+\t */\n \t@Override\n \tprotected void onDetach()\n \t{\n@@ -261,6 +288,9 @@ protected void onDetach()\n \t\tsuper.onDetach();\n \t}\n \n+\t/**\n+\t * \n+\t */\n \tprivate void restoreOriginalChildVisibility()\n \t{\n \t\tif (changes != null)\n", "nb_test": 810, "linesAdd": 9, "jira_id": "2506", "singleLine": false, "nb_skipped": 0, "commit": "0f8a2990", "nb_failure": 0, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["JavaxInjectAnnotProxyFieldValueFactoryTest.required:49->Assert.fail:88 Fields annotated with @Inject are required!"], "patch": "diff --git a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\nindex 6b7d071..54d11de 100644\n--- a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n+++ b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n@@ -68,6 +68,7 @@\n  * @see LazyInitProxyFactory\n  * @see SpringBean\n  * @see SpringBeanLocator\n+ * @see javax.inject.Inject\n  * \n  * @author Igor Vaynberg (ivaynberg)\n  * @author Istvan Devai\n@@ -123,7 +124,7 @@ public Object getFieldValue(final Field field, final Object fieldOwner)\n \t\t\t{\n \t\t\t\tNamed named = field.getAnnotation(Named.class);\n \t\t\t\tname = named != null ? named.value() : \"\";\n-\t\t\t\trequired = false;\n+\t\t\t\trequired = true;\n \t\t\t}\n \n \t\t\tString beanName = getBeanName(field, name, required);\n", "nb_test": 25, "linesAdd": 1, "jira_id": "5686", "singleLine": false, "nb_skipped": 0, "commit": "8e794fc4", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["ComponentQueueingTest.queueInsideHeader:720 \u00bb Markup Unable to find component ..."], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\nindex 0ea0002..5b79f80 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n@@ -18,11 +18,16 @@\n \n import java.text.ParseException;\n \n+import org.apache.wicket.Component;\n+import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.markup.ComponentTag;\n+import org.apache.wicket.markup.ComponentTag.IAutoComponentFactory;\n import org.apache.wicket.markup.Markup;\n import org.apache.wicket.markup.MarkupElement;\n import org.apache.wicket.markup.MarkupException;\n import org.apache.wicket.markup.MarkupStream;\n+import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n+import org.apache.wicket.markup.html.internal.HtmlHeaderItemsContainer;\n import org.apache.wicket.markup.parser.AbstractMarkupFilter;\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n import org.apache.wicket.markup.resolver.HtmlHeaderResolver;\n@@ -72,6 +77,24 @@\n \t/** The Markup available so far for the resource */\n \tprivate final Markup markup;\n \n+\tprivate static final IAutoComponentFactory HTML_HEADER_FACTORY = new IAutoComponentFactory()\n+\t{\n+\t\t@Override\n+\t\tpublic Component newComponent(MarkupContainer container, ComponentTag tag)\n+\t\t{\n+\t\t\treturn new HtmlHeaderContainer(tag.getId());\n+\t\t}\n+\t};\n+\t\n+\tprivate static final IAutoComponentFactory HTML_HEADER_ITEMS_FACTORY = new IAutoComponentFactory()\n+\t{\n+\t\t@Override\n+\t\tpublic Component newComponent(MarkupContainer container, ComponentTag tag)\n+\t\t{\n+\t\t\treturn new HtmlHeaderItemsContainer(tag.getId());\n+\t\t}\n+\t};\n+\t\n \t/**\n \t * Construct.\n \t * \n@@ -164,6 +187,7 @@ else if (foundClosingHead)\n \t\ttag.setId(HEADER_ID);\n \t\ttag.setAutoComponentTag(true);\n \t\ttag.setModified(true);\n+\t\ttag.setAutoComponentFactory(HTML_HEADER_ITEMS_FACTORY);\n \t}\n \n \t/**\n@@ -188,6 +212,7 @@ private void handleHeadTag(ComponentTag tag)\n \t\t\t\ttag.setId(HEADER_ID);\n \t\t\t\ttag.setAutoComponentTag(true);\n \t\t\t\ttag.setModified(true);\n+\t\t\t\ttag.setAutoComponentFactory(HTML_HEADER_FACTORY);\n \t\t\t}\n \t\t}\n \t\telse if (tag.isClose())\n@@ -201,6 +226,7 @@ else if (tag.isClose())\n \t\t\t\theadOpenTag.setAutoComponentTag(false);\n \t\t\t\theadOpenTag.setModified(false);\n \t\t\t\theadOpenTag.setFlag(ComponentTag.RENDER_RAW, true);\n+\t\t\t\theadOpenTag.setAutoComponentFactory(null);\n \t\t\t}\n \n \t\t\tfoundClosingHead = true;\n@@ -217,6 +243,7 @@ private void insertHeadTag()\n \t\topenTag.setId(HEADER_ID);\n \t\topenTag.setAutoComponentTag(true);\n \t\topenTag.setModified(true);\n+\t\topenTag.setAutoComponentFactory(HTML_HEADER_FACTORY);\n \n \t\tfinal ComponentTag closeTag = new ComponentTag(HEAD, TagType.CLOSE);\n \t\tcloseTag.setOpenTag(openTag);\n", "nb_test": 1861, "linesAdd": 27, "jira_id": "5965", "singleLine": false, "nb_skipped": 1, "commit": "31c88569", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["requestWithEmptyFilename(org.apache.wicket.request.mapper.ResourceMapperTest): caching strategy returned empty name for Name:"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/ResourceMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/ResourceMapper.java\nindex 9e15ba4..bc39efb 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/ResourceMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/ResourceMapper.java\n@@ -237,11 +237,23 @@ protected void removeCachingDecoration(Url url, PageParameters parameters)\n \n \t\tif (segments.isEmpty() == false)\n \t\t{\n+\t\t\t// get filename (the last segment)\n \t\t\tfinal int lastSegmentAt = segments.size() - 1;\n-\t\t\tfinal ResourceUrl resourceUrl = new ResourceUrl(segments.get(lastSegmentAt), parameters);\n+\t\t\tString filename = segments.get(lastSegmentAt);\n \t\t\t\n+\t\t\t// ignore requests with empty filename\n+\t\t\tif(Strings.isEmpty(filename))\n+\t\t\t{\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// create resource url from filename and query parameters\n+\t\t\tfinal ResourceUrl resourceUrl = new ResourceUrl(filename, parameters);\n+\n+\t\t\t// remove caching information from request\n \t\t\tgetCachingStrategy().undecorateUrl(resourceUrl);\n \t\t\t\n+\t\t\t// check for broken caching strategy (this must never happen)\n \t\t\tif (Strings.isEmpty(resourceUrl.getFileName()))\n \t\t\t{\n \t\t\t\tthrow new IllegalStateException(\"caching strategy returned empty name for \" + resourceUrl);\n", "nb_test": 1181, "linesAdd": 8, "jira_id": "4020", "singleLine": false, "nb_skipped": 2, "commit": "081cdeb2", "nb_failure": 0, "rtElixir": true, "linesRem": 1}, {"files": 7, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["DequeueingTransparentWebMarkupContainerTest.queuedComponentsInsideTransparentContainer:51 \u00bb Markup"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex b607b4e..1ec4f02 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -1535,7 +1535,7 @@ private void dequeueAutoComponents()\n \t\t\t\tComponentTag.IAutoComponentFactory autoComponentFactory = tag.getAutoComponentFactory();\n \t\t\t\tif (autoComponentFactory != null)\n \t\t\t\t{\n-\t\t\t\t\tqueue(autoComponentFactory.newComponent(tag));\n+\t\t\t\t\tqueue(autoComponentFactory.newComponent(this, tag));\n \t\t\t\t}\n \t\t\t}\n \t\t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/ComponentTag.java b/wicket-core/src/main/java/org/apache/wicket/markup/ComponentTag.java\nindex b572677..bffde4e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/ComponentTag.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/ComponentTag.java\n@@ -25,6 +25,7 @@\n import java.util.Map;\n \n import org.apache.wicket.Component;\n+import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.behavior.Behavior;\n import org.apache.wicket.markup.parser.XmlTag;\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n@@ -65,7 +66,7 @@\n \t\t/**\n \t\t * Creates a new instance of auto component to be queued\n \t\t */\n-\t\tComponent newComponent(ComponentTag tag);\n+\t\tComponent newComponent(MarkupContainer container, ComponentTag tag);\n \t}\n \n \ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/EnclosureHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/EnclosureHandler.java\nindex 4a47f38..098533c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/EnclosureHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/EnclosureHandler.java\n@@ -56,7 +56,7 @@\n \tprivate static final IAutoComponentFactory FACTORY = new IAutoComponentFactory()\n \t{\n \t\t@Override\n-\t\tpublic Component newComponent(ComponentTag tag)\n+\t\tpublic Component newComponent(MarkupContainer container, ComponentTag tag)\n \t\t{\n \t\t\treturn new Enclosure(tag.getId(), tag\n \t\t\t\t.getAttribute(EnclosureHandler.CHILD_ATTRIBUTE));\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\nindex 0f85964..6d08c95 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n@@ -49,8 +49,8 @@\n  */\n public final class HtmlHeaderSectionHandler extends AbstractMarkupFilter\n {\n-\tprivate static final String BODY = \"body\";\n-\tprivate static final String HEAD = \"head\";\n+\tpublic static final String BODY = \"body\";\n+\tpublic static final String HEAD = \"head\";\n \n \t/** The automatically assigned wicket:id to &gt;head&lt; tag */\n \tpublic static final String HEADER_ID = \"_header_\";\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\nindex e3c953a..0014b92 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n@@ -127,7 +127,7 @@ protected MarkupElement onComponentTag(final ComponentTag tag) throws ParseExcep\n \t\t\t\t\ttag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory()\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\t@Override\r\n-\t\t\t\t\t\tpublic Component newComponent(ComponentTag tag)\r\n+\t\t\t\t\t\tpublic Component newComponent(MarkupContainer container, ComponentTag tag)\r\n \t\t\t\t\t\t{\r\n \t\t\t\t\t\t\tString attributeName = getInlineEnclosureAttributeName(null);\r\n \t\t\t\t\t\t\tString childId = tag.getAttribute(attributeName);\r\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java\nindex 0ae97ee..79edb52 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java\n@@ -86,8 +86,8 @@ public void onComponentTag(Component component, ComponentTag tag)\n \t\t\t{\n \t\t\t\tString attrValue = tag.getAttributes().getString(attrName);\n \n-\t\t\t\tif ((attrValue != null) && (attrValue.startsWith(\"/\") == false) &&\n-\t\t\t\t\t(!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\")))\n+\t\t\t\tif ((attrValue != null) && (attrValue.startsWith(\"/\") == false)\n+\t\t\t\t\t&& (!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\")))\n \t\t\t\t{\n \t\t\t\t\ttag.getAttributes().put(attrName,\n \t\t\t\t\t\tUrlUtils.rewriteToContextRelative(attrValue, RequestCycle.get()));\n@@ -97,6 +97,14 @@ public void onComponentTag(Component component, ComponentTag tag)\n \t};\n \t\n \t/** \n+\t * https://issues.apache.org/jira/browse/WICKET-5724\n+\t * \n+\t * Says if we are inside an head tag or wicket:head tag. \n+\t * \n+\t * */\n+\tprivate boolean insideHead;\n+\n+\t/**\n \t * Constructor for the IComponentResolver role.\n \t */\n \tpublic RelativePathPrefixHandler()\n@@ -106,6 +114,7 @@ public RelativePathPrefixHandler()\n \n \t/**\n \t * Constructor for the IMarkupFilter role\n+\t * \n \t * @param markup\n \t *            The markup created by reading the markup file\n \t */\n@@ -119,14 +128,26 @@ protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseExcep\n \t{\n \t\tif (tag.isClose())\n \t\t{\n+\t\t\tif (isHeadTag(tag))\t\n+\t\t\t{\n+\t\t\t\t//outside head tag\n+\t\t\t\tinsideHead = false;\n+\t\t\t}\n+\t\t\t\n \t\t\treturn tag;\n \t\t}\n \n+\t\tif (isHeadTag(tag))\t\n+\t\t{\n+\t\t\t//inside head tag\n+\t\t\tinsideHead = true;\n+\t\t}\n+\n \t\tString wicketIdAttr = getWicketNamespace() + \":\" + \"id\";\n \n \t\t// Don't touch any wicket:id component and any auto-components\n-\t\tif ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true) ||\n-\t\t\t(tag.getAttributes().get(wicketIdAttr) != null))\n+\t\tif ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true)\n+\t\t\t|| (tag.getAttributes().get(wicketIdAttr) != null))\n \t\t{\n \t\t\treturn tag;\n \t\t}\n@@ -136,13 +157,33 @@ protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseExcep\n \t\tfor (String attrName : attributeNames)\n \t\t{\n \t\t\tString attrValue = tag.getAttributes().getString(attrName);\n-\t\t\tif ((attrValue != null) && (attrValue.startsWith(\"/\") == false) &&\n-\t\t\t\t(!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\")))\n+\t\t\tif ((attrValue != null) && (attrValue.startsWith(\"/\") == false)\n+\t\t\t\t&& (!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\")))\n \t\t\t{\n \t\t\t\tif (tag.getId() == null)\n \t\t\t\t{\n \t\t\t\t\ttag.setId(getWicketRelativePathPrefix(null));\n \t\t\t\t\ttag.setAutoComponentTag(true);\n+\t\t\t\t\t\n+\t\t\t\t\t/**\n+\t\t\t\t\t * https://issues.apache.org/jira/browse/WICKET-5724\n+\t\t\t\t\t * Transparent component inside page body must allow \n+\t\t\t\t\t * queued children components.\n+\t\t\t\t\t */\n+\t\t\t\t\tif(!insideHead)\n+\t\t\t\t\t{\n+\t\t\t\t\t\ttag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory()\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tpublic Component newComponent(MarkupContainer container, ComponentTag tag)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tString id = tag.getId() + container.getPage().getAutoIndex();\n+\t\t\t\t\t\t\t\ttag.setId(id);\n+\t\n+\t\t\t\t\t\t\t\treturn new TransparentWebMarkupContainer(id);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\t\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\ttag.addBehavior(RELATIVE_PATH_BEHAVIOR);\n \t\t\t\ttag.setModified(true);\n@@ -153,6 +194,16 @@ protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseExcep\n \t\treturn tag;\n \t}\n \t\n+\tprivate boolean isHeadTag(ComponentTag tag)\n+\t{\n+\t\tif (HtmlHeaderSectionHandler.HEAD.equalsIgnoreCase(tag.getName()))\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\t\n+\t\t\n+\t\treturn false;\n+\t}\n+\t\n \t@Override\n \tpublic Component resolve(final MarkupContainer container, final MarkupStream markupStream,\n \t\tfinal ComponentTag tag)\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/resolver/IComponentResolver.java b/wicket-core/src/main/java/org/apache/wicket/markup/resolver/IComponentResolver.java\nindex b8d1588..9e83b71 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/resolver/IComponentResolver.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/resolver/IComponentResolver.java\n@@ -28,6 +28,8 @@\n  * are first looked up in a component's hierarchy before falling back to a list of\n  * IComponentResolvers maintained in {@link PageSettings}.\n  * \n+ * NOTE: implementations for this interface must be thread-safe!\n+ * \n  * @see ComponentResolvers\n  * \n  * @author Juergen Donnerstag\n", "nb_test": 1692, "linesAdd": 50, "jira_id": "5724", "singleLine": false, "nb_skipped": 1, "commit": "b92591f6", "nb_failure": 0, "linesRem": 12}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["multiPartWebRequest(org.apache.wicket.protocol.http.servlet.ServletWebRequestTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 9d0245d..9d46baf 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -147,6 +147,11 @@\n \tprivate static final String HIDDEN_DIV_START = \"<div style=\\\"width:0px;height:0px;position:absolute;left:-100px;top:-100px;overflow:hidden\\\">\";\n \n \t/**\n+\t * The value of HTMLFormElement's <code>enctype</code> attribute needed for file uploading.\n+\t */\n+\tpublic static final String ENCTYPE_MULTIPART_FORM_DATA = \"multipart/form-data\";\n+\n+\t/**\n \t * Visitor used for validation\n \t * \n \t * @author Igor Vaynberg (ivaynberg)\n@@ -1540,7 +1545,7 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\t\t\ttag.put(\"method\", METHOD_POST.toLowerCase(Locale.ENGLISH));\n \t\t\t\t}\n \n-\t\t\t\ttag.put(\"enctype\", \"multipart/form-data\");\n+\t\t\t\ttag.put(\"enctype\", ENCTYPE_MULTIPART_FORM_DATA);\n \t\t\t\t//\n \t\t\t\t// require the application-encoding for multipart/form-data to be sure to\n \t\t\t\t// get multipart-uploaded characters with the proper encoding on the following\n@@ -1555,7 +1560,7 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\t{\n \t\t\t\t// sanity check\n \t\t\t\tString enctype = (String)tag.getAttributes().get(\"enctype\");\n-\t\t\t\tif (\"multipart/form-data\".equalsIgnoreCase(enctype))\n+\t\t\t\tif (ENCTYPE_MULTIPART_FORM_DATA.equalsIgnoreCase(enctype))\n \t\t\t\t{\n \t\t\t\t\t// though not set explicitly in Java, this is a multipart\n \t\t\t\t\t// form\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\nindex 42ab5d1..117947d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\n@@ -44,6 +44,7 @@\n import org.apache.wicket.markup.html.WebPage;\n import org.apache.wicket.markup.html.form.AutoLabelResolver;\n import org.apache.wicket.markup.html.form.AutoLabelTextResolver;\n+import org.apache.wicket.markup.html.form.Form;\n import org.apache.wicket.markup.html.pages.AccessDeniedPage;\n import org.apache.wicket.markup.html.pages.InternalErrorPage;\n import org.apache.wicket.markup.html.pages.PageExpiredErrorPage;\n@@ -79,6 +80,7 @@\n import org.apache.wicket.util.lang.PackageName;\n import org.apache.wicket.util.string.Strings;\n import org.apache.wicket.util.time.Duration;\n+import org.apache.wicket.util.upload.FileUploadException;\n import org.apache.wicket.util.watch.IModificationWatcher;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -486,6 +488,23 @@ WebRequest createWebRequest(HttpServletRequest servletRequest, final String filt\n \n \t\tWebRequest webRequest = newWebRequest(servletRequest, filterPath);\n \n+\t\tString contentType = servletRequest.getContentType();\n+\t\tString method = servletRequest.getMethod();\n+\n+\t\tif (webRequest instanceof ServletWebRequest && Form.METHOD_POST.equalsIgnoreCase(method) &&\n+\t\t\t\tStrings.isEmpty(contentType) == false && contentType.toLowerCase().startsWith(Form.ENCTYPE_MULTIPART_FORM_DATA))\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\treturn ((ServletWebRequest)webRequest).newMultipartWebRequest(\n+\t\t\t\t\tgetApplicationSettings().getDefaultMaximumUploadSize(), \"externalForm\");\n+\t\t\t}\n+\t\t\tcatch (FileUploadException e)\n+\t\t\t{\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t}\n+\n \t\treturn webRequest;\n \t}\n \n", "nb_test": 1394, "linesAdd": 23, "jira_id": "4715", "singleLine": false, "nb_skipped": 5, "commit": "4fc82e35", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testSubmitWithoutUploadFile(org.apache.wicket.util.tester.FormTesterTest):"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\nindex 2f6bfc6..caa61ca 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\n@@ -88,13 +88,16 @@ public UrlInfo(PageComponentInfo pageComponentInfo,\n \t\t */\n \t\tprivate PageParameters cleanPageParameters(final PageParameters originalParameters)\n \t\t{\n-\t\t\tPageParameters cleanParameters = new PageParameters(originalParameters);\n+\t\t\tPageParameters cleanParameters = null;\n+\t\t\tif (originalParameters != null)\n+\t\t\t{\n+\t\t\t\tcleanParameters = new PageParameters(originalParameters);\n \n \t\t\t\t// WICKET-4038: Ajax related parameters are set by wicket-ajax.js when needed.\n \t\t\t\t// They shouldn't be propagated to the next requests\n \t\t\t\tcleanParameters.remove(WebRequest.PARAM_AJAX);\n \t\t\t\tcleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\n-\n+\t\t\t}\n \t\t\treturn cleanParameters;\n \t\t}\n \n", "nb_test": 1187, "linesAdd": 5, "jira_id": "4038", "singleLine": false, "nb_skipped": 2, "commit": "f3d7565c", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["encodeApostrophe(org.apache.wicket.request.UrlEncoderTest)"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/UrlEncoder.java b/wicket-request/src/main/java/org/apache/wicket/request/UrlEncoder.java\nindex 3bfc78a..aadac5e 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/UrlEncoder.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/UrlEncoder.java\n@@ -174,7 +174,6 @@ protected UrlEncoder(final Type type, final char stopChar)\n \t\tdontNeedEncoding.set('!');\r\n \t\tdontNeedEncoding.set('$');\r\n \t\t// \"&\" needs to be encoded for query stings\r\n-\t\tdontNeedEncoding.set('\\'');\r\n \t\t// \"(\" and \")\" probably don't need encoding, but we'll be conservative\r\n \t\tdontNeedEncoding.set('*');\r\n \t\t// \"+\" needs to be encoded for query strings (since it means =\r\n", "nb_test": 8, "linesAdd": 0, "jira_id": "3721", "singleLine": true, "nb_skipped": 0, "commit": "1858bc18", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 3, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testArray2(org.apache.wicket.util.value.ValueMapTest)", "testArray2(org.apache.wicket.PageParametersTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/PageParameters.java b/wicket/src/main/java/org/apache/wicket/PageParameters.java\nindex 95d1a48..0a865f2 100644\n--- a/wicket/src/main/java/org/apache/wicket/PageParameters.java\n+++ b/wicket/src/main/java/org/apache/wicket/PageParameters.java\n@@ -123,14 +123,14 @@ else if (pos != -1)\n \t\t\t\tfinal String key = pair.substring(0, pos).trim();\n \t\t\t\tfinal String value = pair.substring(pos + 1).trim();\n \n-\t\t\t\tput(key, value);\n+\t\t\t\tadd(key, value);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\tfinal String key = pair.trim();\n \t\t\t\tfinal String value = null;\n \n-\t\t\t\tput(key, value);\n+\t\t\t\tadd(key, value);\n \t\t\t}\n \t\t}\n \t}\ndiff --git a/wicket/src/main/java/org/apache/wicket/Resource.java b/wicket/src/main/java/org/apache/wicket/Resource.java\nindex 85c39aa..78e62b0 100644\n--- a/wicket/src/main/java/org/apache/wicket/Resource.java\n+++ b/wicket/src/main/java/org/apache/wicket/Resource.java\n@@ -149,7 +149,7 @@ public final Resource setCacheable(boolean cacheable)\n \t * @param parameters\n \t *            Map of query parameters that parameterize this resource\n \t */\n-\tpublic final void setParameters(final Map<?, ?> parameters)\n+\tpublic final void setParameters(final Map<String, ?> parameters)\n \t{\n \t\tif (parameters == null)\n \t\t{\ndiff --git a/wicket/src/main/java/org/apache/wicket/util/value/ValueMap.java b/wicket/src/main/java/org/apache/wicket/util/value/ValueMap.java\nindex 3e72e8f..5b5062b 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/value/ValueMap.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/value/ValueMap.java\n@@ -20,7 +20,6 @@\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.Arrays;\n-import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n@@ -91,7 +90,7 @@ public ValueMap()\n \t * @param map\n \t *            the <code>ValueMap</code> to copy\n \t */\n-\tpublic ValueMap(final Map map)\n+\tpublic ValueMap(final Map<? extends String, ? extends Object> map)\n \t{\n \t\tsuper();\n \n@@ -152,7 +151,7 @@ public ValueMap(final String keyValuePairs, final String delimiter)\n \t\t\t}\n \t\t\tString key = keyValuePairs.substring(start, equalsIndex);\n \t\t\tString value = keyValuePairs.substring(equalsIndex + 1, delimiterIndex);\n-\t\t\tput(key, value);\n+\t\t\tadd(key, value);\n \t\t\tif (delimiterIndex < keyValuePairs.length())\n \t\t\t{\n \t\t\t\tstart = delimiterIndex + 1;\n@@ -490,7 +489,7 @@ else if (o.getClass().isArray())\n \t * @see java.util.Map#putAll(java.util.Map)\n \t */\n \t@Override\n-\tpublic void putAll(final Map map)\n+\tpublic void putAll(final Map<? extends String, ? extends Object> map)\n \t{\n \t\tcheckMutability();\n \t\tsuper.putAll(map);\n@@ -535,9 +534,15 @@ public String getKey(final String key)\n \tpublic String toString()\n \t{\n \t\tfinal StringBuffer buffer = new StringBuffer();\n-\t\tfor (final Iterator iterator = entrySet().iterator(); iterator.hasNext();)\n+\t\tboolean first = true;\n+\t\tfor (Map.Entry<String, Object> entry : entrySet())\n \t\t{\n-\t\t\tfinal Map.Entry entry = (Map.Entry)iterator.next();\n+\t\t\tif (first == false)\n+\t\t\t{\n+\t\t\t\tbuffer.append(' ');\n+\t\t\t}\n+\t\t\tfirst = false;\n+\n \t\t\tbuffer.append(entry.getKey());\n \t\t\tbuffer.append(\" = \\\"\");\n \t\t\tfinal Object value = entry.getValue();\n@@ -555,10 +560,6 @@ else if (value.getClass().isArray())\n \t\t\t}\n \n \t\t\tbuffer.append('\\\"');\n-\t\t\tif (iterator.hasNext())\n-\t\t\t{\n-\t\t\t\tbuffer.append(' ');\n-\t\t\t}\n \t\t}\n \t\treturn buffer.toString();\n \t}\n@@ -585,7 +586,9 @@ private void checkMutability()\n \tpublic Boolean getAsBoolean(String key)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn null;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -619,7 +622,9 @@ public boolean getAsBoolean(String key, boolean defaultValue)\n \tpublic Integer getAsInteger(String key)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn null;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -652,7 +657,9 @@ public int getAsInteger(String key, int defaultValue)\n \tpublic Long getAsLong(String key)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn null;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -685,7 +692,9 @@ public long getAsLong(String key, long defaultValue)\n \tpublic Double getAsDouble(String key)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn null;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -700,7 +709,7 @@ public Double getAsDouble(String key)\n \t/**\n \t * @see IValueMap#getAsDouble(String, double)\n \t */\n-\tpublic double getAsDouble(String key, double defaultValue)\n+\tpublic double getAsDouble(final String key, final double defaultValue)\n \t{\n \t\ttry\n \t\t{\n@@ -715,7 +724,7 @@ public double getAsDouble(String key, double defaultValue)\n \t/**\n \t * @see IValueMap#getAsDuration(String)\n \t */\n-\tpublic Duration getAsDuration(String key)\n+\tpublic Duration getAsDuration(final String key)\n \t{\n \t\treturn getAsDuration(key, null);\n \t}\n@@ -723,10 +732,12 @@ public Duration getAsDuration(String key)\n \t/**\n \t * @see IValueMap#getAsDuration(String, Duration)\n \t */\n-\tpublic Duration getAsDuration(String key, Duration defaultValue)\n+\tpublic Duration getAsDuration(final String key, final Duration defaultValue)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn defaultValue;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -741,7 +752,7 @@ public Duration getAsDuration(String key, Duration defaultValue)\n \t/**\n \t * @see IValueMap#getAsTime(String)\n \t */\n-\tpublic Time getAsTime(String key)\n+\tpublic Time getAsTime(final String key)\n \t{\n \t\treturn getAsTime(key, null);\n \t}\n@@ -749,10 +760,12 @@ public Time getAsTime(String key)\n \t/**\n \t * @see IValueMap#getAsTime(String, Time)\n \t */\n-\tpublic Time getAsTime(String key, Time defaultValue)\n+\tpublic Time getAsTime(final String key, final Time defaultValue)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn defaultValue;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -765,43 +778,59 @@ public Time getAsTime(String key, Time defaultValue)\n \t}\n \n \t/**\n-\t * @see IValueMap#getAsEnum(String, Class<T>)\n+\t * @see org.apache.wicket.util.value.IValueMap#getAsEnum(java.lang.String, java.lang.Class)\n \t */\n-\tpublic <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass)\n+\tpublic <T extends Enum<T>> T getAsEnum(final String key, final Class<T> eClass)\n \t{\n \t\treturn getEnumImpl(key, eClass, null);\n \t}\n \n \t/**\n-\t * @see IValueMap#getAsEnum\n+\t * @see org.apache.wicket.util.value.IValueMap#getAsEnum(java.lang.String, java.lang.Enum)\n \t */\n-\tpublic <T extends Enum<T>> T getAsEnum(String key, T defaultValue)\n+\tpublic <T extends Enum<T>> T getAsEnum(final String key, final T defaultValue)\n \t{\n \t\tif (defaultValue == null)\n+\t\t{\n \t\t\tthrow new IllegalArgumentException(\"Default value cannot be null\");\n+\t\t}\n+\n \t\treturn getEnumImpl(key, defaultValue.getClass(), defaultValue);\n \t}\n \n \t/**\n-\t * @see IValueMap#getAsEnum(String, Class<T>, T)\n+\t * @see org.apache.wicket.util.value.IValueMap#getAsEnum(java.lang.String, java.lang.Class,\n+\t *      java.lang.Enum)\n \t */\n-\tpublic <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass, T defaultValue)\n+\tpublic <T extends Enum<T>> T getAsEnum(final String key, final Class<T> eClass,\n+\t\tfinal T defaultValue)\n \t{\n \t\treturn getEnumImpl(key, eClass, defaultValue);\n \t}\n \n \t/**\n \t * get enum implementation\n+\t * \n+\t * @param key\n+\t * @param eClass\n+\t * @param defaultValue\n+\t * @param <T>\n+\t * @return Enum\n \t */\n \t@SuppressWarnings( { \"unchecked\" })\n-\tprivate <T extends Enum<T>> T getEnumImpl(String key, Class<?> eClass, T defaultValue)\n+\tprivate <T extends Enum<T>> T getEnumImpl(final String key, final Class<?> eClass,\n+\t\tfinal T defaultValue)\n \t{\n \t\tif (eClass == null)\n+\t\t{\n \t\t\tthrow new IllegalArgumentException(\"eClass value cannot be null\");\n+\t\t}\n \n \t\tString value = getString(key);\n \t\tif (value == null)\n+\t\t{\n \t\t\treturn defaultValue;\n+\t\t}\n \n \t\tMethod valueOf = null;\n \t\ttry\n", "nb_test": 784, "linesAdd": 44, "jira_id": "2172", "singleLine": false, "nb_skipped": 0, "commit": "ea4a3f8a", "nb_failure": 2, "linesRem": 22}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["exactMountGetsBetterScore_ThanParameterOne_ThenOptionalOne(org.apache.wicket.core.request.mapper.MountedMapperTest): exactCompatScore should have greater compatibility score than required one got exact = 2 and required= 2", "exactMountGetsBetterScore_ThanParameterOne(org.apache.wicket.core.request.mapper.MountedMapperTest): exactCompatScore should have greater compatibility score than required one got exact = 2 and required= 2", "optionalParameterGetsLowerScore_ThanExactOne(org.apache.wicket.core.request.mapper.MountedMapperTest): exactCompatScore should have greater compatibility score than optional one got exact = 2 and optional = 2"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\nindex ae742d6..12f8985 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n@@ -495,7 +495,15 @@ public int getCompatibilityScore(Request request)\n \t{\n \t\tif (urlStartsWith(request.getUrl(), mountSegments))\n \t\t{\n-\t\t\treturn mountSegments.length;\n+\t\t\t/* see WICKET-5056 - alter score with pathSegment type */\n+\t\t\tint countOptional = 0;\n+\t\t\tint fixedSegments = 0;\n+\t\t\tfor (MountPathSegment pathSegment : pathSegments)\n+\t\t\t{\n+\t\t\t\tfixedSegments += pathSegment.getFixedPartSize();\n+\t\t\t\tcountOptional += pathSegment.getOptionalParameters();\n+\t\t\t}\n+\t\t\treturn mountSegments.length - countOptional + fixedSegments;\n \t\t}\n \t\telse\n \t\t{\n", "nb_test": 1494, "linesAdd": 8, "jira_id": "5056", "singleLine": false, "nb_skipped": 4, "commit": "56169634", "nb_failure": 3, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": true}, "failing_tests": ["unixWICKET501(org.apache.wicket.util.string.JavaScriptStripperTest): expected:< [(..)", "dosWICKET501(org.apache.wicket.util.string.JavaScriptStripperTest): expected:< [\r](..)", "macWICKET501(org.apache.wicket.util.string.JavaScriptStripperTest): expected:< [\r] if ( !t.indexOf(\"//...> but was:< [] if ( !t.indexOf(\"//...>", "regexp2(org.apache.wicket.util.string.JavaScriptStripperTest): expected:<...o.replace(/\"/, \"\"); [\r]doFoo();> but was:<...o.replace(/\"/, \"\"); []doFoo();>", "WICKET4760(org.apache.wicket.util.string.JavaScriptStripperTest): expected:<x++ [(..)", "regexp4(org.apache.wicket.util.string.JavaScriptStripperTest): expected:< attr:  [(..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptStripper.java b/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptStripper.java\nindex 79c6542..46988d6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptStripper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptStripper.java\n@@ -173,6 +173,7 @@ else if (c == '\"')\n \t\t\t\tif (c == '\\n' || c == '\\r')\n \t\t\t\t{\n \t\t\t\t\tstate = REGULAR_TEXT;\n+\t\t\t\t\tresult.append(c);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n", "nb_test": 1410, "linesAdd": 1, "jira_id": "4760", "singleLine": true, "nb_skipped": 5, "commit": "2f1ece4b", "nb_failure": 6, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["sessionInvalidate(org.apache.wicket.util.tester.WicketTesterSessionInvalidateTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/mock/MockSessionStore.java b/wicket-core/src/main/java/org/apache/wicket/mock/MockSessionStore.java\nindex 0eb0abe..61c1581 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/mock/MockSessionStore.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/mock/MockSessionStore.java\n@@ -86,12 +86,13 @@ private void cleanup()\n \n \tpublic void invalidate(Request request)\n \t{\n+\t\tString sessId = sessionId;\n+\t\tcleanup();\n \t\tfor (UnboundListener l : unboundListeners)\n \t\t{\n-\t\t\tl.sessionUnbound(sessionId);\n+\t\t\tl.sessionUnbound(sessId);\n \t\t}\n \n-\t\tcleanup();\n \t}\n \n \tpublic Session lookup(Request request)\n", "nb_test": 1196, "linesAdd": 3, "jira_id": "3769", "singleLine": false, "nb_skipped": 1, "commit": "b4e9d426", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testLocaleChangesAreDetectedWithExplicitMessageKeys(org.apache.wicket.markup.html.form.AutoFormLabelPickupTest): null expected:<...bel from properties [FR]> but was:<...bel from properties [DE]>", "testLocaleChangesAreDetectedWithDefaultLabels(org.apache.wicket.markup.html.form.AutoFormLabelPickupTest): null expected:<...pertiesDefaultLabel [FR]> but was:<...pertiesDefaultLabel [DE]>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AutoLabelTextResolver.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AutoLabelTextResolver.java\nindex 85cf7ce..34cfe82 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AutoLabelTextResolver.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AutoLabelTextResolver.java\n@@ -28,7 +28,10 @@\n import org.apache.wicket.markup.parser.XmlTag;\r\n import org.apache.wicket.markup.parser.filter.WicketTagIdentifier;\r\n import org.apache.wicket.markup.resolver.IComponentResolver;\r\n+import org.apache.wicket.model.IModel;\r\n+import org.apache.wicket.model.LoadableDetachableModel;\r\n import org.apache.wicket.model.Model;\r\n+import org.apache.wicket.model.StringResourceModel;\r\n import org.apache.wicket.request.cycle.RequestCycle;\r\n import org.apache.wicket.util.string.Strings;\r\n \r\n@@ -130,76 +133,95 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t@Override\r\n \t\tpublic void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)\r\n \t\t{\r\n-\t\t\tboolean storeLabelText = false;\r\n \r\n \t\t\t// try and find some form of label content...\r\n-\t\t\tString labelText = null;\r\n+\t\t\tIModel<String> labelModel = findLabelContent(markupStream, openTag);\r\n+\t\t\t// print the label text\r\n+\t\t\treplaceComponentTagBody(markupStream, openTag,\r\n+\t\t\t\tlabelModel != null ? labelModel.getObject() : \"\");\r\n \r\n-\t\t\t// check if the labeled component is a label provider\r\n+\t\t\t// store the label text in FormComponent's label model so its available to errors\r\n+\t\t\tif (labelModel != null)\r\n+\t\t\t{\r\n+\t\t\t\tif (labeled instanceof FormComponent)\r\n+\t\t\t\t{\r\n+\t\t\t\t\tFormComponent<?> fc = (FormComponent<?>)labeled;\r\n+\t\t\t\t\tfc.setLabel(labelModel);\r\n+\t\t\t\t}\r\n+\t\t\t\telse\r\n+\t\t\t\t{\r\n+\t\t\t\t\t// if we can't hand off the labelmodel to a component, we have to detach it\r\n+\t\t\t\t\tlabelModel.detach();\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n \r\n+\t\tprivate IModel<String> findLabelContent(final MarkupStream markupStream,\r\n+\t\t\tfinal ComponentTag tag)\r\n+\t\t{\r\n \t\t\tif (labeled instanceof ILabelProvider)\r\n \t\t\t{\r\n+\t\t\t\t// check if the labeled component is a label provider\r\n \t\t\t\tILabelProvider<String> provider = (ILabelProvider<String>)labeled;\r\n \t\t\t\tif (provider.getLabel() != null)\r\n \t\t\t\t{\r\n-\t\t\t\t\tString text = provider.getLabel().getObject();\r\n-\t\t\t\t\tif (!Strings.isEmpty(text))\r\n+\t\t\t\t\tif (!Strings.isEmpty(provider.getLabel().getObject()))\r\n+\r\n \t\t\t\t\t{\r\n-\t\t\t\t\t\tlabelText = text;\r\n+\t\t\t\t\t\treturn provider.getLabel();\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \r\n \t\t\t// check if the labeled component is a form component\r\n-\r\n-\t\t\tif (labelText == null && labeled instanceof FormComponent)\r\n+\t\t\tif (labeled instanceof FormComponent)\r\n \t\t\t{\r\n-\t\t\t\tString text = ((FormComponent<?>)labeled).getDefaultLabel(\"wicket:unknown\");\r\n+\t\t\t\tfinal FormComponent<?> formComponent = (FormComponent<?>)labeled;\r\n+\t\t\t\tString text = formComponent.getDefaultLabel(\"wicket:unknown\");\r\n \t\t\t\tif (!\"wicket:unknown\".equals(text) && !Strings.isEmpty(text))\r\n \t\t\t\t{\r\n-\t\t\t\t\tlabelText = text;\r\n+\t\t\t\t\treturn new LoadableDetachableModel<String>()\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\t@Override\r\n+\t\t\t\t\t\tprotected String load()\r\n+\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\treturn formComponent.getDefaultLabel(\"wicket:unknown\");\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t};\r\n \t\t\t\t}\r\n \t\t\t}\r\n \r\n \t\t\t// check if wicket:label tag has a message key\r\n-\t\t\tif (labelText == null && openTag.getAttribute(\"key\") != null)\r\n \t\t\t{\r\n-\t\t\t\tString text = labeled.getString(openTag.getAttribute(\"key\"));\r\n+\t\t\t\tString resourceKey = tag.getAttribute(\"key\");\r\n+\t\t\t\tif (resourceKey != null)\r\n+\t\t\t\t{\r\n+\t\t\t\t\tString text = labeled.getString(resourceKey);\r\n \t\t\t\t\tif (!Strings.isEmpty(text))\r\n \t\t\t\t\t{\r\n-\t\t\t\t\tlabelText = text;\r\n-\t\t\t\t\tstoreLabelText = true;\r\n+\t\t\t\t\t\treturn new StringResourceModel(resourceKey, labeled, null);\r\n+\t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \r\n \t\t\t// as last resort use the tag body\r\n-\t\t\tif (labelText == null)\r\n \t\t\t{\r\n \t\t\t\tString text = new ResponseBufferZone(RequestCycle.get(), markupStream)\r\n \t\t\t\t{\r\n \t\t\t\t\t@Override\r\n \t\t\t\t\tprotected void executeInsideBufferedZone()\r\n \t\t\t\t\t{\r\n-\t\t\t\t\t\tTextLabel.super.onComponentTagBody(markupStream, openTag);\r\n+\t\t\t\t\t\tTextLabel.super.onComponentTagBody(markupStream, tag);\r\n \t\t\t\t\t}\r\n \t\t\t\t}.execute().toString();\r\n \r\n \t\t\t\tif (!Strings.isEmpty(text))\r\n \t\t\t\t{\r\n-\t\t\t\t\tlabelText = text;\r\n-\t\t\t\t\tstoreLabelText = true;\r\n+\t\t\t\t\treturn Model.of(text);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \r\n-\t\t\t// print the label text\r\n-\t\t\treplaceComponentTagBody(markupStream, openTag, labelText);\r\n-\r\n-\t\t\t// store the label text in FormComponent's label model so its available to errors\r\n-\t\t\tif (labeled instanceof FormComponent)\r\n-\t\t\t{\r\n-\t\t\t\tFormComponent<?> fc = (FormComponent<?>)labeled;\r\n-\t\t\t\tfc.setLabel(Model.of(labelText));\r\n-\t\t\t}\r\n+\t\t\treturn null;\r\n \t\t}\r\n \t}\r\n \r\n", "nb_test": 1199, "linesAdd": 45, "jira_id": "4102", "singleLine": false, "nb_skipped": 2, "commit": "e743fd7e", "nb_failure": 2, "linesRem": 24}, {"files": 0, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["WebSocketTesterRequestCycleListenerTest.verifyRequestCycleListeners:106->Assert.assertThat:832->Assert.assertThat:865", "Expected: is <true>", "but: was <false>"], "patch": "", "nb_test": 8, "linesAdd": 0, "jira_id": "5701", "singleLine": false, "nb_skipped": 0, "commit": "087c0a26", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["resetAfterWrittenContent(org.apache.wicket.protocol.http.HeaderBufferingWebResponseTest)", "additionalHeaderAfterWrittenContent(org.apache.wicket.protocol.http.HeaderBufferingWebResponseTest): Header was already written to response!"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/HeaderBufferingWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/HeaderBufferingWebResponse.java\nindex 0ac0c2a..8771dca 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/HeaderBufferingWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/HeaderBufferingWebResponse.java\n@@ -24,20 +24,24 @@\n import org.apache.wicket.util.time.Time;\n \n /**\n- * Response that keeps headers in buffers but writes the content directly to the response.\n+ * Response that keeps headers in buffers until the first content is written.\n  * \n  * This is necessary to get {@link #reset()} working without removing the JSESSIONID cookie. When\n  * {@link HttpServletResponse#reset()} is called it removes all cookies, including the JSESSIONID\n- * cookie.\n+ * cookie - see <a href=\"https://issues.apache.org/bugzilla/show_bug.cgi?id=26183\">Bug 26183</a>.\n  * \n- * Calling {@link #reset()} on this response only clears the buffered headers. If there is any\n- * content written to response it throws {@link IllegalStateException}.\n+ * Calling {@link #reset()} on this response clears the buffered meta data, if there is already any\n+ * content written it throws {@link IllegalStateException}.\n  * \n  * @author Matej Knopp\n  */\n class HeaderBufferingWebResponse extends WebResponse implements IMetaDataBufferingWebResponse\n {\n \tprivate final WebResponse originalResponse;\n+\n+\t/**\n+\t * Buffer of meta data.\n+\t */\n \tprivate final BufferedWebResponse bufferedResponse;\n \n \tpublic HeaderBufferingWebResponse(WebResponse originalResponse)\n@@ -46,113 +51,107 @@ public HeaderBufferingWebResponse(WebResponse originalResponse)\n \t\tbufferedResponse = new BufferedWebResponse(originalResponse);\n \t}\n \n-\tprivate boolean bufferedWritten = false;\n+\tprivate boolean buffering = true;\n \n-\tprivate void writeBuffered()\n+\tprivate void stopBuffering()\n \t{\n-\t\tif (!bufferedWritten)\n+\t\tif (buffering)\n \t\t{\n \t\t\tbufferedResponse.writeTo(originalResponse);\n-\t\t\tbufferedWritten = true;\n+\t\t\tbuffering = false;\n \t\t}\n \t}\n \n-\tprivate void checkHeader()\n+\t/**\n+\t * The response used for meta data.\n+\t * \n+\t * @return buffered response if nothing was written yet, the original response otherwise\n+\t */\n+\tprivate WebResponse getMetaResponse()\n+\t{\n+\t\tif (buffering)\n \t\t{\n-\t\tif (bufferedWritten)\n+\t\t\treturn bufferedResponse;\n+\t\t}\n+\t\telse\n \t\t{\n-\t\t\tthrow new IllegalStateException(\"Header was already written to response!\");\n+\t\t\treturn originalResponse;\n \t\t}\n \t}\n \n \t@Override\n \tpublic void addCookie(Cookie cookie)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.addCookie(cookie);\n+\t\tgetMetaResponse().addCookie(cookie);\n \t}\n \n \t@Override\n \tpublic void clearCookie(Cookie cookie)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.clearCookie(cookie);\n+\t\tgetMetaResponse().clearCookie(cookie);\n \t}\n \n-\tprivate boolean flushed = false;\n-\n \t@Override\n \tpublic void flush()\n \t{\n-\t\tif (!bufferedWritten)\n-\t\t{\n-\t\t\tbufferedResponse.writeTo(originalResponse);\n-\t\t\tbufferedResponse.reset();\n-\t\t}\n+\t\tstopBuffering();\n+\n \t\toriginalResponse.flush();\n-\t\tflushed = true;\n \t}\n \n \t@Override\n \tpublic boolean isRedirect()\n \t{\n-\t\treturn bufferedResponse.isRedirect();\n+\t\treturn getMetaResponse().isRedirect();\n \t}\n \n \t@Override\n \tpublic void sendError(int sc, String msg)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.sendError(sc, msg);\n+\t\tgetMetaResponse().sendError(sc, msg);\n \t}\n \n \t@Override\n \tpublic void sendRedirect(String url)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.sendRedirect(url);\n+\t\tgetMetaResponse().sendRedirect(url);\n \t}\n \n \t@Override\n \tpublic void setContentLength(long length)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.setContentLength(length);\n+\t\tgetMetaResponse().setContentLength(length);\n \t}\n \n \t@Override\n \tpublic void setContentType(String mimeType)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.setContentType(mimeType);\n+\t\tgetMetaResponse().setContentType(mimeType);\n \t}\n \n \t@Override\n \tpublic void setDateHeader(String name, Time date)\n \t{\n \t\tArgs.notNull(date, \"date\");\n-\t\tcheckHeader();\n-\t\tbufferedResponse.setDateHeader(name, date);\n+\t\tgetMetaResponse().setDateHeader(name, date);\n \t}\n \n \t@Override\n \tpublic void setHeader(String name, String value)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.setHeader(name, value);\n+\t\tgetMetaResponse().setHeader(name, value);\n \t}\n \n \t@Override\n \tpublic void addHeader(String name, String value)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.addHeader(name, value);\n+\t\tgetMetaResponse().addHeader(name, value);\n \t}\n \n \t@Override\n \tpublic void setStatus(int sc)\n \t{\n-\t\tbufferedResponse.setStatus(sc);\n+\t\tgetMetaResponse().setStatus(sc);\n \t}\n \n \t@Override\n@@ -170,14 +169,16 @@ public String encodeRedirectURL(CharSequence url)\n \t@Override\n \tpublic void write(CharSequence sequence)\n \t{\n-\t\twriteBuffered();\n+\t\tstopBuffering();\n+\n \t\toriginalResponse.write(sequence);\n \t}\n \n \t@Override\n \tpublic void write(byte[] array)\n \t{\n-\t\twriteBuffered();\n+\t\tstopBuffering();\n+\n \t\toriginalResponse.write(array);\n \t}\n \n@@ -185,19 +186,24 @@ public void write(byte[] array)\n \t@Override\n \tpublic void write(byte[] array, int offset, int length)\n \t{\n-\t\twriteBuffered();\n+\t\tstopBuffering();\n+\n \t\toriginalResponse.write(array, offset, length);\n \t}\n \n \t@Override\n \tpublic void reset()\n \t{\n-\t\tif (flushed)\n+\t\tif (buffering)\n \t\t{\n-\t\t\tthrow new IllegalStateException(\"Response has already been flushed!\");\n-\t\t}\n+\t\t\t// still buffering so just reset the buffer of meta data\n \t\t\tbufferedResponse.reset();\n-\t\tbufferedWritten = false;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\t// the original response is never reset (see class javadoc)\n+\t\t\tthrow new IllegalStateException(\"Response is no longer buffering!\");\n+\t\t}\n \t}\n \n \t@Override\n", "nb_test": 1442, "linesAdd": 37, "jira_id": "4927", "singleLine": false, "nb_skipped": 5, "commit": "8c827e33", "nb_failure": 1, "linesRem": 42}, {"files": 3, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRender10(org.apache.wicket.markup.html.internal.EnclosureTest): org/apache/wicket/markup/html/internal/EnclosurePageExpectedResult_10-2.html expected:<...ns:wicket>", "testStatelessComponentPage(org.apache.wicket.stateless.StatelessComponentTest): org/apache/wicket/stateless/StatelessComponentPage_result.html expected:<...telessComponentPage?[1-0].ILinkListener-link\"...> but was:<...telessComponentPage?[0-1].ILinkListener-link\"...>", "testStatelessComponentPageWithMount(org.apache.wicket.stateless.StatelessComponentTest): org/apache/wicket/stateless/StatelessComponentPage_mount_result.html expected:<...", "testStatelessComponentPageWithParams(org.apache.wicket.stateless.StatelessComponentTest): org/apache/wicket/stateless/StatelessComponentPageWithParams_result.html expected:<...onentPageWithParams?[1-0].ILinkListener-link&...> but was:<...onentPageWithParams?[0-1].ILinkListener-link&...>", "testStatelessComponentPageWithParamsWithMount(org.apache.wicket.stateless.StatelessComponentTest): org/apache/wicket/stateless/StatelessComponentPageWithParams_mount_result.html expected:<...", "testStatelessComponentPageWithParamsWithIndexMount(org.apache.wicket.stateless.StatelessComponentTest): org/apache/wicket/stateless/StatelessComponentPageWithParams_indexed_mount_result.html expected:<...<a href=\"testValue2?[1-0].ILinkListener-link\"...> but was:<...<a href=\"testValue2?[0-1].ILinkListener-link\"...>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 13ab5e1..a762035 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -3284,15 +3284,18 @@ public String toString(final boolean detailed)\n \tpublic final CharSequence urlFor(final Behavior behaviour,\n \t\tfinal RequestListenerInterface listener)\n \t{\n-\t\tPageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);\n \t\tint id = getBehaviorId(behaviour);\n+\t\tPage page = getPage();\n \t\tIRequestHandler handler;\n-\t\tif (getPage().isPageStateless())\n+\t\tif (page.isPageStateless())\n \t\t{\n+\t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(page.getPageClass(),\n+\t\t\t\tpage.getPageParameters(), getPageRelativePath());\n \t\t\thandler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);\n \t\t}\n \t\telse\n \t\t{\n+\t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(page, this);\n \t\t\thandler = new ListenerInterfaceRequestHandler(provider, listener, id);\n \t\t}\n \t\treturn getRequestCycle().urlFor(handler);\n@@ -3324,14 +3327,17 @@ public final CharSequence urlFor(final IRequestHandler requestHandler)\n \t */\n \tpublic final CharSequence urlFor(final RequestListenerInterface listener)\n \t{\n-\t\tPageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);\n+\t\tPage page = getPage();\n \t\tIRequestHandler handler;\n-\t\tif (getPage().isPageStateless())\n+\t\tif (page.isPageStateless())\n \t\t{\n+\t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(page.getPageClass(),\n+\t\t\t\tpage.getPageParameters(), getPageRelativePath());\n \t\t\thandler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\n \t\t}\n \t\telse\n \t\t{\n+\t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(page, this);\n \t\t\thandler = new ListenerInterfaceRequestHandler(provider, listener);\n \t\t}\n \t\treturn getRequestCycle().urlFor(handler);\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/mock/MockPageManager.java b/wicket-core/src/main/java/org/apache/wicket/mock/MockPageManager.java\nindex 3cf9213..cf18216 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/mock/MockPageManager.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/mock/MockPageManager.java\n@@ -78,8 +78,11 @@ public boolean supportsVersioning()\n \n \tpublic void touchPage(IManageablePage page)\n \t{\n+\t\tif (page.isPageStateless() == false)\n+\t\t{\n \t\t\tpages.put(page.getPageId(), page);\n \t\t}\n+\t}\n \n \t/**\n \t * @see org.apache.wicket.page.IPageManager#getContext()\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\nindex 379b473..c9569a8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n@@ -17,6 +17,7 @@\n package org.apache.wicket.request.handler;\n \n import org.apache.wicket.Application;\n+import org.apache.wicket.Page;\n import org.apache.wicket.Session;\n import org.apache.wicket.page.IPageManager;\n import org.apache.wicket.protocol.http.PageExpiredException;\n@@ -148,6 +149,10 @@ public PageProvider(IRequestablePage page)\n \t\tArgs.notNull(page, \"page\");\n \n \t\tpageInstance = page;\n+\t\tif (pageInstance instanceof Page)\n+\t\t{\n+\t\t\t((Page)pageInstance).setStatelessHint(false);\n+\t\t}\n \t}\n \n \t/**\n", "nb_test": 1163, "linesAdd": 18, "jira_id": "3965", "singleLine": false, "nb_skipped": 2, "commit": "6051019b", "nb_failure": 6, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testOnePassRenderAndAjaxRequest(org.apache.wicket.request.handler.render.WebPageRendererTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex 37b718b..c3a0166 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -163,7 +163,8 @@ public void respond(RequestCycle requestCycle)\n \t\t\t// if there is saved response for this URL render it\n \t\t\tbufferedResponse.writeTo((WebResponse)requestCycle.getResponse());\n \t\t}\n-\t\telse if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || isOnePassRender() //\n+\t\telse if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT ||\n+\t\t\t(isOnePassRender() && isAjax == false) //\n \t\t\t||\n \t\t\t(!isAjax //\n \t\t\t\t&&\n", "nb_test": 1187, "linesAdd": 2, "jira_id": "3617", "singleLine": false, "nb_skipped": 1, "commit": "7ae109a6", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["customDateConverter(org.apache.wicket.ConverterLocatorTest): expected not same"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java b/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\nindex 5e48a83..6c85808 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\n@@ -189,8 +189,10 @@ public ConverterLocator()\n \tpublic final <C> IConverter<C> get(Class<C> c)\n \t{\n \t\t@SuppressWarnings(\"unchecked\")\n-\t\tfinal IConverter<C> converter;\n+\t\tIConverter<C> converter = (IConverter<C>)classToConverter.get(c.getName());\n \n+\t\tif (converter == null)\n+\t\t{\n \t\t\t// Date based converters work with thread unsafe DateFormats and\n \t\t\t// a new instance should be created for each usage\n \t\t\tif (Date.class.equals(c))\n@@ -213,9 +215,6 @@ else if (Calendar.class.equals(c))\n \t\t\t{\n \t\t\t\tconverter = (IConverter<C>) new CalendarConverter();\n \t\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tconverter = (IConverter<C>)classToConverter.get(c.getName());\n \t\t}\n \t\treturn converter;\n \t}\n", "nb_test": 1425, "linesAdd": 3, "jira_id": "4839", "singleLine": false, "nb_skipped": 5, "commit": "8b294488", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testUNIXWICKET501(org.apache.wicket.util.string.JavascriptStripperTest)", "testDOSWICKET501(org.apache.wicket.util.string.JavascriptStripperTest)", "testMACWICKET501(org.apache.wicket.util.string.JavascriptStripperTest)", "testRegexp(org.apache.wicket.util.string.JavascriptStripperTest)", "testRegexp4(org.apache.wicket.util.string.JavascriptStripperTest)", "testWICKET1806(org.apache.wicket.util.string.JavascriptStripperTest)", "testWICKET2060_1(org.apache.wicket.util.string.JavascriptStripperTest)", "testWICKET2060_2(org.apache.wicket.util.string.JavascriptStripperTest)", "testWICKET2060_3(org.apache.wicket.util.string.JavascriptStripperTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/util/string/JavascriptStripper.java b/wicket/src/main/java/org/apache/wicket/util/string/JavascriptStripper.java\nindex e21e9d4..10d05a2 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/string/JavascriptStripper.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/string/JavascriptStripper.java\n@@ -78,6 +78,7 @@ public static String stripCommentsAndWhitespace(String original)\n \t\t// let's be optimistic\n \t\tAppendingStringBuffer result = new AppendingStringBuffer(original.length() / 2);\n \t\tint state = REGULAR_TEXT;\n+\t\tboolean wasNewLineInWhitespace = false;\n \n \t\tfor (int i = 0; i < original.length(); ++i)\n \t\t{\n@@ -87,6 +88,12 @@ public static String stripCommentsAndWhitespace(String original)\n \n \t\t\tif (state == WHITE_SPACE)\n \t\t\t{\n+\t\t\t\t// WICKET 2060\n+\t\t\t\tif (c == '\\n' && !wasNewLineInWhitespace)\n+\t\t\t\t{\n+\t\t\t\t\tresult.append(\"\\n\");\n+\t\t\t\t\twasNewLineInWhitespace = true;\n+\t\t\t\t}\n \t\t\t\tif (Character.isWhitespace(next) == false)\n \t\t\t\t{\n \t\t\t\t\tstate = REGULAR_TEXT;\n@@ -123,7 +130,7 @@ else if (c == '/')\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (tmp == '=' || tmp == '(' || tmp == '{' || tmp == ':' || tmp == ',' ||\n-\t\t\t\t\t\t\ttmp == '[')\n+\t\t\t\t\t\t\ttmp == '[' || tmp == ';')\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tstate = REG_EXP;\n \t\t\t\t\t\t\tbreak;\n@@ -133,9 +140,18 @@ else if (c == '/')\n \t\t\t\t}\n \t\t\t\telse if (Character.isWhitespace(c) && Character.isWhitespace(next))\n \t\t\t\t{\n+\t\t\t\t\t// WICKET-2060\n+\t\t\t\t\tif (c == '\\n' || next == '\\n')\n+\t\t\t\t\t{\n+\t\t\t\t\t\tc = '\\n';\n+\t\t\t\t\t\twasNewLineInWhitespace = true;\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t{\n+\t\t\t\t\t\tc = ' ';\n+\t\t\t\t\t}\n \t\t\t\t\t// ignore all whitespace characters after this one\n \t\t\t\t\tstate = WHITE_SPACE;\n-\t\t\t\t\tc = '\\n';\n \t\t\t\t}\n \t\t\t\telse if (c == '\\'')\n \t\t\t\t{\n", "nb_test": 760, "linesAdd": 16, "jira_id": "2060", "singleLine": false, "nb_skipped": 0, "commit": "0578d6ee", "nb_failure": 9, "linesRem": 2}, {"files": 9, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test_1(wicket.util.tester.apps_4.FormTesterTest)", "testCreateBook_validateFail(wicket.util.tester.WicketTesterTest): (..)", "testCreateBook_validatePass(wicket.util.tester.WicketTesterTest): (..)"], "patch": "diff --git a/jdk-1.4/wicket/src/main/java/wicket/Component.java b/jdk-1.4/wicket/src/main/java/wicket/Component.java\nindex cd19915..a360e4f 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/Component.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/Component.java\n@@ -662,7 +662,7 @@ public final boolean continueToOriginalDestination()\n \t */\n \tpublic final void debug(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().debug(this, message);\n+\t\tSession.get().getFeedbackMessages().debug(this, message);\n \t}\n \n \t/**\n@@ -685,7 +685,7 @@ public void detachModels()\n \t */\n \tpublic final void error(final Serializable message)\n \t{\n-\t\tgetPage().getFeedbackMessages().error(this, message);\n+\t\tSession.get().getFeedbackMessages().error(this, message);\n \t}\n \n \t/**\n@@ -696,7 +696,7 @@ public final void error(final Serializable message)\n \t */\n \tpublic final void fatal(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().fatal(this, message);\n+\t\tSession.get().getFeedbackMessages().fatal(this, message);\n \t}\n \n \t/**\n@@ -825,7 +825,7 @@ public final boolean getEscapeModelStrings()\n \t */\n \tpublic final FeedbackMessage getFeedbackMessage()\n \t{\n-\t\treturn getPage().getFeedbackMessages().messageForComponent(this);\n+\t\treturn Session.get().getFeedbackMessages().messageForComponent(this);\n \t}\n \n \t/**\n@@ -1216,7 +1216,7 @@ public String getVariation()\n \t */\n \tpublic final boolean hasErrorMessage()\n \t{\n-\t\treturn getPage().getFeedbackMessages().hasErrorMessageFor(this);\n+\t\treturn Session.get().getFeedbackMessages().hasErrorMessageFor(this);\n \t}\n \n \t/**\n@@ -1224,7 +1224,7 @@ public final boolean hasErrorMessage()\n \t */\n \tpublic final boolean hasFeedbackMessage()\n \t{\n-\t\treturn getPage().getFeedbackMessages().hasMessageFor(this);\n+\t\treturn Session.get().getFeedbackMessages().hasMessageFor(this);\n \t}\n \n \t/**\n@@ -1235,7 +1235,7 @@ public final boolean hasFeedbackMessage()\n \t */\n \tpublic final void info(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().info(this, message);\n+\t\tSession.get().getFeedbackMessages().info(this, message);\n \t}\n \n \t/**\n@@ -2376,7 +2376,7 @@ public final CharSequence urlFor(final ResourceReference resourceReference)\n \t */\n \tpublic final void warn(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().warn(this, message);\n+\t\tSession.get().getFeedbackMessages().warn(this, message);\n \t}\n \n \t/**\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/Page.java b/jdk-1.4/wicket/src/main/java/wicket/Page.java\nindex c67365c..24c9a2c 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/Page.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/Page.java\n@@ -25,7 +25,6 @@\n import org.apache.commons.logging.LogFactory;\n \n import wicket.authorization.UnauthorizedActionException;\n-import wicket.feedback.FeedbackMessages;\n import wicket.feedback.IFeedback;\n import wicket.markup.MarkupException;\n import wicket.markup.MarkupStream;\n@@ -134,6 +133,12 @@\n  */\n public abstract class Page extends MarkupContainer implements IRedirectListener, IPageMapEntry\n {\n+\t/**\n+\t * When passed to {@link Page#getVersion(int)} the latest page version is\n+\t * returned.\n+\t */\n+\tpublic static final int LATEST_VERSION = -1;\n+\n \tprivate static final long serialVersionUID = 1L;\n \n \t/**\n@@ -141,12 +146,6 @@\n \t */\n \tprivate static final ConcurrentHashMap pageClassToBookmarkableCache = new ConcurrentHashMap();\n \n-\t/**\n-\t * When passed to {@link Page#getVersion(int)} the latest page version is\n-\t * returned.\n-\t */\n-\tpublic static final int LATEST_VERSION = -1;\n-\n \t/** True if this page is currently rendering. */\n \tprivate static final short FLAG_IS_RENDERING = FLAG_RESERVED2;\n \n@@ -165,9 +164,6 @@\n \t/** Used to create page-unique numbers */\n \tprivate short autoIndex;\n \n-\t/** Feedback messages for this page */\n-\tprivate FeedbackMessages feedbackMessages;\n-\n \t/** Numeric version of this page's id */\n \tprivate short numericId;\n \n@@ -284,6 +280,35 @@ public void beforeCallComponent(final Component component,\n \n \n \t/**\n+\t * Adds a component to the set of rendered components.\n+\t * \n+\t * @param component\n+\t *            The component that was rendered\n+\t */\n+\tpublic final void componentRendered(final Component component)\n+\t{\n+\t\t// Inform the page that this component rendered\n+\t\tif (Application.get().getDebugSettings().getComponentUseCheck())\n+\t\t{\n+\t\t\tif (renderedComponents == null)\n+\t\t\t{\n+\t\t\t\trenderedComponents = new HashSet();\n+\t\t\t}\n+\t\t\tif (renderedComponents.add(component) == false)\n+\t\t\t{\n+\t\t\t\tthrow new MarkupException(\n+\t\t\t\t\t\t\"The component \"\n+\t\t\t\t\t\t\t\t+ component\n+\t\t\t\t\t\t\t\t+ \" has the same wicket:id as another component already added at the same level\");\n+\t\t\t}\n+\t\t\tif (log.isDebugEnabled())\n+\t\t\t{\n+\t\t\t\tlog.debug(\"Rendered \" + component);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n \t * Detaches any attached models referenced by this page.\n \t */\n \tpublic void detachModels()\n@@ -300,7 +325,8 @@ public void detachModels()\n \t\t// }\n \t\t// catch (Exception e) // catch anything; we MUST detach all models\n \t\t// {\n-//\t\t\t\t\tlog.error(\"detaching models of component \" + component + \" failed:\", e);\n+\t\t// log.error(\"detaching models of component \" + component + \" failed:\",\n+\t\t// e);\n \t\t// }\n \t\t// return IVisitor.CONTINUE_TRAVERSAL;\n \t\t// }\n@@ -318,88 +344,6 @@ public final void dirty()\n \t}\n \n \t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL IT.\n-\t */\n-\tpublic final void renderPage()\n-\t{\n-\t\t// first try to check if the page can be rendered:\n-\t\tif (!isActionAuthorized(RENDER))\n-\t\t{\n-\t\t\tif (log.isDebugEnabled())\n-\t\t\t{\n-\t\t\t\tlog.debug(\"Page not allowed to render: \" + this);\n-\t\t\t}\n-\t\t\tthrow new UnauthorizedActionException(this, Component.RENDER);\n-\t\t}\n-\n-\t\t// Make sure it is really empty\n-\t\trenderedComponents = null;\n-\n-\t\t// Reset it to stateless so that it can be tested again\n-\t\tthis.stateless = null;\n-\n-\t\t// Set form component values from cookies\n-\t\tsetFormComponentValuesFromCookies();\n-\n-\t\t// First, give priority to IFeedback instances, as they have to\n-\t\t// collect their messages before components like ListViews\n-\t\t// remove any child components\n-\t\tvisitChildren(IFeedback.class, new IVisitor()\n-\t\t{\n-\t\t\tpublic Object component(Component component)\n-\t\t\t{\n-\t\t\t\t((IFeedback)component).updateFeedback();\n-\t\t\t\tcomponent.attach();\n-\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n-\t\t\t}\n-\t\t});\n-\n-\t\tif (this instanceof IFeedback)\n-\t\t{\n-\t\t\t((IFeedback)this).updateFeedback();\n-\t\t}\n-\n-\t\t// Now, do the initialization for the other components\n-\t\tattach();\n-\n-\t\t// Visit all this page's children to reset markup streams and check\n-\t\t// rendering authorization, as appropriate. We set any result; positive\n-\t\t// or negative as a temporary boolean in the components, and when a\n-\t\t// authorization exception is thrown it will block the rendering of this\n-\t\t// page\n-\n-\t\t// first the page itself\n-\t\tsetRenderAllowed(isActionAuthorized(RENDER));\n-\t\t// children of the page\n-\t\tvisitChildren(new IVisitor()\n-\t\t{\n-\t\t\tpublic Object component(final Component component)\n-\t\t\t{\n-\t\t\t\t// Find out if this component can be rendered\n-\t\t\t\tfinal boolean renderAllowed = component.isActionAuthorized(RENDER);\n-\n-\t\t\t\t// Authorize rendering\n-\t\t\t\tcomponent.setRenderAllowed(renderAllowed);\n-\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n-\t\t\t}\n-\t\t});\n-\n-\t\t// Handle request by rendering page\n-\t\trender(null);\n-\n-\t\t// Check rendering if it happened fully\n-\t\tcheckRendering(this);\n-\n-\t\tif (!isPageStateless())\n-\t\t{\n-\t\t\t// trigger creation of the actual session in case it was deferred\n-\t\t\tSession.get().getSessionStore().getSessionId(RequestCycle.get().getRequest(), true);\n-\t\t\t// Add/touch the response page in the session (its pagemap).\n-\t\t\tgetSession().touch(this);\n-\t\t}\n-\t}\n-\n-\t/**\n \t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n \t * \n \t * This method is called when a component was rendered standalone. If it is\n@@ -432,6 +376,14 @@ public final void expireOldestVersion()\n \t}\n \n \t/**\n+\t * @return The current ajax version number of this page.\n+\t */\n+\tpublic final int getAjaxVersionNumber()\n+\t{\n+\t\treturn versionManager == null ? 0 : versionManager.getAjaxVersionNumber();\n+\t}\n+\n+\t/**\n \t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL IT.\n \t * \n \t * Get a page unique number, which will be increased with each call.\n@@ -455,42 +407,6 @@ public final int getCurrentVersionNumber()\n \t}\n \n \t/**\n-\t * @return The current ajax version number of this page. \n-\t */\n-\tpublic final int getAjaxVersionNumber()\n-\t{\n-\t\treturn versionManager == null ? 0 : versionManager.getAjaxVersionNumber();\n-\t}\n-\t\n-\t/**\n-\t * This returns a page instance that is rollbacked the number of versions\n-\t * that is specified compared to the current page.\n-\t * \n-\t * This is a rollback including ajax versions. \n-\t * \n-\t * @param numberOfVersions to rollback\n-\t * @return\n-\t */\n-\tpublic final Page rollbackPage(int numberOfVersions)\n-\t{\n-\t\tPage page =  versionManager == null? this : versionManager.rollbackPage(numberOfVersions);\n-\t\tgetSession().touch(page);\n-\t\treturn page;\n-\t}\n-\t/**\n-\t * @return Returns feedback messages from all components in this page\n-\t *         (including the page itself).\n-\t */\n-\tpublic final FeedbackMessages getFeedbackMessages()\n-\t{\n-\t\tif (feedbackMessages == null)\n-\t\t{\n-\t\t\tfeedbackMessages = new FeedbackMessages();\n-\t\t}\n-\t\treturn feedbackMessages;\n-\t}\n-\n-\t/**\n \t * @see wicket.Component#getId()\n \t */\n \tpublic final String getId()\n@@ -610,7 +526,8 @@ public Page getVersion(final int versionNumber)\n \t\t\t\t}\n \n \t\t\t\t// If we went all the way back to the original page\n-\t\t\t\tif (page != null && page.getCurrentVersionNumber() == 0 && page.getAjaxVersionNumber() == 0)\n+\t\t\t\tif (page != null && page.getCurrentVersionNumber() == 0\n+\t\t\t\t\t\t&& page.getAjaxVersionNumber() == 0)\n \t\t\t\t{\n \t\t\t\t\t// remove version info\n \t\t\t\t\tpage.versionManager = null;\n@@ -659,6 +576,28 @@ public Object component(Component component)\n \t}\n \n \t/**\n+\t * Call this method when the current (ajax) request shouldn't merge the\n+\t * changes that are happening to the page with the previous version.\n+\t * \n+\t * This is for example needed when you want to redirect to this page in an\n+\t * ajax request and then you do want to version normally..\n+\t * \n+\t * This method doesn't do anything if the getRequest().mergeVersion doesn't\n+\t * return true.\n+\t */\n+\tpublic final void ignoreVersionMerge()\n+\t{\n+\t\tif (getRequest().mergeVersion())\n+\t\t{\n+\t\t\tmayTrackChangesFor(this, null);\n+\t\t\tif (versionManager != null)\n+\t\t\t{\n+\t\t\t\tversionManager.ignoreVersionMerge();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n \t * Bookmarkable page can be instantiated using a bookmarkable URL.\n \t * \n \t * @return Returns true if the page is bookmarkable.\n@@ -714,16 +653,6 @@ public boolean isErrorPage()\n \t}\n \n \t/**\n-\t * Set page stateless\n-\t * \n-\t * @param stateless\n-\t */\n-\tvoid setPageStateless(Boolean stateless)\n-\t{\n-\t\tthis.stateless = stateless;\n-\t}\n-\n-\t/**\n \t * Gets whether the page is stateless. Components on stateless page must not\n \t * render any statefull urls, and components on statefull page must not\n \t * render any stateless urls. Statefull urls are urls, which refer to a\n@@ -827,288 +756,117 @@ public Object component(final Component component)\n \t}\n \n \t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n-\t * \n-\t * Set the id for this Page. This method is called by PageMap when a Page is\n-\t * added because the id, which is assigned by PageMap, is not known until\n-\t * this time.\n-\t * \n-\t * @param id\n-\t *            The id\n-\t */\n-\tpublic final void setNumericId(final int id)\n-\t{\n-\t\tthis.numericId = (short)id;\n-\t}\n-\n-\t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n-\t * \n-\t * This method is called when a component will be rendered standalone.\n-\t * \n-\t * @param component\n-\t * \n-\t */\n-\tpublic final void startComponentRender(Component component)\n-\t{\n-\t\trenderedComponents = null;\n-\t}\n-\n-\t/**\n-\t * Get the string representation of this container.\n-\t * \n-\t * @return String representation of this container\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL IT.\n \t */\n-\tpublic String toString()\n+\tpublic final void renderPage()\n \t{\n-\t\tif(versionManager != null)\n+\t\t// first try to check if the page can be rendered:\n+\t\tif (!isActionAuthorized(RENDER))\n \t\t{\n-\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \n-\t\t\t\t\", version = \" + versionManager.getCurrentVersionNumber()  + \", ajax = \" + \n-\t\t\t\tversionManager.getAjaxVersionNumber() + \"]\";\t\n-\t\t}\n-\t\telse\n+\t\t\tif (log.isDebugEnabled())\n \t\t\t{\n-\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \", version = \" + 0 + \"]\";\n+\t\t\t\tlog.debug(\"Page not allowed to render: \" + this);\n \t\t\t}\n+\t\t\tthrow new UnauthorizedActionException(this, Component.RENDER);\n \t\t}\n \n-\t/**\n-\t * Set-up response with appropriate content type, locale and encoding. The\n-\t * locale is set equal to the session's locale. The content type header\n-\t * contains information about the markup type (@see #getMarkupType()) and\n-\t * the encoding. The response (and request) encoding is determined by an\n-\t * application setting (@see\n-\t * ApplicationSettings#getResponseRequestEncoding()). In addition, if the\n-\t * page's markup contains a xml declaration like &lt?xml ... ?&gt; an xml\n-\t * declaration with proper encoding information is written to the output as\n-\t * well, provided it is not disabled by an applicaton setting (@see\n-\t * ApplicationSettings#getStripXmlDeclarationFromOutput()).\n-\t * <p>\n-\t * Note: Prior to Wicket 1.1 the output encoding was determined by the\n-\t * page's markup encoding. Because this caused uncertainties about the\n-\t * /request/ encoding, it has been changed in favour of the new, much safer,\n-\t * approach. Please see the Wiki for more details.\n-\t */\n-\tprotected void configureResponse()\n-\t{\n-\t\t// Get the response and application\n-\t\tfinal RequestCycle cycle = getRequestCycle();\n-\t\tfinal Application application = cycle.getApplication();\n-\t\tfinal Response response = cycle.getResponse();\n+\t\t// Make sure it is really empty\n+\t\trenderedComponents = null;\n \n-\t\t// Determine encoding\n-\t\tfinal String encoding = application.getRequestCycleSettings().getResponseRequestEncoding();\n+\t\t// Reset it to stateless so that it can be tested again\n+\t\tthis.stateless = null;\n \n-\t\t// Set content type based on markup type for page\n-\t\tresponse.setContentType(\"text/\" + getMarkupType() + \"; charset=\" + encoding);\n+\t\t// Set form component values from cookies\n+\t\tsetFormComponentValuesFromCookies();\n \n-\t\t// Write out an xml declaration if the markup stream and settings allow\n-\t\tfinal MarkupStream markupStream = findMarkupStream();\n-\t\tif ((markupStream != null) && (markupStream.getXmlDeclaration() != null)\n-\t\t\t\t&& (application.getMarkupSettings().getStripXmlDeclarationFromOutput() == false))\n+\t\t// First, give priority to IFeedback instances, as they have to\n+\t\t// collect their messages before components like ListViews\n+\t\t// remove any child components\n+\t\tvisitChildren(IFeedback.class, new IVisitor()\n \t\t{\n-\t\t\tresponse.write(\"<?xml version='1.0' encoding='\");\n-\t\t\tresponse.write(encoding);\n-\t\t\tresponse.write(\"'?>\");\n-\t\t}\n-\n-\t\t// Set response locale from session locale\n-\t\tresponse.setLocale(getSession().getLocale());\n+\t\t\tpublic Object component(Component component)\n+\t\t\t{\n+\t\t\t\t((IFeedback)component).updateFeedback();\n+\t\t\t\tcomponent.attach();\n+\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n \t\t\t}\n+\t\t});\n \n-\t/**\n-\t * @see wicket.Component#onDetach()\n-\t */\n-\tprotected void onDetach()\n-\t{\n-\t\tif (log.isDebugEnabled())\n+\t\tif (this instanceof IFeedback)\n \t\t{\n-\t\t\tlog.debug(\"ending request for page \" + this + \", request \" + getRequest());\n+\t\t\t((IFeedback)this).updateFeedback();\n \t\t}\n \n-\t\tendVersion();\n+\t\t// Now, do the initialization for the other components\n+\t\tattach();\n \n-\t\tsuper.onDetach();\n-\t}\n+\t\t// Visit all this page's children to reset markup streams and check\n+\t\t// rendering authorization, as appropriate. We set any result; positive\n+\t\t// or negative as a temporary boolean in the components, and when a\n+\t\t// authorization exception is thrown it will block the rendering of this\n+\t\t// page\n \n-\t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n-\t * OVERRIDE.\n-\t * \n-\t * @see wicket.Component#internalOnModelChanged()\n-\t */\n-\tprotected final void internalOnModelChanged()\n-\t{\n-\t\tvisitChildren(new Component.IVisitor()\n+\t\t// first the page itself\n+\t\tsetRenderAllowed(isActionAuthorized(RENDER));\n+\t\t// children of the page\n+\t\tvisitChildren(new IVisitor()\n \t\t{\n \t\t\tpublic Object component(final Component component)\n \t\t\t{\n-\t\t\t\t// If form component is using form model\n-\t\t\t\tif (component.sameRootModel(Page.this))\n-\t\t\t\t{\n-\t\t\t\t\tcomponent.modelChanged();\n-\t\t\t\t}\n+\t\t\t\t// Find out if this component can be rendered\n+\t\t\t\tfinal boolean renderAllowed = component.isActionAuthorized(RENDER);\n+\n+\t\t\t\t// Authorize rendering\n+\t\t\t\tcomponent.setRenderAllowed(renderAllowed);\n \t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n \t\t\t}\n \t\t});\n-\t}\n \n-\t/**\n-\t * @return Factory method that creates a version manager for this Page\n-\t */\n-\tprotected final IPageVersionManager newVersionManager()\n-\t{\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Renders this container to the given response object.\n-\t * \n-\t * @param markupStream\n-\t */\n-\tprotected void onRender(final MarkupStream markupStream)\n-\t{\n-\t\t// Set page's associated markup stream\n-\t\tfinal MarkupStream associatedMarkupStream = getAssociatedMarkupStream(true);\n-\t\tsetMarkupStream(associatedMarkupStream);\n-\n-\t\t// Configure response object with locale and content type\n-\t\tconfigureResponse();\n-\n-\t\t// Render all the page's markup\n-\t\tsetFlag(FLAG_IS_RENDERING, true);\n-\t\ttry\n-\t\t{\n-\t\t\trenderAll(associatedMarkupStream);\n-\t\t}\n-\t\tfinally\n-\t\t{\n-\t\t\tsetFlag(FLAG_IS_RENDERING, false);\n-\t\t}\n-\t}\n+\t\t// Handle request by rendering page\n+\t\trender(null);\n \n-\t/**\n-\t * A component was added.\n-\t * \n-\t * @param component\n-\t *            The component that was added\n-\t */\n-\tfinal void componentAdded(final Component component)\n-\t{\n-\t\tcheckHierarchyChange(component);\n+\t\t// Check rendering if it happened fully\n+\t\tcheckRendering(this);\n \n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\t\tif (!isPageStateless())\n \t\t{\n-\t\t\tversionManager.componentAdded(component);\n+\t\t\t// trigger creation of the actual session in case it was deferred\n+\t\t\tSession.get().getSessionStore().getSessionId(RequestCycle.get().getRequest(), true);\n+\t\t\t// Add/touch the response page in the session (its pagemap).\n+\t\t\tgetSession().touch(this);\n \t\t}\n \t}\n \n \t/**\n-\t * A component's model changed.\n+\t * This returns a page instance that is rollbacked the number of versions\n+\t * that is specified compared to the current page.\n \t * \n-\t * @param component\n-\t *            The component whose model is about to change\n-\t */\n-\tfinal void componentModelChanging(final Component component)\n-\t{\n-\t\tcheckHierarchyChange(component);\n-\n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, null))\n-\t\t{\n-\t\t\tversionManager.componentModelChanging(component);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * A component was removed.\n+\t * This is a rollback including ajax versions.\n \t * \n-\t * @param component\n-\t *            The component that was removed\n+\t * @param numberOfVersions\n+\t *            to rollback\n+\t * @return\n \t */\n-\tfinal void componentRemoved(final Component component)\n-\t{\n-\t\tcheckHierarchyChange(component);\n-\n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\tpublic final Page rollbackPage(int numberOfVersions)\n \t{\n-\t\t\tversionManager.componentRemoved(component);\n-\t\t}\n+\t\tPage page = versionManager == null ? this : versionManager.rollbackPage(numberOfVersions);\n+\t\tgetSession().touch(page);\n+\t\treturn page;\n \t}\n \n \t/**\n-\t * Adds a component to the set of rendered components.\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n \t * \n-\t * @param component\n-\t *            The component that was rendered\n-\t */\n-\tpublic final void componentRendered(final Component component)\n-\t{\n-\t\t// Inform the page that this component rendered\n-\t\tif (Application.get().getDebugSettings().getComponentUseCheck())\n-\t\t{\n-\t\t\tif (renderedComponents == null)\n-\t\t\t{\n-\t\t\t\trenderedComponents = new HashSet();\n-\t\t\t}\n-\t\t\tif (renderedComponents.add(component) == false)\n-\t\t\t{\n-\t\t\t\tthrow new MarkupException(\n-\t\t\t\t\t\t\"The component \"\n-\t\t\t\t\t\t\t\t+ component\n-\t\t\t\t\t\t\t\t+ \" has the same wicket:id as another component already added at the same level\");\n-\t\t\t}\n-\t\t\tif (log.isDebugEnabled())\n-\t\t\t{\n-\t\t\t\tlog.debug(\"Rendered \" + component);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tfinal void componentStateChanging(final Component component, Change change)\n-\t{\n-\t\tcheckHierarchyChange(component);\n-\n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, null))\n-\t\t{\n-\t\t\tversionManager.componentStateChanging(change);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Sets values for form components based on cookie values in the request.\n+\t * Set the id for this Page. This method is called by PageMap when a Page is\n+\t * added because the id, which is assigned by PageMap, is not known until\n+\t * this time.\n \t * \n+\t * @param id\n+\t *            The id\n \t */\n-\tfinal void setFormComponentValuesFromCookies()\n-\t{\n-\t\t// Visit all Forms contained in the page\n-\t\tvisitChildren(Form.class, new Component.IVisitor()\n-\t\t{\n-\t\t\t// For each FormComponent found on the Page (not Form)\n-\t\t\tpublic Object component(final Component component)\n-\t\t\t{\n-\t\t\t\t((Form)component).loadPersistentFormComponentValues();\n-\t\t\t\treturn CONTINUE_TRAVERSAL;\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t/**\n-\t * @param pageMap\n-\t *            Sets this page into the page map with the given name. If the\n-\t *            page map does not yet exist, it is automatically created.\n-\t */\n-\tfinal void setPageMap(final IPageMap pageMap)\n+\tpublic final void setNumericId(final int id)\n \t{\n-\t\t// Save transient reference to pagemap\n-\t\tthis.pageMap = pageMap;\n-\n-\t\t// Save name for restoring transient\n-\t\tthis.pageMapName = pageMap.getName();\n+\t\tthis.numericId = (short)id;\n \t}\n \n \t/**\n@@ -1131,21 +889,37 @@ public final void setStatelessHint(boolean value)\n \t}\n \n \t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n-\t * OVERRIDE.\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n+\t * \n+\t * This method is called when a component will be rendered standalone.\n+\t * \n+\t * @param component\n \t * \n-\t * @param map\n \t */\n-\tprotected final void moveToPageMap(IPageMap map)\n+\tpublic final void startComponentRender(Component component)\n \t{\n-\t\t// TODO post 1.2 shouldn't we remove this page from the pagemap/session\n-\t\t// if it would be in there?\n-\t\t// This should be done if the page was not cloned first, but shouldn't\n-\t\t// be done if it was cloned..\n-\t\tsetPageMap(map);\n-\t\tnumericId = (short)map.nextId();\n+\t\trenderedComponents = null;\n \t}\n \n+\t/**\n+\t * Get the string representation of this container.\n+\t * \n+\t * @return String representation of this container\n+\t */\n+\tpublic String toString()\n+\t{\n+\t\tif (versionManager != null)\n+\t\t{\n+\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \", version = \"\n+\t\t\t\t\t+ versionManager.getCurrentVersionNumber() + \", ajax = \"\n+\t\t\t\t\t+ versionManager.getAjaxVersionNumber() + \"]\";\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \", version = \"\n+\t\t\t\t\t+ 0 + \"]\";\n+\t\t}\n+\t}\n \n \t/**\n \t * Checks whether the hierarchy may be changed at all, and throws an\n@@ -1362,24 +1136,238 @@ private final boolean mayTrackChangesFor(final Component component, MarkupContai\n \t}\n \n \t/**\n-\t * Call this method when the current (ajax) request shouldn't merge \n-\t * the changes that are happening to the page with the previous version. \n+\t * Set-up response with appropriate content type, locale and encoding. The\n+\t * locale is set equal to the session's locale. The content type header\n+\t * contains information about the markup type (@see #getMarkupType()) and\n+\t * the encoding. The response (and request) encoding is determined by an\n+\t * application setting (@see\n+\t * ApplicationSettings#getResponseRequestEncoding()). In addition, if the\n+\t * page's markup contains a xml declaration like &lt?xml ... ?&gt; an xml\n+\t * declaration with proper encoding information is written to the output as\n+\t * well, provided it is not disabled by an applicaton setting (@see\n+\t * ApplicationSettings#getStripXmlDeclarationFromOutput()).\n+\t * <p>\n+\t * Note: Prior to Wicket 1.1 the output encoding was determined by the\n+\t * page's markup encoding. Because this caused uncertainties about the\n+\t * /request/ encoding, it has been changed in favour of the new, much safer,\n+\t * approach. Please see the Wiki for more details.\n+\t */\n+\tprotected void configureResponse()\n+\t{\n+\t\t// Get the response and application\n+\t\tfinal RequestCycle cycle = getRequestCycle();\n+\t\tfinal Application application = cycle.getApplication();\n+\t\tfinal Response response = cycle.getResponse();\n+\n+\t\t// Determine encoding\n+\t\tfinal String encoding = application.getRequestCycleSettings().getResponseRequestEncoding();\n+\n+\t\t// Set content type based on markup type for page\n+\t\tresponse.setContentType(\"text/\" + getMarkupType() + \"; charset=\" + encoding);\n+\n+\t\t// Write out an xml declaration if the markup stream and settings allow\n+\t\tfinal MarkupStream markupStream = findMarkupStream();\n+\t\tif ((markupStream != null) && (markupStream.getXmlDeclaration() != null)\n+\t\t\t\t&& (application.getMarkupSettings().getStripXmlDeclarationFromOutput() == false))\n+\t\t{\n+\t\t\tresponse.write(\"<?xml version='1.0' encoding='\");\n+\t\t\tresponse.write(encoding);\n+\t\t\tresponse.write(\"'?>\");\n+\t\t}\n+\n+\t\t// Set response locale from session locale\n+\t\tresponse.setLocale(getSession().getLocale());\n+\t}\n+\n+\t/**\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n+\t * OVERRIDE.\n+\t * \n+\t * @see wicket.Component#internalOnModelChanged()\n+\t */\n+\tprotected final void internalOnModelChanged()\n+\t{\n+\t\tvisitChildren(new Component.IVisitor()\n+\t\t{\n+\t\t\tpublic Object component(final Component component)\n+\t\t\t{\n+\t\t\t\t// If form component is using form model\n+\t\t\t\tif (component.sameRootModel(Page.this))\n+\t\t\t\t{\n+\t\t\t\t\tcomponent.modelChanged();\n+\t\t\t\t}\n+\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n+\t * OVERRIDE.\n \t * \n-\t * This is for example needed when you want to redirect to this \n-\t * page in an ajax request and then you do want to version normally.. \n+\t * @param map\n+\t */\n+\tprotected final void moveToPageMap(IPageMap map)\n+\t{\n+\t\t// TODO post 1.2 shouldn't we remove this page from the pagemap/session\n+\t\t// if it would be in there?\n+\t\t// This should be done if the page was not cloned first, but shouldn't\n+\t\t// be done if it was cloned..\n+\t\tsetPageMap(map);\n+\t\tnumericId = (short)map.nextId();\n+\t}\n+\n+\t/**\n+\t * @return Factory method that creates a version manager for this Page\n+\t */\n+\tprotected final IPageVersionManager newVersionManager()\n+\t{\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * @see wicket.Component#onDetach()\n+\t */\n+\tprotected void onDetach()\n+\t{\n+\t\tif (log.isDebugEnabled())\n+\t\t{\n+\t\t\tlog.debug(\"ending request for page \" + this + \", request \" + getRequest());\n+\t\t}\n+\n+\t\tendVersion();\n+\n+\t\tsuper.onDetach();\n+\t}\n+\n+\t/**\n+\t * Renders this container to the given response object.\n \t * \n-\t * This method doesn't do anything if the getRequest().mergeVersion\n-\t * doesn't return true.\n+\t * @param markupStream\n \t */\n-\tpublic final void ignoreVersionMerge()\n+\tprotected void onRender(final MarkupStream markupStream)\n \t{\n-\t\tif (getRequest().mergeVersion())\n+\t\t// Set page's associated markup stream\n+\t\tfinal MarkupStream associatedMarkupStream = getAssociatedMarkupStream(true);\n+\t\tsetMarkupStream(associatedMarkupStream);\n+\n+\t\t// Configure response object with locale and content type\n+\t\tconfigureResponse();\n+\n+\t\t// Render all the page's markup\n+\t\tsetFlag(FLAG_IS_RENDERING, true);\n+\t\ttry\n \t\t{\n-\t\t\tmayTrackChangesFor(this, null);\n-\t\t\tif (versionManager != null)\n+\t\t\trenderAll(associatedMarkupStream);\n+\t\t}\n+\t\tfinally\n \t\t{\n-\t\t\t\tversionManager.ignoreVersionMerge();\n+\t\t\tsetFlag(FLAG_IS_RENDERING, false);\n \t\t}\n \t}\n+\n+\n+\t/**\n+\t * A component was added.\n+\t * \n+\t * @param component\n+\t *            The component that was added\n+\t */\n+\tfinal void componentAdded(final Component component)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\t\t{\n+\t\t\tversionManager.componentAdded(component);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A component's model changed.\n+\t * \n+\t * @param component\n+\t *            The component whose model is about to change\n+\t */\n+\tfinal void componentModelChanging(final Component component)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, null))\n+\t\t{\n+\t\t\tversionManager.componentModelChanging(component);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A component was removed.\n+\t * \n+\t * @param component\n+\t *            The component that was removed\n+\t */\n+\tfinal void componentRemoved(final Component component)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\t\t{\n+\t\t\tversionManager.componentRemoved(component);\n+\t\t}\n+\t}\n+\n+\tfinal void componentStateChanging(final Component component, Change change)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, null))\n+\t\t{\n+\t\t\tversionManager.componentStateChanging(change);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets values for form components based on cookie values in the request.\n+\t * \n+\t */\n+\tfinal void setFormComponentValuesFromCookies()\n+\t{\n+\t\t// Visit all Forms contained in the page\n+\t\tvisitChildren(Form.class, new Component.IVisitor()\n+\t\t{\n+\t\t\t// For each FormComponent found on the Page (not Form)\n+\t\t\tpublic Object component(final Component component)\n+\t\t\t{\n+\t\t\t\t((Form)component).loadPersistentFormComponentValues();\n+\t\t\t\treturn CONTINUE_TRAVERSAL;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * @param pageMap\n+\t *            Sets this page into the page map with the given name. If the\n+\t *            page map does not yet exist, it is automatically created.\n+\t */\n+\tfinal void setPageMap(final IPageMap pageMap)\n+\t{\n+\t\t// Save transient reference to pagemap\n+\t\tthis.pageMap = pageMap;\n+\n+\t\t// Save name for restoring transient\n+\t\tthis.pageMapName = pageMap.getName();\n+\t}\n+\n+\t/**\n+\t * Set page stateless\n+\t * \n+\t * @param stateless\n+\t */\n+\tvoid setPageStateless(Boolean stateless)\n+\t{\n+\t\tthis.stateless = stateless;\n \t}\n }\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java b/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java\nindex 9db2282..b8e00a5 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java\n@@ -886,7 +886,7 @@ private void detach()\n \t\t// remove any rendered feedback messages from the session\n \t\ttry\n \t\t{\n-\t\t\tsession.cleanupFeedbackMessages();\n+\t\t\tsession.cleanupRenderedFeedbackMessages();\n \t\t}\n \t\tcatch (RuntimeException re)\n \t\t{\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/Session.java b/jdk-1.4/wicket/src/main/java/wicket/Session.java\nindex ae82d31..0e88aed 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/Session.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/Session.java\n@@ -37,7 +37,6 @@\n import wicket.feedback.FeedbackMessages;\n import wicket.request.ClientInfo;\n import wicket.session.ISessionStore;\n-import wicket.util.concurrent.CopyOnWriteArrayList;\n import wicket.util.convert.IConverter;\n import wicket.util.lang.Objects;\n import wicket.util.string.Strings;\n@@ -199,7 +198,7 @@ public boolean add(IPageMap pagemap)\n \tprivate String style;\n \n \t/** feedback messages */\n-\tprivate FeedbackMessages feedbackMessages = new FeedbackMessages(new CopyOnWriteArrayList());\n+\tprivate FeedbackMessages feedbackMessages = new FeedbackMessages();\n \n \tprivate transient Map pageMapsUsedInRequest;\n \n@@ -1133,7 +1132,7 @@ else if (object instanceof IPageMap)\n \t * Removes any rendered feedback messages as well as compacts memory. This\n \t * method is usually called at the end of the request cycle processing.\n \t */\n-\tfinal void cleanupFeedbackMessages()\n+\tfinal void cleanupRenderedFeedbackMessages()\n \t{\n \t\tint size = feedbackMessages.size();\n \t\tfeedbackMessages.clearRendered();\n@@ -1146,6 +1145,26 @@ final void cleanupFeedbackMessages()\n \t}\n \n \t/**\n+\t * Cleans up any unrendered, dangling feedback messages there may be. This\n+\t * implementation calls {@link FeedbackMessages#clearComponentSpecific()} to\n+\t * aggresively ensure there won't be memory leaks. Clients can override this\n+\t * method to e.g. call {@link FeedbackMessages#clearPageSpecific(Page)}.\n+\t * <p>\n+\t * This method should be called from by the framework right before a even\n+\t * handler is called. There is no need for clients to call this method\n+\t * directly\n+\t * </p>\n+\t * \n+\t * @param page\n+\t *            any current page (the page on which the event handler is that\n+\t *            is about to be processed)\n+\t */\n+\tpublic void cleanupFeedbackMessages(Page page)\n+\t{\n+\t\tfeedbackMessages.clearComponentSpecific();\n+\t}\n+\n+\t/**\n \t * @param page\n \t *            The page to add to dirty objects list\n \t */\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java\nindex 7da2662..719e177 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java\n@@ -27,6 +27,7 @@\n \n import wicket.Component;\n import wicket.IClusterable;\n+import wicket.Page;\n import wicket.util.concurrent.CopyOnWriteArrayList;\n import wicket.util.string.StringList;\n \n@@ -58,25 +59,38 @@\n \t */\n \tpublic FeedbackMessages()\n \t{\n-\t\tmessages = new ArrayList();\n+\t\tmessages = new CopyOnWriteArrayList();\n \t}\n \n \t/**\n-\t * Call this constructor if you want to replace the internal\n-\t * store with another implemention then the default (ArrayList). \n-\t * This could be a {@link CopyOnWriteArrayList} if this feedbackmessages \n-\t * instance is used by multiply threads.\n+\t * Call this constructor if you want to replace the internal store with\n+\t * another implemention then the default (ArrayList). This could be a\n+\t * {@link CopyOnWriteArrayList} if this feedbackmessages instance is used by\n+\t * multiply threads.\n \t * \n \t * @param messagesList\n \t * \n \t */\n \tpublic FeedbackMessages(List messagesList)\n \t{\n-\t\tif(messagesList == null) throw new IllegalArgumentException(\"messages list can't be null\");\n+\t\tif (messagesList == null)\n+\t\t\tthrow new IllegalArgumentException(\"messages list can't be null\");\n \t\tmessages = messagesList;\n \t}\n \n \t/**\n+\t * Adds a message\n+\t * \n+\t * @param reporter\n+\t * @param message\n+\t * @param level\n+\t */\n+\tpublic final void add(Component reporter, String message, int level)\n+\t{\n+\t\tadd(new FeedbackMessage(reporter, message, level));\n+\t}\n+\n+\t/**\n \t * Clears any existing messages\n \t */\n \tpublic final void clear()\n@@ -85,13 +99,50 @@ public final void clear()\n \t}\n \n \t/**\n-\t * Gets the number of messages\n+\t * Clears any messages specifically for components. This is an aggressive\n+\t * cleanup to ensure there won't be a memory leak in session.\n+\t */\n+\tpublic final void clearComponentSpecific()\n+\t{\n+\t\tfor (int i = messages.size() - 1; i >= 0; i--)\n+\t\t{\n+\t\t\tfinal FeedbackMessage msg = (FeedbackMessage)messages.get(i);\n+\t\t\tComponent reporter = msg.getReporter();\n+\t\t\tif (reporter != null)\n+\t\t\t{\n+\t\t\t\tmessages.remove(i);\n+\t\t\t}\n+\t\t}\n+\t\ttrimToSize();\n+\t}\n+\n+\t/**\n+\t * Clears any messages specifically for components on the provided page.\n \t * \n-\t * @return the number of messages\n+\t * @param page\n+\t *            The page to clear messages for\n \t */\n-\tpublic final int size()\n+\tpublic final void clearPageSpecific(Page page)\n \t{\n-\t\treturn messages.size();\n+\t\tif (page == null)\n+\t\t{\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfor (int i = messages.size() - 1; i >= 0; i--)\n+\t\t{\n+\t\t\tfinal FeedbackMessage msg = (FeedbackMessage)messages.get(i);\n+\t\t\tComponent reporter = msg.getReporter();\n+\t\t\tif (reporter != null)\n+\t\t\t{\n+\t\t\t\tPage reporterPage = (Page)reporter.findParent(Page.class);\n+\t\t\t\tif (reporterPage != null && reporterPage.equals(page))\n+\t\t\t\t{\n+\t\t\t\t\tmessages.remove(i);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\ttrimToSize();\n \t}\n \n \t/**\n@@ -226,6 +277,16 @@ public final boolean isEmpty()\n \t}\n \n \t/**\n+\t * Gets an iterator over stored messages\n+\t * \n+\t * @return iterator over stored messages\n+\t */\n+\tpublic final Iterator iterator()\n+\t{\n+\t\treturn messages.iterator();\n+\t}\n+\n+\t/**\n \t * Looks up a message for the given component.\n \t * \n \t * @param component\n@@ -275,6 +336,16 @@ public final List messages(final IFeedbackMessageFilter filter)\n \t}\n \n \t/**\n+\t * Gets the number of messages\n+\t * \n+\t * @return the number of messages\n+\t */\n+\tpublic final int size()\n+\t{\n+\t\treturn messages.size();\n+\t}\n+\n+\t/**\n \t * @see java.lang.Object#toString()\n \t */\n \tpublic String toString()\n@@ -283,6 +354,17 @@ public String toString()\n \t}\n \n \t/**\n+\t * Frees any unnecessary internal storage\n+\t */\n+\tpublic final void trimToSize()\n+\t{\n+\t\tif (messages instanceof ArrayList)\n+\t\t{\n+\t\t\t((ArrayList)messages).trimToSize();\n+\t\t}\n+\t}\n+\n+\t/**\n \t * Adds a new ui message with level WARNING to the current messages.\n \t * \n \t * @param reporter\n@@ -296,16 +378,6 @@ public final void warn(Component reporter, String message)\n \t}\n \n \t/**\n-\t * Adds a message\n-\t * @param reporter\n-\t * @param message\n-\t * @param level\n-\t */\n-\tpublic final void add(Component reporter, String message, int level) {\n-\t\tadd(new FeedbackMessage(reporter, message, level));\n-\t}\n-\t\n-\t/**\n \t * Adds a message.\n \t * \n \t * @param message\n@@ -319,25 +391,4 @@ final void add(FeedbackMessage message)\n \t\t}\n \t\tmessages.add(message);\n \t}\n-\n-\t/**\n-\t * Gets an iterator over stored messages\n-\t * \n-\t * @return iterator over stored messages\n-\t */\n-\tpublic final Iterator iterator()\n-\t{\n-\t\treturn messages.iterator();\n-\t}\n-\n-\t/**\n-\t * Frees any unnecessary internal storage\n-\t */\n-\tpublic final void trimToSize()\n-\t{\n-\t\tif(messages instanceof ArrayList)\n-\t\t{\n-\t\t\t((ArrayList)messages).trimToSize();\n-\t\t}\n-\t}\n }\n\\ No newline at end of file\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java\nindex 7b52300..82f39b2 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java\n@@ -17,13 +17,13 @@\n package wicket.feedback;\n \n import java.io.Serializable;\n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n \n import wicket.Component;\n import wicket.Page;\n+import wicket.Session;\n import wicket.model.IModel;\n \n /**\n@@ -51,8 +51,9 @@\n \t * Constructor. Creates a model for all feedback messages on the page.\n \t * \n \t * @param component\n-\t *            The component where the page will be get from for which messages will be displayed \n-\t *            usually the same page as the one feedbackpanel is attached to\n+\t *            The component where the page will be get from for which\n+\t *            messages will be displayed usually the same page as the one\n+\t *            feedbackpanel is attached to\n \t */\n \tpublic FeedbackMessagesModel(Component component)\n \t{\n@@ -104,13 +105,7 @@ public final Object getObject()\n \t\tif (messages == null)\n \t\t{\n \t\t\t// Get filtered messages from page where component lives\n-\t\t\tList pageMessages = component.getPage().getFeedbackMessages().messages(filter);\n-\n-\t\t\tList sessionMessages = component.getSession().getFeedbackMessages().messages(filter);\n-\n-\t\t\tmessages = new ArrayList(pageMessages.size() + sessionMessages.size());\n-\t\t\tmessages.addAll(pageMessages);\n-\t\t\tmessages.addAll(sessionMessages);\n+\t\t\tmessages = Session.get().getFeedbackMessages().messages(filter);\n \n \t\t\t// Sort the list before returning it\n \t\t\tif (sortingComparator != null)\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java\nindex 2198c9e..5d4f34a 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java\n@@ -16,6 +16,7 @@\n  */\n package wicket.markup.html.form.validation;\n \n+import wicket.Session;\n import wicket.feedback.ContainerFeedbackMessageFilter;\n import wicket.feedback.IFeedback;\n import wicket.feedback.IFeedbackMessageFilter;\n@@ -87,7 +88,7 @@ public FormComponentFeedbackBorder(final String id)\n \tpublic void updateFeedback()\n \t{\n \t\t// Get the messages for the current page\n-\t\tvisible = getPage().getFeedbackMessages().messages(getMessagesFilter()).size() != 0;\n+\t\tvisible = Session.get().getFeedbackMessages().messages(getMessagesFilter()).size() != 0;\n \t}\n \n \t/**\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java\nindex 0653181..bb76fee 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java\n@@ -17,6 +17,7 @@\n package wicket.markup.html.form.validation;\n \n import wicket.Component;\n+import wicket.Session;\n import wicket.feedback.ComponentFeedbackMessageFilter;\n import wicket.feedback.IFeedback;\n import wicket.feedback.IFeedbackMessageFilter;\n@@ -74,7 +75,7 @@ public void setIndicatorFor(final Component component)\n \tpublic void updateFeedback()\n \t{\n \t\t// Get the messages for the current page\n-\t\tsetVisible(getPage().getFeedbackMessages().hasMessage(getFeedbackMessageFilter()));\n+\t\tsetVisible(Session.get().getFeedbackMessages().hasMessage(getFeedbackMessageFilter()));\n \t}\n \n \t/**\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java b/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java\nindex 7d8fb92..ed88751 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java\n@@ -21,6 +21,7 @@\n import wicket.Page;\n import wicket.RequestCycle;\n import wicket.RequestListenerInterface;\n+import wicket.Session;\n import wicket.request.RequestParameters;\n import wicket.request.target.IEventProcessor;\n import wicket.request.target.component.PageRequestTarget;\n@@ -189,7 +190,7 @@ protected void onProcessEvents(final RequestCycle requestCycle)\n \t\trequestCycle.setUpdateSession(true);\n \n \t\t// Clear all feedback messages if it isn't a redirect\n-\t\tgetPage().getFeedbackMessages().clear();\n+\t\tSession.get().cleanupFeedbackMessages(getPage());\n \n \t\tgetPage().startComponentRender(getTarget());\n \n", "nb_test": 409, "linesAdd": 318, "jira_id": "442", "singleLine": false, "nb_skipped": 0, "commit": "246d53c5", "nb_failure": 3, "linesRem": 286}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testHeaderCollection(org.apache.wicket.request.HttpHeaderCollectionTest)"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/HttpHeaderCollection.java b/wicket-request/src/main/java/org/apache/wicket/request/HttpHeaderCollection.java\nindex 3e97a1e..8e0cb55 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/HttpHeaderCollection.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/HttpHeaderCollection.java\n@@ -99,7 +99,7 @@ public void setHeader(String name, String value)\n \tpublic void addHeader(String name, String value)\n \t{\n \t\t// be lenient and strip leading / trailing blanks\n-\t\tvalue = Args.notEmpty(value, \"value\").trim();\n+\t\tvalue = Args.notNull(value, \"value\").trim();\n \n \t\tinternalAdd(name, value);\n \t}\n", "nb_test": 46, "linesAdd": 1, "jira_id": "3845", "singleLine": false, "nb_skipped": 0, "commit": "afc7034d", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["isRelative(org.apache.wicket.util.string.UrlUtilsTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/util/string/UrlUtils.java b/wicket/src/main/java/org/apache/wicket/util/string/UrlUtils.java\nindex c18852d..6f1e8d7 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/string/UrlUtils.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/string/UrlUtils.java\n@@ -39,9 +39,10 @@ private UrlUtils()\n \t * @param url\r\n \t * @return <code>true</code> if url is relative, <code>false</code> otherwise\r\n \t */\r\n-\tpublic static boolean isRelative(String url)\r\n+\tpublic static boolean isRelative(final String url)\r\n \t{\r\n-\t\tif ((url != null) && (url.startsWith(\"/\") == false) && (url.indexOf(\"://\") < 0) &&\r\n+\t\t// the regex means \"doesn't start with 'scheme://'\"\r\n+\t\tif ((url != null) && (url.startsWith(\"/\") == false) && (!url.matches(\"^\\\\w+\\\\:\\\\/\\\\/.*\")) &&\r\n \t\t\t!(url.startsWith(\"#\")))\r\n \t\t{\r\n \t\t\treturn true;\r\n", "nb_test": 966, "linesAdd": 2, "jira_id": "3076", "singleLine": false, "nb_skipped": 1, "commit": "d3dc9a50", "nb_failure": 1, "linesRem": 2}, {"files": 3, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["normalRequest(org.apache.wicket.response.filter.ResponseFilterTest)", "ajaxRequest(org.apache.wicket.response.filter.ResponseFilterTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java b/wicket/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\nindex 84ff3f0..c1ff4a5 100644\n--- a/wicket/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n+++ b/wicket/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n@@ -51,6 +51,8 @@\n import org.apache.wicket.request.http.WebResponse;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n import org.apache.wicket.request.resource.ResourceReference;\n+import org.apache.wicket.response.StringResponse;\n+import org.apache.wicket.response.filter.IResponseFilter;\n import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.string.AppendingStringBuffer;\n import org.apache.wicket.util.string.Strings;\n@@ -603,10 +605,40 @@ public final void respond(final IRequestCycle requestCycle)\n \t\t\t// Make sure it is not cached by a client\n \t\t\tresponse.disableCaching();\n \n-\t\t\tresponse.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n-\t\t\tresponse.write(encoding);\n-\t\t\tresponse.write(\"\\\"?>\");\n-\t\t\tresponse.write(\"<ajax-response>\");\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tfinal StringResponse bodyResponse = new StringResponse();\n+\t\t\t\tcontructResponseBody(bodyResponse, encoding);\n+\t\t\t\tinvokeResponseFilters(bodyResponse);\n+\t\t\t\tresponse.write(bodyResponse.getBuffer());\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\t// restore the original response\n+\t\t\t\tRequestCycle.get().setResponse(response);\n+\t\t\t}\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\tpage.setFreezePageId(frozen);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Collects the response body (without the headers) so that it can be pre-processed before\n+\t * written down to the original response.\n+\t * \n+\t * @param bodyResponse\n+\t *            the buffering response\n+\t * @param encoding\n+\t *            the encoding that should be used to encode the body\n+\t */\n+\tprivate void contructResponseBody(final Response bodyResponse, final String encoding)\n+\t{\n+\t\tbodyResponse.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n+\t\tbodyResponse.write(encoding);\n+\t\tbodyResponse.write(\"\\\"?>\");\n+\t\tbodyResponse.write(\"<ajax-response>\");\n \n \t\t// invoke onbeforerespond event on listeners\n \t\tfireOnBeforeRespondListeners();\n@@ -616,13 +648,13 @@ public final void respond(final IRequestCycle requestCycle)\n \t\twhile (it.hasNext())\n \t\t{\n \t\t\tCharSequence js = it.next();\n-\t\t\t\trespondInvocation(response, js);\n+\t\t\trespondInvocation(bodyResponse, js);\n \t\t}\n \n \t\t// process added components\n-\t\t\trespondComponents(response);\n+\t\trespondComponents(bodyResponse);\n \n-\t\t\tfireOnAfterRespondListeners(response);\n+\t\tfireOnAfterRespondListeners(bodyResponse);\n \n \t\t// execute the dom ready javascripts as first javascripts\n \t\t// after component replacement\n@@ -630,20 +662,39 @@ public final void respond(final IRequestCycle requestCycle)\n \t\twhile (it.hasNext())\n \t\t{\n \t\t\tCharSequence js = it.next();\n-\t\t\t\trespondInvocation(response, js);\n+\t\t\trespondInvocation(bodyResponse, js);\n \t\t}\n \t\tit = appendJavaScripts.iterator();\n \t\twhile (it.hasNext())\n \t\t{\n \t\t\tCharSequence js = it.next();\n-\t\t\t\trespondInvocation(response, js);\n+\t\t\trespondInvocation(bodyResponse, js);\n \t\t}\n \n-\t\t\tresponse.write(\"</ajax-response>\");\n+\t\tbodyResponse.write(\"</ajax-response>\");\n \t}\n-\t\tfinally\n+\n+\t/**\n+\t * Runs the configured {@link IResponseFilter}s over the constructed Ajax response\n+\t * \n+\t * @param contentResponse\n+\t *            the Ajax {@link Response} body\n+\t */\n+\tprivate void invokeResponseFilters(final StringResponse contentResponse)\n \t{\n-\t\t\tpage.setFreezePageId(frozen);\n+\t\tAppendingStringBuffer responseBuffer = new AppendingStringBuffer(\n+\t\t\tcontentResponse.getBuffer());\n+\n+\t\tList<IResponseFilter> responseFilters = Application.get()\n+\t\t\t.getRequestCycleSettings()\n+\t\t\t.getResponseFilters();\n+\n+\t\tif (responseFilters != null)\n+\t\t{\n+\t\t\tfor (IResponseFilter filter : responseFilters)\n+\t\t\t{\n+\t\t\t\tfilter.filter(responseBuffer);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -667,7 +718,7 @@ private void fireOnBeforeRespondListeners()\n \t * \n \t * @param response\n \t */\n-\tprivate void fireOnAfterRespondListeners(final WebResponse response)\n+\tprivate void fireOnAfterRespondListeners(final Response response)\n \t{\n \t\t// invoke onafterresponse event on listeners\n \t\tif (listeners != null)\n@@ -697,7 +748,7 @@ public void addJavaScript(String script)\n \t * \n \t * @param response\n \t */\n-\tprivate void respondComponents(WebResponse response)\n+\tprivate void respondComponents(Response response)\n \t{\n \t\t// TODO: We might need to call prepareRender on all components upfront\n \ndiff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java b/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\nindex 113e442..1c9debe 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n@@ -24,10 +24,13 @@\n \n import javax.servlet.http.Cookie;\n \n+import org.apache.wicket.Application;\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.request.Response;\n import org.apache.wicket.request.http.WebResponse;\n+import org.apache.wicket.response.filter.IResponseFilter;\n import org.apache.wicket.util.lang.Args;\n+import org.apache.wicket.util.string.AppendingStringBuffer;\n \n /**\n  * Subclass of {@link WebResponse} that buffers the actions and performs those on another response.\n@@ -117,6 +120,20 @@ public void append(CharSequence sequence)\n \t\t@Override\n \t\tprotected void invoke(WebResponse response)\n \t\t{\n+\n+\t\t\tAppendingStringBuffer responseBuffer = new AppendingStringBuffer(builder);\n+\n+\t\t\tList<IResponseFilter> responseFilters = Application.get()\n+\t\t\t\t.getRequestCycleSettings()\n+\t\t\t\t.getResponseFilters();\n+\n+\t\t\tif (responseFilters != null)\n+\t\t\t{\n+\t\t\t\tfor (IResponseFilter filter : responseFilters)\n+\t\t\t\t{\n+\t\t\t\t\tfilter.filter(responseBuffer);\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tresponse.write(builder);\n \t\t}\n \t};\ndiff --git a/wicket/src/main/java/org/apache/wicket/response/filter/IResponseFilter.java b/wicket/src/main/java/org/apache/wicket/response/filter/IResponseFilter.java\nindex e2f76cc..c106782 100644\n--- a/wicket/src/main/java/org/apache/wicket/response/filter/IResponseFilter.java\n+++ b/wicket/src/main/java/org/apache/wicket/response/filter/IResponseFilter.java\n@@ -21,7 +21,7 @@\n /**\n  * A response filter can be added to the\n  * {@link org.apache.wicket.settings.IRequestCycleSettings#addResponseFilter(IResponseFilter)}\n- * object The will be called from the Buffered Response objects right before they would send it to\n+ * object. This will be called from the Buffered Response objects right before they would send it to\n  * the real responses. You have to use the\n  * {@link org.apache.wicket.settings.IRequestCycleSettings#setBufferResponse(boolean)}(to true which\n  * is the default) for this filtering to work.\n", "nb_test": 1039, "linesAdd": 66, "jira_id": "3280", "singleLine": false, "nb_skipped": 0, "commit": "295e73bd", "nb_failure": 2, "linesRem": 14}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testBasicOperations(org.apache.wicket.request.cycle.RequestCycleListenerTest)", "testExceptionHandingInOnDetach(org.apache.wicket.request.cycle.RequestCycleListenerTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\nindex 81923b6..4c93370 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n@@ -199,6 +199,8 @@ public boolean processRequest()\n \t\ttry\n \t\t{\n \t\t\tset(this);\n+\t\t\tlisteners.onBeginRequest(this);\n+\t\t\tonBeginRequest();\n \t\t\tIRequestHandler handler = resolveRequestHandler();\n \t\t\tif (handler != null)\n \t\t\t{\n@@ -242,8 +244,6 @@ public boolean processRequestAndDetach()\n \t\tboolean result;\n \t\ttry\n \t\t{\n-\t\t\tlisteners.onBeginRequest(this);\n-\t\t\tonBeginRequest();\n \t\t\tresult = processRequest();\n \t\t}\n \t\tfinally\n", "nb_test": 1063, "linesAdd": 2, "jira_id": "3428", "singleLine": false, "nb_skipped": 0, "commit": "ffc0cae9", "nb_failure": 2, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ISecuritySettingsTest.enforceMounts:85->Assert.assertNull:656->Assert.assertNull:646->Assert.failNotNull:664->Assert.fail:88 expected null, but was:<[Page class = org.apache.wicket.settings.ISecuritySettingsTest$UnknownPage, id = 3, render count = 1]>", "ISecuritySettingsTest.enforceMountsWithCryptoMapper:96->enforceMounts:85->Assert.assertNull:656->Assert.assertNull:646->Assert.failNotNull:664->Assert.fail:88 expected null, but was:<[Page class = org.apache.wicket.settings.ISecuritySettingsTest$UnknownPage, id = 3, render count = 1]>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex eca607b..bf1d888 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -24,6 +24,7 @@\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n import org.apache.wicket.request.mapper.ICompoundRequestMapper;\n+import org.apache.wicket.request.mapper.IRequestMapperDelegate;\n import org.apache.wicket.request.mapper.info.PageComponentInfo;\n import org.apache.wicket.request.mapper.parameter.IPageParametersEncoder;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n@@ -119,7 +120,7 @@ protected UrlInfo parseRequest(Request request)\n \t\t\t\t\t\tif (!pageClass.equals(application.getHomePage()))\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\t// WICKET-5094 only enforce mount if page is mounted\n-\t\t\t\t\t\t\tif (isPageMounted(pageClass, application))\n+\t\t\t\t\t\t\tif (isPageMounted(pageClass, application.getRootRequestMapperAsCompound()))\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n@@ -137,11 +138,23 @@ protected UrlInfo parseRequest(Request request)\n \t\treturn null;\n \t}\n \n-\tprivate boolean isPageMounted(Class<? extends IRequestablePage> pageClass, Application application)\n+\tprivate boolean isPageMounted(Class<? extends IRequestablePage> pageClass, ICompoundRequestMapper compoundMapper)\n \t{\n-\t\tICompoundRequestMapper applicationMappers = application.getRootRequestMapperAsCompound();\n+\t\tfor (IRequestMapper requestMapper : compoundMapper)\n+\t\t{\n+\t\t\twhile (requestMapper instanceof IRequestMapperDelegate)\n+\t\t\t{\n+\t\t\t\trequestMapper = ((IRequestMapperDelegate)requestMapper).getDelegateMapper();\n+\t\t\t}\n \n-\t\tfor (IRequestMapper requestMapper : applicationMappers)\n+\t\t\tif (requestMapper instanceof ICompoundRequestMapper)\n+\t\t\t{\n+\t\t\t\tif (isPageMounted(pageClass, (ICompoundRequestMapper)requestMapper))\n+\t\t\t\t{\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse\n \t\t\t{\n \t\t\t\tif (requestMapper instanceof AbstractBookmarkableMapper  && requestMapper != this)\n \t\t\t\t{\n@@ -153,6 +166,7 @@ private boolean isPageMounted(Class<? extends IRequestablePage> pageClass, Appli\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n \n \t\treturn false;\n \t}\n", "nb_test": 1690, "linesAdd": 18, "jira_id": "5712", "singleLine": false, "nb_skipped": 1, "commit": "145da021", "nb_failure": 2, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["firstSelected_1Visible(org.apache.wicket.extensions.markup.html.tabs.TabbedPanelVisibilityTest): expected:<tab0 selected[ last]> but was:<tab0 selected[]>"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/tabs/TabbedPanel.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/tabs/TabbedPanel.java\nindex 10be55d..f70ef2b 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/tabs/TabbedPanel.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/tabs/TabbedPanel.java\n@@ -84,7 +84,7 @@\n \t/** the current tab */\n \tprivate int currentTab = -1;\n \n-\tprivate transient Boolean[] tabsVisibilityCache;\n+\tprivate transient VisibilityCache visibilityCache;\n \n \t/**\n \t * Constructor\n@@ -204,6 +204,14 @@ protected LoopItem newTabContainer(final int tabIndex)\n \t\t\tprivate static final long serialVersionUID = 1L;\n \n \t\t\t@Override\n+\t\t\tprotected void onConfigure()\n+\t\t\t{\n+\t\t\t\tsuper.onConfigure();\n+\n+\t\t\t\tsetVisible(getVisiblityCache().isVisible(tabIndex));\n+\t\t\t}\n+\n+\t\t\t@Override\n \t\t\tprotected void onComponentTag(final ComponentTag tag)\n \t\t\t{\n \t\t\t\tsuper.onComponentTag(tag);\n@@ -218,18 +227,12 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\t\t{\n \t\t\t\t\tcssClass += ' ' + getSelectedTabCssClass();\n \t\t\t\t}\n-\t\t\t\tif (getIndex() == getTabs().size() - 1)\n+\t\t\t\tif (getVisiblityCache().getLastVisible() == getIndex())\n \t\t\t\t{\n \t\t\t\t\tcssClass += ' ' + getLastTabCssClass();\n \t\t\t\t}\n \t\t\t\ttag.put(\"class\", cssClass.trim());\n \t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic boolean isVisible()\n-\t\t\t{\n-\t\t\t\treturn getTabs().get(tabIndex).isVisible();\n-\t\t\t}\n \t\t};\n \t}\n \n@@ -238,13 +241,13 @@ protected void onBeforeRender()\n \t{\n \t\tint index = getSelectedTab();\n \n-\t\tif ((index == -1) || (isTabVisible(index) == false))\n+\t\tif ((index == -1) || (getVisiblityCache().isVisible(index) == false))\n \t\t{\n \t\t\t// find first visible tab\n \t\t\tindex = -1;\n \t\t\tfor (int i = 0; i < tabs.size(); i++)\n \t\t\t{\n-\t\t\t\tif (isTabVisible(i))\n+\t\t\t\tif (getVisiblityCache().isVisible(i))\n \t\t\t\t{\n \t\t\t\t\tindex = i;\n \t\t\t\t\tbreak;\n@@ -253,9 +256,7 @@ protected void onBeforeRender()\n \n \t\t\tif (index != -1)\n \t\t\t{\n-\t\t\t\t/*\n-\t\t\t\t * found a visible tab, so select it\n-\t\t\t\t */\n+\t\t\t\t// found a visible tab, so select it\n \t\t\t\tsetSelectedTab(index);\n \t\t\t}\n \t\t}\n@@ -401,7 +402,7 @@ private void setCurrentTab(int index)\n \n \t\tfinal Component component;\n \n-\t\tif (currentTab == -1 || (tabs.size() == 0) || !isTabVisible(currentTab))\n+\t\tif (currentTab == -1 || (tabs.size() == 0) || !getVisiblityCache().isVisible(currentTab))\n \t\t{\n \t\t\t// no tabs or the current tab is not visible\n \t\t\tcomponent = newPanel();\n@@ -443,32 +444,77 @@ public final int getSelectedTab()\n \t\treturn (Integer)getDefaultModelObject();\n \t}\n \n+\t@Override\n+\tprotected void onDetach()\n+\t{\n+\t\tvisibilityCache = null;\n+\n+\t\tsuper.onDetach();\n+\t}\n+\n+\tprivate VisibilityCache getVisiblityCache()\n+\t{\n+\t\tif (visibilityCache == null)\n+\t\t{\n+\t\t\tvisibilityCache = new VisibilityCache();\n+\t\t}\n+\n+\t\treturn visibilityCache;\n+\t}\n+\n \t/**\n-\t * \n-\t * @param tabIndex\n-\t * @return visible\n+\t * A cache for visibilities of {@link ITab}s.\n \t */\n-\tprivate boolean isTabVisible(final int tabIndex)\n+\tprivate class VisibilityCache\n \t{\n-\t\tif (tabsVisibilityCache == null)\n+\n+\t\t/**\n+\t\t * Visibility for each tab.\n+\t\t */\n+\t\tprivate Boolean[] visibilities;\n+\n+\t\t/**\n+\t\t * Last visible tab.\n+\t\t */\n+\t\tprivate int lastVisible = -1;\n+\n+\t\tpublic VisibilityCache()\n \t\t{\n-\t\t\ttabsVisibilityCache = new Boolean[tabs.size()];\n+\t\t\tvisibilities = new Boolean[tabs.size()];\n \t\t}\n \n-\t\tif (tabsVisibilityCache.length < tabIndex + 1)\n+\t\tpublic int getLastVisible()\n+\t\t{\n+\t\t\tif (lastVisible == -1)\n \t\t\t{\n-\t\t\tBoolean[] resized = new Boolean[tabIndex + 1];\n-\t\t\tSystem.arraycopy(tabsVisibilityCache, 0, resized, 0, tabsVisibilityCache.length);\n-\t\t\ttabsVisibilityCache = resized;\n+\t\t\t\tfor (int t = 0; t < tabs.size(); t++)\n+\t\t\t\t{\n+\t\t\t\t\tif (isVisible(t))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tlastVisible = t;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn lastVisible;\n+\t\t}\n+\n+\t\tpublic boolean isVisible(int index)\n+\t\t{\n+\t\t\tif (visibilities.length < index + 1)\n+\t\t\t{\n+\t\t\t\tBoolean[] resized = new Boolean[index + 1];\n+\t\t\t\tSystem.arraycopy(visibilities, 0, resized, 0, visibilities.length);\n+\t\t\t\tvisibilities = resized;\n \t\t\t}\n \n-\t\tif (tabsVisibilityCache.length > 0)\n+\t\t\tif (visibilities.length > 0)\n \t\t\t{\n-\t\t\tBoolean visible = tabsVisibilityCache[tabIndex];\n+\t\t\t\tBoolean visible = visibilities[index];\n \t\t\t\tif (visible == null)\n \t\t\t\t{\n-\t\t\t\tvisible = tabs.get(tabIndex).isVisible();\n-\t\t\t\ttabsVisibilityCache[tabIndex] = visible;\n+\t\t\t\t\tvisible = tabs.get(index).isVisible();\n+\t\t\t\t\tvisibilities[index] = visible;\n \t\t\t\t}\n \t\t\t\treturn visible;\n \t\t\t}\n@@ -477,11 +523,5 @@ private boolean isTabVisible(final int tabIndex)\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n-\n-\t@Override\n-\tprotected void onDetach()\n-\t{\n-\t\ttabsVisibilityCache = null;\n-\t\tsuper.onDetach();\n \t}\n }\n\\ No newline at end of file\n", "nb_test": 50, "linesAdd": 65, "jira_id": "4658", "singleLine": false, "nb_skipped": 0, "commit": "ef3adb12", "nb_failure": 1, "linesRem": 28}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["isInstance(org.apache.wicket.ConverterLocatorTest): Could not convert value: test to type: java.io.Serializable. Could not find compatible converter."], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java b/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\nindex 437ed8c..e2d9cc6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\n@@ -105,16 +105,19 @@ public C convertToObject(String value, Locale locale)\n \t\t\t\t{\n \t\t\t\t\treturn converted;\n \t\t\t\t}\n-\t\t\t\telse\n+\n+\t\t\t\tif (theType.isInstance(value))\n \t\t\t\t{\n-\t\t\t\t\tthrow new ConversionException(\"Could not convert value: \" + value +\n-\t\t\t\t\t\t\" to type: \" + theType.getName() + \". Could not find compatible converter.\").setSourceValue(value);\n+\t\t\t\t\treturn theType.cast(value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception e)\n \t\t\t{\n \t\t\t\tthrow new ConversionException(e.getMessage(), e).setSourceValue(value);\n \t\t\t}\n+\n+\t\t\tthrow new ConversionException(\"Could not convert value: \" + value + \" to type: \" +\n+\t\t\t\ttheType.getName() + \". Could not find compatible converter.\").setSourceValue(value);\n \t\t}\n \n \t\t/**\n", "nb_test": 1411, "linesAdd": 6, "jira_id": "4755", "singleLine": false, "nb_skipped": 5, "commit": "87ae870f", "nb_failure": 0, "linesRem": 3}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testResetInitsSteps(org.apache.wicket.extensions.wizard.WizardModelTest): expected:<org.apache.wicket.extensions.wizard.WizardModel@6c747b55> but was:<null>"], "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/Wizard.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/Wizard.java\nindex b6ebad4..3bad8db 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/Wizard.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/Wizard.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.wicket.extensions.wizard;\n \n-import java.util.Iterator;\n-\n import org.apache.wicket.Component;\n import org.apache.wicket.feedback.ContainerFeedbackMessageFilter;\n import org.apache.wicket.markup.html.IHeaderResponse;\n@@ -276,15 +274,6 @@ protected void init(final IWizardModel wizardModel)\n \n \t\twizardModel.addListener(this);\n \n-\t\tIterator<IWizardStep> stepsIterator = wizardModel.stepIterator();\n-\t\tif (stepsIterator != null)\n-\t\t{\n-\t\t\twhile (stepsIterator.hasNext())\n-\t\t\t{\n-\t\t\t\t(stepsIterator.next()).init(wizardModel);\n-\t\t\t}\n-\t\t}\n-\n \t\t// reset model to prepare for action\n \t\twizardModel.reset();\n \t}\ndiff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/WizardModel.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/WizardModel.java\nindex c66d352..69c973f 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/WizardModel.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/WizardModel.java\n@@ -217,6 +217,12 @@ public void reset()\n \t{\n \t\thistory.clear();\n \t\tactiveStep = null;\n+\t\t\n+\t\tfor (IWizardStep step : steps)\n+\t\t{\n+\t\t\tstep.init(this);\n+\t\t}\n+\n \t\tsetActiveStep(findNextVisibleStep());\n \t}\n \n", "nb_test": 17, "linesAdd": 6, "jira_id": "4121", "singleLine": false, "nb_skipped": 0, "commit": "8967eb2b", "nb_failure": 1, "linesRem": 11}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["redirectToBufferForNonVersionedPage(org.apache.wicket.RestartResponseAtInterceptPageExceptionTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\nindex 819df88..1a31878 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n@@ -52,7 +52,7 @@\n \tpublic RestartResponseAtInterceptPageException(Page interceptPage)\n \t{\n \t\tsuper(new RenderPageRequestHandler(new PageProvider(interceptPage),\n-\t\t\tRedirectPolicy.ALWAYS_REDIRECT));\n+\t\t\tRedirectPolicy.AUTO_REDIRECT));\n \t\tInterceptData.set();\n \t}\n \n@@ -76,7 +76,7 @@ public RestartResponseAtInterceptPageException(Class<? extends Page> interceptPa\n \t\tPageParameters parameters)\n \t{\n \t\tsuper(new RenderPageRequestHandler(new PageProvider(interceptPageClass, parameters),\n-\t\t\tRedirectPolicy.ALWAYS_REDIRECT));\n+\t\t\tRedirectPolicy.AUTO_REDIRECT));\n \t\tInterceptData.set();\n \t}\n \n", "nb_test": 1201, "linesAdd": 2, "jira_id": "3836", "singleLine": false, "nb_skipped": 2, "commit": "843b76b1", "nb_failure": 0, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["preserveCookie(org.apache.wicket.response.PreserveCookieForTheNextHandlerTest): expected:<1> but was:<0>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex b92f3e3..a0dbfeb 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -20,7 +20,6 @@\n import org.apache.wicket.protocol.http.WebApplication;\n import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.Request;\n-import org.apache.wicket.request.Response;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n@@ -91,10 +90,10 @@ protected BufferedWebResponse renderPage(Url targetUrl, RequestCycle requestCycl\n \t\tIRequestHandler scheduled = requestCycle.getRequestHandlerScheduledAfterCurrent();\n \n \t\t// keep the original response\n-\t\tfinal Response originalResponse = requestCycle.getResponse();\n+\t\tfinal WebResponse originalResponse = (WebResponse) requestCycle.getResponse();\n \n \t\t// buffered web response for page\n-\t\tBufferedWebResponse response = new BufferedWebResponse((WebResponse)originalResponse);\n+\t\tBufferedWebResponse response = new BufferedWebResponse(originalResponse);\n \n \t\t// keep the original base URL\n \t\tUrl originalBaseUrl = requestCycle.getUrlRenderer().setBaseUrl(targetUrl);\n@@ -106,9 +105,12 @@ protected BufferedWebResponse renderPage(Url targetUrl, RequestCycle requestCycl\n \n \t\t\tif (scheduled == null && requestCycle.getRequestHandlerScheduledAfterCurrent() != null)\n \t\t\t{\n-\t\t\t\t// This is a special case. During page render another request handler got scheduled.\n-\t\t\t\t// The handler\n-\t\t\t\t// will want to overwrite the response, so we need to let it\n+\t\t\t\t// This is a special case.\n+\t\t\t\t// During page render another request handler got scheduled and will want to overwrite\n+\t\t\t\t// the response, so we need to let it.\n+\t\t\t\t// Just preserve the meta data headers\n+\t\t\t\toriginalResponse.reset(); // clear the initial actions because they are already copied into the new response's actions\n+\t\t\t\tresponse.writeMetaData(originalResponse);\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\telse\n", "nb_test": 1379, "linesAdd": 4, "jira_id": "4358", "singleLine": false, "nb_skipped": 5, "commit": "02ebc8ae", "nb_failure": 1, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testMiniMap(wicket.util.collections.MiniMapTest)"], "patch": "diff --git a/jdk-1.4/wicket/src/main/java/wicket/util/collections/MiniMap.java b/jdk-1.4/wicket/src/main/java/wicket/util/collections/MiniMap.java\nindex 7581c21..d63c836 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/util/collections/MiniMap.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/util/collections/MiniMap.java\n@@ -229,19 +229,19 @@ public Iterator iterator()\n \t\t\t\t{\n \t\t\t\t\tpublic boolean hasNext()\n \t\t\t\t\t{\n-\t\t\t\t\t\treturn i < size;\n+\t\t\t\t\t\treturn i < size - 1;\n \t\t\t\t\t}\n \n \t\t\t\t\tpublic Object next()\n \t\t\t\t\t{\n-\t\t\t\t\t\t// Find next key\n-\t\t\t\t\t\ti = nextKey(nextIndex(i));\n-\n \t\t\t\t\t\t// Just in case... (WICKET-428)\n \t\t\t\t\t\tif (!hasNext()) {\n \t\t\t\t\t\t\tthrow new NoSuchElementException();\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\n+\t\t\t\t\t\t// Find next key\n+\t\t\t\t\t\ti = nextKey(nextIndex(i));\n+\t\t\t\t\t\t\n \t\t\t\t\t\t// Get key\n \t\t\t\t\t\treturn keys[i];\n \t\t\t\t\t}\n@@ -273,6 +273,9 @@ public Collection values()\n \t\t{\n \t\t\tpublic Object get(final int index)\n \t\t\t{\n+\t\t\t\tif (index > size - 1) {\n+\t\t\t\t\tthrow new IndexOutOfBoundsException();\n+\t\t\t\t}\n \t\t\t\tint keyIndex = nextKey(0);\n \n \t\t\t\tfor (int i = 0; i < index; i++)\n", "nb_test": 407, "linesAdd": 6, "jira_id": "428", "singleLine": false, "nb_skipped": 0, "commit": "4a6a573b", "nb_failure": 1, "linesRem": 3}, {"files": 2, "project": "wicket", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["testInlineEnclosureAjaxPage(org.apache.wicket.markup.html.internal.TogglePageTest): pattern '<tr id=\"wicket_InlineEnclosure-0\" style=\"display:none\"></tr>' not found in:(..)", "inlineEnclosuresAreResolvedOnceOnly(org.apache.wicket.markup.html.internal.InlineEnclosureTest): expected:<2> but was:<4>", "inlineEnclosurePage_1(org.apache.wicket.markup.html.internal.InlineEnclosureTest): org/apache/wicket/markup/html/internal/InlineEnclosurePageExpectedResult_1.html expected:<...ket_InlineEnclosure-[0\"> <span>Test Label 1</span> </span>(..)", "inlineEnclosurePage_2(org.apache.wicket.markup.html.internal.InlineEnclosureTest): org/apache/wicket/markup/html/internal/InlineEnclosurePageExpectedResult_2.html expected:<...ket_InlineEnclosure-[0\"><span>Test Label 1</span>(..)", "inlineEnclosurePanelPage(org.apache.wicket.markup.html.internal.InlineEnclosureTest): org/apache/wicket/markup/html/internal/InlineEnclosurePanelPageExpectedResult.html expected:<...ket_InlineEnclosure-[0\">(..)", "inlineEnclosurePageDifferentNamespace(org.apache.wicket.markup.html.internal.InlineEnclosureTest): org/apache/wicket/markup/html/internal/InlineEnclosureDifferentNamespaceExpectedResult.html expected:<...=\"w_InlineEnclosure-[0\"><span>Test Label 1</span>(..)", "inlineEnclosureWithWicketMessageVisible(org.apache.wicket.markup.html.internal.InlineEnclosureTest): org/apache/wicket/markup/html/internal/InlineEnclosureWithWicketMessagePage_visible_expected.html expected:<...wicket_message_attr_[]\" title=\"Some title\"...> but was:<...wicket_message_attr_[1]\" title=\"Some title\"...>", "inlineEnclosureWithWicketMessageInvisible(org.apache.wicket.markup.html.internal.InlineEnclosureTest): org/apache/wicket/markup/html/internal/InlineEnclosureWithWicketMessagePage_invisible_expected.html expected:<...wicket_message_attr_[]\" style=\"display:non...> but was:<...wicket_message_attr_[1]\" style=\"display:non...>", "ajaxTogglingControllingChildShouldToggleInlineEnclosure(org.apache.wicket.markup.html.internal.AjaxEnclosureTest): pattern '<div id=\"wicket_InlineEnclosure-0\" style=\"display:none\"></div>' not found in:(..)", "ajaxTogglingNonControllingChildShouldNotToggleEnclosure(org.apache.wicket.markup.html.internal.AjaxEnclosureTest)", "nestedInlineEnclosuresShouldToggleNormally(org.apache.wicket.markup.html.internal.AjaxEnclosureTest)", "controllingChildShouldDefaultToTheSingleComponentInsideEnclosure(org.apache.wicket.markup.html.internal.AjaxEnclosureTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\nindex 6ce1edc..3e4d230 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\n@@ -19,7 +19,6 @@\n import org.apache.wicket.Page;\r\n import org.apache.wicket.markup.ComponentTag;\r\n import org.apache.wicket.markup.IMarkupFragment;\r\n-import org.apache.wicket.markup.Markup;\r\n import org.apache.wicket.markup.MarkupParser;\r\n import org.apache.wicket.markup.MarkupResourceStream;\r\n import org.apache.wicket.markup.parser.filter.InlineEnclosureHandler;\r\n@@ -47,8 +46,6 @@\n \r\n \tprivate static final Logger log = LoggerFactory.getLogger(InlineEnclosure.class);\r\n \r\n-\tprivate String enclosureMarkupAsString;\r\n-\r\n \t/**\r\n \t * Construct.\r\n \t * \r\n@@ -59,8 +56,6 @@ public InlineEnclosure(final String id, final String childId)\n \t{\r\n \t\tsuper(id, childId);\r\n \r\n-\t\tenclosureMarkupAsString = null;\r\n-\r\n \t\t// ensure that the Enclosure is ready for ajax updates\r\n \t\tsetOutputMarkupPlaceholderTag(true);\r\n \t\tsetMarkupId(getId());\r\n@@ -88,34 +83,6 @@ public boolean updateVisibility()\n \t}\r\n \r\n \t/**\r\n-\t * {@link InlineEnclosure}s keep their own cache of their markup because Component#markup is\r\n-\t * detached and later during Ajax request it is hard to re-lookup {@link InlineEnclosure}'s\r\n-\t * markup from its parent.\r\n-\t * \r\n-\t * @see org.apache.wicket.Component#getMarkup()\r\n-\t */\r\n-\t@Override\r\n-\tpublic IMarkupFragment getMarkup()\r\n-\t{\r\n-\t\tIMarkupFragment enclosureMarkup = null;\r\n-\t\tif (enclosureMarkupAsString == null)\r\n-\t\t{\r\n-\t\t\tIMarkupFragment markup = super.getMarkup();\r\n-\t\t\tif (markup != null && markup != Markup.NO_MARKUP)\r\n-\t\t\t{\r\n-\t\t\t\tenclosureMarkup = markup;\r\n-\t\t\t\tenclosureMarkupAsString = markup.toString(true);\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\telse\r\n-\t\t{\r\n-\t\t\tenclosureMarkup = Markup.of(enclosureMarkupAsString, getWicketNamespace());\r\n-\t\t}\r\n-\r\n-\t\treturn enclosureMarkup;\r\n-\t}\r\n-\r\n-\t/**\r\n \t * @return the markup namespace for Wicket elements and attributes.\r\n \t */\r\n \tprivate String getWicketNamespace()\r\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\nindex 7e9ea8e..507339b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n@@ -65,6 +65,12 @@\n \tprivate Stack<ComponentTag> enclosures;\r\n \r\n \t/**\r\n+\t * InlinceEnclosures are not removed after render as other auto-components,\r\n+\t * thus they have to have a stable id.\r\n+\t */\r\n+\tprivate int counter;\r\n+\r\n+\t/**\r\n \t * Construct.\r\n \t */\r\n \tpublic InlineEnclosureHandler()\r\n@@ -107,7 +113,8 @@ protected MarkupElement onComponentTag(final ComponentTag tag) throws ParseExcep\n \t\t\t\t{\r\n \t\t\t\t\tif (Strings.isEmpty(htmlId))\r\n \t\t\t\t\t{\r\n-\t\t\t\t\t\tString id = getWicketNamespace() + \"_\" + INLINE_ENCLOSURE_ID_PREFIX;\r\n+\t\t\t\t\t\tString id = getWicketNamespace() + \"_\" + INLINE_ENCLOSURE_ID_PREFIX +\r\n+\t\t\t\t\t\t\t(counter++);\r\n \t\t\t\t\t\ttag.setId(id);\r\n \t\t\t\t\t}\r\n \t\t\t\t\telse\r\n@@ -198,10 +205,7 @@ public Component resolve(final MarkupContainer container, final MarkupStream mar\n \t\tif (Strings.isEmpty(inlineEnclosureChildId) == false)\r\n \t\t{\r\n \t\t\tString id = tag.getId();\r\n-\t\t\tif (id.startsWith(getWicketNamespace(markupStream)))\r\n-\t\t\t{\r\n-\t\t\t\tid = id + container.getPage().getAutoIndex();\r\n-\t\t\t}\r\n+\r\n \t\t\t// Yes, we handled the tag\r\n \t\t\treturn new InlineEnclosure(id, inlineEnclosureChildId);\r\n \t\t}\r\n", "nb_test": 1461, "linesAdd": 5, "jira_id": "5085", "singleLine": false, "nb_skipped": 3, "commit": "581c7306", "nb_failure": 9, "linesRem": 31}, {"files": 0, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["parseForwardAttributes(org.apache.wicket.protocol.http.servlet.ServletWebRequestTest): expected:<[some/forwarded/url]> but was:<[request/Uri]>"], "patch": "", "nb_test": 1244, "linesAdd": 0, "jira_id": "4138", "singleLine": false, "nb_skipped": 3, "commit": "7c89598a", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["WicketFilterTest.parsingOfAnnotatedServlet3FiltersWorks:121->Assert.assertThat:923->Assert.assertThat:956", "Expected: is \"web/\"", "but: was \"web/*/\""], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\nindex 679cfbf..d73a4a7 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n@@ -519,6 +519,10 @@ protected String getFilterPathFromAnnotation(boolean isServlet)\n \t\t\t\tpattern = \"\";\n \t\t\t}\n \n+\t\t\tif (pattern.endsWith(\"*\"))\n+\t\t\t{\n+\t\t\t\tpattern = pattern.substring(0, pattern.length() - 1);\n+\t\t\t}\n \t\t\treturn pattern;\n \t\t}\n \t\treturn null;\n", "nb_test": 1864, "linesAdd": 4, "jira_id": "5980", "singleLine": false, "nb_skipped": 1, "commit": "294b0b2f", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test1(org.apache.wicket.markup.html.form.ValidatorPropertiesTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\nindex 32edb5c..5673f23 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n@@ -159,11 +159,12 @@ public String getMessage(String key)\n \t\t\tString prefix = formComponent.getValidatorKeyPrefix();\n \t\t\tString message = null;\n \n-\t\t\t// first try the full form of key [prefix].[form-component-id].[key]\n-\t\t\tString resource = prefix(prefix, getId() + \".\" + key);\n+\t\t\t// first try the full form of key [form-component-id].[key]\n+\t\t\tString resource = getId() + \".\" + prefix(prefix, key);\n \t\t\tmessage = getString(localizer, resource, formComponent);\n \n-\t\t\t// if not found, try a more general form (without prefix) [form-component-id].[key]\n+\t\t\t// if not found, try a more general form (without prefix)\n+\t\t\t// [form-component-id].[prefix].[key]\n \t\t\tif (Strings.isEmpty(message) && Strings.isEmpty(prefix))\n \t\t\t{\n \t\t\t\tresource = getId() + \".\" + key;\n", "nb_test": 798, "linesAdd": 1, "jira_id": "2350", "singleLine": false, "nb_skipped": 0, "commit": "cd281092", "nb_failure": 1, "linesRem": 1}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["decode13(org.apache.wicket.core.request.mapper.BookmarkableMapperTest): A handler should be resolved for relative url to a bookmarkable page url!"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex 1fd71d6..a9fd212 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -190,6 +190,11 @@ else if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace,\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n+\t\t// baseUrl = 'bookmarkable/com.example.SomePage', requestUrl = 'bookmarkable/com.example.SomePage'\n+\t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, bookmarkableIdentifier) && url.getSegments().size() == 2 && urlStartsWith(url, bookmarkableIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n \t\t// baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n \t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))\n \t\t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\nindex 3789a9f..a034642 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n@@ -175,17 +175,19 @@ private boolean matches(final Request request)\n \t{\n \t\tboolean matches = false;\n \t\tUrl url = request.getUrl();\n+\t\tUrl baseUrl = request.getClientUrl();\n \t\tString namespace = getContext().getNamespace();\n \t\tString pageIdentifier = getContext().getPageIdentifier();\n+\n \t\tif (urlStartsWith(url, namespace, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n-\t\telse if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n+\t\telse if (urlStartsWith(baseUrl, namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n-\t\telse if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier))\n+\t\telse if (urlStartsWith(baseUrl, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n", "nb_test": 1495, "linesAdd": 8, "jira_id": "5071", "singleLine": false, "nb_skipped": 4, "commit": "faaae8d3", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testPageParametersInLink(org.apache.wicket.markup.html.link.MountedPageLinkTest): URL for link should contain 'mount/value/part2': mount//part2?0-1.ILinkListener-link", "testLinkOnExpiredPage(org.apache.wicket.markup.html.link.MountedPageLinkTest): Can't instantiate page using constructor 'public org.apache.wicket.markup.html.link.PageWithLink(org.apache.wicket.request.mapper.parameter.PageParameters)' and argument 'param=[]'. Might be it doesn't exist, may be it is not visible (public)."], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\nindex 3137b6c..f5271c5 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\n@@ -385,7 +385,7 @@ public Url mapHandler(IRequestHandler requestHandler)\n \t\t\t\t\thandler.getBehaviorIndex());\n \t\t\t\tPageComponentInfo pageComponentInfo = new PageComponentInfo(pageInfo, componentInfo);\n \t\t\t\tUrlInfo urlInfo = new UrlInfo(pageComponentInfo, page.getClass(),\n-\t\t\t\t\thandler.getPageParameters());\n+\t\t\t\t\tpage.getPageParameters());\n \t\t\t\turl = buildUrl(urlInfo);\n \t\t\t}\n \t\t}\n", "nb_test": 1283, "linesAdd": 1, "jira_id": "4290", "singleLine": false, "nb_skipped": 4, "commit": "e1953357", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["foo(org.apache.wicket.stateless.StatelessDynmicLinksTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 62f1eba..e139f99 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -4200,15 +4200,10 @@ public Component get(final String path)\n \t */\n \tvoid internalMarkRendering(boolean setRenderingFlag)\n \t{\n-\t\tif (setRenderingFlag)\n-\t\t{\n+\t\t// WICKET-5460 no longer prepared for render\n \t\tsetFlag(FLAG_PREPARED_FOR_RENDER, false);\n-\t\t\tsetFlag(FLAG_RENDERING, true);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tsetFlag(FLAG_RENDERING, false);\n-\t\t}\n+\n+\t\tsetFlag(FLAG_RENDERING, setRenderingFlag);\n \t}\n \n \t/**\n", "nb_test": 1546, "linesAdd": 2, "jira_id": "5460", "singleLine": false, "nb_skipped": 2, "commit": "a3a5a40f", "nb_failure": 1, "linesRem": 8}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["isStateless(org.apache.wicket.util.tester.WicketTesterLazyIsPageStatelessRedirectToBufferTest): expected:<[tru]e> but was:<[fals]e>", "isStateless(org.apache.wicket.util.tester.WicketTesterLazyIsPageStatelessRedirectToRenderTest): expected:<[tru]e> but was:<[fals]e>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Page.java b/wicket-core/src/main/java/org/apache/wicket/Page.java\nindex 2be236d..1a3e9aa 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Page.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Page.java\n@@ -801,11 +801,8 @@ protected void onBeforeRender()\n \t\t// Make sure it is really empty\n \t\trenderedComponents = null;\n \n-\t\t// if the page is stateless, reset the flag so that it is tested again\n-\t\tif (Boolean.TRUE.equals(stateless))\n-\t\t{\n+\t\t// rendering might remove or add stateful components, so clear flag to force reevaluation\n \t\tstateless = null;\n-\t\t}\n \n \t\tsuper.onBeforeRender();\n \n@@ -1020,6 +1017,8 @@ public void renderPage()\n \t\t{\n \t\t\t++renderCount;\n \t\t\trender();\n+\n+\t\t\t// stateless = null;\n \t\t}\n \t\tfinally\n \t\t{\n", "nb_test": 1545, "linesAdd": 1, "jira_id": "5426", "singleLine": false, "nb_skipped": 2, "commit": "fb45a781", "nb_failure": 2, "linesRem": 3}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["removeObsoleteIndices(org.apache.wicket.page.persistent.disk.PageWindowManagerTest): Page0 must be lost when Page1 has been added."], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/pageStore/PageWindowManager.java b/wicket-core/src/main/java/org/apache/wicket/pageStore/PageWindowManager.java\nindex 0f2faa6..03887bb 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/pageStore/PageWindowManager.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/pageStore/PageWindowManager.java\n@@ -64,6 +64,11 @@\n \t */\n \tprivate IntHashMap<Integer> idToWindowIndex = null;\n \n+\t/**\n+\t * Inversed index of #idToWindowIndex\n+\t */\n+\tprivate IntHashMap<Integer> windowIndexToPageId = null;\n+\n \t/** index of last added page */\n \tprivate int indexPointer = -1;\n \n@@ -84,7 +89,13 @@ private void putWindowIndex(int pageId, int windowIndex)\n \t{\n \t\tif (idToWindowIndex != null && pageId != -1 && windowIndex != -1)\n \t\t{\n+\t\t\tInteger oldPageId = windowIndexToPageId.remove(windowIndex);\n+\t\t\tif (oldPageId != null)\n+\t\t\t{\n+\t\t\t\tidToWindowIndex.remove(oldPageId);\n+\t\t\t}\n \t\t\tidToWindowIndex.put(pageId, windowIndex);\n+\t\t\twindowIndexToPageId.put(windowIndex, pageId);\n \t\t}\n \t}\n \n@@ -94,7 +105,11 @@ private void putWindowIndex(int pageId, int windowIndex)\n \t */\n \tprivate void removeWindowIndex(int pageId)\n \t{\n-\t\tidToWindowIndex.remove(pageId);\n+\t\tInteger windowIndex = idToWindowIndex.remove(pageId);\n+\t\tif (windowIndex != null)\n+\t\t{\n+\t\t\twindowIndexToPageId.remove(windowIndex);\n+\t\t}\n \t}\n \n \t/**\n@@ -104,6 +119,8 @@ private void rebuildIndices()\n \t{\n \t\tidToWindowIndex = null;\n \t\tidToWindowIndex = new IntHashMap<Integer>();\n+\t\twindowIndexToPageId = null;\n+\t\twindowIndexToPageId = new IntHashMap<Integer>();\n \t\tfor (int i = 0; i < windows.size(); ++i)\n \t\t{\n \t\t\tPageWindowInternal window = windows.get(i);\n@@ -195,6 +212,7 @@ else if (window.filePartSize != size)\n \t\t}\n \n \t\tidToWindowIndex = null;\n+\t\twindowIndexToPageId = null;\n \t}\n \n \t/**\n@@ -213,6 +231,7 @@ private void mergeWindowWithNext(int index)\n \n \t\t\twindows.remove(index + 1);\n \t\t\tidToWindowIndex = null; // reset index\n+\t\t\twindowIndexToPageId = null;\n \t\t}\n \t}\n \n@@ -364,7 +383,7 @@ public PageWindow createPageWindow(int pageId, int size)\n \t\t}\n \n \t\t// if we are not going to reuse a page window (because it's not on\n-\t\t// indexPointor position or because we didn't find it), increment the\n+\t\t// indexPointer position or because we didn't find it), increment the\n \t\t// indexPointer\n \t\tif (index == -1 || index != indexPointer)\n \t\t{\n", "nb_test": 1367, "linesAdd": 17, "jira_id": "4572", "singleLine": false, "nb_skipped": 8, "commit": "dfc56674", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["anonymousClass(org.apache.wicket.cdi.ComponentInjectorTest): (..)"], "patch": "diff --git a/wicket-cdi/src/main/java/org/apache/wicket/cdi/ComponentInjector.java b/wicket-cdi/src/main/java/org/apache/wicket/cdi/ComponentInjector.java\nindex 0316004..c921706 100644\n--- a/wicket-cdi/src/main/java/org/apache/wicket/cdi/ComponentInjector.java\n+++ b/wicket-cdi/src/main/java/org/apache/wicket/cdi/ComponentInjector.java\n@@ -48,7 +48,8 @@ public void onInstantiation(Component component)\n \t{\r\n \t\tClass<? extends Component> componentClass = component.getClass();\r\n \r\n-\t\tif (componentClass.isMemberClass() && Modifier.isStatic(componentClass.getModifiers()) == false)\r\n+\t\tif (componentClass.isAnonymousClass() ||\r\n+\t\t\t(componentClass.isMemberClass() && Modifier.isStatic(componentClass.getModifiers()) == false))\r\n \t\t{\r\n \t\t\tLOG.debug(\"Skipping non-static inner class '{}' \", componentClass);\r\n \t\t}\r\n", "nb_test": 4, "linesAdd": 2, "jira_id": "5226", "singleLine": false, "nb_skipped": 0, "commit": "8e518d88", "nb_failure": 1, "rtElixir": true, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testInvalidCreditCardNumbers(org.apache.wicket.validation.validator.CreditCardValidatorTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java b/wicket/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\nindex 96ba9c0..b84d461 100644\n--- a/wicket/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n+++ b/wicket/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n@@ -19,27 +19,586 @@\n import org.apache.wicket.validation.IValidatable;\n \n /**\n- * Performs the so-called \"mod 10\" algorithm to check the validity of credit card numbers such as\n- * VISA.\n+ * Checks if a credit card number is valid. The number will be checked for \"American Express\",\n+ * \"China UnionPay\", \"Diners Club Carte Blanche\", \"Diners Club International\",\n+ * \"Diners Club US & Canada\", \"Discover Card\", \"JCB\", \"Laser\", \"Maestro\", \"MasterCard\", \"Solo\",\n+ * \"Switch\", \"Visa\" and \"Visa Electron\". If none of those apply to the credit card number, the\n+ * credit card number is considered invalid.\n+ * \n  * <p>\n- * In addition to this, the credit card number can be further validated by its length and prefix,\n- * but those properties depend upon the credit card type, and such validation is not performed by\n- * this validator.\n+ * Card prefixes and lengths have been taken from <a\n+ * href=\"http://en.wikipedia.org/w/index.php?title=Bank_card_number&oldid=322132931\">Wikipedia</a>.\n  * \n  * @author Johan Compagner\n+ * @author Joachim F. Rohde\n  * @since 1.2.6\n  */\n public class CreditCardValidator extends AbstractValidator<String>\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\t/** The credit card number, which should be validated. */\n+\tprivate String creditCardNumber = null;\n+\n+\t/** The ID which represents the credit card institute. */\n+\tprivate int cardId = -1;\n+\n+\t/** */\n+\tpublic static final int INVALID = -1;\n+\tpublic static final int AMERICAN_EXPRESS = 0;\n+\tpublic static final int CHINA_UNIONPAY = 1;\n+\tpublic static final int DINERS_CLUB_CARTE_BLANCHE = 2;\n+\tpublic static final int DINERS_CLUB_INTERNATIONAL = 3;\n+\tpublic static final int DINERS_CLUB_US_AND_CANADA = 4;\n+\tpublic static final int DISCOVER_CARD = 5;\n+\tpublic static final int JCB = 6;\n+\tpublic static final int LASER = 7;\n+\tpublic static final int MAESTRO = 8;\n+\tpublic static final int MASTERCARD = 9;\n+\tpublic static final int SOLO = 10;\n+\tpublic static final int SWITCH = 11;\n+\tpublic static final int VISA = 12;\n+\tpublic static final int VISA_ELECTRON = 13;\n+\n+\tprivate static final String[] creditCardNames = { \"American Express\", \"China UnionPay\",\n+\t\t\t\"Diners Club Carte Blanche\", \"Diners Club International\", \"Diners Club US & Canada\",\n+\t\t\t\"Discover Card\", \"JCB\", \"Laser\", \"Maestro\", \"MasterCard\", \"Solo\", \"Switch\", \"Visa\",\n+\t\t\t\"Visa Electron\" };\n+\n \t/**\n \t * @see AbstractValidator#onValidate(IValidatable)\n \t */\n \t@Override\n \tprotected void onValidate(IValidatable<String> validatable)\n \t{\n-\t\tString input = (validatable.getValue());\n+\t\tcreditCardNumber = validatable.getValue();\n+\t\tif (!isLengthAndPrefixCorrect(creditCardNumber))\n+\t\t{\n+\t\t\terror(validatable);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks if the credit card number can be determined as a valid number.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number could be determined as a valid number,\n+\t *         else <code>FALSE</code> is returned\n+\t */\n+\tprivate boolean isLengthAndPrefixCorrect(String creditCardNumber)\n+\t{\n+\t\tif (creditCardNumber != null)\n+\t\t{\n+\t\t\t// strip spaces and dashes\n+\t\t\tcreditCardNumber = creditCardNumber.replaceAll(\"[ -]\", \"\");\n+\t\t}\n+\n+\t\t// the length of the credit card number has to be between 12 and 19.\n+\t\t// else the number is invalid.\n+\t\tif (creditCardNumber != null && creditCardNumber.length() >= 12 &&\n+\t\t\tcreditCardNumber.length() <= 19)\n+\t\t{\n+\t\t\tif (isAmericanExpress(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isChinaUnionPay(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isDinersClubCarteBlanche(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isDinersClubInternational(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isDinersClubUsAndCanada(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isDiscoverCard(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isJCB(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isLaser(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isMaestro(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isMastercard(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isSolo(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isSwitch(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isVisa(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isVisaElectron(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isUnknown(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Can be used (subclassed) to extend the test with a credit card not yet known by the\n+\t * validator.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid American Express\n+\t *         number. Else <code>FALSE</code> will be returned\n+\t */\n+\tprotected boolean isUnknown(String creditCardNumber)\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is an American Express. An American Express number has to start with\n+\t * 34 or 37 and has to have a length of 15. The number has to be validated with the Luhn\n+\t * alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid American Express\n+\t *         number. Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isAmericanExpress(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 15 &&\n+\t\t\t(creditCardNumber.startsWith(\"34\") || creditCardNumber.startsWith(\"37\")))\n+\t\t{\n+\t\t\tif (isChecksumCorrect(creditCardNumber))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.AMERICAN_EXPRESS;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a China UnionPay. A China UnionPay number has to start with 622\n+\t * (622126-622925) and has to have a length between 16 and 19. No further validation takes\n+\t * place.<br/>\n+\t * <br/>\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid China UnionPay\n+\t *         number. Else <code>FALSE</code> will be returned.\n+\t */\n+\tprivate boolean isChinaUnionPay(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif ((creditCardNumber.length() >= 16 && creditCardNumber.length() <= 19) &&\n+\t\t\t(creditCardNumber.startsWith(\"622\")))\n+\t\t{\n+\t\t\tint firstDigits = Integer.parseInt(creditCardNumber.substring(0, 5));\n+\t\t\tif (firstDigits >= 622126 && firstDigits <= 622925)\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.CHINA_UNIONPAY;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Diners Club Carte Blanche. A Diners Club Carte Blanche number\n+\t * has to start with a number between 300 and 305 and has to have a length of 14. The number has\n+\t * to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Diners Club Carte\n+\t *         Blanche number. Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isDinersClubCarteBlanche(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 14 && creditCardNumber.startsWith(\"30\"))\n+\t\t{\n+\t\t\tint firstDigits = Integer.parseInt(creditCardNumber.substring(0, 3));\n+\t\t\tif (firstDigits >= 300 && firstDigits <= 305 && isChecksumCorrect(creditCardNumber))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.DINERS_CLUB_CARTE_BLANCHE;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Diners Club International. A Diners Club International number\n+\t * has to start with the number 36 and has to have a length of 14. The number has to be\n+\t * validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Diners Club\n+\t *         International number. Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isDinersClubInternational(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 14 && creditCardNumber.startsWith(\"36\") &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tcardId = CreditCardValidator.DINERS_CLUB_INTERNATIONAL;\n+\t\t\treturnValue = true;\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Diners Club US & Canada. A Diners Club US & Canada number has\n+\t * to start with the number 54 or 55 and has to have a length of 16. The number has to be\n+\t * validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Diners Club US &\n+\t *         Canada number. Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isDinersClubUsAndCanada(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 16 &&\n+\t\t\t(creditCardNumber.startsWith(\"54\") || creditCardNumber.startsWith(\"55\")) &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tcardId = CreditCardValidator.DINERS_CLUB_US_AND_CANADA;\n+\t\t\treturnValue = true;\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Discover Card. A Discover Card number has to start with 6011,\n+\t * 622126-622925, 644-649 or 65 and has to have a length of 16. The number has to be validated\n+\t * with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Discover Card number.\n+\t *         Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isDiscoverCard(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 16 && creditCardNumber.startsWith(\"6\") &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tint firstThreeDigits = Integer.parseInt(creditCardNumber.substring(0, 3));\n+\t\t\tint firstSixDigits = Integer.parseInt(creditCardNumber.substring(0, 6));\n+\t\t\tif (creditCardNumber.startsWith(\"6011\") || creditCardNumber.startsWith(\"65\") ||\n+\t\t\t\t(firstThreeDigits >= 644 && firstThreeDigits <= 649) ||\n+\t\t\t\t(firstSixDigits >= 622126 && firstSixDigits <= 622925))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.DISCOVER_CARD;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a JCB. A JCB number has to start with a number between 3528 and\n+\t * 3589 and has to have a length of 16. The number has to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid JCB number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isJCB(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 16 && isChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tint firstFourDigits = Integer.parseInt(creditCardNumber.substring(0, 4));\n+\t\t\tif (firstFourDigits >= 3528 && firstFourDigits <= 3589)\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.JCB;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Laser. A Laser number has to start with 6304, 6706, 6771 or\n+\t * 6709 and has to have a length between 16 and 19 digits. The number has to be validated with\n+\t * the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Laser number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isLaser(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() >= 16 && creditCardNumber.length() <= 19 &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tif (creditCardNumber.startsWith(\"6304\") || creditCardNumber.startsWith(\"6706\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"6771\") || creditCardNumber.startsWith(\"6709\"))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.LASER;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Maestro. A Maestro number has to start with\n+\t * 5018,5020,5038,6304,6759,6761 or 6763 and has to have a length between 12 and 19 digits. The\n+\t * number has to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Maestro number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isMaestro(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() >= 12 && creditCardNumber.length() <= 19 &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tif (creditCardNumber.startsWith(\"5018\") || creditCardNumber.startsWith(\"5020\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"5038\") || creditCardNumber.startsWith(\"6304\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"6759\") || creditCardNumber.startsWith(\"6761\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"6763\"))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.MAESTRO;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Solo. A Solo number has to start with 6334 or 6767 and has to\n+\t * have a length of 16, 18 or 19 digits. The number has to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Solo number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isSolo(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif ((creditCardNumber.length() == 16 || creditCardNumber.length() == 18 || creditCardNumber.length() == 19) &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tif (creditCardNumber.startsWith(\"6334\") || creditCardNumber.startsWith(\"6767\"))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.SOLO;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Switch. A Switch number has to start with\n+\t * 4903,4905,4911,4936,564182,633110,6333 or 6759 and has to have a length of 16, 18 or 19\n+\t * digits. The number has to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Switch number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isSwitch(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif ((creditCardNumber.length() == 16 || creditCardNumber.length() == 18 || creditCardNumber.length() == 19) &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tif (creditCardNumber.startsWith(\"4903\") || creditCardNumber.startsWith(\"4905\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"4911\") || creditCardNumber.startsWith(\"4936\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"564182\") || creditCardNumber.startsWith(\"633110\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"6333\") || creditCardNumber.startsWith(\"6759\"))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.SWITCH;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Visa. A Visa number has to start with a 4 and has to have a\n+\t * length of 13 or 16 digits. The number has to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Visa number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isVisa(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 13 || creditCardNumber.length() == 16)\n+\t\t{\n+\t\t\tif (creditCardNumber.startsWith(\"4\"))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.SWITCH;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Visa Electron. A Visa Electron number has to start with\n+\t * 417500,4917,4913,4508 or 4844 and has to have a length of 16 digits. The number has to be\n+\t * validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Visa Electron number.\n+\t *         Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isVisaElectron(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 16 &&\n+\t\t\t(creditCardNumber.startsWith(\"417500\") || creditCardNumber.startsWith(\"4917\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"4913\") || creditCardNumber.startsWith(\"4508\") || creditCardNumber.startsWith(\"4844\")))\n+\t\t{\n+\t\t\tcardId = CreditCardValidator.VISA_ELECTRON;\n+\t\t\treturnValue = true;\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Mastercard. A Mastercard number has to start with a number\n+\t * between 51 and 55 and has to have a length of 16. The number has to be validated with the\n+\t * Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Mastercard number.\n+\t *         Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isMastercard(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 16 && isChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tint firstTwoDigits = Integer.parseInt(creditCardNumber.substring(0, 2));\n+\t\t\tif (firstTwoDigits >= 51 && firstTwoDigits <= 55)\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.MASTERCARD;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Just used for debugging purposes.<br>\n+\t * Due to re-branding (e.g. Switch was re-branded as Maestro in mid 2007) some rules might\n+\t * overlap, but those overlappings are not considered. So it might happen, that a Switch-card is\n+\t * identified as a Maestro. <br>\n+\t * So you shouldn't rely on the name which is returned here.\n+\t * \n+\t * @return the name of the credit card if it could be determined, else an empty string\n+\t */\n+\tprivate String getCardName()\n+\t{\n+\t\treturn (cardId > -1 && cardId < creditCardNames.length ? creditCardNames[cardId] : \"\");\n+\t}\n+\n+\t/**\n+\t * Calculates the checksum of a credit card number using the Luhn algorithm (the so-called\n+\t * \"mod 10\" algorithm).\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number for which the checksum should be calculated\n+\t * @return <code>TRUE</code> if the checksum for the given credit card number is valid, else\n+\t *         return <code>FALSE</code>\n+\t * @see <a href=\"http://en.wikipedia.org/wiki/Luhn_algorithm\">Wikipedie - Luhn algorithm</a>\n+\t */\n+\tprivate boolean isChecksumCorrect(String creditCardNumber)\n+\t{\n+\t\tString input = creditCardNumber;\n \t\tString numberToCheck = input.replaceAll(\"[ -]\", \"\");\n \t\tint nulOffset = '0';\n \t\tint sum = 0;\n@@ -57,9 +616,7 @@ protected void onValidate(IValidatable<String> validatable)\n \t\t\t\tsum += currentDigit;\n \t\t\t}\n \t\t}\n-\t\tif (!((sum % 10) == 0))\n-\t\t{\n-\t\t\terror(validatable);\n-\t\t}\n+\n+\t\treturn (sum % 10) == 0;\n \t}\n }\n", "nb_test": 927, "linesAdd": 378, "jira_id": "2552", "singleLine": false, "nb_skipped": 0, "commit": "12e1f39b", "nb_failure": 0, "linesRem": 5}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["wicket4066(org.apache.wicket.wicket4066.Wicket4066Test): classes not the same, expected 'class org.apache.wicket.wicket4066.SuccessPage', current 'class org.apache.wicket.wicket4066.SecurePage'"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\nindex 1a31878..98668ad 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n@@ -165,7 +165,7 @@ static boolean continueToOriginalDestination()\n \t{\n \t\tpublic int getCompatibilityScore(Request request)\n \t\t{\n-\t\t\treturn 0;\n+\t\t\treturn matchedData(request) != null ? Integer.MAX_VALUE : 0;\n \t\t}\n \n \t\tpublic Url mapHandler(IRequestHandler requestHandler)\n@@ -175,11 +175,9 @@ public Url mapHandler(IRequestHandler requestHandler)\n \n \t\tpublic IRequestHandler mapRequest(Request request)\n \t\t{\n-\t\t\tInterceptData data = InterceptData.get();\n+\t\t\tInterceptData data = matchedData(request);\n \t\t\tif (data != null)\n \t\t\t{\n-\t\t\t\tif (data.originalUrl.equals(request.getOriginalUrl()))\n-\t\t\t\t{\n \t\t\t\tif (data.postParameters.isEmpty() == false &&\n \t\t\t\t\trequest.getPostParameters() instanceof IWritableRequestParameters)\n \t\t\t\t{\n@@ -192,6 +190,15 @@ public IRequestHandler mapRequest(Request request)\n \t\t\t\t}\n \t\t\t\tInterceptData.clear();\n \t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\t\t\n+\t\tprivate InterceptData matchedData(Request request)\n+\t\t{\n+\t\t\tInterceptData data = InterceptData.get();\n+\t\t\tif(data != null && data.originalUrl.equals(request.getOriginalUrl()))\n+\t\t\t{\n+\t\t\t\treturn data;\n \t\t\t}\n \t\t\treturn null;\n \t\t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/SystemMapper.java b/wicket-core/src/main/java/org/apache/wicket/SystemMapper.java\nindex e0eea63..7412737 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/SystemMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/SystemMapper.java\n@@ -46,12 +46,12 @@\n \tpublic SystemMapper(final Application application)\r\n \t{\r\n \t\tthis.application = application;\r\n-\t\tadd(RestartResponseAtInterceptPageException.MAPPER);\r\n \t\tadd(new PageInstanceMapper());\r\n \t\tadd(new BookmarkableMapper());\r\n \t\tadd(new HomePageMapper(new HomePageProvider<Page>(application)));\r\n \t\tadd(new ResourceReferenceMapper(new PageParametersEncoder(),\r\n \t\t\tnew ParentFolderPlaceholderProvider(application), getResourceCachingStrategy()));\r\n+\t\tadd(RestartResponseAtInterceptPageException.MAPPER);\r\n \t\tadd(new BufferedResponseMapper());\r\n \t}\r\n \r\n", "nb_test": 1194, "linesAdd": 12, "jira_id": "4066", "singleLine": false, "nb_skipped": 2, "commit": "4d3d1f85", "nb_failure": 1, "linesRem": 5}, {"files": 3, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": [], "patch": "diff --git a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\nindex 032a818..e8e6376 100644\n--- a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\n+++ b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\n@@ -1,6 +1,10 @@\n package org.apache.wicket.bean.validation;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Set;\n \n import javax.validation.ConstraintViolation;\n@@ -62,8 +66,8 @@\n \tprivate final IModel<Class<?>[]> groups_;\n \n \t/**\n-\t * A flag that indicates whether {@linkplain #setComponentRequiredFlag()}\n-\t * has been called for this behavior.\n+\t * A flag that indicates whether {@linkplain #setComponentRequiredFlag()} has been called for\n+\t * this behavior.\n \t */\n \tprivate boolean requiredFlagSet;\n \n@@ -132,8 +136,10 @@ public void bind(Component component)\n \t\t\t\t\" can only be added to FormComponents\");\n \t\t}\n \n-\t\t// TODO add a validation key that appends the type so we can have different messages for\n-\t\t// @Size on String vs Collection - done but need to add a key for each superclass/interface\n+\t\t// TODO add a validation key that appends the type so we can have\n+\t\t// different messages for\n+\t\t// @Size on String vs Collection - done but need to add a key for each\n+\t\t// superclass/interface\n \n \t\tthis.component = (FormComponent<T>)component;\n \t}\n@@ -144,10 +150,15 @@ public void onConfigure(Component component)\n \t\tsuper.onConfigure(component);\n \t\tif (requiredFlagSet == false)\n \t\t{\n-\t\t\t// \"Required\" flag is calculated upon component's model property, so we must ensure,\n-\t\t\t// that model object is accessible (i.e. component is already added in a page).\n+\t\t\t// \"Required\" flag is calculated upon component's model property, so\n+\t\t\t// we must ensure,\n+\t\t\t// that model object is accessible (i.e. component is already added\n+\t\t\t// in a page).\n \t\t\trequiredFlagSet = true;\n-\t\t\tsetComponentRequiredFlag();\n+\t\t\tif (isRequired())\n+\t\t\t{\n+\t\t\t\tthis.component.setRequired(true);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -161,28 +172,58 @@ public void detach(Component component)\n \t\t}\n \t}\n \n-\t/**\n-\t * Marks the form component required if necessary\n-\t */\n-\tprivate void setComponentRequiredFlag()\n+\tprivate List<NotNull> findNotNullConstraints()\n \t{\n \t\tBeanValidationContext config = BeanValidationConfiguration.get();\n \t\tValidator validator = config.getValidator();\n \t\tProperty property = getProperty();\n \n-\t\t// if the property has a NotNull constraint mark the form component required\n+\t\tList<NotNull> constraints = new ArrayList<NotNull>();\n \n \t\tIterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property);\n+\n \t\twhile (it.hasNext())\n \t\t{\n \t\t\tConstraintDescriptor<?> desc = it.next();\n \t\t\tif (desc.getAnnotation().annotationType().equals(NotNull.class))\n \t\t\t{\n-\t\t\t\tcomponent.setRequired(true);\n-\t\t\t\tbreak;\n+\t\t\t\tconstraints.add((NotNull)desc.getAnnotation());\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn constraints;\n+\t}\n+\n+\tboolean isRequired()\n+\t{\n+\t\tList<NotNull> constraints = findNotNullConstraints();\n+\n+\t\tif (constraints.isEmpty())\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tHashSet<Class<?>> validatorGroups = new HashSet<Class<?>>();\n+\t\tvalidatorGroups.addAll(Arrays.asList(getGroups()));\n+\n+\t\tfor (NotNull constraint : constraints)\n+\t\t{\n+\t\t\tif (constraint.groups().length == 0 && validatorGroups.isEmpty())\n+\t\t\t{\n+\t\t\t\treturn true;\n \t\t\t}\n+\n+\t\t\tfor (Class<?> constraintGroup : constraint.groups())\n+\t\t\t{\n+\t\t\t\tif (validatorGroups.contains(constraintGroup))\n+\t\t\t\t{\n+\t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n \n \t@Override\n \t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n@@ -194,7 +235,8 @@ public void onComponentTag(Component component, ComponentTag tag)\n \t\tValidator validator = config.getValidator();\n \t\tProperty property = getProperty();\n \n-\t\t// find any tag modifiers that apply to the constraints of the property being validated\n+\t\t// find any tag modifiers that apply to the constraints of the property\n+\t\t// being validated\n \t\t// and allow them to modify the component tag\n \n \t\tIterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property,\ndiff --git a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SessionLocaleInterpolator.java b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SessionLocaleInterpolator.java\nindex 00aa506..f8927e2 100644\n--- a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SessionLocaleInterpolator.java\n+++ b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SessionLocaleInterpolator.java\n@@ -28,7 +28,8 @@ public SessionLocaleInterpolator(MessageInterpolator delegate)\n \t\tthis.delegate = delegate;\n \t}\n \n-\tpublic String interpolate(final String messageTemplate, final MessageInterpolator.Context context)\n+\tpublic String interpolate(final String messageTemplate,\n+\t\tfinal MessageInterpolator.Context context)\n \t{\n \t\tfinal Locale locale = getLocale();\n \t\tif (locale != null)\n@@ -41,7 +42,8 @@ public String interpolate(final String messageTemplate, final MessageInterpolato\n \t\t}\n \t}\n \n-\tpublic String interpolate(final String message, final MessageInterpolator.Context context, final Locale locale)\n+\tpublic String interpolate(final String message, final MessageInterpolator.Context context,\n+\t\tfinal Locale locale)\n \t{\n \t\treturn delegate.interpolate(message, context, locale);\n \t}\ndiff --git a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SizeTagModifier.java b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SizeTagModifier.java\nindex 4124974..1795dc4 100644\n--- a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SizeTagModifier.java\n+++ b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SizeTagModifier.java\n@@ -6,8 +6,8 @@\n import org.apache.wicket.markup.html.form.FormComponent;\n \n /**\n- * A tag modifier that adds the {@code maxlength} attribute to the {@code input} tag with the max value\n- * from the {@link Size} constraint annotation.\n+ * A tag modifier that adds the {@code maxlength} attribute to the {@code input} tag with the max\n+ * value from the {@link Size} constraint annotation.\n  * \n  * @author igor\n  * \n", "nb_test": 1, "linesAdd": 49, "jira_id": "5418", "singleLine": false, "nb_skipped": 0, "commit": "e350f19e", "nb_failure": 0, "linesRem": 6}, {"files": 1, "project": "wicket", "nb_error": 6, "classification": {"singleLine": false}, "failing_tests": ["testHideableBorder(org.apache.wicket.markup.html.border.ComponentBorderTest)", "versionPage(org.apache.wicket.versioning.PageVersioningTest)", "testConfiguration(org.apache.wicket.ComponentConfigurationTest)", "testVisibilityOfChildren(org.apache.wicket.markup.html.internal.EnclosureTest)", "testRender9(org.apache.wicket.markup.html.internal.EnclosureTest)", "testRender9a(org.apache.wicket.markup.html.internal.EnclosureTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/Component.java b/wicket/src/main/java/org/apache/wicket/Component.java\nindex c9d7bde..fa7e85a 100644\n--- a/wicket/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket/src/main/java/org/apache/wicket/Component.java\n@@ -430,16 +430,6 @@ public boolean compare(Component component, Object b)\n \t};\n \n \t/**\n-\t * Keeps metadata about the visibility state of the component\n-\t * \n-\t * The states are: null - not calculated, true and false\n-\t */\n-\tprivate static final MetaDataKey<Boolean> VISIBLE_IN_HIERARCHY_CACHE_KEY = new MetaDataKey<Boolean>()\n-\t{\n-\t\tprivate static final long serialVersionUID = 1L;\n-\t};\n-\n-\t/**\n \t * Keeps metadata about the enabled state of the component\n \t * \n \t * The states are: null - not calculated, true and false\n@@ -2148,21 +2138,15 @@ public boolean isVisible()\n \t */\n \tpublic final boolean isVisibleInHierarchy()\n \t{\n-\t\tBoolean state = getMetaData(VISIBLE_IN_HIERARCHY_CACHE_KEY);\n-\t\tif (state == null)\n-\t\t{\n \t\tComponent parent = getParent();\n \t\tif (parent != null && !parent.isVisibleInHierarchy())\n \t\t{\n-\t\t\t\tstate = false;\n+\t\t\treturn false;\n \t\t}\n \t\telse\n \t\t{\n-\t\t\t\tstate = determineVisibility();\n-\t\t\t}\n-\t\t\tsetMetaData(VISIBLE_IN_HIERARCHY_CACHE_KEY, state);\n+\t\t\treturn determineVisibility();\n \t\t}\n-\t\treturn state;\n \t}\n \n \t/**\n", "nb_test": 992, "linesAdd": 2, "jira_id": "3166", "singleLine": false, "nb_skipped": 0, "commit": "4d7f7359", "nb_failure": 0, "linesRem": 13}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["set(org.apache.wicket.request.mapper.parameter.PageParametersTest)"], "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\nindex 03c3dc5..bb11fa4 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\n@@ -483,7 +483,8 @@ public PageParameters set(final String name, final Object value, final int index\n \t */\n \tpublic PageParameters set(final String name, final Object value)\n \t{\n-\t\tset(name, value, -1);\n+\t\tint position = getPosition(name);\n+\t\tset(name, value, position);\n \t\treturn this;\n \t}\n \n", "nb_test": 48, "linesAdd": 2, "jira_id": "3906", "singleLine": false, "nb_skipped": 0, "commit": "aadaa4e9", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testDropDownEvent(wicket.FormDispatchEventTest): Internal error cloning object. Make sure all dependent objects implement Serializable. Class: wicket.protocol.http.SecondLevelCacheSessionStore$SecondLevelCachePageMap"], "patch": "diff --git a/wicket/src/main/java/wicket/Session.java b/wicket/src/main/java/wicket/Session.java\nindex 0a64238..1de82b7 100644\n--- a/wicket/src/main/java/wicket/Session.java\n+++ b/wicket/src/main/java/wicket/Session.java\n@@ -16,8 +16,6 @@\n  */\n package wicket;\n \n-import java.io.ByteArrayOutputStream;\n-import java.io.ObjectOutputStream;\n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.HashMap;\n@@ -41,7 +39,6 @@\n import wicket.request.ClientInfo;\n import wicket.session.ISessionStore;\n import wicket.util.convert.IConverter;\n-import wicket.util.lang.Bytes;\n import wicket.util.lang.Objects;\n import wicket.util.string.Strings;\n import wicket.util.time.Duration;\n@@ -1036,20 +1033,6 @@ protected final void setAttribute(String name, Object value)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tString valueTypeName = (value != null ? value.getClass().getName() : \"null\");\n-\t\ttry\n-\t\t{\n-\t\t\tfinal ByteArrayOutputStream out = new ByteArrayOutputStream();\n-\t\t\tnew ObjectOutputStream(out).writeObject(value);\n-\t\t\tlog.debug(\"Stored attribute \" + name + \"{ \" + valueTypeName + \"} with size: \"\n-\t\t\t\t\t+ Bytes.bytes(out.size()));\n-\t\t}\n-\t\tcatch (Exception e)\n-\t\t{\n-\t\t\tthrow new WicketRuntimeException(\n-\t\t\t\t\t\"Internal error cloning object. Make sure all dependent objects implement Serializable. Class: \"\n-\t\t\t\t\t\t\t+ valueTypeName, e);\n-\t\t}\n \n \t\t// Set the actual attribute\n \t\tstore.setAttribute(request, name, value);\n", "nb_test": 377, "linesAdd": 0, "jira_id": "128", "singleLine": false, "nb_skipped": 0, "commit": "7e1000dd", "nb_failure": 0, "linesRem": 17}, {"files": 2, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["recreateThePageWhenListenereInterfaceIsExecutedOnExpiredPage(org.apache.wicket.request.handler.ListenerInterfaceRequestHandlerTest): Cannot find behavior with id: 0 on component: [ [Component id = test]]. Perhaps the behavior did not properly implement getStatelessHint() and returned 'true' to indicate that it is stateless instead of returning 'false' to indicate that it is stateful."], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\nindex de801ef..a74d098 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\n@@ -26,6 +26,8 @@\n import org.apache.wicket.request.http.WebRequest;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n import org.apache.wicket.util.lang.Args;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Request handler that invokes the listener interface on component and renders page afterwards.\n@@ -37,6 +39,9 @@\n \t\tIPageRequestHandler,\n \t\tIComponentRequestHandler\n {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(ListenerInterfaceRequestHandler.class);\n+\n \tprivate final IPageAndComponentProvider pageComponentProvider;\n \n \tprivate final RequestListenerInterface listenerInterface;\n@@ -146,19 +151,42 @@ public Integer getBehaviorIndex()\n \t */\n \tpublic void respond(final IRequestCycle requestCycle)\n \t{\n+\t\tfinal boolean isNewPageInstance = pageComponentProvider.isNewPageInstance();\n+\t\tfinal boolean isAjax = ((WebRequest)requestCycle.getRequest()).isAjax();\n \t\tfinal IRequestablePage page = getPage();\n+\t\tfinal boolean isStateless = page.isPageStateless();\n+\t\tfinal IPageProvider pageProvider = new PageProvider(page);\n+\n \t\tif (getComponent().getPage() == page)\n \t\t{\n-\t\t\tboolean isAjax = ((WebRequest)requestCycle.getRequest()).isAjax();\n+\t\t\tRedirectPolicy policy = isStateless ? RedirectPolicy.NEVER_REDIRECT\n+\t\t\t\t: RedirectPolicy.AUTO_REDIRECT;\n+\n+\t\t\tif (isNewPageInstance)\n+\t\t\t{\n+\t\t\t\tif (LOG.isDebugEnabled())\n+\t\t\t\t{\n+\t\t\t\t\tLOG.debug(\n+\t\t\t\t\t\t\"A ListenerInterface '{}' assigned to '{}' is executed on an expired page. \"\n+\t\t\t\t\t\t\t+ \"Scheduling re-create of the page and ignoring the listener interface...\",\n+\t\t\t\t\t\tlistenerInterface, getComponentPath());\n+\t\t\t\t}\n+\n+\t\t\t\tif (isAjax)\n+\t\t\t\t{\n+\t\t\t\t\tpolicy = RedirectPolicy.ALWAYS_REDIRECT;\n+\t\t\t\t}\n+\n+\t\t\t\trequestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(\n+\t\t\t\t\tpageProvider, policy));\n+\t\t\t\treturn;\n+\t\t\t}\n+\n \t\t\tif (isAjax == false && listenerInterface.isRenderPageAfterInvocation())\n \t\t\t{\n \t\t\t\t// schedule page render after current request handler is done. this can be\n \t\t\t\t// overridden during invocation of listener\n \t\t\t\t// method (i.e. by calling RequestCycle#setResponsePage)\n-\t\t\t\tfinal IPageProvider pageProvider = new PageProvider(page);\n-\t\t\t\tfinal RedirectPolicy policy = page.isPageStateless()\n-\t\t\t\t\t? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;\n-\n \t\t\t\trequestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(\n \t\t\t\t\tpageProvider, policy));\n \t\t\t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\nindex f000bad..ed9af8f 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n@@ -59,6 +59,8 @@\n \n \tprivate PageParameters pageParameters;\n \n+\tprivate Boolean isNewInstance = null;\n+\n \t/**\n \t * Creates a new page provider object. Upon calling of {@link #getPageInstance()} this provider\n \t * will return page instance with specified id.\n@@ -198,17 +200,20 @@ else if (isNewPageInstance() == false)\n \t */\n \tpublic boolean isNewPageInstance()\n \t{\n-\t\tboolean isNew = pageInstance == null;\n-\t\tif (isNew && pageId != null)\n+\t\tif (isNewInstance == null)\n+\t\t{\n+\t\t\tisNewInstance = pageInstance == null;\n+\t\t\tif (isNewInstance && pageId != null)\n \t\t\t{\n \t\t\t\tIRequestablePage storedPageInstance = getStoredPage(pageId);\n \t\t\t\tif (storedPageInstance != null)\n \t\t\t\t{\n \t\t\t\t\tpageInstance = storedPageInstance;\n-\t\t\t\tisNew = false;\n+\t\t\t\t\tisNewInstance = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn isNew;\n+\t\treturn isNewInstance;\n \t}\n \n \t/**\n@@ -292,6 +297,14 @@ private IRequestablePage getStoredPage(final int pageId)\n \t\t\t(pageClass == null || pageClass.equals(storedPageInstance.getClass())))\n \t\t{\n \t\t\tpageInstance = storedPageInstance;\n+\n+\t\t\tif (pageInstance != null)\n+\t\t\t{\n+\t\t\t\tif (renderCount != null && pageInstance.getRenderCount() != renderCount)\n+\t\t\t\t{\n+\t\t\t\t\tthrow new StalePageException(pageInstance);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\treturn storedPageInstance;\n \t}\n", "nb_test": 1202, "linesAdd": 50, "jira_id": "4116", "singleLine": false, "nb_skipped": 2, "commit": "4624ab3d", "nb_failure": 0, "linesRem": 9}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testParentheses(org.apache.wicket.validation.validator.UrlValidatorTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java b/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\nindex a259c51..b7eee15 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n@@ -115,7 +115,7 @@\n \tprivate static final int PARSE_AUTHORITY_PORT = 4;\n \tprivate static final int PARSE_AUTHORITY_EXTRA = 5; // Should always be empty.\n \n-\tprivate static final String PATH_PATTERN = \"^(/[-\\\\w:@&?=+,.!/~*'%$_;]*)?$\";\n+\tprivate static final String PATH_PATTERN = \"^(/[-\\\\w:@&?=+,.!/~*'%$_;\\\\(\\\\)]*)?$\";\n \n \tprivate static final String QUERY_PATTERN = \"^(.*)$\";\n \n", "nb_test": 1466, "linesAdd": 1, "jira_id": "5112", "singleLine": false, "nb_skipped": 3, "commit": "ed780cc7", "nb_failure": 1, "linesRem": 1}, {"files": 0, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ignoreBOM(org.apache.wicket.util.io.XmlReaderTest): expected:<UTF-8> but was:<null>"], "patch": "", "nb_test": 171, "linesAdd": 0, "jira_id": "5416", "singleLine": false, "nb_skipped": 0, "commit": "87fa630f", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRendering(org.apache.wicket.ajax.form.OnChangeAjaxBehaviorTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/AbstractSingleSelectChoice.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/AbstractSingleSelectChoice.java\nindex b86f32e..937acc9 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/AbstractSingleSelectChoice.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/AbstractSingleSelectChoice.java\n@@ -165,7 +165,8 @@ public String getModelValue()\n \t\t\tint index = getChoices().indexOf(object);\n \t\t\treturn getChoiceRenderer().getIdValue(object, index);\n \t\t}\n-\t\treturn getNoSelectionValue().toString();\n+\t\tObject noSelectionValue = getNoSelectionValue();\n+\t\treturn noSelectionValue != null ? noSelectionValue.toString() : null;\n \t}\n \n \t/**\n@@ -269,6 +270,9 @@ protected T convertChoiceIdToChoice(String id)\n \t@Override\n \tprotected CharSequence getDefaultChoice(final Object selected)\n \t{\n+\n+\t\tfinal Object noSelectionValue = getNoSelectionValue();\n+\n \t\t// Is null a valid selection value?\n \t\tif (isNullValid())\n \t\t{\n@@ -287,19 +291,21 @@ protected CharSequence getDefaultChoice(final Object selected)\n \t\t\tbuffer.append(\"\\n<option\");\n \n \t\t\t// If null is selected, indicate that\n-\t\t\tif (selected == null)\n+\t\t\tif (selected == noSelectionValue)\n \t\t\t{\n \t\t\t\tbuffer.append(\" selected=\\\"selected\\\"\");\n \t\t\t}\n \n \t\t\t// Add body of option tag\n-\t\t\tbuffer.append(\" value=\\\"\\\">\").append(option).append(\"</option>\");\n+\t\t\tbuffer.append(\" value=\\\"\" + noSelectionValue + \"\\\">\")\n+\t\t\t\t.append(option)\n+\t\t\t\t.append(\"</option>\");\n \t\t\treturn buffer;\n \t\t}\n \t\telse\n \t\t{\n \t\t\t// Null is not valid. Is it selected anyway?\n-\t\t\tif ((selected == null) || getNoSelectionValue().equals(selected) ||\n+\t\t\tif ((selected == null) || selected.equals(noSelectionValue) ||\n \t\t\t\tselected.equals(EMPTY_STRING))\n \t\t\t{\n \t\t\t\t// Force the user to pick a non-null value\n@@ -311,7 +317,8 @@ protected CharSequence getDefaultChoice(final Object selected)\n \t\t\t\t\toption = getLocalizer().getString(\"null\", this, CHOOSE_ONE);\n \t\t\t\t}\n \n-\t\t\t\treturn \"\\n<option selected=\\\"selected\\\" value=\\\"\\\">\" + option + \"</option>\";\n+\t\t\t\treturn \"\\n<option selected=\\\"selected\\\" value=\\\"\" + noSelectionValue + \"\\\">\" +\n+\t\t\t\t\toption + \"</option>\";\n \t\t\t}\n \t\t}\n \t\treturn \"\";\n", "nb_test": 1039, "linesAdd": 12, "jira_id": "3278", "singleLine": false, "nb_skipped": 0, "commit": "60d07288", "nb_failure": 1, "linesRem": 5}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testTwoBundlesWithDependenciesAndPriority(org.apache.wicket.resource.aggregator.ResourceAggregatorTest): expected:<[JavaScriptReferenceHeaderItem(./wicket/resource/org.apache.wicket.Application/ab.js), JavaScriptReferenceHeaderItem(./wicket/resource/org.apache.wicket.Application/cd.js)]> but was:<[PriorityHeaderItem(JavaScriptReferenceHeaderItem(./wicket/resource/org.apache.wicket.resource.aggregator.ResourceAggregatorTest/a.js)), PriorityHeaderItem(JavaScriptReferenceHeaderItem(./wicket/resource/org.apache.wicket.resource.aggregator.ResourceAggregatorTest/b.js)), JavaScriptReferenceHeaderItem(./wicket/resource/org.apache.wicket.Application/ab.js), JavaScriptReferenceHeaderItem(./wicket/resource/org.apache.wicket.Application/cd.js)]>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/head/ResourceAggregator.java b/wicket-core/src/main/java/org/apache/wicket/markup/head/ResourceAggregator.java\nindex bce6a11..02221e7 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/head/ResourceAggregator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/head/ResourceAggregator.java\n@@ -126,7 +126,7 @@ public String toString()\n \t\tpublic RecordedHeaderItem(HeaderItem item)\n \t\t{\n \t\t\tthis.item = item;\n-\t\t\tthis.locations = new ArrayList<RecordedHeaderItemLocation>();\n+\t\t\tlocations = new ArrayList<RecordedHeaderItemLocation>();\n \t\t}\n \n \t\t/**\n@@ -186,9 +186,9 @@ public ResourceAggregator(IHeaderResponse real)\n \t{\n \t\tsuper(real);\n \n-\t\tthis.itemsToBeRendered = new LinkedHashMap<HeaderItem, RecordedHeaderItem>();\n-\t\tthis.domReadyItemsToBeRendered = new ArrayList<OnDomReadyHeaderItem>();\n-\t\tthis.loadItemsToBeRendered = new ArrayList<OnLoadHeaderItem>();\n+\t\titemsToBeRendered = new LinkedHashMap<HeaderItem, RecordedHeaderItem>();\n+\t\tdomReadyItemsToBeRendered = new ArrayList<OnDomReadyHeaderItem>();\n+\t\tloadItemsToBeRendered = new ArrayList<OnLoadHeaderItem>();\n \t}\n \n \t@Override\n@@ -375,6 +375,10 @@ private void renderSeperateEventScripts()\n \t */\n \tprivate HeaderItem getItemToBeRendered(HeaderItem item)\n \t{\n+\t\twhile (item instanceof IWrappedHeaderItem)\n+\t\t{\n+\t\t\titem = ((IWrappedHeaderItem)item).getWrapped();\n+\t\t}\n \t\tif (getRealResponse().wasRendered(item))\n \t\t{\n \t\t\treturn NoHeaderItem.get();\n", "nb_test": 1406, "linesAdd": 8, "jira_id": "4753", "singleLine": false, "nb_skipped": 5, "commit": "21a47387", "nb_failure": 1, "linesRem": 4}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["interfaceValidator(org.apache.wicket.resource.loader.ValidatorStringResourceLoaderTest): (..)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/resource/loader/ValidatorStringResourceLoader.java b/wicket-core/src/main/java/org/apache/wicket/resource/loader/ValidatorStringResourceLoader.java\nindex f3f03a2..ad7a610 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/resource/loader/ValidatorStringResourceLoader.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/resource/loader/ValidatorStringResourceLoader.java\n@@ -21,6 +21,7 @@\n import org.apache.wicket.Component;\r\n import org.apache.wicket.markup.html.form.FormComponent;\r\n import org.apache.wicket.validation.IValidator;\r\n+import org.apache.wicket.validation.ValidatorAdapter;\r\n import org.slf4j.Logger;\r\n import org.slf4j.LoggerFactory;\r\n \r\n@@ -81,7 +82,8 @@ public String loadStringResource(final Component component, final String key,\n \t\tFormComponent<?> fc = (FormComponent<?>)component;\r\n \t\tfor (IValidator<?> validator : fc.getValidators())\r\n \t\t{\r\n-\t\t\tString resource = loadStringResource(validator.getClass(), key, locale, style,\r\n+\t\t\tClass<?> scope = getScope(validator);\r\n+\t\t\tString resource = loadStringResource(scope, key, locale, style,\r\n \t\t\t\tvariation);\r\n \t\t\tif (resource != null)\r\n \t\t\t{\r\n@@ -92,4 +94,18 @@ public String loadStringResource(final Component component, final String key,\n \t\t// not found\r\n \t\treturn null;\r\n \t}\r\n+\r\n+\tprivate Class<? extends IValidator> getScope(IValidator<?> validator)\r\n+\t{\r\n+\t\tClass<? extends IValidator> scope;\r\n+\t\tif (validator instanceof ValidatorAdapter)\r\n+\t\t{\r\n+\t\t\tscope = ((ValidatorAdapter) validator).getValidator().getClass();\r\n+\t\t}\r\n+\t\telse\r\n+\t\t{\r\n+\t\t\tscope = validator.getClass();\r\n+\t\t}\r\n+\t\treturn scope;\r\n+\t}\r\n }\r\n", "nb_test": 1304, "linesAdd": 17, "jira_id": "4379", "singleLine": false, "nb_skipped": 5, "commit": "7a162f77", "nb_failure": 1, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 3, "classification": {"singleLine": false}, "failing_tests": ["testGetPropertyByNotExistingIndexArrayLookup(org.apache.wicket.util.lang.PropertyResolverTest)", "testGetPropertyByNotExistingIndexListLookup(org.apache.wicket.util.lang.PropertyResolverTest)", "testGetIndexPropertyDirectly(org.apache.wicket.util.lang.PropertyResolverTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java b/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\nindex ae38446..d83ba14 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\n@@ -217,6 +217,12 @@ private static ObjectAndGetSetter getObjectAndGetSetter(final String expression,\n \t\twhile (index != -1)\n \t\t{\n \t\t\texp = expressionBracketsSeperated.substring(lastIndex, index);\n+\t\t\tif (exp.length() == 0)\n+\t\t\t{\n+\t\t\t\texp = expressionBracketsSeperated.substring(index + 1);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n \t\t\tIGetAndSet getAndSetter = null;\n \t\t\ttry\n \t\t\t{\n@@ -762,6 +768,8 @@ public Object newValue(Object object)\n \t\t */\n \t\tpublic Object getValue(Object object)\n \t\t{\n+\t\t\tif (((List<?>)object).size() <= index)\n+\t\t\t\treturn null;\n \t\t\treturn ((List<?>)object).get(index);\n \t\t}\n \n@@ -819,8 +827,12 @@ public Object newValue(Object object)\n \t\t */\n \t\tpublic Object getValue(Object object)\n \t\t{\n+\t\t\tif (Array.getLength(object) > index)\n+\t\t\t{\n \t\t\t\treturn Array.get(object, index);\n \t\t\t}\n+\t\t\treturn null;\n+\t\t}\n \n \t\t/**\n \t\t * @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#setValue(Object, Object,\n", "nb_test": 798, "linesAdd": 12, "jira_id": "2337", "singleLine": false, "nb_skipped": 0, "commit": "36a41358", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["thousandSeperatorWithCurrency(org.apache.wicket.util.convert.converters.ConvertersTest): Cannot parse '1\u00a0234,00\u00a0\u00a4' using format java.text.DecimalFormat@674dc"], "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\nindex b3b970e..5c448c0 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\n@@ -65,10 +65,9 @@ protected N parse(Object value, final double min, final double max, Locale local\n \t\t}\n \t\telse if (value instanceof String)\n \t\t{\n-\t\t\t// Convert spaces to no-break space (U+00A0) to fix problems with\n-\t\t\t// browser conversions.\n-\t\t\t// Space is not valid thousands-separator, but no-br space is.\n-\t\t\tvalue = ((String)value).replace(' ', '\\u00A0');\n+\t\t\t// Convert spaces to no-break space (U+00A0) as required by Java formats:\n+\t\t\t// http://bugs.sun.com/view_bug.do?bug_id=4510618\n+\t\t\tvalue = ((String)value).replaceAll(\"(\\\\d+)\\\\s(?=\\\\d)\", \"$1\\u00A0\");\n \t\t}\n \n \t\tfinal NumberFormat numberFormat = getNumberFormat(locale);\n", "nb_test": 170, "linesAdd": 1, "jira_id": "4988", "singleLine": false, "nb_skipped": 0, "commit": "a4a3a9a6", "nb_failure": 0, "linesRem": 1}, {"files": 1, "project": "wicket", "nb_error": 2, "classification": {"singleLine": false}, "failing_tests": ["testEncode6_1(org.apache.wicket.request.mapper.MountedMapperTest)", "testEncode7_1(org.apache.wicket.request.mapper.MountedMapperTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\nindex 1c5d039..04fe4e8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\n@@ -19,10 +19,15 @@\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.wicket.RequestListenerInterface;\n+import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n+import org.apache.wicket.request.handler.ListenerInterfaceRequestHandler;\n+import org.apache.wicket.request.mapper.info.ComponentInfo;\n import org.apache.wicket.request.mapper.info.PageComponentInfo;\n+import org.apache.wicket.request.mapper.info.PageInfo;\n import org.apache.wicket.request.mapper.parameter.IPageParametersEncoder;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n import org.apache.wicket.request.mapper.parameter.PageParametersEncoder;\n@@ -354,6 +359,41 @@ protected PageParameters newPageParameters()\n \t\treturn new PageParameters();\n \t}\n \n+\t@Override\n+\tpublic Url mapHandler(IRequestHandler requestHandler)\n+\t{\n+\t\tUrl url = super.mapHandler(requestHandler);\n+\n+\t\tif (url == null && requestHandler instanceof ListenerInterfaceRequestHandler)\n+\t\t{\n+\t\t\tListenerInterfaceRequestHandler handler = (ListenerInterfaceRequestHandler)requestHandler;\n+\t\t\tIRequestablePage page = handler.getPage();\n+\t\t\tClass<? extends IRequestablePage> pageClass = page.getClass();\n+\t\t\tif (checkPageClass(pageClass))\n+\t\t\t{\n+\t\t\t\tString componentPath = handler.getComponentPath();\n+\t\t\t\tRequestListenerInterface listenerInterface = handler.getListenerInterface();\n+\n+\t\t\t\tInteger renderCount = null;\n+\t\t\t\tif (listenerInterface.isIncludeRenderCount())\n+\t\t\t\t{\n+\t\t\t\t\trenderCount = page.getRenderCount();\n+\t\t\t\t}\n+\n+\t\t\t\tPageInfo pageInfo = new PageInfo(page.getPageId());\n+\t\t\t\tComponentInfo componentInfo = new ComponentInfo(renderCount,\n+\t\t\t\t\trequestListenerInterfaceToString(listenerInterface), componentPath,\n+\t\t\t\t\thandler.getBehaviorIndex());\n+\t\t\t\tPageComponentInfo pageComponentInfo = new PageComponentInfo(pageInfo, componentInfo);\n+\t\t\t\tUrlInfo urlInfo = new UrlInfo(pageComponentInfo, page.getClass(),\n+\t\t\t\t\thandler.getPageParameters());\n+\t\t\t\turl = buildUrl(urlInfo);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn url;\n+\t}\n+\n \t/**\n \t * @see org.apache.wicket.request.mapper.AbstractBookmarkableMapper#buildUrl(org.apache.wicket.request.mapper.AbstractBookmarkableMapper.UrlInfo)\n \t */\n", "nb_test": 1184, "linesAdd": 40, "jira_id": "4014", "singleLine": false, "nb_skipped": 2, "commit": "e60bac5f", "nb_failure": 0, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["test2(org.apache.wicket.markup.parser.MergedMarkupTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/MergedMarkup.java b/wicket/src/main/java/org/apache/wicket/markup/MergedMarkup.java\nindex 1e686c2..c1194ff 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/MergedMarkup.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/MergedMarkup.java\n@@ -63,6 +63,12 @@ public MergedMarkup(final Markup markup, final Markup baseMarkup, int extendInde\n \n \t\tgetMarkupResourceStream().setBaseMarkup(baseMarkup);\n \n+\t\t// Copy settings from derived markup\n+\t\tMarkupResourceStream baseResourceStream = baseMarkup.getMarkupResourceStream();\n+\t\tgetMarkupResourceStream().setXmlDeclaration(baseResourceStream.getXmlDeclaration());\n+\t\tgetMarkupResourceStream().setEncoding(baseResourceStream.getEncoding());\n+\t\tgetMarkupResourceStream().setWicketNamespace(baseResourceStream.getWicketNamespace());\n+\n \t\tif (log.isDebugEnabled())\n \t\t{\n \t\t\tString derivedResource = Strings.afterLast(markup.getMarkupResourceStream()\n", "nb_test": 935, "linesAdd": 5, "jira_id": "2569", "singleLine": false, "nb_skipped": 0, "commit": "9ced53a5", "nb_failure": 1, "linesRem": 0}, {"files": 5, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["testRenderHomePage_2(org.apache.wicket.markup.outputTransformer.OutputTransformerContainerTest)", "testRenderHomePage(org.apache.wicket.markup.outputTransformer.OutputTransformerContainerTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex ebbe98f..17f43d7 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -1811,12 +1811,8 @@ public void component(Component component, IVisit<Void> visit)\n \tprotected void onAfterRenderChildren()\n \t{\n \t\t// Loop through child components\n-\t\tfinal Iterator<? extends Component> iter = iterator();\n-\t\twhile (iter.hasNext())\n+\t\tfor (Component child : this)\n \t\t{\n-\t\t\t// Get next child\n-\t\t\tfinal Component child = iter.next();\n-\n \t\t\t// Call end request on the child\n \t\t\tchild.afterRender();\n \t\t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/MarkupResourceStream.java b/wicket-core/src/main/java/org/apache/wicket/markup/MarkupResourceStream.java\nindex 95cd456..9e26187 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/MarkupResourceStream.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/MarkupResourceStream.java\n@@ -45,6 +45,9 @@\n \n \tprivate static final Logger log = LoggerFactory.getLogger(MarkupResourceStream.class);\n \n+\t/** */\n+\tpublic static final String WICKET_XHTML_DTD = \"http://wicket.apache.org/dtds.data/wicket-xhtml1.4-strict.dtd\";\n+\n \tprivate static final Pattern DOCTYPE_REGEX = Pattern.compile(\"!DOCTYPE\\\\s+(.*)\\\\s*\");\n \n \t/** The associated markup resource stream */\n@@ -68,10 +71,7 @@\n \t/** The encoding as found in <?xml ... encoding=\"\" ?>. Null, else */\n \tprivate String encoding;\n \n-\t/**\n-\t * Wicket namespace: <html\n-\t * xmlns:wicket=\"http://wicket.apache.org/dtds.data/wicket-xhtml1.3-strict.dtd>\n-\t */\n+\t/** Wicket namespace: see WICKET_XHTML_DTD */\n \tprivate String wicketNamespace;\n \n \t/** == wicket namespace name + \":id\" */\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\nindex 0e82dc3..be0490b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\n@@ -19,7 +19,6 @@\n import org.apache.wicket.Component;\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.behavior.Behavior;\n-import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.protocol.http.BufferedWebResponse;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.http.WebResponse;\n@@ -59,12 +58,6 @@ protected BufferedWebResponse newResponse(final WebResponse originalResponse)\n \t}\n \n \t@Override\n-\tpublic void onComponentTag(final Component component, final ComponentTag tag)\n-\t{\n-\t\ttag.put(\"xmlns:wicket\", \"http://wicket.apache.org\");\n-\t}\n-\n-\t@Override\n \tpublic void beforeRender(Component component)\n \t{\n \t\tsuper.beforeRender(component);\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\nindex 873c476..d09c100 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\n@@ -18,6 +18,7 @@\n \n import org.apache.wicket.AttributeModifier;\n import org.apache.wicket.Component;\n+import org.apache.wicket.markup.MarkupResourceStream;\n import org.apache.wicket.markup.MarkupType;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.Model;\n@@ -74,7 +75,7 @@ public XsltOutputTransformerContainer(final String id, final IModel<?> model,\n \t\t// Make the XSLT processor happy and allow him to handle the wicket\n \t\t// tags and attributes which are in the wicket namespace\n \t\tadd(AttributeModifier.replace(\"xmlns:wicket\",\n-\t\t\tModel.of(\"http://wicket.apache.org/dtds.data/wicket-xhtml1.3-strict.dtd\")));\n+\t\t\tModel.of(MarkupResourceStream.WICKET_XHTML_DTD)));\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltTransformerBehavior.java b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltTransformerBehavior.java\nindex 97a1680..d1c3efa 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltTransformerBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltTransformerBehavior.java\n@@ -20,6 +20,7 @@\n import org.apache.wicket.Page;\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.markup.ComponentTag;\n+import org.apache.wicket.markup.MarkupResourceStream;\n \n /**\n  * An IBehavior which can be added to any component except ListView. It allows to post-process\n@@ -69,10 +70,10 @@ public XsltTransformerBehavior(final String xslFilePath)\n \t@Override\n \tpublic void onComponentTag(final Component component, final ComponentTag tag)\n \t{\n-\t\ttag.put(\"xmlns:wicket\", \"http://wicket.apache.org/dtds.data/wicket-xhtml1.3-strict.dtd\");\n-\n \t\t// Make the XSLT processor happy and allow it to handle the wicket tags\n \t\t// and attributes that are in the wicket namespace\n+\t\ttag.put(\"xmlns:wicket\", MarkupResourceStream.WICKET_XHTML_DTD);\n+\n \t\tsuper.onComponentTag(component, tag);\n \t}\n \n", "nb_test": 1242, "linesAdd": 8, "jira_id": "3861", "singleLine": false, "nb_skipped": 2, "commit": "d1e0e411", "nb_failure": 2, "linesRem": 14}, {"files": 2, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["wicket3563(org.apache.wicket.PlaceholderTagIdTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 238b278..6644c24 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -23,6 +23,7 @@\n import java.util.Locale;\n import java.util.Stack;\n \n+import org.apache.wicket.ajax.IAjaxRegionMarkupIdProvider;\n import org.apache.wicket.authorization.Action;\n import org.apache.wicket.authorization.AuthorizationException;\n import org.apache.wicket.authorization.IAuthorizationStrategy;\n@@ -2463,7 +2464,7 @@ protected void renderPlaceholderTag(final ComponentTag tag, final Response respo\n \t\t}\n \t\tresponse.write(tag.getName());\n \t\tresponse.write(\" id=\\\"\");\n-\t\tresponse.write(getMarkupId());\n+\t\tresponse.write(getAjaxRegionMarkupId());\n \t\tresponse.write(\"\\\" style=\\\"display:none\\\"></\");\n \t\tif (ns != null)\n \t\t{\n@@ -2473,6 +2474,39 @@ protected void renderPlaceholderTag(final ComponentTag tag, final Response respo\n \t\tresponse.write(\">\");\n \t}\n \n+\n+\t/**\n+\t * Returns the id of the markup region that will be updated via ajax. This can be different to\n+\t * the markup id of the component if a {@link IAjaxRegionMarkupIdProvider} behavior has been\n+\t * added.\n+\t * \n+\t * @return the markup id of the region to be updated via ajax.\n+\t */\n+\tpublic final String getAjaxRegionMarkupId()\n+\t{\n+\t\tString markupId = null;\n+\t\tfor (Behavior behavior : getBehaviors())\n+\t\t{\n+\t\t\tif (behavior instanceof IAjaxRegionMarkupIdProvider)\n+\t\t\t{\n+\t\t\t\tmarkupId = ((IAjaxRegionMarkupIdProvider)behavior).getAjaxRegionMarkupId(this);\n+\t\t\t}\n+\t\t}\n+\t\tif (markupId == null)\n+\t\t{\n+\t\t\tif (this instanceof IAjaxRegionMarkupIdProvider)\n+\t\t\t{\n+\t\t\t\tmarkupId = ((IAjaxRegionMarkupIdProvider)this).getAjaxRegionMarkupId(this);\n+\t\t\t}\n+\t\t}\n+\t\tif (markupId == null)\n+\t\t{\n+\t\t\tmarkupId = getMarkupId();\n+\t\t}\n+\t\treturn markupId;\n+\t}\n+\n+\n \t/**\n \t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.\n \t * <p>\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\nindex f6ff1ad..7b2467e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n@@ -31,7 +31,6 @@\n import org.apache.wicket.Component;\n import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.Page;\n-import org.apache.wicket.behavior.Behavior;\n import org.apache.wicket.event.Broadcast;\n import org.apache.wicket.markup.html.IHeaderResponse;\n import org.apache.wicket.markup.html.internal.HeaderResponse;\n@@ -753,7 +752,7 @@ private void respondComponents(Response response)\n \n \t\t\tif (!containsAncestorFor(component))\n \t\t\t{\n-\t\t\t\trespondComponent(response, getAjaxRegionMarkupId(component), component);\n+\t\t\t\trespondComponent(response, component.getAjaxRegionMarkupId(), component);\n \t\t\t}\n \t\t}\n \n@@ -803,30 +802,6 @@ private void writeHeaderContribution(Response response)\n \t\t}\n \t}\n \n-\tprivate String getAjaxRegionMarkupId(Component component)\n-\t{\n-\t\tString markupId = null;\n-\t\tfor (Behavior behavior : component.getBehaviors())\n-\t\t{\n-\t\t\tif (behavior instanceof IAjaxRegionMarkupIdProvider)\n-\t\t\t{\n-\t\t\t\tmarkupId = ((IAjaxRegionMarkupIdProvider)behavior).getAjaxRegionMarkupId(component);\n-\t\t\t}\n-\t\t}\n-\t\tif (markupId == null)\n-\t\t{\n-\t\t\tif (component instanceof IAjaxRegionMarkupIdProvider)\n-\t\t\t{\n-\t\t\t\tmarkupId = ((IAjaxRegionMarkupIdProvider)component).getAjaxRegionMarkupId(component);\n-\t\t\t}\n-\t\t}\n-\t\tif (markupId == null)\n-\t\t{\n-\t\t\tmarkupId = component.getMarkupId();\n-\t\t}\n-\t\treturn markupId;\n-\t}\n-\n \t/**\n \t * Checks if the target contains an ancestor for the given component\n \t * \n", "nb_test": 1114, "linesAdd": 29, "jira_id": "3563", "singleLine": false, "nb_skipped": 0, "commit": "c62b66c1", "nb_failure": 1, "linesRem": 27}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["bindSessionWhenThereAreFeedbackMessages(org.apache.wicket.session.BindSessionOnRedirectTest)"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex e25142c..c3899ec 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -16,9 +16,14 @@\n  */\n package org.apache.wicket.request.handler.render;\n \n+import java.util.List;\n+\n import org.apache.wicket.Application;\n+import org.apache.wicket.Session;\n import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n import org.apache.wicket.core.request.handler.RenderPageRequestHandler.RedirectPolicy;\n+import org.apache.wicket.feedback.FeedbackCollector;\n+import org.apache.wicket.feedback.FeedbackMessage;\n import org.apache.wicket.protocol.http.BufferedWebResponse;\n import org.apache.wicket.protocol.http.WebApplication;\n import org.apache.wicket.request.IRequestHandler;\n@@ -145,11 +150,28 @@ protected BufferedWebResponse renderPage(Url targetUrl, RequestCycle requestCycl\n \t */\n \tprotected void redirectTo(Url url, RequestCycle requestCycle)\n \t{\n+\t\tbindSessionIfNeeded();\n+\n \t\tWebResponse response = (WebResponse)requestCycle.getResponse();\n \t\tString relativeUrl = requestCycle.getUrlRenderer().renderUrl(url);\n \t\tresponse.sendRedirect(relativeUrl);\n \t}\n \n+\t/**\n+\t * Bind the session if there are feedback messages pending.\n+\t * https://issues.apache.org/jira/browse/WICKET-5165\n+\t */\n+\tprivate void bindSessionIfNeeded()\n+\t{\n+\t\t// check for session feedback messages only\n+\t\tFeedbackCollector collector = new FeedbackCollector();\n+\t\tList<FeedbackMessage> feedbackMessages = collector.collect();\n+\t\tif (feedbackMessages.size() > 0)\n+\t\t{\n+\t\t\tSession.get().bind();\n+\t\t}\n+\t}\n+\n \t/*\n \t * TODO: simplify the code below. See WICKET-3347\n \t */\n", "nb_test": 1497, "linesAdd": 17, "jira_id": "5165", "singleLine": false, "nb_skipped": 3, "commit": "0d4d1df7", "nb_failure": 1, "linesRem": 0}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["RestartResponseAtInterceptPageExceptionTest.interceptPagePreventsHeaderContributionButShouldNotBeLogged:88->Assert.fail:88 missing headers should not be reported for unrendered page"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/WebPage.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/WebPage.java\nindex 903d7c4..5c7d6bb 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/WebPage.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/WebPage.java\n@@ -26,11 +26,9 @@\n import org.apache.wicket.markup.renderStrategy.AbstractHeaderRenderStrategy;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.protocol.http.WebApplication;\n-import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Response;\n import org.apache.wicket.request.cycle.RequestCycle;\n-import org.apache.wicket.core.request.handler.IPageRequestHandler;\n import org.apache.wicket.request.http.WebRequest;\n import org.apache.wicket.request.http.WebResponse;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n@@ -216,8 +214,11 @@ protected void onAfterRender()\n \t\t// only in development mode validate the headers\n \t\tif (getApplication().usesDevelopmentConfig())\n \t\t{\n+\t\t\t// check headers only when page was completely rendered\n+\t\t\tif (wasRendered(this)) {\n \t\t\t\tvalidateHeaders();\n \t\t\t}\n+\t\t}\n \n \t\tsuper.onAfterRender();\n \t}\n", "nb_test": 1791, "linesAdd": 2, "jira_id": "1718", "singleLine": false, "nb_skipped": 1, "commit": "bb7f9cf5", "nb_failure": 1, "linesRem": 2}, {"files": 1, "project": "wicket", "nb_error": 1, "classification": {"singleLine": false}, "failing_tests": ["testCookieIsFoundOnNextRequestWhenAddedToWicketResponse(org.apache.wicket.util.tester.WicketTesterTest)"], "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java b/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\nindex aaf95f6..3ad878f 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\n@@ -16,16 +16,18 @@\n  */\n package org.apache.wicket.protocol.http;\n \n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n import java.io.File;\n import java.util.Enumeration;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Map;\n-\n-import javax.servlet.FilterConfig;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.http.HttpServletResponse;\n+import java.util.Set;\n \n import org.apache.wicket.Application;\n import org.apache.wicket.Component;\n@@ -121,6 +123,7 @@\n \tprivate final ServletContext context;\n \n \tprivate final WicketFilter filter;\n+\tprivate Set<Cookie> cookiesOfThisSession = new HashSet<Cookie>();\n \n \t/**\n \t * Create the mock http tester that can be used for testing.\n@@ -195,7 +198,15 @@ public String getFilterName()\n \t\tservletSession = new MockHttpSession(context);\n \t\tservletSession.setTemporary(initializeHttpSessionAsTemporary());\n \t\tservletRequest = new MockHttpServletRequest(this.application, servletSession, context);\n-\t\tservletResponse = new MockHttpServletResponse(servletRequest);\n+\t\tservletResponse = new MockHttpServletResponse(servletRequest)\n+\t\t{\n+\t\t\t@Override\n+\t\t\tpublic void addCookie(Cookie cookie)\n+\t\t\t{\n+\t\t\t\tsuper.addCookie(cookie);\n+\t\t\t\tcookiesOfThisSession.add(cookie);\n+\t\t\t}\n+\t\t};\n \n \t\t// Construct request and response using factories\n \t\twicketRequest = this.application.newWebRequest(servletRequest);\n@@ -620,6 +631,7 @@ public WebRequestCycle setupRequestAndResponse(boolean isAjax)\n \t{\n \t\tservletRequest.initialize();\n \t\tservletResponse.initialize();\n+\t\tservletRequest.addCookies(cookiesOfThisSession);\n \t\tservletRequest.setParameters(parametersForNextRequest);\n \t\tif (isAjax)\n \t\t{\n", "nb_test": 726, "linesAdd": 18, "jira_id": "1886", "singleLine": false, "nb_skipped": 0, "commit": "5226978a", "nb_failure": 0, "linesRem": 6}, {"files": 1, "project": "wicket", "nb_error": 0, "classification": {"singleLine": false}, "failing_tests": ["ServletWebResponseTest.encodeAbsoluteUrl:186->Assert.assertEquals:144->Assert.assertEquals:115 expected:<[http://localhost:8080]/path;foo> but was:<[../]/path;foo>", "ServletWebResponseTest.encodeRedirectAbsoluteUrl:215->Assert.assertEquals:144->Assert.assertEquals:115 expected:<[http://localhost:8080]/path;foo> but was:<[../]/path;foo>"], "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\nindex e665aaf..e7e32d1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n@@ -173,29 +173,39 @@ public String encodeURL(CharSequence url)\n \t{\n \t\tArgs.notNull(url, \"url\");\n \n+\t\tUrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();\n+\n+\t\tUrl originalUrl = Url.parse(url);\n+\n \t\t/*\n \t\t  WICKET-4645 - always pass absolute url to the web container for encoding\n \t\t  because when REDIRECT_TO_BUFFER is in use Wicket may render PageB when\n \t\t  PageA is actually the requested one and the web container cannot resolve\n \t\t  the base url properly\n \t\t */\n-\t\tUrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();\n-\t\tUrl relativeUrl = Url.parse(url);\n-\t\tString fullUrl = urlRenderer.renderFullUrl(relativeUrl);\n+\t\tString fullUrl = urlRenderer.renderFullUrl(originalUrl);\n \t\tString encodedFullUrl = httpServletResponse.encodeURL(fullUrl);\n-\t\tfinal String encodedRelativeUrl;\n+\n+\t\tfinal String encodedUrl;\n+\t\tif (originalUrl.isFull())\n+\t\t{\n+\t\t\tencodedUrl = encodedFullUrl;\n+\t\t}\n+\t\telse\n+\t\t{\n \t\t\tif (fullUrl.equals(encodedFullUrl))\n \t\t\t{\n-\t\t\t// no encoding happened so just reuse the relative url\n-\t\t\tencodedRelativeUrl = url.toString();\n+\t\t\t\t// no encoding happened so just reuse the original url\n+\t\t\t\tencodedUrl = url.toString();\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\t// get the relative url with the jsessionid encoded in it\n \t\t\t\tUrl _encoded = Url.parse(encodedFullUrl);\n-\t\t\tencodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);\n+\t\t\t\tencodedUrl = urlRenderer.renderRelativeUrl(_encoded);\n \t\t\t}\n-\t\treturn encodedRelativeUrl;\n+\t\t}\n+\t\treturn encodedUrl;\n \t}\n \n \t@Override\n@@ -203,29 +213,38 @@ public String encodeRedirectURL(CharSequence url)\n \t{\n \t\tArgs.notNull(url, \"url\");\n \n+\t\tUrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();\n+\n+\t\tUrl originalUrl = Url.parse(url);\n+\n \t\t/*\n-\t\t  WICKET-4854 - always pass absolute url to the web container for encoding\n-\t\t  because when REDIRECT_TO_BUFFER is in use Wicket may render PageB when\n-\t\t  PageA is actually the requested one and the web container cannot resolve\n-\t\t  the base url properly\n+\t\t * WICKET-4645 - always pass absolute url to the web container for encoding because when\n+\t\t * REDIRECT_TO_BUFFER is in use Wicket may render PageB when PageA is actually the requested\n+\t\t * one and the web container cannot resolve the base url properly\n \t\t */\n-\t\tUrlRenderer urlRenderer = new UrlRenderer(webRequest);\n-\t\tUrl relativeUrl = Url.parse(url);\n-\t\tString fullUrl = urlRenderer.renderFullUrl(relativeUrl);\n+\t\tString fullUrl = urlRenderer.renderFullUrl(originalUrl);\n \t\tString encodedFullUrl = httpServletResponse.encodeRedirectURL(fullUrl);\n-\t\tfinal String encodedRelativeUrl;\n+\n+\t\tfinal String encodedUrl;\n+\t\tif (originalUrl.isFull())\n+\t\t{\n+\t\t\tencodedUrl = encodedFullUrl;\n+\t\t}\n+\t\telse\n+\t\t{\n \t\t\tif (fullUrl.equals(encodedFullUrl))\n \t\t\t{\n-\t\t\t// no encoding happened so just reuse the relative url\n-\t\t\tencodedRelativeUrl = url.toString();\n+\t\t\t\t// no encoding happened so just reuse the original url\n+\t\t\t\tencodedUrl = url.toString();\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\t// get the relative url with the jsessionid encoded in it\n \t\t\t\tUrl _encoded = Url.parse(encodedFullUrl);\n-\t\t\tencodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);\n+\t\t\t\tencodedUrl = urlRenderer.renderRelativeUrl(_encoded);\n+\t\t\t}\n \t\t}\n-\t\treturn encodedRelativeUrl;\n+\t\treturn encodedUrl;\n \t}\n \n \t@Override\n", "nb_test": 1641, "linesAdd": 34, "jira_id": "5582", "singleLine": false, "nb_skipped": 2, "commit": "1fb66533", "nb_failure": 2, "linesRem": 18}]